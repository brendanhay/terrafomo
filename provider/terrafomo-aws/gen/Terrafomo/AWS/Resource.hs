-- This module is auto-generated.

{-# LANGUAGE DataKinds              #-}
{-# LANGUAGE PolyKinds              #-}
{-# LANGUAGE DuplicateRecordFields  #-}
{-# LANGUAGE FlexibleInstances      #-}
{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE MultiParamTypeClasses  #-}
{-# LANGUAGE NoImplicitPrelude      #-}
{-# LANGUAGE OverloadedStrings      #-}
{-# LANGUAGE RankNTypes             #-}
{-# LANGUAGE RecordWildCards        #-}
{-# LANGUAGE UndecidableInstances   #-}

{-# OPTIONS_GHC -fno-warn-unused-imports #-}

-- |
-- Module      : Terrafomo.AWS.Resource
-- Copyright   : (c) 2017 Brendan Hay
-- License     : Mozilla Public License, v. 2.0.
-- Maintainer  : Brendan Hay <brendan.g.hay+terrafomo@gmail.com>
-- Stability   : auto-generated
-- Portability : non-portable (GHC extensions)
--
module Terrafomo.AWS.Resource
    (
    -- * Types
      ActivityResource (..)
    , activityResource

    , AmiCopyResource (..)
    , amiCopyResource

    , AmiFromInstanceResource (..)
    , amiFromInstanceResource

    , AmiLaunchPermissionResource (..)
    , amiLaunchPermissionResource

    , AmiResource (..)
    , amiResource

    , ApiGatewayAccountResource (..)
    , apiGatewayAccountResource

    , ApiGatewayApiKeyResource (..)
    , apiGatewayApiKeyResource

    , ApiGatewayAuthorizerResource (..)
    , apiGatewayAuthorizerResource

    , ApiGatewayBasePathMappingResource (..)
    , apiGatewayBasePathMappingResource

    , ApiGatewayClientCertificateResource (..)
    , apiGatewayClientCertificateResource

    , ApiGatewayDeploymentResource (..)
    , apiGatewayDeploymentResource

    , ApiGatewayDocumentationPartResource (..)
    , apiGatewayDocumentationPartResource

    , ApiGatewayDomainNameResource (..)
    , apiGatewayDomainNameResource

    , ApiGatewayGatewayResponseResource (..)
    , apiGatewayGatewayResponseResource

    , ApiGatewayIntegrationResource (..)
    , apiGatewayIntegrationResource

    , ApiGatewayIntegrationResponseResource (..)
    , apiGatewayIntegrationResponseResource

    , ApiGatewayMethodResource (..)
    , apiGatewayMethodResource

    , ApiGatewayMethodResponseResource (..)
    , apiGatewayMethodResponseResource

    , ApiGatewayMethodSettingsResource (..)
    , apiGatewayMethodSettingsResource

    , ApiGatewayModelResource (..)
    , apiGatewayModelResource

    , ApiGatewayResourceResource (..)
    , apiGatewayResourceResource

    , ApiGatewayRestApiResource (..)
    , apiGatewayRestApiResource

    , ApiGatewayStageResource (..)
    , apiGatewayStageResource

    , ApiGatewayUsagePlanKeyResource (..)
    , apiGatewayUsagePlanKeyResource

    , ApiGatewayUsagePlanResource (..)
    , apiGatewayUsagePlanResource

    , AppCookieStickinessPolicyResource (..)
    , appCookieStickinessPolicyResource

    , AppautoscalingPolicyResource (..)
    , appautoscalingPolicyResource

    , AppautoscalingScheduledActionResource (..)
    , appautoscalingScheduledActionResource

    , AppautoscalingTargetResource (..)
    , appautoscalingTargetResource

    , AthenaDatabaseResource (..)
    , athenaDatabaseResource

    , AthenaNamedQueryResource (..)
    , athenaNamedQueryResource

    , AutoscalingAttachmentResource (..)
    , autoscalingAttachmentResource

    , AutoscalingGroupResource (..)
    , autoscalingGroupResource

    , AutoscalingLifecycleHookResource (..)
    , autoscalingLifecycleHookResource

    , AutoscalingNotificationResource (..)
    , autoscalingNotificationResource

    , AutoscalingPolicyResource (..)
    , autoscalingPolicyResource

    , AutoscalingScheduleResource (..)
    , autoscalingScheduleResource

    , BatchComputeEnvironmentResource (..)
    , batchComputeEnvironmentResource

    , BatchJobDefinitionResource (..)
    , batchJobDefinitionResource

    , BatchJobQueueResource (..)
    , batchJobQueueResource

    , CloudformationStackResource (..)
    , cloudformationStackResource

    , CloudfrontDistributionResource (..)
    , cloudfrontDistributionResource

    , CloudfrontOriginAccessIdentityResource (..)
    , cloudfrontOriginAccessIdentityResource

    , CloudtrailResource (..)
    , cloudtrailResource

    , CloudwatchDashboardResource (..)
    , cloudwatchDashboardResource

    , CloudwatchEventPermissionResource (..)
    , cloudwatchEventPermissionResource

    , CloudwatchEventRuleResource (..)
    , cloudwatchEventRuleResource

    , CloudwatchEventTargetResource (..)
    , cloudwatchEventTargetResource

    , CloudwatchLogDestinationPolicyResource (..)
    , cloudwatchLogDestinationPolicyResource

    , CloudwatchLogDestinationResource (..)
    , cloudwatchLogDestinationResource

    , CloudwatchLogGroupResource (..)
    , cloudwatchLogGroupResource

    , CloudwatchLogMetricFilterResource (..)
    , cloudwatchLogMetricFilterResource

    , CloudwatchLogResourcePolicyResource (..)
    , cloudwatchLogResourcePolicyResource

    , CloudwatchLogStreamResource (..)
    , cloudwatchLogStreamResource

    , CloudwatchLogSubscriptionFilterResource (..)
    , cloudwatchLogSubscriptionFilterResource

    , CloudwatchMetricAlarmResource (..)
    , cloudwatchMetricAlarmResource

    , CodebuildProjectResource (..)
    , codebuildProjectResource

    , CodecommitRepositoryResource (..)
    , codecommitRepositoryResource

    , CodecommitTriggerResource (..)
    , codecommitTriggerResource

    , CodedeployAppResource (..)
    , codedeployAppResource

    , CodedeployDeploymentConfigResource (..)
    , codedeployDeploymentConfigResource

    , CodedeployDeploymentGroupResource (..)
    , codedeployDeploymentGroupResource

    , CodepipelineResource (..)
    , codepipelineResource

    , CognitoIdentityPoolResource (..)
    , cognitoIdentityPoolResource

    , CognitoIdentityPoolRolesAttachmentResource (..)
    , cognitoIdentityPoolRolesAttachmentResource

    , CognitoUserPoolClientResource (..)
    , cognitoUserPoolClientResource

    , CognitoUserPoolDomainResource (..)
    , cognitoUserPoolDomainResource

    , CognitoUserPoolResource (..)
    , cognitoUserPoolResource

    , ConfigConfigRuleResource (..)
    , configConfigRuleResource

    , ConfigConfigurationRecorderResource (..)
    , configConfigurationRecorderResource

    , ConfigConfigurationRecorderStatusResource (..)
    , configConfigurationRecorderStatusResource

    , ConfigDeliveryChannelResource (..)
    , configDeliveryChannelResource

    , CustomerGatewayResource (..)
    , customerGatewayResource

    , DbEventSubscriptionResource (..)
    , dbEventSubscriptionResource

    , DbInstanceResource (..)
    , dbInstanceResource

    , DbOptionGroupResource (..)
    , dbOptionGroupResource

    , DbParameterGroupResource (..)
    , dbParameterGroupResource

    , DbSecurityGroupResource (..)
    , dbSecurityGroupResource

    , DbSnapshotResource (..)
    , dbSnapshotResource

    , DbSubnetGroupResource (..)
    , dbSubnetGroupResource

    , DefaultNetworkAclResource (..)
    , defaultNetworkAclResource

    , DefaultRouteTableResource (..)
    , defaultRouteTableResource

    , DefaultSecurityGroupResource (..)
    , defaultSecurityGroupResource

    , DefaultSubnetResource (..)
    , defaultSubnetResource

    , DefaultVpcDhcpOptionsResource (..)
    , defaultVpcDhcpOptionsResource

    , DefaultVpcResource (..)
    , defaultVpcResource

    , DevicefarmProjectResource (..)
    , devicefarmProjectResource

    , DirectoryServiceDirectoryResource (..)
    , directoryServiceDirectoryResource

    , DmsCertificateResource (..)
    , dmsCertificateResource

    , DmsEndpointResource (..)
    , dmsEndpointResource

    , DmsReplicationInstanceResource (..)
    , dmsReplicationInstanceResource

    , DmsReplicationSubnetGroupResource (..)
    , dmsReplicationSubnetGroupResource

    , DmsReplicationTaskResource (..)
    , dmsReplicationTaskResource

    , DxConnectionAssociationResource (..)
    , dxConnectionAssociationResource

    , DxConnectionResource (..)
    , dxConnectionResource

    , DxLagResource (..)
    , dxLagResource

    , DynamodbTableResource (..)
    , dynamodbTableResource

    , EbsSnapshotResource (..)
    , ebsSnapshotResource

    , EbsVolumeResource (..)
    , ebsVolumeResource

    , EcrLifecyclePolicyResource (..)
    , ecrLifecyclePolicyResource

    , EcrRepositoryPolicyResource (..)
    , ecrRepositoryPolicyResource

    , EcrRepositoryResource (..)
    , ecrRepositoryResource

    , EcsClusterResource (..)
    , ecsClusterResource

    , EcsServiceResource (..)
    , ecsServiceResource

    , EcsTaskDefinitionResource (..)
    , ecsTaskDefinitionResource

    , EfsFileSystemResource (..)
    , efsFileSystemResource

    , EfsMountTargetResource (..)
    , efsMountTargetResource

    , EgressOnlyInternetGatewayResource (..)
    , egressOnlyInternetGatewayResource

    , EipAssociationResource (..)
    , eipAssociationResource

    , EipResource (..)
    , eipResource

    , ElasticBeanstalkApplicationResource (..)
    , elasticBeanstalkApplicationResource

    , ElasticBeanstalkApplicationVersionResource (..)
    , elasticBeanstalkApplicationVersionResource

    , ElasticBeanstalkConfigurationTemplateResource (..)
    , elasticBeanstalkConfigurationTemplateResource

    , ElasticBeanstalkEnvironmentResource (..)
    , elasticBeanstalkEnvironmentResource

    , ElasticacheClusterResource (..)
    , elasticacheClusterResource

    , ElasticacheParameterGroupResource (..)
    , elasticacheParameterGroupResource

    , ElasticacheReplicationGroupResource (..)
    , elasticacheReplicationGroupResource

    , ElasticacheSecurityGroupResource (..)
    , elasticacheSecurityGroupResource

    , ElasticacheSubnetGroupResource (..)
    , elasticacheSubnetGroupResource

    , ElasticsearchDomainPolicyResource (..)
    , elasticsearchDomainPolicyResource

    , ElasticsearchDomainResource (..)
    , elasticsearchDomainResource

    , ElastictranscoderPipelineResource (..)
    , elastictranscoderPipelineResource

    , ElastictranscoderPresetResource (..)
    , elastictranscoderPresetResource

    , ElbAttachmentResource (..)
    , elbAttachmentResource

    , ElbLoadBalancerBackendServerPolicyResource (..)
    , elbLoadBalancerBackendServerPolicyResource

    , ElbLoadBalancerListenerPolicyResource (..)
    , elbLoadBalancerListenerPolicyResource

    , ElbLoadBalancerPolicyResource (..)
    , elbLoadBalancerPolicyResource

    , ElbResource (..)
    , elbResource

    , EmrClusterResource (..)
    , emrClusterResource

    , EmrInstanceGroupResource (..)
    , emrInstanceGroupResource

    , EmrSecurityConfigurationResource (..)
    , emrSecurityConfigurationResource

    , FlowLogResource (..)
    , flowLogResource

    , GlacierVaultResource (..)
    , glacierVaultResource

    , GlueCatalogDatabaseResource (..)
    , glueCatalogDatabaseResource

    , GuarddutyDetectorResource (..)
    , guarddutyDetectorResource

    , GuarddutyMemberResource (..)
    , guarddutyMemberResource

    , IamAccessKeyResource (..)
    , iamAccessKeyResource

    , IamAccountAliasResource (..)
    , iamAccountAliasResource

    , IamAccountPasswordPolicyResource (..)
    , iamAccountPasswordPolicyResource

    , IamGroupMembershipResource (..)
    , iamGroupMembershipResource

    , IamGroupPolicyAttachmentResource (..)
    , iamGroupPolicyAttachmentResource

    , IamGroupPolicyResource (..)
    , iamGroupPolicyResource

    , IamGroupResource (..)
    , iamGroupResource

    , IamInstanceProfileResource (..)
    , iamInstanceProfileResource

    , IamOpenidConnectProviderResource (..)
    , iamOpenidConnectProviderResource

    , IamPolicyAttachmentResource (..)
    , iamPolicyAttachmentResource

    , IamPolicyResource (..)
    , iamPolicyResource

    , IamRolePolicyAttachmentResource (..)
    , iamRolePolicyAttachmentResource

    , IamRolePolicyResource (..)
    , iamRolePolicyResource

    , IamRoleResource (..)
    , iamRoleResource

    , IamSamlProviderResource (..)
    , iamSamlProviderResource

    , IamServerCertificateResource (..)
    , iamServerCertificateResource

    , IamUserLoginProfileResource (..)
    , iamUserLoginProfileResource

    , IamUserPolicyAttachmentResource (..)
    , iamUserPolicyAttachmentResource

    , IamUserPolicyResource (..)
    , iamUserPolicyResource

    , IamUserResource (..)
    , iamUserResource

    , IamUserSshKeyResource (..)
    , iamUserSshKeyResource

    , InspectorAssessmentTargetResource (..)
    , inspectorAssessmentTargetResource

    , InspectorAssessmentTemplateResource (..)
    , inspectorAssessmentTemplateResource

    , InspectorResourceGroupResource (..)
    , inspectorResourceGroupResource

    , InstanceResource (..)
    , instanceResource

    , InternetGatewayResource (..)
    , internetGatewayResource

    , IotCertificateResource (..)
    , iotCertificateResource

    , IotPolicyResource (..)
    , iotPolicyResource

    , KeyPairResource (..)
    , keyPairResource

    , KinesisFirehoseDeliveryStreamResource (..)
    , kinesisFirehoseDeliveryStreamResource

    , KinesisStreamResource (..)
    , kinesisStreamResource

    , KmsAliasResource (..)
    , kmsAliasResource

    , KmsKeyResource (..)
    , kmsKeyResource

    , LambdaAliasResource (..)
    , lambdaAliasResource

    , LambdaEventSourceMappingResource (..)
    , lambdaEventSourceMappingResource

    , LambdaFunctionResource (..)
    , lambdaFunctionResource

    , LambdaPermissionResource (..)
    , lambdaPermissionResource

    , LaunchConfigurationResource (..)
    , launchConfigurationResource

    , LbCookieStickinessPolicyResource (..)
    , lbCookieStickinessPolicyResource

    , LbListenerResource (..)
    , lbListenerResource

    , LbListenerRuleResource (..)
    , lbListenerRuleResource

    , LbResource (..)
    , lbResource

    , LbSslNegotiationPolicyResource (..)
    , lbSslNegotiationPolicyResource

    , LbTargetGroupAttachmentResource (..)
    , lbTargetGroupAttachmentResource

    , LbTargetGroupResource (..)
    , lbTargetGroupResource

    , LightsailDomainResource (..)
    , lightsailDomainResource

    , LightsailInstanceResource (..)
    , lightsailInstanceResource

    , LightsailKeyPairResource (..)
    , lightsailKeyPairResource

    , LightsailStaticIpAttachmentResource (..)
    , lightsailStaticIpAttachmentResource

    , LightsailStaticIpResource (..)
    , lightsailStaticIpResource

    , MainRouteTableAssociationResource (..)
    , mainRouteTableAssociationResource

    , MediaStoreContainerResource (..)
    , mediaStoreContainerResource

    , MqBrokerResource (..)
    , mqBrokerResource

    , MqConfigurationResource (..)
    , mqConfigurationResource

    , NatGatewayResource (..)
    , natGatewayResource

    , NetworkAclResource (..)
    , networkAclResource

    , NetworkAclRuleResource (..)
    , networkAclRuleResource

    , NetworkInterfaceAttachmentResource (..)
    , networkInterfaceAttachmentResource

    , NetworkInterfaceResource (..)
    , networkInterfaceResource

    , NetworkInterfaceSgAttachmentResource (..)
    , networkInterfaceSgAttachmentResource

    , OpsworksApplicationResource (..)
    , opsworksApplicationResource

    , OpsworksCustomLayerResource (..)
    , opsworksCustomLayerResource

    , OpsworksGangliaLayerResource (..)
    , opsworksGangliaLayerResource

    , OpsworksHaproxyLayerResource (..)
    , opsworksHaproxyLayerResource

    , OpsworksInstanceResource (..)
    , opsworksInstanceResource

    , OpsworksJavaAppLayerResource (..)
    , opsworksJavaAppLayerResource

    , OpsworksMemcachedLayerResource (..)
    , opsworksMemcachedLayerResource

    , OpsworksMysqlLayerResource (..)
    , opsworksMysqlLayerResource

    , OpsworksNodejsAppLayerResource (..)
    , opsworksNodejsAppLayerResource

    , OpsworksPermissionResource (..)
    , opsworksPermissionResource

    , OpsworksPhpAppLayerResource (..)
    , opsworksPhpAppLayerResource

    , OpsworksRailsAppLayerResource (..)
    , opsworksRailsAppLayerResource

    , OpsworksRdsDbInstanceResource (..)
    , opsworksRdsDbInstanceResource

    , OpsworksStackResource (..)
    , opsworksStackResource

    , OpsworksStaticWebLayerResource (..)
    , opsworksStaticWebLayerResource

    , OpsworksUserProfileResource (..)
    , opsworksUserProfileResource

    , PlacementGroupResource (..)
    , placementGroupResource

    , ProxyProtocolPolicyResource (..)
    , proxyProtocolPolicyResource

    , RdsClusterInstanceResource (..)
    , rdsClusterInstanceResource

    , RdsClusterParameterGroupResource (..)
    , rdsClusterParameterGroupResource

    , RdsClusterResource (..)
    , rdsClusterResource

    , RedshiftClusterResource (..)
    , redshiftClusterResource

    , RedshiftParameterGroupResource (..)
    , redshiftParameterGroupResource

    , RedshiftSecurityGroupResource (..)
    , redshiftSecurityGroupResource

    , RedshiftSubnetGroupResource (..)
    , redshiftSubnetGroupResource

    , Route53DelegationSetResource (..)
    , route53DelegationSetResource

    , Route53HealthCheckResource (..)
    , route53HealthCheckResource

    , Route53QueryLogResource (..)
    , route53QueryLogResource

    , Route53RecordResource (..)
    , route53RecordResource

    , Route53ZoneAssociationResource (..)
    , route53ZoneAssociationResource

    , Route53ZoneResource (..)
    , route53ZoneResource

    , RouteResource (..)
    , routeResource

    , RouteTableAssociationResource (..)
    , routeTableAssociationResource

    , RouteTableResource (..)
    , routeTableResource

    , S3BucketNotificationResource (..)
    , s3BucketNotificationResource

    , S3BucketObjectResource (..)
    , s3BucketObjectResource

    , S3BucketPolicyResource (..)
    , s3BucketPolicyResource

    , S3BucketResource (..)
    , s3BucketResource

    , SecurityGroupResource (..)
    , securityGroupResource

    , SecurityGroupRuleResource (..)
    , securityGroupRuleResource

    , ServiceDiscoveryPrivateDnsNamespaceResource (..)
    , serviceDiscoveryPrivateDnsNamespaceResource

    , ServiceDiscoveryPublicDnsNamespaceResource (..)
    , serviceDiscoveryPublicDnsNamespaceResource

    , ServiceDiscoveryServiceResource (..)
    , serviceDiscoveryServiceResource

    , ServicecatalogPortfolioResource (..)
    , servicecatalogPortfolioResource

    , SesActiveReceiptRuleSetResource (..)
    , sesActiveReceiptRuleSetResource

    , SesConfigurationSetResource (..)
    , sesConfigurationSetResource

    , SesDomainDkimResource (..)
    , sesDomainDkimResource

    , SesDomainIdentityResource (..)
    , sesDomainIdentityResource

    , SesEventDestinationResource (..)
    , sesEventDestinationResource

    , SesReceiptFilterResource (..)
    , sesReceiptFilterResource

    , SesReceiptRuleResource (..)
    , sesReceiptRuleResource

    , SesReceiptRuleSetResource (..)
    , sesReceiptRuleSetResource

    , SesTemplateResource (..)
    , sesTemplateResource

    , SimpledbDomainResource (..)
    , simpledbDomainResource

    , SnapshotCreateVolumePermissionResource (..)
    , snapshotCreateVolumePermissionResource

    , SnsTopicPolicyResource (..)
    , snsTopicPolicyResource

    , SnsTopicResource (..)
    , snsTopicResource

    , SnsTopicSubscriptionResource (..)
    , snsTopicSubscriptionResource

    , SpotDatafeedSubscriptionResource (..)
    , spotDatafeedSubscriptionResource

    , SpotFleetRequestResource (..)
    , spotFleetRequestResource

    , SpotInstanceRequestResource (..)
    , spotInstanceRequestResource

    , SqsQueuePolicyResource (..)
    , sqsQueuePolicyResource

    , SqsQueueResource (..)
    , sqsQueueResource

    , SsmActivationResource (..)
    , ssmActivationResource

    , SsmAssociationResource (..)
    , ssmAssociationResource

    , SsmDocumentResource (..)
    , ssmDocumentResource

    , SsmMaintenanceWindowResource (..)
    , ssmMaintenanceWindowResource

    , SsmMaintenanceWindowTargetResource (..)
    , ssmMaintenanceWindowTargetResource

    , SsmMaintenanceWindowTaskResource (..)
    , ssmMaintenanceWindowTaskResource

    , SsmParameterResource (..)
    , ssmParameterResource

    , SsmPatchBaselineResource (..)
    , ssmPatchBaselineResource

    , SsmPatchGroupResource (..)
    , ssmPatchGroupResource

    , StateMachineResource (..)
    , stateMachineResource

    , SubnetResource (..)
    , subnetResource

    , VolumeAttachmentResource (..)
    , volumeAttachmentResource

    , VpcDhcpOptionsAssociationResource (..)
    , vpcDhcpOptionsAssociationResource

    , VpcDhcpOptionsResource (..)
    , vpcDhcpOptionsResource

    , VpcEndpointResource (..)
    , vpcEndpointResource

    , VpcEndpointRouteTableAssociationResource (..)
    , vpcEndpointRouteTableAssociationResource

    , VpcPeeringConnectionAccepterResource (..)
    , vpcPeeringConnectionAccepterResource

    , VpcPeeringConnectionResource (..)
    , vpcPeeringConnectionResource

    , VpcResource (..)
    , vpcResource

    , VpnConnectionResource (..)
    , vpnConnectionResource

    , VpnConnectionRouteResource (..)
    , vpnConnectionRouteResource

    , VpnGatewayAttachmentResource (..)
    , vpnGatewayAttachmentResource

    , VpnGatewayResource (..)
    , vpnGatewayResource

    , VpnGatewayRoutePropagationResource (..)
    , vpnGatewayRoutePropagationResource

    , WafByteMatchSetResource (..)
    , wafByteMatchSetResource

    , WafIpsetResource (..)
    , wafIpsetResource

    , WafRateBasedRuleResource (..)
    , wafRateBasedRuleResource

    , WafRuleResource (..)
    , wafRuleResource

    , WafSizeConstraintSetResource (..)
    , wafSizeConstraintSetResource

    , WafSqlInjectionMatchSetResource (..)
    , wafSqlInjectionMatchSetResource

    , WafWebAclResource (..)
    , wafWebAclResource

    , WafXssMatchSetResource (..)
    , wafXssMatchSetResource

    , WafregionalByteMatchSetResource (..)
    , wafregionalByteMatchSetResource

    , WafregionalIpsetResource (..)
    , wafregionalIpsetResource

    -- * Overloaded Fields
    -- ** Arguments
    , HasAccelerationStatus (..)
    , HasAccepter (..)
    , HasAccessLogs (..)
    , HasAccessPolicies (..)
    , HasAccessPolicy (..)
    , HasAccountAlias (..)
    , HasAccountId (..)
    , HasAcl (..)
    , HasAction (..)
    , HasActionsEnabled (..)
    , HasActive (..)
    , HasAddHeaderAction (..)
    , HasAdjustmentType (..)
    , HasAdminCreateUserConfig (..)
    , HasAdvancedOptions (..)
    , HasAfter (..)
    , HasAgentVersion (..)
    , HasAlarmActions (..)
    , HasAlarmConfiguration (..)
    , HasAlarmDescription (..)
    , HasAlarmName (..)
    , HasAlbTargetGroupArn (..)
    , HasAlias (..)
    , HasAliasAttributes (..)
    , HasAliases (..)
    , HasAllocatedMemory (..)
    , HasAllocatedStorage (..)
    , HasAllocationId (..)
    , HasAllocationStrategy (..)
    , HasAllowMajorVersionUpgrade (..)
    , HasAllowReassociation (..)
    , HasAllowSelfManagement (..)
    , HasAllowSsh (..)
    , HasAllowSudo (..)
    , HasAllowUnassociatedTargets (..)
    , HasAllowUnauthenticatedIdentities (..)
    , HasAllowUsersToChangePassword (..)
    , HasAllowVersionUpgrade (..)
    , HasAllowedOauthFlows (..)
    , HasAllowedOauthFlowsUserPoolClient (..)
    , HasAllowedOauthScopes (..)
    , HasAmi (..)
    , HasAmiId (..)
    , HasApiId (..)
    , HasApiKeyRequired (..)
    , HasApiStages (..)
    , HasAppName (..)
    , HasAppServer (..)
    , HasAppServerVersion (..)
    , HasAppSource (..)
    , HasApplication (..)
    , HasApplications (..)
    , HasApplyImmediately (..)
    , HasApprovalRule (..)
    , HasApprovedPatches (..)
    , HasApprovedPatchesComplianceLevel (..)
    , HasArchitecture (..)
    , HasArn (..)
    , HasArtifactStore (..)
    , HasArtifacts (..)
    , HasAssignGeneratedIpv6CidrBlock (..)
    , HasAssignIpv6AddressOnCreation (..)
    , HasAssociatePublicIpAddress (..)
    , HasAssociateWithPrivateIp (..)
    , HasAssociationName (..)
    , HasAssumeRolePolicy (..)
    , HasAtRestEncryptionEnabled (..)
    , HasAttachment (..)
    , HasAttribute (..)
    , HasAudio (..)
    , HasAudioCodecOptions (..)
    , HasAuthToken (..)
    , HasAuthorization (..)
    , HasAuthorizerCredentials (..)
    , HasAuthorizerId (..)
    , HasAuthorizerResultTtlInSeconds (..)
    , HasAuthorizerUri (..)
    , HasAutoAccept (..)
    , HasAutoAssignElasticIps (..)
    , HasAutoAssignPublicIps (..)
    , HasAutoBundleOnDeploy (..)
    , HasAutoHealing (..)
    , HasAutoMinorVersionUpgrade (..)
    , HasAutoRollbackConfiguration (..)
    , HasAutoScalingType (..)
    , HasAutoVerifiedAttributes (..)
    , HasAutomatedSnapshotRetentionPeriod (..)
    , HasAutomaticFailoverEnabled (..)
    , HasAutoscalingGroupName (..)
    , HasAutoscalingGroups (..)
    , HasAutoscalingRole (..)
    , HasAvailabilityZone (..)
    , HasAvailabilityZones (..)
    , HasAwsFlowRubySettings (..)
    , HasAwsKmsKeyArn (..)
    , HasAzMode (..)
    , HasBackupRetentionPeriod (..)
    , HasBackupWindow (..)
    , HasBandwidth (..)
    , HasBasePath (..)
    , HasBaselineId (..)
    , HasBatchSize (..)
    , HasBerkshelfVersion (..)
    , HasBgpAsn (..)
    , HasBinaryMediaTypes (..)
    , HasBlockDurationMinutes (..)
    , HasBlueGreenDeploymentConfig (..)
    , HasBlueprintId (..)
    , HasBody (..)
    , HasBootstrapAction (..)
    , HasBounceAction (..)
    , HasBranches (..)
    , HasBrokerName (..)
    , HasBucket (..)
    , HasBucketPrefix (..)
    , HasBuildTimeout (..)
    , HasBundleId (..)
    , HasBundlerVersion (..)
    , HasByteMatchTuple (..)
    , HasByteMatchTuples (..)
    , HasCacheBehavior (..)
    , HasCacheClusterEnabled (..)
    , HasCacheClusterSize (..)
    , HasCacheControl (..)
    , HasCacheKeyNamespace (..)
    , HasCacheKeyParameters (..)
    , HasCallbackUrls (..)
    , HasCapabilities (..)
    , HasCatalogId (..)
    , HasCdcStartTime (..)
    , HasCertificateArn (..)
    , HasCertificateBody (..)
    , HasCertificateChain (..)
    , HasCertificateId (..)
    , HasCertificateName (..)
    , HasCertificatePem (..)
    , HasCertificatePrivateKey (..)
    , HasCertificateWallet (..)
    , HasCharacterSetName (..)
    , HasChildHealthThreshold (..)
    , HasChildHealthchecks (..)
    , HasCidr (..)
    , HasCidrBlock (..)
    , HasCidrBlocks (..)
    , HasClientCertificateId (..)
    , HasClientIdList (..)
    , HasCloudWatchLogsGroupArn (..)
    , HasCloudWatchLogsRoleArn (..)
    , HasCloudwatchAlarmName (..)
    , HasCloudwatchAlarmRegion (..)
    , HasCloudwatchDestination (..)
    , HasCloudwatchLogGroupArn (..)
    , HasCloudwatchRoleArn (..)
    , HasCluster (..)
    , HasClusterConfig (..)
    , HasClusterId (..)
    , HasClusterIdentifier (..)
    , HasClusterIdentifierPrefix (..)
    , HasClusterMode (..)
    , HasClusterParameterGroupName (..)
    , HasClusterSecurityGroups (..)
    , HasClusterSubnetGroupName (..)
    , HasClusterType (..)
    , HasClusterVersion (..)
    , HasCnamePrefix (..)
    , HasCognitoIdentityProviders (..)
    , HasColor (..)
    , HasComment (..)
    , HasComparisonOperator (..)
    , HasComputeEnvironmentName (..)
    , HasComputeEnvironments (..)
    , HasComputeResources (..)
    , HasCondition (..)
    , HasConfiguration (..)
    , HasConfigurationManagerName (..)
    , HasConfigurationManagerVersion (..)
    , HasConfigurationSetName (..)
    , HasConfigurations (..)
    , HasConfirmationTimeoutInMinutes (..)
    , HasConnectSettings (..)
    , HasConnectionDraining (..)
    , HasConnectionDrainingTimeout (..)
    , HasConnectionId (..)
    , HasConnectionsBandwidth (..)
    , HasContainer (..)
    , HasContainerDefinitions (..)
    , HasContainerProperties (..)
    , HasContent (..)
    , HasContentBasedDeduplication (..)
    , HasContentConfig (..)
    , HasContentConfigPermissions (..)
    , HasContentDisposition (..)
    , HasContentEncoding (..)
    , HasContentHandling (..)
    , HasContentLanguage (..)
    , HasContentType (..)
    , HasCookieExpirationPeriod (..)
    , HasCookieName (..)
    , HasCopyTagsToSnapshot (..)
    , HasCoreInstanceCount (..)
    , HasCoreInstanceType (..)
    , HasCorsRule (..)
    , HasCreationToken (..)
    , HasCredentials (..)
    , HasCrossZoneLoadBalancing (..)
    , HasCsr (..)
    , HasCustomCookbooksSource (..)
    , HasCustomData (..)
    , HasCustomErrorResponse (..)
    , HasCustomInstanceProfileArn (..)
    , HasCustomJson (..)
    , HasCustomSecurityGroupIds (..)
    , HasCustomerGatewayId (..)
    , HasCutoff (..)
    , HasDashboardBody (..)
    , HasDashboardName (..)
    , HasData' (..)
    , HasDataSourceArn (..)
    , HasDataSourceDatabaseName (..)
    , HasDataSourceType (..)
    , HasDatabase (..)
    , HasDatabaseName (..)
    , HasDatapointsToAlarm (..)
    , HasDbClusterParameterGroupName (..)
    , HasDbInstanceIdentifier (..)
    , HasDbParameterGroupName (..)
    , HasDbPassword (..)
    , HasDbSnapshotIdentifier (..)
    , HasDbSubnetGroupName (..)
    , HasDbUser (..)
    , HasDeadLetterConfig (..)
    , HasDefaultAction (..)
    , HasDefaultAvailabilityZone (..)
    , HasDefaultBranch (..)
    , HasDefaultCacheBehavior (..)
    , HasDefaultCooldown (..)
    , HasDefaultInstanceProfileArn (..)
    , HasDefaultNetworkAclId (..)
    , HasDefaultOs (..)
    , HasDefaultRedirectUri (..)
    , HasDefaultResult (..)
    , HasDefaultRootDeviceType (..)
    , HasDefaultRootObject (..)
    , HasDefaultRouteTableId (..)
    , HasDefaultSshKeyName (..)
    , HasDefaultSubnetId (..)
    , HasDefinition (..)
    , HasDelaySeconds (..)
    , HasDelegationSetId (..)
    , HasDeletionWindowInDays (..)
    , HasDeliveryPolicy (..)
    , HasDeploymentConfigName (..)
    , HasDeploymentGroupName (..)
    , HasDeploymentId (..)
    , HasDeploymentMaximumPercent (..)
    , HasDeploymentMinimumHealthyPercent (..)
    , HasDeploymentMode (..)
    , HasDeploymentStyle (..)
    , HasDeregistrationDelay (..)
    , HasDescription (..)
    , HasDesiredCapacity (..)
    , HasDesiredCount (..)
    , HasDestination (..)
    , HasDestinationArn (..)
    , HasDestinationCidrBlock (..)
    , HasDestinationIpv6CidrBlock (..)
    , HasDestinationName (..)
    , HasDetectorId (..)
    , HasDeveloperProviderName (..)
    , HasDeviceConfiguration (..)
    , HasDeviceIndex (..)
    , HasDeviceName (..)
    , HasDhcpOptionsId (..)
    , HasDimensions (..)
    , HasDisableApiTermination (..)
    , HasDisableRollback (..)
    , HasDisplayName (..)
    , HasDnsConfig (..)
    , HasDocumentRoot (..)
    , HasDocumentType (..)
    , HasDocumentVersion (..)
    , HasDocumentationVersion (..)
    , HasDomain (..)
    , HasDomainName (..)
    , HasDomainNameServers (..)
    , HasDomains (..)
    , HasDrainElbOnShutdown (..)
    , HasDuration (..)
    , HasEbsBlockDevice (..)
    , HasEbsConfig (..)
    , HasEbsOptimized (..)
    , HasEbsOptions (..)
    , HasEbsRootVolumeSize (..)
    , HasEbsVolume (..)
    , HasEc2Attributes (..)
    , HasEc2TagFilter (..)
    , HasEcsTarget (..)
    , HasEgress (..)
    , HasEgressOnlyGatewayId (..)
    , HasElasticIp (..)
    , HasElasticLoadBalancer (..)
    , HasElasticsearchVersion (..)
    , HasElb (..)
    , HasEmail (..)
    , HasEmailConfiguration (..)
    , HasEmailVerificationMessage (..)
    , HasEmailVerificationSubject (..)
    , HasEnable (..)
    , HasEnableClassiclink (..)
    , HasEnableClassiclinkDnsSupport (..)
    , HasEnableDeletionProtection (..)
    , HasEnableDnsHostnames (..)
    , HasEnableDnsSupport (..)
    , HasEnableKeyRotation (..)
    , HasEnableLogFileValidation (..)
    , HasEnableLogging (..)
    , HasEnableMonitoring (..)
    , HasEnableSni (..)
    , HasEnableSsl (..)
    , HasEnableSso (..)
    , HasEnabled (..)
    , HasEnabledMetrics (..)
    , HasEncoding (..)
    , HasEncryptAtRest (..)
    , HasEncrypted (..)
    , HasEncryptionKey (..)
    , HasEncryptionType (..)
    , HasEndTime (..)
    , HasEndpoint (..)
    , HasEndpointAutoConfirms (..)
    , HasEndpointId (..)
    , HasEndpointType (..)
    , HasEngine (..)
    , HasEngineName (..)
    , HasEngineType (..)
    , HasEngineVersion (..)
    , HasEnhancedVpcRouting (..)
    , HasEniId (..)
    , HasEnvironment (..)
    , HasEnvironmentId (..)
    , HasEphemeralBlockDevice (..)
    , HasEtag (..)
    , HasEvaluateLowSampleCountPercentiles (..)
    , HasEvaluationPeriods (..)
    , HasEventCategories (..)
    , HasEventPattern (..)
    , HasEventSourceArn (..)
    , HasEvents (..)
    , HasExcessCapacityTerminationPolicy (..)
    , HasExpirationDate (..)
    , HasExplicitAuthFlows (..)
    , HasExtendedS3Configuration (..)
    , HasExtendedStatistic (..)
    , HasExtraConnectionAttributes (..)
    , HasFailoverRoutingPolicy (..)
    , HasFailureThreshold (..)
    , HasFamily' (..)
    , HasFifoQueue (..)
    , HasFileSystemId (..)
    , HasFilename (..)
    , HasFilterPattern (..)
    , HasFinalSnapshotIdentifier (..)
    , HasForceDelete (..)
    , HasForceDestroy (..)
    , HasForceDetach (..)
    , HasFqdn (..)
    , HasFromPort (..)
    , HasFunctionName (..)
    , HasFunctionVersion (..)
    , HasGatewayId (..)
    , HasGenerateSecret (..)
    , HasGeolocationRoutingPolicy (..)
    , HasGlobalFilter (..)
    , HasGlobalSecondaryIndex (..)
    , HasGroup (..)
    , HasGroupNames (..)
    , HasGroups (..)
    , HasHandler (..)
    , HasHardExpiry (..)
    , HasHashKey (..)
    , HasHealthCheck (..)
    , HasHealthCheckConfig (..)
    , HasHealthCheckGracePeriod (..)
    , HasHealthCheckGracePeriodSeconds (..)
    , HasHealthCheckId (..)
    , HasHealthCheckType (..)
    , HasHealthcheckMethod (..)
    , HasHealthcheckUrl (..)
    , HasHeartbeatTimeout (..)
    , HasHostInstanceType (..)
    , HasHostname (..)
    , HasHostnameTheme (..)
    , HasHtml (..)
    , HasHttpMethod (..)
    , HasHttpVersion (..)
    , HasIamDatabaseAuthenticationEnabled (..)
    , HasIamFleetRole (..)
    , HasIamInstanceProfile (..)
    , HasIamRole (..)
    , HasIamRoleArn (..)
    , HasIamRoles (..)
    , HasIcmpCode (..)
    , HasIcmpType (..)
    , HasIdentifier (..)
    , HasIdentifierPrefix (..)
    , HasIdentityPoolId (..)
    , HasIdentityPoolName (..)
    , HasIdentitySource (..)
    , HasIdentityValidationExpression (..)
    , HasIdleTimeout (..)
    , HasImageId (..)
    , HasIncludeGlobalServiceEvents (..)
    , HasIngress (..)
    , HasInitialLifecycleHook (..)
    , HasInput (..)
    , HasInputBucket (..)
    , HasInputParameters (..)
    , HasInputPath (..)
    , HasInputTransformer (..)
    , HasInstallUpdatesOnBoot (..)
    , HasInstance' (..)
    , HasInstanceClass (..)
    , HasInstanceCount (..)
    , HasInstanceGroup (..)
    , HasInstanceId (..)
    , HasInstanceInitiatedShutdownBehavior (..)
    , HasInstanceInterruptionBehavior (..)
    , HasInstanceName (..)
    , HasInstancePort (..)
    , HasInstancePorts (..)
    , HasInstanceShutdownTimeout (..)
    , HasInstanceTenancy (..)
    , HasInstanceType (..)
    , HasInstances (..)
    , HasInsufficientDataActions (..)
    , HasInsufficientDataHealthStatus (..)
    , HasIntegrationHttpMethod (..)
    , HasInternal (..)
    , HasInvertHealthcheck (..)
    , HasIops (..)
    , HasIpAddress (..)
    , HasIpAddressType (..)
    , HasIpSetDescriptor (..)
    , HasIpSetDescriptors (..)
    , HasIpv6AddressCount (..)
    , HasIpv6Addresses (..)
    , HasIpv6CidrBlock (..)
    , HasIpv6CidrBlocks (..)
    , HasIsEnabled (..)
    , HasIsIpv6Enabled (..)
    , HasIsMultiRegionTrail (..)
    , HasJvmOptions (..)
    , HasJvmType (..)
    , HasJvmVersion (..)
    , HasKeepJobFlowAliveWhenNoSteps (..)
    , HasKey (..)
    , HasKeyId (..)
    , HasKeyName (..)
    , HasKeyNamePrefix (..)
    , HasKeyPairName (..)
    , HasKeyType (..)
    , HasKeyUsage (..)
    , HasKinesisDestination (..)
    , HasKinesisSourceConfiguration (..)
    , HasKmsDataKeyReusePeriodSeconds (..)
    , HasKmsKeyArn (..)
    , HasKmsKeyId (..)
    , HasKmsMasterKeyId (..)
    , HasLagId (..)
    , HasLambdaAction (..)
    , HasLambdaConfig (..)
    , HasLambdaFunction (..)
    , HasLatencyRoutingPolicy (..)
    , HasLaunchConfiguration (..)
    , HasLaunchGroup (..)
    , HasLaunchSpecification (..)
    , HasLaunchType (..)
    , HasLayerIds (..)
    , HasLbPort (..)
    , HasLevel (..)
    , HasLicenseModel (..)
    , HasLifecycleRule (..)
    , HasLifecycleTransition (..)
    , HasListener (..)
    , HasListenerArn (..)
    , HasLoadBalancer (..)
    , HasLoadBalancerArn (..)
    , HasLoadBalancerInfo (..)
    , HasLoadBalancerName (..)
    , HasLoadBalancerPort (..)
    , HasLoadBalancerType (..)
    , HasLoadBalancers (..)
    , HasLocalSecondaryIndex (..)
    , HasLocation (..)
    , HasLocationUri (..)
    , HasLogGroupName (..)
    , HasLogPublishingOptions (..)
    , HasLogUri (..)
    , HasLogging (..)
    , HasLoggingConfig (..)
    , HasLoggingInfo (..)
    , HasLogoutUrls (..)
    , HasMaintenanceWindow (..)
    , HasMaintenanceWindowStartTime (..)
    , HasMajorEngineVersion (..)
    , HasManageBerkshelf (..)
    , HasManageBundler (..)
    , HasMapPublicIpOnLaunch (..)
    , HasMasterInstanceType (..)
    , HasMasterPassword (..)
    , HasMasterUsername (..)
    , HasMatchingTypes (..)
    , HasMaxCapacity (..)
    , HasMaxConcurrency (..)
    , HasMaxErrors (..)
    , HasMaxMessageSize (..)
    , HasMaxPasswordAge (..)
    , HasMaxSize (..)
    , HasMaximumExecutionFrequency (..)
    , HasMeasureLatency (..)
    , HasMemorySize (..)
    , HasMessageRetentionSeconds (..)
    , HasMethodPath (..)
    , HasMetricName (..)
    , HasMetricTransformation (..)
    , HasMetricsGranularity (..)
    , HasMfaConfiguration (..)
    , HasMigrationType (..)
    , HasMinCapacity (..)
    , HasMinElbCapacity (..)
    , HasMinSize (..)
    , HasMinimumHealthyHosts (..)
    , HasMinimumPasswordLength (..)
    , HasMonitoring (..)
    , HasMonitoringInterval (..)
    , HasMonitoringRoleArn (..)
    , HasMultiAz (..)
    , HasMultivalueAnswerRoutingPolicy (..)
    , HasName (..)
    , HasNamePrefix (..)
    , HasNamespace (..)
    , HasNatGatewayId (..)
    , HasNetbiosNameServers (..)
    , HasNetbiosNodeType (..)
    , HasNetworkAclId (..)
    , HasNetworkConfiguration (..)
    , HasNetworkInterface (..)
    , HasNetworkInterfaceId (..)
    , HasNodeType (..)
    , HasNodejsVersion (..)
    , HasNotification (..)
    , HasNotificationArns (..)
    , HasNotificationMetadata (..)
    , HasNotificationTargetArn (..)
    , HasNotificationTopicArn (..)
    , HasNotifications (..)
    , HasNtpServers (..)
    , HasNumCacheNodes (..)
    , HasNumberCacheClusters (..)
    , HasNumberOfConnections (..)
    , HasNumberOfNodes (..)
    , HasOkActions (..)
    , HasOnFailure (..)
    , HasOnPremisesInstanceTagFilter (..)
    , HasOpenidConnectProviderArns (..)
    , HasOperatingSystem (..)
    , HasOption (..)
    , HasOptionGroupDescription (..)
    , HasOptionGroupName (..)
    , HasOrigin (..)
    , HasOs (..)
    , HasOutputBucket (..)
    , HasOutputLocation (..)
    , HasOverwrite (..)
    , HasOwnerAccount (..)
    , HasOwnerInformation (..)
    , HasParameter (..)
    , HasParameterGroupName (..)
    , HasParameters (..)
    , HasParentId (..)
    , HasPassengerVersion (..)
    , HasPassthroughBehavior (..)
    , HasPassword (..)
    , HasPasswordLength (..)
    , HasPasswordPolicy (..)
    , HasPasswordResetRequired (..)
    , HasPasswordReusePrevention (..)
    , HasPatchGroup (..)
    , HasPath (..)
    , HasPathPart (..)
    , HasPattern (..)
    , HasPeerOwnerId (..)
    , HasPeerRegion (..)
    , HasPeerVpcId (..)
    , HasPerformanceInsightsEnabled (..)
    , HasPerformanceInsightsKmsKeyId (..)
    , HasPerformanceMode (..)
    , HasPeriod (..)
    , HasPermissions (..)
    , HasPgpKey (..)
    , HasPlacementConstraints (..)
    , HasPlacementGroup (..)
    , HasPlacementStrategy (..)
    , HasPlacementTenancy (..)
    , HasPolicy (..)
    , HasPolicyArn (..)
    , HasPolicyAttribute (..)
    , HasPolicyBody (..)
    , HasPolicyDocument (..)
    , HasPolicyName (..)
    , HasPolicyNames (..)
    , HasPolicyType (..)
    , HasPolicyTypeName (..)
    , HasPolicyUrl (..)
    , HasPollInterval (..)
    , HasPort (..)
    , HasPredicates (..)
    , HasPreferredBackupWindow (..)
    , HasPreferredMaintenanceWindow (..)
    , HasPrefix (..)
    , HasPrefixListIds (..)
    , HasPriceClass (..)
    , HasPrincipal (..)
    , HasPriority (..)
    , HasPrivateIp (..)
    , HasPrivateIpAddress (..)
    , HasPrivateIps (..)
    , HasPrivateIpsCount (..)
    , HasPrivateKey (..)
    , HasProductCode (..)
    , HasPromotionTier (..)
    , HasPropagatingVgws (..)
    , HasProperties (..)
    , HasProtectFromScaleIn (..)
    , HasProtocol (..)
    , HasProviderName (..)
    , HasPublicIp (..)
    , HasPublicKey (..)
    , HasPubliclyAccessible (..)
    , HasPublish (..)
    , HasQualifier (..)
    , HasQuery (..)
    , HasQueue (..)
    , HasQueueUrl (..)
    , HasQuotaSettings (..)
    , HasRailsEnv (..)
    , HasRangeKey (..)
    , HasRateKey (..)
    , HasRateLimit (..)
    , HasRawMessageDelivery (..)
    , HasRdsDbInstanceArn (..)
    , HasReadAttributes (..)
    , HasReadCapacity (..)
    , HasReceiveWaitTimeSeconds (..)
    , HasRecipients (..)
    , HasRecordingGroup (..)
    , HasRecords (..)
    , HasRecurrence (..)
    , HasRedrivePolicy (..)
    , HasRedshiftConfiguration (..)
    , HasReferenceName (..)
    , HasRefreshTokenValidity (..)
    , HasRegion (..)
    , HasRegions (..)
    , HasRegistrationLimit (..)
    , HasRejectedPatches (..)
    , HasReleaseLabel (..)
    , HasReplaceUnhealthyInstances (..)
    , HasReplicateSourceDb (..)
    , HasReplicationConfiguration (..)
    , HasReplicationGroupDescription (..)
    , HasReplicationGroupId (..)
    , HasReplicationInstanceArn (..)
    , HasReplicationInstanceClass (..)
    , HasReplicationInstanceId (..)
    , HasReplicationSubnetGroupDescription (..)
    , HasReplicationSubnetGroupId (..)
    , HasReplicationTaskId (..)
    , HasReplicationTaskSettings (..)
    , HasRepository (..)
    , HasRepositoryName (..)
    , HasRequestInterval (..)
    , HasRequestModels (..)
    , HasRequestParameters (..)
    , HasRequestParametersInJson (..)
    , HasRequestPayer (..)
    , HasRequestTemplates (..)
    , HasRequestValidatorId (..)
    , HasRequester (..)
    , HasRequireLowercaseCharacters (..)
    , HasRequireNumbers (..)
    , HasRequireSymbols (..)
    , HasRequireUppercaseCharacters (..)
    , HasReservedConcurrentExecutions (..)
    , HasResourceGroupArn (..)
    , HasResourceId (..)
    , HasResourcePath (..)
    , HasResourceType (..)
    , HasResponseModels (..)
    , HasResponseParameters (..)
    , HasResponseParametersInJson (..)
    , HasResponseTemplates (..)
    , HasResponseType (..)
    , HasRestApiId (..)
    , HasRestrictions (..)
    , HasRetainOnDelete (..)
    , HasRetentionInDays (..)
    , HasRetentionPeriod (..)
    , HasRetryStrategy (..)
    , HasRevokeRulesOnDelete (..)
    , HasRole (..)
    , HasRoleArn (..)
    , HasRoleMapping (..)
    , HasRoles (..)
    , HasRootBlockDevice (..)
    , HasRootDeviceName (..)
    , HasRootDeviceType (..)
    , HasRootPassword (..)
    , HasRootPasswordOnAllInstances (..)
    , HasRoute (..)
    , HasRouteTableId (..)
    , HasRouteTableIds (..)
    , HasRubyVersion (..)
    , HasRubygemsVersion (..)
    , HasRule (..)
    , HasRuleAction (..)
    , HasRuleNumber (..)
    , HasRuleSetName (..)
    , HasRules (..)
    , HasRulesPackageArns (..)
    , HasRunCommandTargets (..)
    , HasRuntime (..)
    , HasS3Action (..)
    , HasS3Bucket (..)
    , HasS3BucketName (..)
    , HasS3Configuration (..)
    , HasS3Destination (..)
    , HasS3Key (..)
    , HasS3KeyPrefix (..)
    , HasS3ObjectVersion (..)
    , HasSamlMetadataDocument (..)
    , HasSamlProviderArns (..)
    , HasScalableDimension (..)
    , HasScalableTargetAction (..)
    , HasScanEnabled (..)
    , HasSchedule (..)
    , HasScheduleExpression (..)
    , HasScheduledActionName (..)
    , HasSchema (..)
    , HasScope (..)
    , HasSearchString (..)
    , HasSecurityConfiguration (..)
    , HasSecurityGroupId (..)
    , HasSecurityGroupIds (..)
    , HasSecurityGroupNames (..)
    , HasSecurityGroups (..)
    , HasSelectionPattern (..)
    , HasSelf (..)
    , HasServerName (..)
    , HasServerSideEncryption (..)
    , HasServerSideEncryptionConfiguration (..)
    , HasServiceAccessRole (..)
    , HasServiceName (..)
    , HasServiceNamespace (..)
    , HasServiceRole (..)
    , HasServiceRoleArn (..)
    , HasSetIdentifier (..)
    , HasSetting (..)
    , HasSettings (..)
    , HasShardCount (..)
    , HasShardLevelMetrics (..)
    , HasShortName (..)
    , HasSize (..)
    , HasSizeConstraints (..)
    , HasSkipDestroy (..)
    , HasSkipFinalSnapshot (..)
    , HasSmsAuthenticationMessage (..)
    , HasSmsConfiguration (..)
    , HasSmsVerificationMessage (..)
    , HasSnapshotArns (..)
    , HasSnapshotClusterIdentifier (..)
    , HasSnapshotCopy (..)
    , HasSnapshotDeliveryProperties (..)
    , HasSnapshotId (..)
    , HasSnapshotIdentifier (..)
    , HasSnapshotName (..)
    , HasSnapshotOptions (..)
    , HasSnapshotRetentionLimit (..)
    , HasSnapshotWindow (..)
    , HasSnapshotWithoutReboot (..)
    , HasSnsAction (..)
    , HasSnsDestination (..)
    , HasSnsTopic (..)
    , HasSnsTopicArn (..)
    , HasSnsTopicName (..)
    , HasSolutionStackName (..)
    , HasSource (..)
    , HasSourceAccount (..)
    , HasSourceAmiId (..)
    , HasSourceAmiRegion (..)
    , HasSourceArn (..)
    , HasSourceCodeHash (..)
    , HasSourceDestCheck (..)
    , HasSourceEndpointArn (..)
    , HasSourceIds (..)
    , HasSourceInstanceId (..)
    , HasSourceSecurityGroupId (..)
    , HasSourceType (..)
    , HasSpotPrice (..)
    , HasSpotType (..)
    , HasSqlInjectionMatchTuples (..)
    , HasSshKeyName (..)
    , HasSshPublicKey (..)
    , HasSshUsername (..)
    , HasSslConfiguration (..)
    , HasSslMode (..)
    , HasSslPolicy (..)
    , HasStackId (..)
    , HasStage (..)
    , HasStageDescription (..)
    , HasStageKey (..)
    , HasStageName (..)
    , HasStartTime (..)
    , HasStartingPosition (..)
    , HasState (..)
    , HasStatementId (..)
    , HasStaticIpName (..)
    , HasStaticRoutesOnly (..)
    , HasStatistic (..)
    , HasStatsEnabled (..)
    , HasStatsPassword (..)
    , HasStatsUrl (..)
    , HasStatsUser (..)
    , HasStatus (..)
    , HasStatusCode (..)
    , HasStepScalingPolicyConfiguration (..)
    , HasStickiness (..)
    , HasStopAction (..)
    , HasStorageClass (..)
    , HasStorageEncrypted (..)
    , HasStorageType (..)
    , HasStrategy (..)
    , HasStreamEnabled (..)
    , HasStreamViewType (..)
    , HasSubject (..)
    , HasSubnetGroupName (..)
    , HasSubnetId (..)
    , HasSubnetIds (..)
    , HasSubnetMapping (..)
    , HasSubnets (..)
    , HasSupportedIdentityProviders (..)
    , HasSupportedLoginProviders (..)
    , HasSuspendedProcesses (..)
    , HasSystemPackages (..)
    , HasTableMappings (..)
    , HasTag (..)
    , HasTags (..)
    , HasTargetArn (..)
    , HasTargetCapacity (..)
    , HasTargetEndpointArn (..)
    , HasTargetGroupArn (..)
    , HasTargetGroupArns (..)
    , HasTargetId (..)
    , HasTargetKeyId (..)
    , HasTargetTrackingScalingPolicyConfiguration (..)
    , HasTargetType (..)
    , HasTargets (..)
    , HasTaskArn (..)
    , HasTaskDefinition (..)
    , HasTaskParameters (..)
    , HasTaskType (..)
    , HasTemplateBody (..)
    , HasTemplateName (..)
    , HasTemplateUrl (..)
    , HasTenancy (..)
    , HasTerminateInstancesWithExpiration (..)
    , HasTerminationPolicies (..)
    , HasTerminationProtection (..)
    , HasText (..)
    , HasThreshold (..)
    , HasThrottleSettings (..)
    , HasThumbnailConfig (..)
    , HasThumbnailConfigPermissions (..)
    , HasThumbnails (..)
    , HasThumbprintList (..)
    , HasTier (..)
    , HasTimeout (..)
    , HasTimeoutInMinutes (..)
    , HasTimezone (..)
    , HasTlsPolicy (..)
    , HasToPort (..)
    , HasTopic (..)
    , HasTopicArn (..)
    , HasTrafficType (..)
    , HasTransitEncryptionEnabled (..)
    , HasTreatMissingData (..)
    , HasTriggerConfiguration (..)
    , HasTtl (..)
    , HasType' (..)
    , HasUnit (..)
    , HasUri (..)
    , HasUrl (..)
    , HasUsagePlanId (..)
    , HasUseCustomCookbooks (..)
    , HasUseEbsOptimizedInstances (..)
    , HasUseOpsworksSecurityGroups (..)
    , HasUser (..)
    , HasUserArn (..)
    , HasUserData (..)
    , HasUserDataBase64 (..)
    , HasUserPoolId (..)
    , HasUsername (..)
    , HasUsernameAttributes (..)
    , HasUsers (..)
    , HasValidUntil (..)
    , HasValue (..)
    , HasVariables (..)
    , HasVerificationMessageTemplate (..)
    , HasVersionLabel (..)
    , HasVersioning (..)
    , HasVideo (..)
    , HasVideoCodecOptions (..)
    , HasVideoWatermarks (..)
    , HasViewerCertificate (..)
    , HasVirtualizationType (..)
    , HasVisibilityTimeoutSeconds (..)
    , HasVisibleToAllUsers (..)
    , HasVolumeId (..)
    , HasVolumeTags (..)
    , HasVpc (..)
    , HasVpcClassicLinkId (..)
    , HasVpcClassicLinkSecurityGroups (..)
    , HasVpcConfig (..)
    , HasVpcEndpointId (..)
    , HasVpcId (..)
    , HasVpcOptions (..)
    , HasVpcPeeringConnectionId (..)
    , HasVpcRegion (..)
    , HasVpcSecurityGroupIds (..)
    , HasVpcSettings (..)
    , HasVpcZoneIdentifier (..)
    , HasVpnConnectionId (..)
    , HasVpnGatewayId (..)
    , HasWaitForCapacityTimeout (..)
    , HasWaitForElbCapacity (..)
    , HasWaitForFulfillment (..)
    , HasWaitForReadyTimeout (..)
    , HasWebAclId (..)
    , HasWebsite (..)
    , HasWebsiteRedirect (..)
    , HasWeightedRoutingPolicy (..)
    , HasWindowId (..)
    , HasWorkmailAction (..)
    , HasWriteAttributes (..)
    , HasWriteCapacity (..)
    , HasXssMatchTuples (..)
    , HasZoneId (..)

    -- ** Computed Attributes
    , HasComputedAccessUrl (..)
    , HasComputedAccountId (..)
    , HasComputedActivationCode (..)
    , HasComputedAdjustmentType (..)
    , HasComputedAllocatedStorage (..)
    , HasComputedAllocationId (..)
    , HasComputedArn (..)
    , HasComputedArnSuffix (..)
    , HasComputedAssociateWithPrivateIp (..)
    , HasComputedAssociationId (..)
    , HasComputedAttachment (..)
    , HasComputedAttachmentId (..)
    , HasComputedAttribute (..)
    , HasComputedAutoscalingGroupName (..)
    , HasComputedAvailabilityZone (..)
    , HasComputedAvailabilityZones (..)
    , HasComputedAwsAccountId (..)
    , HasComputedBackupRetentionPeriod (..)
    , HasComputedBgpAsn (..)
    , HasComputedBucketDomainName (..)
    , HasComputedCacheNodes (..)
    , HasComputedCallerReference (..)
    , HasComputedCanonicalHostedZoneId (..)
    , HasComputedCertificateArn (..)
    , HasComputedCertificateUploadDate (..)
    , HasComputedCidrBlock (..)
    , HasComputedCidrBlocks (..)
    , HasComputedClientSecret (..)
    , HasComputedCloneUrlHttp (..)
    , HasComputedCloneUrlSsh (..)
    , HasComputedCloudfrontAccessIdentityPath (..)
    , HasComputedCloudfrontDistributionArn (..)
    , HasComputedCloudfrontDomainName (..)
    , HasComputedCloudfrontZoneId (..)
    , HasComputedClusterAddress (..)
    , HasComputedClusterIdentifier (..)
    , HasComputedClusterMembers (..)
    , HasComputedClusterResourceId (..)
    , HasComputedConfiguration (..)
    , HasComputedConfigurationEndpoint (..)
    , HasComputedConfigurationEndpointAddress (..)
    , HasComputedContent (..)
    , HasComputedCookieExpirationPeriod (..)
    , HasComputedCookieName (..)
    , HasComputedCreateDate (..)
    , HasComputedCreatedDate (..)
    , HasComputedCreationDate (..)
    , HasComputedCustomerGatewayConfiguration (..)
    , HasComputedCustomerGatewayId (..)
    , HasComputedDashboardArn (..)
    , HasComputedDataEncryptionKeyId (..)
    , HasComputedDatabaseName (..)
    , HasComputedDbSnapshotArn (..)
    , HasComputedDbiResourceId (..)
    , HasComputedDefaultCooldown (..)
    , HasComputedDefaultNetworkAclId (..)
    , HasComputedDefaultRouteTableId (..)
    , HasComputedDefaultSecurityGroupId (..)
    , HasComputedDefaultVersion (..)
    , HasComputedDefaultVersionId (..)
    , HasComputedDeploymentConfigId (..)
    , HasComputedDescription (..)
    , HasComputedDesiredCapacity (..)
    , HasComputedDestinationCidrBlock (..)
    , HasComputedDestinationIpv6CidrBlock (..)
    , HasComputedDeviceName (..)
    , HasComputedDkimTokens (..)
    , HasComputedDnsIpAddresses (..)
    , HasComputedDnsName (..)
    , HasComputedDocumentType (..)
    , HasComputedDomainId (..)
    , HasComputedEcsClusterArn (..)
    , HasComputedEgressOnlyGatewayId (..)
    , HasComputedEnableClassiclink (..)
    , HasComputedEnableDnsHostnames (..)
    , HasComputedEnableDnsSupport (..)
    , HasComputedEncrypted (..)
    , HasComputedEncryptedFingerprint (..)
    , HasComputedEncryptedPassword (..)
    , HasComputedEncryptedPrivateKey (..)
    , HasComputedEncryptedSecret (..)
    , HasComputedEncryptionKey (..)
    , HasComputedEndpoint (..)
    , HasComputedEndpointArn (..)
    , HasComputedEngine (..)
    , HasComputedEngineVersion (..)
    , HasComputedEtag (..)
    , HasComputedExecutionArn (..)
    , HasComputedExpirationDate (..)
    , HasComputedExpirePasswords (..)
    , HasComputedExpired (..)
    , HasComputedFingerprint (..)
    , HasComputedFqdn (..)
    , HasComputedFunctionArn (..)
    , HasComputedGatewayId (..)
    , HasComputedGroup (..)
    , HasComputedHash (..)
    , HasComputedHashType (..)
    , HasComputedHealthCheckGracePeriod (..)
    , HasComputedHealthCheckType (..)
    , HasComputedHomeRegion (..)
    , HasComputedHostedZone (..)
    , HasComputedHostedZoneId (..)
    , HasComputedIamArn (..)
    , HasComputedIamRole (..)
    , HasComputedId (..)
    , HasComputedIdentifier (..)
    , HasComputedInstance' (..)
    , HasComputedInstanceId (..)
    , HasComputedInstanceIds (..)
    , HasComputedInstancePort (..)
    , HasComputedInstanceTenancy (..)
    , HasComputedInvokeArn (..)
    , HasComputedInvokeUrl (..)
    , HasComputedIops (..)
    , HasComputedIpAddress (..)
    , HasComputedIpv6AssociationId (..)
    , HasComputedIpv6CidrBlock (..)
    , HasComputedKeyFingerprint (..)
    , HasComputedKeyId (..)
    , HasComputedKeyName (..)
    , HasComputedKeyType (..)
    , HasComputedKibanaEndpoint (..)
    , HasComputedKmsKeyArn (..)
    , HasComputedKmsKeyId (..)
    , HasComputedLastModified (..)
    , HasComputedLastProcessingResult (..)
    , HasComputedLastUpdatedDate (..)
    , HasComputedLatestRevision (..)
    , HasComputedLatestVersion (..)
    , HasComputedLaunchConfiguration (..)
    , HasComputedLbPort (..)
    , HasComputedLicenseModel (..)
    , HasComputedLoadBalancer (..)
    , HasComputedLoadBalancerName (..)
    , HasComputedLoadBalancerPort (..)
    , HasComputedLoadBalancers (..)
    , HasComputedLocation (..)
    , HasComputedMainRouteTableId (..)
    , HasComputedMaintenanceWindow (..)
    , HasComputedMasterUsername (..)
    , HasComputedMaxSize (..)
    , HasComputedMinSize (..)
    , HasComputedName (..)
    , HasComputedNameServers (..)
    , HasComputedNatGatewayId (..)
    , HasComputedNetworkInterface (..)
    , HasComputedNetworkInterfaceId (..)
    , HasComputedOptionGroupName (..)
    , HasComputedOriginalRouteTableId (..)
    , HasComputedOutputs (..)
    , HasComputedOwner (..)
    , HasComputedOwnerAlias (..)
    , HasComputedOwnerId (..)
    , HasComputedParameter (..)
    , HasComputedParameters (..)
    , HasComputedPath (..)
    , HasComputedPemEncodedCertificate (..)
    , HasComputedPerformanceInsightsEnabled (..)
    , HasComputedPerformanceInsightsKmsKeyId (..)
    , HasComputedPermissions (..)
    , HasComputedPlatformTypes (..)
    , HasComputedPolicy (..)
    , HasComputedPolicyName (..)
    , HasComputedPolicyType (..)
    , HasComputedPolicyTypeName (..)
    , HasComputedPort (..)
    , HasComputedPreferredBackupWindow (..)
    , HasComputedPreferredMaintenanceWindow (..)
    , HasComputedPrefixListId (..)
    , HasComputedPrimaryEndpointAddress (..)
    , HasComputedPrivateIp (..)
    , HasComputedPrivateIpAddress (..)
    , HasComputedPrivateIps (..)
    , HasComputedPrivateKey (..)
    , HasComputedPublicIp (..)
    , HasComputedPublicKey (..)
    , HasComputedQualifiedArn (..)
    , HasComputedReaderEndpoint (..)
    , HasComputedRegion (..)
    , HasComputedRegistrationCount (..)
    , HasComputedRegistrationLimit (..)
    , HasComputedRegistryId (..)
    , HasComputedReplicationInstanceArn (..)
    , HasComputedReplicationInstancePrivateIps (..)
    , HasComputedReplicationInstancePublicIps (..)
    , HasComputedReplicationSourceIdentifier (..)
    , HasComputedReplicationTaskArn (..)
    , HasComputedRepository (..)
    , HasComputedRepositoryId (..)
    , HasComputedRepositoryUrl (..)
    , HasComputedRole (..)
    , HasComputedRoles (..)
    , HasComputedRootResourceId (..)
    , HasComputedRouteTableId (..)
    , HasComputedRunningInstanceCount (..)
    , HasComputedS3Bucket (..)
    , HasComputedS3CanonicalUserId (..)
    , HasComputedSchemaVersion (..)
    , HasComputedSecret (..)
    , HasComputedSecurityGroupId (..)
    , HasComputedSecurityGroups (..)
    , HasComputedServiceRole (..)
    , HasComputedSesSmtpPassword (..)
    , HasComputedShardCount (..)
    , HasComputedSourceCodeHash (..)
    , HasComputedSourceDbSnapshotIdentifier (..)
    , HasComputedSourceDestCheck (..)
    , HasComputedSourceRegion (..)
    , HasComputedSshPublicKeyId (..)
    , HasComputedState (..)
    , HasComputedStateTransitionReason (..)
    , HasComputedStaticRoutesOnly (..)
    , HasComputedStatus (..)
    , HasComputedStatusReason (..)
    , HasComputedStorageEncrypted (..)
    , HasComputedStorageType (..)
    , HasComputedSubnetId (..)
    , HasComputedSupportCode (..)
    , HasComputedTags (..)
    , HasComputedTargetGroupArns (..)
    , HasComputedThrottleSettings (..)
    , HasComputedTunnel1Address (..)
    , HasComputedTunnel1BgpAsn (..)
    , HasComputedTunnel1BgpHoldtime (..)
    , HasComputedTunnel1CgwInsideAddress (..)
    , HasComputedTunnel1PresharedKey (..)
    , HasComputedTunnel1VgwInsideAddress (..)
    , HasComputedTunnel2Address (..)
    , HasComputedTunnel2BgpAsn (..)
    , HasComputedTunnel2BgpHoldtime (..)
    , HasComputedTunnel2CgwInsideAddress (..)
    , HasComputedTunnel2PresharedKey (..)
    , HasComputedTunnel2VgwInsideAddress (..)
    , HasComputedType' (..)
    , HasComputedUniqueId (..)
    , HasComputedUsagePlanId (..)
    , HasComputedUser (..)
    , HasComputedUsers (..)
    , HasComputedUuid (..)
    , HasComputedValidUntil (..)
    , HasComputedValue (..)
    , HasComputedVerificationToken (..)
    , HasComputedVersion (..)
    , HasComputedVersionId (..)
    , HasComputedVolumeId (..)
    , HasComputedVolumeSize (..)
    , HasComputedVpcId (..)
    , HasComputedVpcOptions0AvailabilityZones (..)
    , HasComputedVpcOptions0VpcId (..)
    , HasComputedVpcPeeringConnectionId (..)
    , HasComputedVpcRegion (..)
    , HasComputedVpcZoneIdentifier (..)
    , HasComputedVpnConnectionId (..)
    , HasComputedVpnGatewayId (..)
    , HasComputedWebsiteDomain (..)
    , HasComputedWebsiteEndpoint (..)
    , HasComputedWriter (..)
    , HasComputedZoneId (..)
    ) where

import Data.Maybe (catMaybes)
import Data.Text  (Text)

import GHC.Base (Eq, ($), (.))
import GHC.Show (Show)

import Lens.Micro (Getting, Lens', lens, to)

import qualified Terrafomo.AWS.Types as TF
import qualified Terrafomo.AWS.Provider as TF
import qualified Terrafomo.Syntax.Resource as TF
import qualified Terrafomo.Syntax.HCL      as TF
import qualified Terrafomo.Syntax.IP       as TF
import qualified Terrafomo.Syntax.Meta     as TF (configuration)
import qualified Terrafomo.Syntax.Resource as TF
import qualified Terrafomo.Syntax.Variable as TF

{- | The @sfn_activity@ AWS resource.

Provides a Step Function Activity resource
-}
data ActivityResource = ActivityResource {
      _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the activity to create. -}
    } deriving (Show, Eq)

instance TF.ToHCL ActivityResource where
    toHCL ActivityResource{..} = TF.block $ catMaybes
        [ TF.argument _name
        ]

instance HasName ActivityResource Text where
    name =
        lens (_name :: ActivityResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: ActivityResource)

instance HasComputedCreationDate ActivityResource Text where
    computedCreationDate =
        to (\_  -> TF.Compute "creation_date")

instance HasComputedId ActivityResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedName ActivityResource Text where
    computedName =
        to (\_  -> TF.Compute "name")

activityResource :: TF.Resource TF.AWS ActivityResource
activityResource =
    TF.newResource "sfn_activity" $
        ActivityResource {
            _name = TF.Nil
            }

{- | The @aws_ami_copy@ AWS resource.

The "AMI copy" resource allows duplication of an Amazon Machine Image (AMI),
including cross-region copies. If the source AMI has associated EBS
snapshots, those will also be duplicated along with the AMI. This is useful
for taking a single AMI provisioned in one region and making it available in
another for a multi-region deployment. Copying an AMI can take several
minutes. The creation of this resource will block until the new AMI is
available for use on new instances.
-}
data AmiCopyResource = AmiCopyResource {
      _encrypted :: !(TF.Argument "encrypted" Text)
    {- ^ (Optional) Specifies whether the destination snapshots of the copied image should be encrypted. Defaults to @false@ -}
    , _kms_key_id :: !(TF.Argument "kms_key_id" Text)
    {- ^ (Optional) The full ARN of the KMS Key to use when encrypting the snapshots of an image during a copy operation. If not specified, then the default AWS KMS Key will be used -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) A region-unique name for the AMI. -}
    , _source_ami_id :: !(TF.Argument "source_ami_id" Text)
    {- ^ (Required) The id of the AMI to copy. This id must be valid in the region given by @source_ami_region@ . -}
    , _source_ami_region :: !(TF.Argument "source_ami_region" TF.Region)
    {- ^ (Required) The region from which the AMI will be copied. This may be the same as the AWS provider region in order to create a copy within the same region. -}
    } deriving (Show, Eq)

instance TF.ToHCL AmiCopyResource where
    toHCL AmiCopyResource{..} = TF.block $ catMaybes
        [ TF.argument _encrypted
        , TF.argument _kms_key_id
        , TF.argument _name
        , TF.argument _source_ami_id
        , TF.argument _source_ami_region
        ]

instance HasEncrypted AmiCopyResource Text where
    encrypted =
        lens (_encrypted :: AmiCopyResource -> TF.Argument "encrypted" Text)
             (\s a -> s { _encrypted = a } :: AmiCopyResource)

instance HasKmsKeyId AmiCopyResource Text where
    kmsKeyId =
        lens (_kms_key_id :: AmiCopyResource -> TF.Argument "kms_key_id" Text)
             (\s a -> s { _kms_key_id = a } :: AmiCopyResource)

instance HasName AmiCopyResource Text where
    name =
        lens (_name :: AmiCopyResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: AmiCopyResource)

instance HasSourceAmiId AmiCopyResource Text where
    sourceAmiId =
        lens (_source_ami_id :: AmiCopyResource -> TF.Argument "source_ami_id" Text)
             (\s a -> s { _source_ami_id = a } :: AmiCopyResource)

instance HasSourceAmiRegion AmiCopyResource TF.Region where
    sourceAmiRegion =
        lens (_source_ami_region :: AmiCopyResource -> TF.Argument "source_ami_region" TF.Region)
             (\s a -> s { _source_ami_region = a } :: AmiCopyResource)

amiCopyResource :: TF.Resource TF.AWS AmiCopyResource
amiCopyResource =
    TF.newResource "aws_ami_copy" $
        AmiCopyResource {
            _encrypted = TF.Nil
            , _kms_key_id = TF.Nil
            , _name = TF.Nil
            , _source_ami_id = TF.Nil
            , _source_ami_region = TF.Nil
            }

{- | The @aws_ami_from_instance@ AWS resource.

The "AMI from instance" resource allows the creation of an Amazon Machine
Image (AMI) modelled after an existing EBS-backed EC2 instance. The created
AMI will refer to implicitly-created snapshots of the instance's EBS volumes
and mimick its assigned block device configuration at the time the resource
is created. This resource is best applied to an instance that is stopped
when this instance is created, so that the contents of the created image are
predictable. When applied to an instance that is running, the instance will
be stopped before taking the snapshots and then started back up again ,
resulting in a period of downtime. Note that the source instance is
inspected only at the initial creation of this resource. Ongoing updates to
the referenced instance will not be propagated into the generated AMI. Users
may taint or otherwise recreate the resource in order to produce a fresh
snapshot.
-}
data AmiFromInstanceResource = AmiFromInstanceResource {
      _name :: !(TF.Argument "name" Text)
    {- ^ (Required) A region-unique name for the AMI. -}
    , _snapshot_without_reboot :: !(TF.Argument "snapshot_without_reboot" Text)
    {- ^ (Optional) Boolean that overrides the behavior of stopping the instance before snapshotting. This is risky since it may cause a snapshot of an inconsistent filesystem state, but can be used to avoid downtime if the user otherwise guarantees that no filesystem writes will be underway at the time of snapshot. -}
    , _source_instance_id :: !(TF.Argument "source_instance_id" Text)
    {- ^ (Required) The id of the instance to use as the basis of the AMI. -}
    } deriving (Show, Eq)

instance TF.ToHCL AmiFromInstanceResource where
    toHCL AmiFromInstanceResource{..} = TF.block $ catMaybes
        [ TF.argument _name
        , TF.argument _snapshot_without_reboot
        , TF.argument _source_instance_id
        ]

instance HasName AmiFromInstanceResource Text where
    name =
        lens (_name :: AmiFromInstanceResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: AmiFromInstanceResource)

instance HasSnapshotWithoutReboot AmiFromInstanceResource Text where
    snapshotWithoutReboot =
        lens (_snapshot_without_reboot :: AmiFromInstanceResource -> TF.Argument "snapshot_without_reboot" Text)
             (\s a -> s { _snapshot_without_reboot = a } :: AmiFromInstanceResource)

instance HasSourceInstanceId AmiFromInstanceResource Text where
    sourceInstanceId =
        lens (_source_instance_id :: AmiFromInstanceResource -> TF.Argument "source_instance_id" Text)
             (\s a -> s { _source_instance_id = a } :: AmiFromInstanceResource)

amiFromInstanceResource :: TF.Resource TF.AWS AmiFromInstanceResource
amiFromInstanceResource =
    TF.newResource "aws_ami_from_instance" $
        AmiFromInstanceResource {
            _name = TF.Nil
            , _snapshot_without_reboot = TF.Nil
            , _source_instance_id = TF.Nil
            }

{- | The @aws_ami_launch_permission@ AWS resource.

Adds launch permission to Amazon Machine Image (AMI) from another AWS
account.
-}
data AmiLaunchPermissionResource = AmiLaunchPermissionResource {
      _account_id :: !(TF.Argument "account_id" Text)
    {- ^ - (required) An AWS Account ID to add launch permissions. -}
    , _image_id :: !(TF.Argument "image_id" Text)
    {- ^ - (required) A region-unique name for the AMI. -}
    } deriving (Show, Eq)

instance TF.ToHCL AmiLaunchPermissionResource where
    toHCL AmiLaunchPermissionResource{..} = TF.block $ catMaybes
        [ TF.argument _account_id
        , TF.argument _image_id
        ]

instance HasAccountId AmiLaunchPermissionResource Text where
    accountId =
        lens (_account_id :: AmiLaunchPermissionResource -> TF.Argument "account_id" Text)
             (\s a -> s { _account_id = a } :: AmiLaunchPermissionResource)

instance HasImageId AmiLaunchPermissionResource Text where
    imageId =
        lens (_image_id :: AmiLaunchPermissionResource -> TF.Argument "image_id" Text)
             (\s a -> s { _image_id = a } :: AmiLaunchPermissionResource)

instance HasComputedId AmiLaunchPermissionResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

amiLaunchPermissionResource :: TF.Resource TF.AWS AmiLaunchPermissionResource
amiLaunchPermissionResource =
    TF.newResource "aws_ami_launch_permission" $
        AmiLaunchPermissionResource {
            _account_id = TF.Nil
            , _image_id = TF.Nil
            }

{- | The @aws_ami@ AWS resource.

The AMI resource allows the creation and management of a completely-custom
Amazon Machine Image (AMI). If you just want to duplicate an existing AMI,
possibly copying it to another region, it's better to use @aws_ami_copy@
instead. If you just want to share an existing AMI with another AWS account,
it's better to use @aws_ami_launch_permission@ instead.
-}
data AmiResource = AmiResource {
      _architecture :: !(TF.Argument "architecture" Text)
    {- ^ (Optional) Machine architecture for created instances. Defaults to "x86_64". -}
    , _description :: !(TF.Argument "description" Text)
    {- ^ (Optional) A longer, human-readable description for the AMI. -}
    , _ebs_block_device :: !(TF.Argument "ebs_block_device" Text)
    {- ^ (Optional) Nested block describing an EBS block device that should be attached to created instances. The structure of this block is described below. -}
    , _ephemeral_block_device :: !(TF.Argument "ephemeral_block_device" Text)
    {- ^ (Optional) Nested block describing an ephemeral block device that should be attached to created instances. The structure of this block is described below. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) A region-unique name for the AMI. -}
    , _root_device_name :: !(TF.Argument "root_device_name" Text)
    {- ^ (Optional) The name of the root device (for example, @/dev/sda1@ , or @/dev/xvda@ ). -}
    , _virtualization_type :: !(TF.Argument "virtualization_type" Text)
    {- ^ (Optional) Keyword to choose what virtualization mode created instances will use. Can be either "paravirtual" (the default) or "hvm". The choice of virtualization type changes the set of further arguments that are required, as described below. -}
    } deriving (Show, Eq)

instance TF.ToHCL AmiResource where
    toHCL AmiResource{..} = TF.block $ catMaybes
        [ TF.argument _architecture
        , TF.argument _description
        , TF.argument _ebs_block_device
        , TF.argument _ephemeral_block_device
        , TF.argument _name
        , TF.argument _root_device_name
        , TF.argument _virtualization_type
        ]

instance HasArchitecture AmiResource Text where
    architecture =
        lens (_architecture :: AmiResource -> TF.Argument "architecture" Text)
             (\s a -> s { _architecture = a } :: AmiResource)

instance HasDescription AmiResource Text where
    description =
        lens (_description :: AmiResource -> TF.Argument "description" Text)
             (\s a -> s { _description = a } :: AmiResource)

instance HasEbsBlockDevice AmiResource Text where
    ebsBlockDevice =
        lens (_ebs_block_device :: AmiResource -> TF.Argument "ebs_block_device" Text)
             (\s a -> s { _ebs_block_device = a } :: AmiResource)

instance HasEphemeralBlockDevice AmiResource Text where
    ephemeralBlockDevice =
        lens (_ephemeral_block_device :: AmiResource -> TF.Argument "ephemeral_block_device" Text)
             (\s a -> s { _ephemeral_block_device = a } :: AmiResource)

instance HasName AmiResource Text where
    name =
        lens (_name :: AmiResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: AmiResource)

instance HasRootDeviceName AmiResource Text where
    rootDeviceName =
        lens (_root_device_name :: AmiResource -> TF.Argument "root_device_name" Text)
             (\s a -> s { _root_device_name = a } :: AmiResource)

instance HasVirtualizationType AmiResource Text where
    virtualizationType =
        lens (_virtualization_type :: AmiResource -> TF.Argument "virtualization_type" Text)
             (\s a -> s { _virtualization_type = a } :: AmiResource)

amiResource :: TF.Resource TF.AWS AmiResource
amiResource =
    TF.newResource "aws_ami" $
        AmiResource {
            _architecture = TF.Nil
            , _description = TF.Nil
            , _ebs_block_device = TF.Nil
            , _ephemeral_block_device = TF.Nil
            , _name = TF.Nil
            , _root_device_name = TF.Nil
            , _virtualization_type = TF.Nil
            }

{- | The @aws_api_gateway_account@ AWS resource.

Provides a settings of an API Gateway Account. Settings is applied
region-wide per @provider@ block. -> Note: As there is no API method for
deleting account settings or resetting it to defaults, destroying this
resource will keep your account settings intact
-}
data ApiGatewayAccountResource = ApiGatewayAccountResource {
      _cloudwatch_role_arn :: !(TF.Argument "cloudwatch_role_arn" Text)
    {- ^ (Optional) The ARN of an IAM role for CloudWatch (to allow logging & monitoring). See more <https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-stage-settings.html#how-to-stage-settings-console> . Logging & monitoring can be enabled/disabled and otherwise tuned on the API Gateway Stage level. -}
    } deriving (Show, Eq)

instance TF.ToHCL ApiGatewayAccountResource where
    toHCL ApiGatewayAccountResource{..} = TF.block $ catMaybes
        [ TF.argument _cloudwatch_role_arn
        ]

instance HasCloudwatchRoleArn ApiGatewayAccountResource Text where
    cloudwatchRoleArn =
        lens (_cloudwatch_role_arn :: ApiGatewayAccountResource -> TF.Argument "cloudwatch_role_arn" Text)
             (\s a -> s { _cloudwatch_role_arn = a } :: ApiGatewayAccountResource)

instance HasComputedThrottleSettings ApiGatewayAccountResource Text where
    computedThrottleSettings =
        to (\_  -> TF.Compute "throttle_settings")

apiGatewayAccountResource :: TF.Resource TF.AWS ApiGatewayAccountResource
apiGatewayAccountResource =
    TF.newResource "aws_api_gateway_account" $
        ApiGatewayAccountResource {
            _cloudwatch_role_arn = TF.Nil
            }

{- | The @aws_api_gateway_api_key@ AWS resource.

Provides an API Gateway API Key. ~> Warning: Since the API Gateway usage
plans feature was launched on August 11, 2016, usage plans are now required
to associate an API key with an API stage.
-}
data ApiGatewayApiKeyResource = ApiGatewayApiKeyResource {
      _description :: !(TF.Argument "description" Text)
    {- ^ (Optional) The API key description. Defaults to "Managed by Terraform". -}
    , _enabled :: !(TF.Argument "enabled" TF.Bool)
    {- ^ (Optional) Specifies whether the API key can be used by callers. Defaults to @true@ . -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the API key -}
    , _stage_key :: !(TF.Argument "stage_key" Text)
    {- ^ (Optional) A list of stage keys associated with the API key - see below -}
    , _value :: !(TF.Argument "value" Text)
    {- ^ (Optional) The value of the API key. If not specified, it will be automatically generated by AWS on creation. -}
    } deriving (Show, Eq)

instance TF.ToHCL ApiGatewayApiKeyResource where
    toHCL ApiGatewayApiKeyResource{..} = TF.block $ catMaybes
        [ TF.argument _description
        , TF.argument _enabled
        , TF.argument _name
        , TF.argument _stage_key
        , TF.argument _value
        ]

instance HasDescription ApiGatewayApiKeyResource Text where
    description =
        lens (_description :: ApiGatewayApiKeyResource -> TF.Argument "description" Text)
             (\s a -> s { _description = a } :: ApiGatewayApiKeyResource)

instance HasEnabled ApiGatewayApiKeyResource TF.Bool where
    enabled =
        lens (_enabled :: ApiGatewayApiKeyResource -> TF.Argument "enabled" TF.Bool)
             (\s a -> s { _enabled = a } :: ApiGatewayApiKeyResource)

instance HasName ApiGatewayApiKeyResource Text where
    name =
        lens (_name :: ApiGatewayApiKeyResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: ApiGatewayApiKeyResource)

instance HasStageKey ApiGatewayApiKeyResource Text where
    stageKey =
        lens (_stage_key :: ApiGatewayApiKeyResource -> TF.Argument "stage_key" Text)
             (\s a -> s { _stage_key = a } :: ApiGatewayApiKeyResource)

instance HasValue ApiGatewayApiKeyResource Text where
    value =
        lens (_value :: ApiGatewayApiKeyResource -> TF.Argument "value" Text)
             (\s a -> s { _value = a } :: ApiGatewayApiKeyResource)

instance HasComputedCreatedDate ApiGatewayApiKeyResource Text where
    computedCreatedDate =
        to (\_  -> TF.Compute "created_date")

instance HasComputedId ApiGatewayApiKeyResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedLastUpdatedDate ApiGatewayApiKeyResource Text where
    computedLastUpdatedDate =
        to (\_  -> TF.Compute "last_updated_date")

instance HasComputedValue ApiGatewayApiKeyResource Text where
    computedValue =
        to (\_  -> TF.Compute "value")

apiGatewayApiKeyResource :: TF.Resource TF.AWS ApiGatewayApiKeyResource
apiGatewayApiKeyResource =
    TF.newResource "aws_api_gateway_api_key" $
        ApiGatewayApiKeyResource {
            _description = TF.Nil
            , _enabled = TF.Nil
            , _name = TF.Nil
            , _stage_key = TF.Nil
            , _value = TF.Nil
            }

{- | The @aws_api_gateway_authorizer@ AWS resource.

Provides an API Gateway Authorizer.
-}
data ApiGatewayAuthorizerResource = ApiGatewayAuthorizerResource {
      _authorizer_credentials :: !(TF.Argument "authorizer_credentials" Text)
    {- ^ (Optional) The credentials required for the authorizer. To specify an IAM Role for API Gateway to assume, use the IAM Role ARN. -}
    , _authorizer_result_ttl_in_seconds :: !(TF.Argument "authorizer_result_ttl_in_seconds" Text)
    {- ^ (Optional) The TTL of cached authorizer results in seconds. Defaults to @300@ . -}
    , _authorizer_uri :: !(TF.Argument "authorizer_uri" Text)
    {- ^ (Required) The authorizer's Uniform Resource Identifier (URI). For @TOKEN@ type, this must be a well-formed Lambda function URI in the form of @arn:aws:apigateway:{region}:lambda:path/{service_api}@ . e.g. @arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:012345678912:function:my-function/invocations@ -}
    , _identity_source :: !(TF.Argument "identity_source" Text)
    {- ^ (Optional) The source of the identity in an incoming request. Defaults to @method.request.header.Authorization@ . For @REQUEST@ type, this may be a comma-separated list of values, including headers, query string parameters and stage variables - e.g. @"method.request.header.SomeHeaderName,method.request.querystring.SomeQueryStringName,stageVariables.SomeStageVariableName"@ -}
    , _identity_validation_expression :: !(TF.Argument "identity_validation_expression" Text)
    {- ^ (Optional) A validation expression for the incoming identity. For @TOKEN@ type, this value should be a regular expression. The incoming token from the client is matched against this expression, and will proceed if the token matches. If the token doesn't match, the client receives a 401 Unauthorized response. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the authorizer -}
    , _rest_api_id :: !(TF.Argument "rest_api_id" Text)
    {- ^ (Required) The ID of the associated REST API -}
    , _type' :: !(TF.Argument "type" Text)
    {- ^ (Optional) The type of the authorizer. Possible values are @TOKEN@ and @REQUEST@ . Defaults to @TOKEN@ . -}
    } deriving (Show, Eq)

instance TF.ToHCL ApiGatewayAuthorizerResource where
    toHCL ApiGatewayAuthorizerResource{..} = TF.block $ catMaybes
        [ TF.argument _authorizer_credentials
        , TF.argument _authorizer_result_ttl_in_seconds
        , TF.argument _authorizer_uri
        , TF.argument _identity_source
        , TF.argument _identity_validation_expression
        , TF.argument _name
        , TF.argument _rest_api_id
        , TF.argument _type'
        ]

instance HasAuthorizerCredentials ApiGatewayAuthorizerResource Text where
    authorizerCredentials =
        lens (_authorizer_credentials :: ApiGatewayAuthorizerResource -> TF.Argument "authorizer_credentials" Text)
             (\s a -> s { _authorizer_credentials = a } :: ApiGatewayAuthorizerResource)

instance HasAuthorizerResultTtlInSeconds ApiGatewayAuthorizerResource Text where
    authorizerResultTtlInSeconds =
        lens (_authorizer_result_ttl_in_seconds :: ApiGatewayAuthorizerResource -> TF.Argument "authorizer_result_ttl_in_seconds" Text)
             (\s a -> s { _authorizer_result_ttl_in_seconds = a } :: ApiGatewayAuthorizerResource)

instance HasAuthorizerUri ApiGatewayAuthorizerResource Text where
    authorizerUri =
        lens (_authorizer_uri :: ApiGatewayAuthorizerResource -> TF.Argument "authorizer_uri" Text)
             (\s a -> s { _authorizer_uri = a } :: ApiGatewayAuthorizerResource)

instance HasIdentitySource ApiGatewayAuthorizerResource Text where
    identitySource =
        lens (_identity_source :: ApiGatewayAuthorizerResource -> TF.Argument "identity_source" Text)
             (\s a -> s { _identity_source = a } :: ApiGatewayAuthorizerResource)

instance HasIdentityValidationExpression ApiGatewayAuthorizerResource Text where
    identityValidationExpression =
        lens (_identity_validation_expression :: ApiGatewayAuthorizerResource -> TF.Argument "identity_validation_expression" Text)
             (\s a -> s { _identity_validation_expression = a } :: ApiGatewayAuthorizerResource)

instance HasName ApiGatewayAuthorizerResource Text where
    name =
        lens (_name :: ApiGatewayAuthorizerResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: ApiGatewayAuthorizerResource)

instance HasRestApiId ApiGatewayAuthorizerResource Text where
    restApiId =
        lens (_rest_api_id :: ApiGatewayAuthorizerResource -> TF.Argument "rest_api_id" Text)
             (\s a -> s { _rest_api_id = a } :: ApiGatewayAuthorizerResource)

instance HasType' ApiGatewayAuthorizerResource Text where
    type' =
        lens (_type' :: ApiGatewayAuthorizerResource -> TF.Argument "type" Text)
             (\s a -> s { _type' = a } :: ApiGatewayAuthorizerResource)

apiGatewayAuthorizerResource :: TF.Resource TF.AWS ApiGatewayAuthorizerResource
apiGatewayAuthorizerResource =
    TF.newResource "aws_api_gateway_authorizer" $
        ApiGatewayAuthorizerResource {
            _authorizer_credentials = TF.Nil
            , _authorizer_result_ttl_in_seconds = TF.Nil
            , _authorizer_uri = TF.Nil
            , _identity_source = TF.Nil
            , _identity_validation_expression = TF.Nil
            , _name = TF.Nil
            , _rest_api_id = TF.Nil
            , _type' = TF.Nil
            }

{- | The @aws_api_gateway_base_path_mapping@ AWS resource.

Connects a custom domain name registered via @aws_api_gateway_domain_name@
with a deployed API so that its methods can be called via the custom domain
name.
-}
data ApiGatewayBasePathMappingResource = ApiGatewayBasePathMappingResource {
      _api_id :: !(TF.Argument "api_id" Text)
    {- ^ (Required) The id of the API to connect. -}
    , _base_path :: !(TF.Argument "base_path" Text)
    {- ^ (Optional) Path segment that must be prepended to the path when accessing the API via this mapping. If omitted, the API is exposed at the root of the given domain. -}
    , _domain_name :: !(TF.Argument "domain_name" Text)
    {- ^ (Required) The already-registered domain name to connect the API to. -}
    , _stage_name :: !(TF.Argument "stage_name" Text)
    {- ^ (Optional) The name of a specific deployment stage to expose at the given path. If omitted, callers may select any stage by including its name as a path element after the base path. -}
    } deriving (Show, Eq)

instance TF.ToHCL ApiGatewayBasePathMappingResource where
    toHCL ApiGatewayBasePathMappingResource{..} = TF.block $ catMaybes
        [ TF.argument _api_id
        , TF.argument _base_path
        , TF.argument _domain_name
        , TF.argument _stage_name
        ]

instance HasApiId ApiGatewayBasePathMappingResource Text where
    apiId =
        lens (_api_id :: ApiGatewayBasePathMappingResource -> TF.Argument "api_id" Text)
             (\s a -> s { _api_id = a } :: ApiGatewayBasePathMappingResource)

instance HasBasePath ApiGatewayBasePathMappingResource Text where
    basePath =
        lens (_base_path :: ApiGatewayBasePathMappingResource -> TF.Argument "base_path" Text)
             (\s a -> s { _base_path = a } :: ApiGatewayBasePathMappingResource)

instance HasDomainName ApiGatewayBasePathMappingResource Text where
    domainName =
        lens (_domain_name :: ApiGatewayBasePathMappingResource -> TF.Argument "domain_name" Text)
             (\s a -> s { _domain_name = a } :: ApiGatewayBasePathMappingResource)

instance HasStageName ApiGatewayBasePathMappingResource Text where
    stageName =
        lens (_stage_name :: ApiGatewayBasePathMappingResource -> TF.Argument "stage_name" Text)
             (\s a -> s { _stage_name = a } :: ApiGatewayBasePathMappingResource)

apiGatewayBasePathMappingResource :: TF.Resource TF.AWS ApiGatewayBasePathMappingResource
apiGatewayBasePathMappingResource =
    TF.newResource "aws_api_gateway_base_path_mapping" $
        ApiGatewayBasePathMappingResource {
            _api_id = TF.Nil
            , _base_path = TF.Nil
            , _domain_name = TF.Nil
            , _stage_name = TF.Nil
            }

{- | The @aws_api_gateway_client_certificate@ AWS resource.

Provides an API Gateway Client Certificate.
-}
data ApiGatewayClientCertificateResource = ApiGatewayClientCertificateResource {
      _description :: !(TF.Argument "description" Text)
    {- ^ (Optional) The description of the client certificate. -}
    } deriving (Show, Eq)

instance TF.ToHCL ApiGatewayClientCertificateResource where
    toHCL ApiGatewayClientCertificateResource{..} = TF.block $ catMaybes
        [ TF.argument _description
        ]

instance HasDescription ApiGatewayClientCertificateResource Text where
    description =
        lens (_description :: ApiGatewayClientCertificateResource -> TF.Argument "description" Text)
             (\s a -> s { _description = a } :: ApiGatewayClientCertificateResource)

instance HasComputedCreatedDate ApiGatewayClientCertificateResource Text where
    computedCreatedDate =
        to (\_  -> TF.Compute "created_date")

instance HasComputedExpirationDate ApiGatewayClientCertificateResource Text where
    computedExpirationDate =
        to (\_  -> TF.Compute "expiration_date")

instance HasComputedId ApiGatewayClientCertificateResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedPemEncodedCertificate ApiGatewayClientCertificateResource Text where
    computedPemEncodedCertificate =
        to (\_  -> TF.Compute "pem_encoded_certificate")

apiGatewayClientCertificateResource :: TF.Resource TF.AWS ApiGatewayClientCertificateResource
apiGatewayClientCertificateResource =
    TF.newResource "aws_api_gateway_client_certificate" $
        ApiGatewayClientCertificateResource {
            _description = TF.Nil
            }

{- | The @aws_api_gateway_deployment@ AWS resource.

Provides an API Gateway Deployment. -> Note: Depends on having
@aws_api_gateway_integration@ inside your rest api (which in turn depends on
@aws_api_gateway_method@ ). To avoid race conditions you might need to add
an explicit @depends_on = ["aws_api_gateway_integration.name"]@ .
-}
data ApiGatewayDeploymentResource = ApiGatewayDeploymentResource {
      _description :: !(TF.Argument "description" Text)
    {- ^ (Optional) The description of the deployment -}
    , _rest_api_id :: !(TF.Argument "rest_api_id" Text)
    {- ^ (Required) The ID of the associated REST API -}
    , _stage_description :: !(TF.Argument "stage_description" Text)
    {- ^ (Optional) The description of the stage -}
    , _stage_name :: !(TF.Argument "stage_name" Text)
    {- ^ (Required) The name of the stage -}
    , _variables :: !(TF.Argument "variables" Text)
    {- ^ (Optional) A map that defines variables for the stage -}
    } deriving (Show, Eq)

instance TF.ToHCL ApiGatewayDeploymentResource where
    toHCL ApiGatewayDeploymentResource{..} = TF.block $ catMaybes
        [ TF.argument _description
        , TF.argument _rest_api_id
        , TF.argument _stage_description
        , TF.argument _stage_name
        , TF.argument _variables
        ]

instance HasDescription ApiGatewayDeploymentResource Text where
    description =
        lens (_description :: ApiGatewayDeploymentResource -> TF.Argument "description" Text)
             (\s a -> s { _description = a } :: ApiGatewayDeploymentResource)

instance HasRestApiId ApiGatewayDeploymentResource Text where
    restApiId =
        lens (_rest_api_id :: ApiGatewayDeploymentResource -> TF.Argument "rest_api_id" Text)
             (\s a -> s { _rest_api_id = a } :: ApiGatewayDeploymentResource)

instance HasStageDescription ApiGatewayDeploymentResource Text where
    stageDescription =
        lens (_stage_description :: ApiGatewayDeploymentResource -> TF.Argument "stage_description" Text)
             (\s a -> s { _stage_description = a } :: ApiGatewayDeploymentResource)

instance HasStageName ApiGatewayDeploymentResource Text where
    stageName =
        lens (_stage_name :: ApiGatewayDeploymentResource -> TF.Argument "stage_name" Text)
             (\s a -> s { _stage_name = a } :: ApiGatewayDeploymentResource)

instance HasVariables ApiGatewayDeploymentResource Text where
    variables =
        lens (_variables :: ApiGatewayDeploymentResource -> TF.Argument "variables" Text)
             (\s a -> s { _variables = a } :: ApiGatewayDeploymentResource)

instance HasComputedCreatedDate ApiGatewayDeploymentResource Text where
    computedCreatedDate =
        to (\_  -> TF.Compute "created_date")

instance HasComputedExecutionArn ApiGatewayDeploymentResource Text where
    computedExecutionArn =
        to (\_  -> TF.Compute "execution_arn")

instance HasComputedId ApiGatewayDeploymentResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedInvokeUrl ApiGatewayDeploymentResource Text where
    computedInvokeUrl =
        to (\_  -> TF.Compute "invoke_url")

apiGatewayDeploymentResource :: TF.Resource TF.AWS ApiGatewayDeploymentResource
apiGatewayDeploymentResource =
    TF.newResource "aws_api_gateway_deployment" $
        ApiGatewayDeploymentResource {
            _description = TF.Nil
            , _rest_api_id = TF.Nil
            , _stage_description = TF.Nil
            , _stage_name = TF.Nil
            , _variables = TF.Nil
            }

{- | The @aws_api_gateway_documentation_part@ AWS resource.

Provides a settings of an API Gateway Documentation Part.
-}
data ApiGatewayDocumentationPartResource = ApiGatewayDocumentationPartResource {
      _location :: !(TF.Argument "location" Text)
    {- ^ (Required) The location of the targeted API entity of the to-be-created documentation part. See below. -}
    , _properties :: !(TF.Argument "properties" Text)
    {- ^ (Required) A content map of API-specific key-value pairs describing the targeted API entity. The map must be encoded as a JSON string, e.g., "{ "description": "The API does ..." }". Only Swagger-compliant key-value pairs can be exported and, hence, published. -}
    , _rest_api_id :: !(TF.Argument "rest_api_id" Text)
    {- ^ (Required) The ID of the associated Rest API -}
    } deriving (Show, Eq)

instance TF.ToHCL ApiGatewayDocumentationPartResource where
    toHCL ApiGatewayDocumentationPartResource{..} = TF.block $ catMaybes
        [ TF.argument _location
        , TF.argument _properties
        , TF.argument _rest_api_id
        ]

instance HasLocation ApiGatewayDocumentationPartResource Text where
    location =
        lens (_location :: ApiGatewayDocumentationPartResource -> TF.Argument "location" Text)
             (\s a -> s { _location = a } :: ApiGatewayDocumentationPartResource)

instance HasProperties ApiGatewayDocumentationPartResource Text where
    properties =
        lens (_properties :: ApiGatewayDocumentationPartResource -> TF.Argument "properties" Text)
             (\s a -> s { _properties = a } :: ApiGatewayDocumentationPartResource)

instance HasRestApiId ApiGatewayDocumentationPartResource Text where
    restApiId =
        lens (_rest_api_id :: ApiGatewayDocumentationPartResource -> TF.Argument "rest_api_id" Text)
             (\s a -> s { _rest_api_id = a } :: ApiGatewayDocumentationPartResource)

apiGatewayDocumentationPartResource :: TF.Resource TF.AWS ApiGatewayDocumentationPartResource
apiGatewayDocumentationPartResource =
    TF.newResource "aws_api_gateway_documentation_part" $
        ApiGatewayDocumentationPartResource {
            _location = TF.Nil
            , _properties = TF.Nil
            , _rest_api_id = TF.Nil
            }

{- | The @aws_api_gateway_domain_name@ AWS resource.

Registers a custom domain name for use with AWS API Gateway. This resource
just establishes ownership of and the TLS settings for a particular domain
name. An API can be attached to a particular path under the registered
domain name using <api_gateway_base_path_mapping.html> . Internally API
Gateway creates a CloudFront distribution to route requests on the given
hostname. In addition to this resource it's necessary to create a DNS record
corresponding to the given domain name which is an alias (either Route53
alias or traditional CNAME) to the Cloudfront domain name exported in the
@cloudfront_domain_name@ attribute. ~> Note: All arguments including the
private key will be stored in the raw state as plain-text.
</docs/state/sensitive-data.html> .
-}
data ApiGatewayDomainNameResource = ApiGatewayDomainNameResource {
      _certificate_arn :: !(TF.Argument "certificate_arn" Text)
    {- ^ (Optional) The ARN for an AWS-managed certificate. Conflicts with @certificate_name@ , @certificate_body@ , @certificate_chain@ and @certificate_private_key@ . -}
    , _certificate_body :: !(TF.Argument "certificate_body" Text)
    {- ^ (Optional) The certificate issued for the domain name being registered, in PEM format. Conflicts with @certificate_arn@ . -}
    , _certificate_chain :: !(TF.Argument "certificate_chain" Text)
    {- ^ (Optional) The certificate for the CA that issued the certificate, along with any intermediate CA certificates required to create an unbroken chain to a certificate trusted by the intended API clients. Conflicts with @certificate_arn@ . -}
    , _certificate_name :: !(TF.Argument "certificate_name" Text)
    {- ^ (Optional) The unique name to use when registering this cert as an IAM server certificate. Conflicts with @certificate_arn@ . Required if @certificate_arn@ is not set. -}
    , _certificate_private_key :: !(TF.Argument "certificate_private_key" Text)
    {- ^ (Optional) The private key associated with the domain certificate given in @certificate_body@ . Conflicts with @certificate_arn@ . -}
    , _domain_name :: !(TF.Argument "domain_name" Text)
    {- ^ (Required) The fully-qualified domain name to register -}
    } deriving (Show, Eq)

instance TF.ToHCL ApiGatewayDomainNameResource where
    toHCL ApiGatewayDomainNameResource{..} = TF.block $ catMaybes
        [ TF.argument _certificate_arn
        , TF.argument _certificate_body
        , TF.argument _certificate_chain
        , TF.argument _certificate_name
        , TF.argument _certificate_private_key
        , TF.argument _domain_name
        ]

instance HasCertificateArn ApiGatewayDomainNameResource Text where
    certificateArn =
        lens (_certificate_arn :: ApiGatewayDomainNameResource -> TF.Argument "certificate_arn" Text)
             (\s a -> s { _certificate_arn = a } :: ApiGatewayDomainNameResource)

instance HasCertificateBody ApiGatewayDomainNameResource Text where
    certificateBody =
        lens (_certificate_body :: ApiGatewayDomainNameResource -> TF.Argument "certificate_body" Text)
             (\s a -> s { _certificate_body = a } :: ApiGatewayDomainNameResource)

instance HasCertificateChain ApiGatewayDomainNameResource Text where
    certificateChain =
        lens (_certificate_chain :: ApiGatewayDomainNameResource -> TF.Argument "certificate_chain" Text)
             (\s a -> s { _certificate_chain = a } :: ApiGatewayDomainNameResource)

instance HasCertificateName ApiGatewayDomainNameResource Text where
    certificateName =
        lens (_certificate_name :: ApiGatewayDomainNameResource -> TF.Argument "certificate_name" Text)
             (\s a -> s { _certificate_name = a } :: ApiGatewayDomainNameResource)

instance HasCertificatePrivateKey ApiGatewayDomainNameResource Text where
    certificatePrivateKey =
        lens (_certificate_private_key :: ApiGatewayDomainNameResource -> TF.Argument "certificate_private_key" Text)
             (\s a -> s { _certificate_private_key = a } :: ApiGatewayDomainNameResource)

instance HasDomainName ApiGatewayDomainNameResource Text where
    domainName =
        lens (_domain_name :: ApiGatewayDomainNameResource -> TF.Argument "domain_name" Text)
             (\s a -> s { _domain_name = a } :: ApiGatewayDomainNameResource)

instance HasComputedCertificateUploadDate ApiGatewayDomainNameResource Text where
    computedCertificateUploadDate =
        to (\_  -> TF.Compute "certificate_upload_date")

instance HasComputedCloudfrontDomainName ApiGatewayDomainNameResource Text where
    computedCloudfrontDomainName =
        to (\_  -> TF.Compute "cloudfront_domain_name")

instance HasComputedCloudfrontZoneId ApiGatewayDomainNameResource Text where
    computedCloudfrontZoneId =
        to (\_  -> TF.Compute "cloudfront_zone_id")

instance HasComputedId ApiGatewayDomainNameResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

apiGatewayDomainNameResource :: TF.Resource TF.AWS ApiGatewayDomainNameResource
apiGatewayDomainNameResource =
    TF.newResource "aws_api_gateway_domain_name" $
        ApiGatewayDomainNameResource {
            _certificate_arn = TF.Nil
            , _certificate_body = TF.Nil
            , _certificate_chain = TF.Nil
            , _certificate_name = TF.Nil
            , _certificate_private_key = TF.Nil
            , _domain_name = TF.Nil
            }

{- | The @aws_api_gateway_gateway_response@ AWS resource.

Provides an API Gateway Gateway Response for a REST API Gateway.
-}
data ApiGatewayGatewayResponseResource = ApiGatewayGatewayResponseResource {
      _response_parameters :: !(TF.Argument "response_parameters" Text)
    {- ^ (Optional) A map specifying the templates used to transform the response body. -}
    , _response_templates :: !(TF.Argument "response_templates" Text)
    {- ^ (Optional) A map specifying the parameters (paths, query strings and headers) of the Gateway Response. -}
    , _response_type :: !(TF.Argument "response_type" Text)
    {- ^ (Required) The response type of the associated GatewayResponse. -}
    , _rest_api_id :: !(TF.Argument "rest_api_id" Text)
    {- ^ (Required) The string identifier of the associated REST API. -}
    , _status_code :: !(TF.Argument "status_code" Text)
    {- ^ (Optional) The HTTP status code of the Gateway Response. -}
    } deriving (Show, Eq)

instance TF.ToHCL ApiGatewayGatewayResponseResource where
    toHCL ApiGatewayGatewayResponseResource{..} = TF.block $ catMaybes
        [ TF.argument _response_parameters
        , TF.argument _response_templates
        , TF.argument _response_type
        , TF.argument _rest_api_id
        , TF.argument _status_code
        ]

instance HasResponseParameters ApiGatewayGatewayResponseResource Text where
    responseParameters =
        lens (_response_parameters :: ApiGatewayGatewayResponseResource -> TF.Argument "response_parameters" Text)
             (\s a -> s { _response_parameters = a } :: ApiGatewayGatewayResponseResource)

instance HasResponseTemplates ApiGatewayGatewayResponseResource Text where
    responseTemplates =
        lens (_response_templates :: ApiGatewayGatewayResponseResource -> TF.Argument "response_templates" Text)
             (\s a -> s { _response_templates = a } :: ApiGatewayGatewayResponseResource)

instance HasResponseType ApiGatewayGatewayResponseResource Text where
    responseType =
        lens (_response_type :: ApiGatewayGatewayResponseResource -> TF.Argument "response_type" Text)
             (\s a -> s { _response_type = a } :: ApiGatewayGatewayResponseResource)

instance HasRestApiId ApiGatewayGatewayResponseResource Text where
    restApiId =
        lens (_rest_api_id :: ApiGatewayGatewayResponseResource -> TF.Argument "rest_api_id" Text)
             (\s a -> s { _rest_api_id = a } :: ApiGatewayGatewayResponseResource)

instance HasStatusCode ApiGatewayGatewayResponseResource Text where
    statusCode =
        lens (_status_code :: ApiGatewayGatewayResponseResource -> TF.Argument "status_code" Text)
             (\s a -> s { _status_code = a } :: ApiGatewayGatewayResponseResource)

apiGatewayGatewayResponseResource :: TF.Resource TF.AWS ApiGatewayGatewayResponseResource
apiGatewayGatewayResponseResource =
    TF.newResource "aws_api_gateway_gateway_response" $
        ApiGatewayGatewayResponseResource {
            _response_parameters = TF.Nil
            , _response_templates = TF.Nil
            , _response_type = TF.Nil
            , _rest_api_id = TF.Nil
            , _status_code = TF.Nil
            }

{- | The @aws_api_gateway_integration@ AWS resource.

Provides an HTTP Method Integration for an API Gateway Integration.
-}
data ApiGatewayIntegrationResource = ApiGatewayIntegrationResource {
      _cache_key_namespace :: !(TF.Argument "cache_key_namespace" Text)
    {- ^ (Optional) The integration's cache namespace. -}
    , _cache_key_parameters :: !(TF.Argument "cache_key_parameters" Text)
    {- ^ (Optional) A list of cache key parameters for the integration. -}
    , _content_handling :: !(TF.Argument "content_handling" Text)
    {- ^ (Optional) Specifies how to handle request payload content type conversions. Supported values are @CONVERT_TO_BINARY@ and @CONVERT_TO_TEXT@ . If this property is not defined, the request payload will be passed through from the method request to integration request without modification, provided that the passthroughBehaviors is configured to support payload pass-through. -}
    , _credentials :: !(TF.Argument "credentials" Text)
    {- ^ (Optional) The credentials required for the integration. For @AWS@ integrations, 2 options are available. To specify an IAM Role for Amazon API Gateway to assume, use the role's ARN. To require that the caller's identity be passed through from the request, specify the string @arn:aws:iam::\*:user/\*@ . -}
    , _http_method :: !(TF.Argument "http_method" Text)
    {- ^ (Required) The HTTP method ( @GET@ , @POST@ , @PUT@ , @DELETE@ , @HEAD@ , @OPTION@ , @ANY@ ) when calling the associated resource. -}
    , _integration_http_method :: !(TF.Argument "integration_http_method" Text)
    {- ^ (Optional) The integration HTTP method ( @GET@ , @POST@ , @PUT@ , @DELETE@ , @HEAD@ , @OPTION@ ) specifying how API Gateway will interact with the back end. Required if @type@ is @AWS@ , @AWS_PROXY@ , @HTTP@ or @HTTP_PROXY@ . Not all methods are compatible with all @AWS@ integrations. e.g. Lambda function <https://github.com/awslabs/aws-apigateway-importer/issues/9#issuecomment-129651005> via @POST@ . -}
    , _passthrough_behavior :: !(TF.Argument "passthrough_behavior" Text)
    {- ^ (Optional) The integration passthrough behavior ( @WHEN_NO_MATCH@ , @WHEN_NO_TEMPLATES@ , @NEVER@ ). Required if @request_templates@ is used. -}
    , _request_parameters :: !(TF.Argument "request_parameters" Text)
    {- ^ (Optional) A map of request query string parameters and headers that should be passed to the backend responder. For example: @request_parameters = { "integration.request.header.X-Some-Other-Header" = "method.request.header.X-Some-Header" }@ -}
    , _request_parameters_in_json :: !(TF.Argument "request_parameters_in_json" Text)
    {- ^ - Deprecated , use @request_parameters@ instead. -}
    , _request_templates :: !(TF.Argument "request_templates" Text)
    {- ^ (Optional) A map of the integration's request templates. -}
    , _resource_id :: !(TF.Argument "resource_id" Text)
    {- ^ (Required) The API resource ID. -}
    , _rest_api_id :: !(TF.Argument "rest_api_id" Text)
    {- ^ (Required) The ID of the associated REST API. -}
    , _type' :: !(TF.Argument "type" Text)
    {- ^ (Required) The integration input's <https://docs.aws.amazon.com/apigateway/api-reference/resource/integration/> . Valid values are @HTTP@ (for HTTP backends), @MOCK@ (not calling any real backend), @AWS@ (for AWS services), @AWS_PROXY@ (for Lambda proxy integration) and @HTTP_PROXY@ (for HTTP proxy integration). -}
    , _uri :: !(TF.Argument "uri" Text)
    {- ^ (Optional) The input's URI (HTTP, AWS). Required if @type@ is @HTTP@ or @AWS@ . For HTTP integrations, the URI must be a fully formed, encoded HTTP(S) URL according to the RFC-3986 specification . For AWS integrations, the URI should be of the form @arn:aws:apigateway:{region}:{subdomain.service|service}:{path|action}/{service_api}@ . @region@ , @subdomain@ and @service@ are used to determine the right endpoint. e.g. @arn:aws:apigateway:eu-west-1:lambda:path/2015-03-31/functions/arn:aws:lambda:eu-west-1:012345678901:function:my-func/invocations@ -}
    } deriving (Show, Eq)

instance TF.ToHCL ApiGatewayIntegrationResource where
    toHCL ApiGatewayIntegrationResource{..} = TF.block $ catMaybes
        [ TF.argument _cache_key_namespace
        , TF.argument _cache_key_parameters
        , TF.argument _content_handling
        , TF.argument _credentials
        , TF.argument _http_method
        , TF.argument _integration_http_method
        , TF.argument _passthrough_behavior
        , TF.argument _request_parameters
        , TF.argument _request_parameters_in_json
        , TF.argument _request_templates
        , TF.argument _resource_id
        , TF.argument _rest_api_id
        , TF.argument _type'
        , TF.argument _uri
        ]

instance HasCacheKeyNamespace ApiGatewayIntegrationResource Text where
    cacheKeyNamespace =
        lens (_cache_key_namespace :: ApiGatewayIntegrationResource -> TF.Argument "cache_key_namespace" Text)
             (\s a -> s { _cache_key_namespace = a } :: ApiGatewayIntegrationResource)

instance HasCacheKeyParameters ApiGatewayIntegrationResource Text where
    cacheKeyParameters =
        lens (_cache_key_parameters :: ApiGatewayIntegrationResource -> TF.Argument "cache_key_parameters" Text)
             (\s a -> s { _cache_key_parameters = a } :: ApiGatewayIntegrationResource)

instance HasContentHandling ApiGatewayIntegrationResource Text where
    contentHandling =
        lens (_content_handling :: ApiGatewayIntegrationResource -> TF.Argument "content_handling" Text)
             (\s a -> s { _content_handling = a } :: ApiGatewayIntegrationResource)

instance HasCredentials ApiGatewayIntegrationResource Text where
    credentials =
        lens (_credentials :: ApiGatewayIntegrationResource -> TF.Argument "credentials" Text)
             (\s a -> s { _credentials = a } :: ApiGatewayIntegrationResource)

instance HasHttpMethod ApiGatewayIntegrationResource Text where
    httpMethod =
        lens (_http_method :: ApiGatewayIntegrationResource -> TF.Argument "http_method" Text)
             (\s a -> s { _http_method = a } :: ApiGatewayIntegrationResource)

instance HasIntegrationHttpMethod ApiGatewayIntegrationResource Text where
    integrationHttpMethod =
        lens (_integration_http_method :: ApiGatewayIntegrationResource -> TF.Argument "integration_http_method" Text)
             (\s a -> s { _integration_http_method = a } :: ApiGatewayIntegrationResource)

instance HasPassthroughBehavior ApiGatewayIntegrationResource Text where
    passthroughBehavior =
        lens (_passthrough_behavior :: ApiGatewayIntegrationResource -> TF.Argument "passthrough_behavior" Text)
             (\s a -> s { _passthrough_behavior = a } :: ApiGatewayIntegrationResource)

instance HasRequestParameters ApiGatewayIntegrationResource Text where
    requestParameters =
        lens (_request_parameters :: ApiGatewayIntegrationResource -> TF.Argument "request_parameters" Text)
             (\s a -> s { _request_parameters = a } :: ApiGatewayIntegrationResource)

instance HasRequestParametersInJson ApiGatewayIntegrationResource Text where
    requestParametersInJson =
        lens (_request_parameters_in_json :: ApiGatewayIntegrationResource -> TF.Argument "request_parameters_in_json" Text)
             (\s a -> s { _request_parameters_in_json = a } :: ApiGatewayIntegrationResource)

instance HasRequestTemplates ApiGatewayIntegrationResource Text where
    requestTemplates =
        lens (_request_templates :: ApiGatewayIntegrationResource -> TF.Argument "request_templates" Text)
             (\s a -> s { _request_templates = a } :: ApiGatewayIntegrationResource)

instance HasResourceId ApiGatewayIntegrationResource Text where
    resourceId =
        lens (_resource_id :: ApiGatewayIntegrationResource -> TF.Argument "resource_id" Text)
             (\s a -> s { _resource_id = a } :: ApiGatewayIntegrationResource)

instance HasRestApiId ApiGatewayIntegrationResource Text where
    restApiId =
        lens (_rest_api_id :: ApiGatewayIntegrationResource -> TF.Argument "rest_api_id" Text)
             (\s a -> s { _rest_api_id = a } :: ApiGatewayIntegrationResource)

instance HasType' ApiGatewayIntegrationResource Text where
    type' =
        lens (_type' :: ApiGatewayIntegrationResource -> TF.Argument "type" Text)
             (\s a -> s { _type' = a } :: ApiGatewayIntegrationResource)

instance HasUri ApiGatewayIntegrationResource Text where
    uri =
        lens (_uri :: ApiGatewayIntegrationResource -> TF.Argument "uri" Text)
             (\s a -> s { _uri = a } :: ApiGatewayIntegrationResource)

apiGatewayIntegrationResource :: TF.Resource TF.AWS ApiGatewayIntegrationResource
apiGatewayIntegrationResource =
    TF.newResource "aws_api_gateway_integration" $
        ApiGatewayIntegrationResource {
            _cache_key_namespace = TF.Nil
            , _cache_key_parameters = TF.Nil
            , _content_handling = TF.Nil
            , _credentials = TF.Nil
            , _http_method = TF.Nil
            , _integration_http_method = TF.Nil
            , _passthrough_behavior = TF.Nil
            , _request_parameters = TF.Nil
            , _request_parameters_in_json = TF.Nil
            , _request_templates = TF.Nil
            , _resource_id = TF.Nil
            , _rest_api_id = TF.Nil
            , _type' = TF.Nil
            , _uri = TF.Nil
            }

{- | The @aws_api_gateway_integration_response@ AWS resource.

Provides an HTTP Method Integration Response for an API Gateway Resource. ->
Note: Depends on having @aws_api_gateway_integration@ inside your rest api.
To ensure this you might need to add an explicit @depends_on@ for clean
runs.
-}
data ApiGatewayIntegrationResponseResource = ApiGatewayIntegrationResponseResource {
      _content_handling :: !(TF.Argument "content_handling" Text)
    {- ^ (Optional) Specifies how to handle request payload content type conversions. Supported values are @CONVERT_TO_BINARY@ and @CONVERT_TO_TEXT@ . If this property is not defined, the response payload will be passed through from the integration response to the method response without modification. -}
    , _http_method :: !(TF.Argument "http_method" Text)
    {- ^ (Required) The HTTP method ( @GET@ , @POST@ , @PUT@ , @DELETE@ , @HEAD@ , @OPTIONS@ , @ANY@ ) -}
    , _resource_id :: !(TF.Argument "resource_id" Text)
    {- ^ (Required) The API resource ID -}
    , _response_parameters :: !(TF.Argument "response_parameters" Text)
    {- ^ (Optional) A map of response parameters that can be read from the backend response. For example: @response_parameters = { "method.response.header.X-Some-Header" = "integration.response.header.X-Some-Other-Header" }@ , -}
    , _response_parameters_in_json :: !(TF.Argument "response_parameters_in_json" Text)
    {- ^ - Deprecated , use @response_parameters@ instead. -}
    , _response_templates :: !(TF.Argument "response_templates" Text)
    {- ^ (Optional) A map specifying the templates used to transform the integration response body -}
    , _rest_api_id :: !(TF.Argument "rest_api_id" Text)
    {- ^ (Required) The ID of the associated REST API -}
    , _selection_pattern :: !(TF.Argument "selection_pattern" Text)
    {- ^ (Optional) Specifies the regular expression pattern used to choose an integration response based on the response from the backend. Setting this to @-@ makes the integration the default one. If the backend is an @AWS@ Lambda function, the AWS Lambda function error header is matched. For all other @HTTP@ and @AWS@ backends, the HTTP status code is matched. -}
    , _status_code :: !(TF.Argument "status_code" Text)
    {- ^ (Required) The HTTP status code -}
    } deriving (Show, Eq)

instance TF.ToHCL ApiGatewayIntegrationResponseResource where
    toHCL ApiGatewayIntegrationResponseResource{..} = TF.block $ catMaybes
        [ TF.argument _content_handling
        , TF.argument _http_method
        , TF.argument _resource_id
        , TF.argument _response_parameters
        , TF.argument _response_parameters_in_json
        , TF.argument _response_templates
        , TF.argument _rest_api_id
        , TF.argument _selection_pattern
        , TF.argument _status_code
        ]

instance HasContentHandling ApiGatewayIntegrationResponseResource Text where
    contentHandling =
        lens (_content_handling :: ApiGatewayIntegrationResponseResource -> TF.Argument "content_handling" Text)
             (\s a -> s { _content_handling = a } :: ApiGatewayIntegrationResponseResource)

instance HasHttpMethod ApiGatewayIntegrationResponseResource Text where
    httpMethod =
        lens (_http_method :: ApiGatewayIntegrationResponseResource -> TF.Argument "http_method" Text)
             (\s a -> s { _http_method = a } :: ApiGatewayIntegrationResponseResource)

instance HasResourceId ApiGatewayIntegrationResponseResource Text where
    resourceId =
        lens (_resource_id :: ApiGatewayIntegrationResponseResource -> TF.Argument "resource_id" Text)
             (\s a -> s { _resource_id = a } :: ApiGatewayIntegrationResponseResource)

instance HasResponseParameters ApiGatewayIntegrationResponseResource Text where
    responseParameters =
        lens (_response_parameters :: ApiGatewayIntegrationResponseResource -> TF.Argument "response_parameters" Text)
             (\s a -> s { _response_parameters = a } :: ApiGatewayIntegrationResponseResource)

instance HasResponseParametersInJson ApiGatewayIntegrationResponseResource Text where
    responseParametersInJson =
        lens (_response_parameters_in_json :: ApiGatewayIntegrationResponseResource -> TF.Argument "response_parameters_in_json" Text)
             (\s a -> s { _response_parameters_in_json = a } :: ApiGatewayIntegrationResponseResource)

instance HasResponseTemplates ApiGatewayIntegrationResponseResource Text where
    responseTemplates =
        lens (_response_templates :: ApiGatewayIntegrationResponseResource -> TF.Argument "response_templates" Text)
             (\s a -> s { _response_templates = a } :: ApiGatewayIntegrationResponseResource)

instance HasRestApiId ApiGatewayIntegrationResponseResource Text where
    restApiId =
        lens (_rest_api_id :: ApiGatewayIntegrationResponseResource -> TF.Argument "rest_api_id" Text)
             (\s a -> s { _rest_api_id = a } :: ApiGatewayIntegrationResponseResource)

instance HasSelectionPattern ApiGatewayIntegrationResponseResource Text where
    selectionPattern =
        lens (_selection_pattern :: ApiGatewayIntegrationResponseResource -> TF.Argument "selection_pattern" Text)
             (\s a -> s { _selection_pattern = a } :: ApiGatewayIntegrationResponseResource)

instance HasStatusCode ApiGatewayIntegrationResponseResource Text where
    statusCode =
        lens (_status_code :: ApiGatewayIntegrationResponseResource -> TF.Argument "status_code" Text)
             (\s a -> s { _status_code = a } :: ApiGatewayIntegrationResponseResource)

apiGatewayIntegrationResponseResource :: TF.Resource TF.AWS ApiGatewayIntegrationResponseResource
apiGatewayIntegrationResponseResource =
    TF.newResource "aws_api_gateway_integration_response" $
        ApiGatewayIntegrationResponseResource {
            _content_handling = TF.Nil
            , _http_method = TF.Nil
            , _resource_id = TF.Nil
            , _response_parameters = TF.Nil
            , _response_parameters_in_json = TF.Nil
            , _response_templates = TF.Nil
            , _rest_api_id = TF.Nil
            , _selection_pattern = TF.Nil
            , _status_code = TF.Nil
            }

{- | The @aws_api_gateway_method@ AWS resource.

Provides a HTTP Method for an API Gateway Resource.
-}
data ApiGatewayMethodResource = ApiGatewayMethodResource {
      _api_key_required :: !(TF.Argument "api_key_required" Text)
    {- ^ (Optional) Specify if the method requires an API key -}
    , _authorization :: !(TF.Argument "authorization" Text)
    {- ^ (Required) The type of authorization used for the method ( @NONE@ , @CUSTOM@ , @AWS_IAM@ ) -}
    , _authorizer_id :: !(TF.Argument "authorizer_id" Text)
    {- ^ (Optional) The authorizer id to be used when the authorization is @CUSTOM@ -}
    , _http_method :: !(TF.Argument "http_method" Text)
    {- ^ (Required) The HTTP Method ( @GET@ , @POST@ , @PUT@ , @DELETE@ , @HEAD@ , @OPTIONS@ , @ANY@ ) -}
    , _request_models :: !(TF.Argument "request_models" Text)
    {- ^ (Optional) A map of the API models used for the request's content type where key is the content type (e.g. @application/json@ ) and value is either @Error@ , @Empty@ (built-in models) or @aws_api_gateway_model@ 's @name@ . -}
    , _request_parameters :: !(TF.Argument "request_parameters" Text)
    {- ^ (Optional) A map of request query string parameters and headers that should be passed to the integration. For example: -}
    , _request_validator_id :: !(TF.Argument "request_validator_id" Text)
    {- ^ (Optional) The ID of a @aws_api_gateway_request_validator@ -}
    , _resource_id :: !(TF.Argument "resource_id" Text)
    {- ^ (Required) The API resource ID -}
    , _rest_api_id :: !(TF.Argument "rest_api_id" Text)
    {- ^ (Required) The ID of the associated REST API -}
    } deriving (Show, Eq)

instance TF.ToHCL ApiGatewayMethodResource where
    toHCL ApiGatewayMethodResource{..} = TF.block $ catMaybes
        [ TF.argument _api_key_required
        , TF.argument _authorization
        , TF.argument _authorizer_id
        , TF.argument _http_method
        , TF.argument _request_models
        , TF.argument _request_parameters
        , TF.argument _request_validator_id
        , TF.argument _resource_id
        , TF.argument _rest_api_id
        ]

instance HasApiKeyRequired ApiGatewayMethodResource Text where
    apiKeyRequired =
        lens (_api_key_required :: ApiGatewayMethodResource -> TF.Argument "api_key_required" Text)
             (\s a -> s { _api_key_required = a } :: ApiGatewayMethodResource)

instance HasAuthorization ApiGatewayMethodResource Text where
    authorization =
        lens (_authorization :: ApiGatewayMethodResource -> TF.Argument "authorization" Text)
             (\s a -> s { _authorization = a } :: ApiGatewayMethodResource)

instance HasAuthorizerId ApiGatewayMethodResource Text where
    authorizerId =
        lens (_authorizer_id :: ApiGatewayMethodResource -> TF.Argument "authorizer_id" Text)
             (\s a -> s { _authorizer_id = a } :: ApiGatewayMethodResource)

instance HasHttpMethod ApiGatewayMethodResource Text where
    httpMethod =
        lens (_http_method :: ApiGatewayMethodResource -> TF.Argument "http_method" Text)
             (\s a -> s { _http_method = a } :: ApiGatewayMethodResource)

instance HasRequestModels ApiGatewayMethodResource Text where
    requestModels =
        lens (_request_models :: ApiGatewayMethodResource -> TF.Argument "request_models" Text)
             (\s a -> s { _request_models = a } :: ApiGatewayMethodResource)

instance HasRequestParameters ApiGatewayMethodResource Text where
    requestParameters =
        lens (_request_parameters :: ApiGatewayMethodResource -> TF.Argument "request_parameters" Text)
             (\s a -> s { _request_parameters = a } :: ApiGatewayMethodResource)

instance HasRequestValidatorId ApiGatewayMethodResource Text where
    requestValidatorId =
        lens (_request_validator_id :: ApiGatewayMethodResource -> TF.Argument "request_validator_id" Text)
             (\s a -> s { _request_validator_id = a } :: ApiGatewayMethodResource)

instance HasResourceId ApiGatewayMethodResource Text where
    resourceId =
        lens (_resource_id :: ApiGatewayMethodResource -> TF.Argument "resource_id" Text)
             (\s a -> s { _resource_id = a } :: ApiGatewayMethodResource)

instance HasRestApiId ApiGatewayMethodResource Text where
    restApiId =
        lens (_rest_api_id :: ApiGatewayMethodResource -> TF.Argument "rest_api_id" Text)
             (\s a -> s { _rest_api_id = a } :: ApiGatewayMethodResource)

apiGatewayMethodResource :: TF.Resource TF.AWS ApiGatewayMethodResource
apiGatewayMethodResource =
    TF.newResource "aws_api_gateway_method" $
        ApiGatewayMethodResource {
            _api_key_required = TF.Nil
            , _authorization = TF.Nil
            , _authorizer_id = TF.Nil
            , _http_method = TF.Nil
            , _request_models = TF.Nil
            , _request_parameters = TF.Nil
            , _request_validator_id = TF.Nil
            , _resource_id = TF.Nil
            , _rest_api_id = TF.Nil
            }

{- | The @aws_api_gateway_method_response@ AWS resource.

Provides an HTTP Method Response for an API Gateway Resource.
-}
data ApiGatewayMethodResponseResource = ApiGatewayMethodResponseResource {
      _http_method :: !(TF.Argument "http_method" Text)
    {- ^ (Required) The HTTP Method ( @GET@ , @POST@ , @PUT@ , @DELETE@ , @HEAD@ , @OPTIONS@ , @ANY@ ) -}
    , _resource_id :: !(TF.Argument "resource_id" Text)
    {- ^ (Required) The API resource ID -}
    , _response_models :: !(TF.Argument "response_models" Text)
    {- ^ (Optional) A map of the API models used for the response's content type -}
    , _response_parameters :: !(TF.Argument "response_parameters" Text)
    {- ^ (Optional) A map of response parameters that can be sent to the caller. For example: @response_parameters = { "method.response.header.X-Some-Header" = true }@ would define that the header @X-Some-Header@ can be provided on the response. -}
    , _response_parameters_in_json :: !(TF.Argument "response_parameters_in_json" Text)
    {- ^ - Deprecated , use @response_parameters@ instead. -}
    , _rest_api_id :: !(TF.Argument "rest_api_id" Text)
    {- ^ (Required) The ID of the associated REST API -}
    , _status_code :: !(TF.Argument "status_code" Text)
    {- ^ (Required) The HTTP status code -}
    } deriving (Show, Eq)

instance TF.ToHCL ApiGatewayMethodResponseResource where
    toHCL ApiGatewayMethodResponseResource{..} = TF.block $ catMaybes
        [ TF.argument _http_method
        , TF.argument _resource_id
        , TF.argument _response_models
        , TF.argument _response_parameters
        , TF.argument _response_parameters_in_json
        , TF.argument _rest_api_id
        , TF.argument _status_code
        ]

instance HasHttpMethod ApiGatewayMethodResponseResource Text where
    httpMethod =
        lens (_http_method :: ApiGatewayMethodResponseResource -> TF.Argument "http_method" Text)
             (\s a -> s { _http_method = a } :: ApiGatewayMethodResponseResource)

instance HasResourceId ApiGatewayMethodResponseResource Text where
    resourceId =
        lens (_resource_id :: ApiGatewayMethodResponseResource -> TF.Argument "resource_id" Text)
             (\s a -> s { _resource_id = a } :: ApiGatewayMethodResponseResource)

instance HasResponseModels ApiGatewayMethodResponseResource Text where
    responseModels =
        lens (_response_models :: ApiGatewayMethodResponseResource -> TF.Argument "response_models" Text)
             (\s a -> s { _response_models = a } :: ApiGatewayMethodResponseResource)

instance HasResponseParameters ApiGatewayMethodResponseResource Text where
    responseParameters =
        lens (_response_parameters :: ApiGatewayMethodResponseResource -> TF.Argument "response_parameters" Text)
             (\s a -> s { _response_parameters = a } :: ApiGatewayMethodResponseResource)

instance HasResponseParametersInJson ApiGatewayMethodResponseResource Text where
    responseParametersInJson =
        lens (_response_parameters_in_json :: ApiGatewayMethodResponseResource -> TF.Argument "response_parameters_in_json" Text)
             (\s a -> s { _response_parameters_in_json = a } :: ApiGatewayMethodResponseResource)

instance HasRestApiId ApiGatewayMethodResponseResource Text where
    restApiId =
        lens (_rest_api_id :: ApiGatewayMethodResponseResource -> TF.Argument "rest_api_id" Text)
             (\s a -> s { _rest_api_id = a } :: ApiGatewayMethodResponseResource)

instance HasStatusCode ApiGatewayMethodResponseResource Text where
    statusCode =
        lens (_status_code :: ApiGatewayMethodResponseResource -> TF.Argument "status_code" Text)
             (\s a -> s { _status_code = a } :: ApiGatewayMethodResponseResource)

apiGatewayMethodResponseResource :: TF.Resource TF.AWS ApiGatewayMethodResponseResource
apiGatewayMethodResponseResource =
    TF.newResource "aws_api_gateway_method_response" $
        ApiGatewayMethodResponseResource {
            _http_method = TF.Nil
            , _resource_id = TF.Nil
            , _response_models = TF.Nil
            , _response_parameters = TF.Nil
            , _response_parameters_in_json = TF.Nil
            , _rest_api_id = TF.Nil
            , _status_code = TF.Nil
            }

{- | The @aws_api_gateway_method_settings@ AWS resource.

Provides an API Gateway Method Settings, e.g. logging or monitoring.
-}
data ApiGatewayMethodSettingsResource = ApiGatewayMethodSettingsResource {
      _method_path :: !(TF.Argument "method_path" Text)
    {- ^ (Required) Method path defined as @{resource_path}/{http_method}@ for an individual method override, or @*/*@ for overriding all methods in the stage. -}
    , _rest_api_id :: !(TF.Argument "rest_api_id" Text)
    {- ^ (Required) The ID of the REST API -}
    , _settings :: !(TF.Argument "settings" Text)
    {- ^ (Required) The settings block, see below. -}
    , _stage_name :: !(TF.Argument "stage_name" Text)
    {- ^ (Required) The name of the stage -}
    } deriving (Show, Eq)

instance TF.ToHCL ApiGatewayMethodSettingsResource where
    toHCL ApiGatewayMethodSettingsResource{..} = TF.block $ catMaybes
        [ TF.argument _method_path
        , TF.argument _rest_api_id
        , TF.argument _settings
        , TF.argument _stage_name
        ]

instance HasMethodPath ApiGatewayMethodSettingsResource Text where
    methodPath =
        lens (_method_path :: ApiGatewayMethodSettingsResource -> TF.Argument "method_path" Text)
             (\s a -> s { _method_path = a } :: ApiGatewayMethodSettingsResource)

instance HasRestApiId ApiGatewayMethodSettingsResource Text where
    restApiId =
        lens (_rest_api_id :: ApiGatewayMethodSettingsResource -> TF.Argument "rest_api_id" Text)
             (\s a -> s { _rest_api_id = a } :: ApiGatewayMethodSettingsResource)

instance HasSettings ApiGatewayMethodSettingsResource Text where
    settings =
        lens (_settings :: ApiGatewayMethodSettingsResource -> TF.Argument "settings" Text)
             (\s a -> s { _settings = a } :: ApiGatewayMethodSettingsResource)

instance HasStageName ApiGatewayMethodSettingsResource Text where
    stageName =
        lens (_stage_name :: ApiGatewayMethodSettingsResource -> TF.Argument "stage_name" Text)
             (\s a -> s { _stage_name = a } :: ApiGatewayMethodSettingsResource)

apiGatewayMethodSettingsResource :: TF.Resource TF.AWS ApiGatewayMethodSettingsResource
apiGatewayMethodSettingsResource =
    TF.newResource "aws_api_gateway_method_settings" $
        ApiGatewayMethodSettingsResource {
            _method_path = TF.Nil
            , _rest_api_id = TF.Nil
            , _settings = TF.Nil
            , _stage_name = TF.Nil
            }

{- | The @aws_api_gateway_model@ AWS resource.

Provides a Model for a API Gateway.
-}
data ApiGatewayModelResource = ApiGatewayModelResource {
      _content_type :: !(TF.Argument "content_type" Text)
    {- ^ (Required) The content type of the model -}
    , _description :: !(TF.Argument "description" Text)
    {- ^ (Optional) The description of the model -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the model -}
    , _rest_api_id :: !(TF.Argument "rest_api_id" Text)
    {- ^ (Required) The ID of the associated REST API -}
    , _schema :: !(TF.Argument "schema" Text)
    {- ^ (Required) The schema of the model in a JSON form -}
    } deriving (Show, Eq)

instance TF.ToHCL ApiGatewayModelResource where
    toHCL ApiGatewayModelResource{..} = TF.block $ catMaybes
        [ TF.argument _content_type
        , TF.argument _description
        , TF.argument _name
        , TF.argument _rest_api_id
        , TF.argument _schema
        ]

instance HasContentType ApiGatewayModelResource Text where
    contentType =
        lens (_content_type :: ApiGatewayModelResource -> TF.Argument "content_type" Text)
             (\s a -> s { _content_type = a } :: ApiGatewayModelResource)

instance HasDescription ApiGatewayModelResource Text where
    description =
        lens (_description :: ApiGatewayModelResource -> TF.Argument "description" Text)
             (\s a -> s { _description = a } :: ApiGatewayModelResource)

instance HasName ApiGatewayModelResource Text where
    name =
        lens (_name :: ApiGatewayModelResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: ApiGatewayModelResource)

instance HasRestApiId ApiGatewayModelResource Text where
    restApiId =
        lens (_rest_api_id :: ApiGatewayModelResource -> TF.Argument "rest_api_id" Text)
             (\s a -> s { _rest_api_id = a } :: ApiGatewayModelResource)

instance HasSchema ApiGatewayModelResource Text where
    schema =
        lens (_schema :: ApiGatewayModelResource -> TF.Argument "schema" Text)
             (\s a -> s { _schema = a } :: ApiGatewayModelResource)

instance HasComputedId ApiGatewayModelResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

apiGatewayModelResource :: TF.Resource TF.AWS ApiGatewayModelResource
apiGatewayModelResource =
    TF.newResource "aws_api_gateway_model" $
        ApiGatewayModelResource {
            _content_type = TF.Nil
            , _description = TF.Nil
            , _name = TF.Nil
            , _rest_api_id = TF.Nil
            , _schema = TF.Nil
            }

{- | The @aws_api_gateway_resource@ AWS resource.

Provides an API Gateway Resource.
-}
data ApiGatewayResourceResource = ApiGatewayResourceResource {
      _parent_id :: !(TF.Argument "parent_id" Text)
    {- ^ (Required) The ID of the parent API resource -}
    , _path_part :: !(TF.Argument "path_part" Text)
    {- ^ (Required) The last path segment of this API resource. -}
    , _rest_api_id :: !(TF.Argument "rest_api_id" Text)
    {- ^ (Required) The ID of the associated REST API -}
    } deriving (Show, Eq)

instance TF.ToHCL ApiGatewayResourceResource where
    toHCL ApiGatewayResourceResource{..} = TF.block $ catMaybes
        [ TF.argument _parent_id
        , TF.argument _path_part
        , TF.argument _rest_api_id
        ]

instance HasParentId ApiGatewayResourceResource Text where
    parentId =
        lens (_parent_id :: ApiGatewayResourceResource -> TF.Argument "parent_id" Text)
             (\s a -> s { _parent_id = a } :: ApiGatewayResourceResource)

instance HasPathPart ApiGatewayResourceResource Text where
    pathPart =
        lens (_path_part :: ApiGatewayResourceResource -> TF.Argument "path_part" Text)
             (\s a -> s { _path_part = a } :: ApiGatewayResourceResource)

instance HasRestApiId ApiGatewayResourceResource Text where
    restApiId =
        lens (_rest_api_id :: ApiGatewayResourceResource -> TF.Argument "rest_api_id" Text)
             (\s a -> s { _rest_api_id = a } :: ApiGatewayResourceResource)

instance HasComputedId ApiGatewayResourceResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedPath ApiGatewayResourceResource Text where
    computedPath =
        to (\_  -> TF.Compute "path")

apiGatewayResourceResource :: TF.Resource TF.AWS ApiGatewayResourceResource
apiGatewayResourceResource =
    TF.newResource "aws_api_gateway_resource" $
        ApiGatewayResourceResource {
            _parent_id = TF.Nil
            , _path_part = TF.Nil
            , _rest_api_id = TF.Nil
            }

{- | The @aws_api_gateway_rest_api@ AWS resource.

Provides an API Gateway REST API.
-}
data ApiGatewayRestApiResource = ApiGatewayRestApiResource {
      _binary_media_types :: !(TF.Argument "binary_media_types" Text)
    {- ^ (Optional) The list of binary media types supported by the RestApi. By default, the RestApi supports only UTF-8-encoded text payloads. -}
    , _body :: !(TF.Argument "body" Text)
    {- ^ (Optional) An OpenAPI specification that defines the set of routes and integrations to create as part of the REST API. -}
    , _description :: !(TF.Argument "description" Text)
    {- ^ (Optional) The description of the REST API -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the REST API -}
    } deriving (Show, Eq)

instance TF.ToHCL ApiGatewayRestApiResource where
    toHCL ApiGatewayRestApiResource{..} = TF.block $ catMaybes
        [ TF.argument _binary_media_types
        , TF.argument _body
        , TF.argument _description
        , TF.argument _name
        ]

instance HasBinaryMediaTypes ApiGatewayRestApiResource Text where
    binaryMediaTypes =
        lens (_binary_media_types :: ApiGatewayRestApiResource -> TF.Argument "binary_media_types" Text)
             (\s a -> s { _binary_media_types = a } :: ApiGatewayRestApiResource)

instance HasBody ApiGatewayRestApiResource Text where
    body =
        lens (_body :: ApiGatewayRestApiResource -> TF.Argument "body" Text)
             (\s a -> s { _body = a } :: ApiGatewayRestApiResource)

instance HasDescription ApiGatewayRestApiResource Text where
    description =
        lens (_description :: ApiGatewayRestApiResource -> TF.Argument "description" Text)
             (\s a -> s { _description = a } :: ApiGatewayRestApiResource)

instance HasName ApiGatewayRestApiResource Text where
    name =
        lens (_name :: ApiGatewayRestApiResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: ApiGatewayRestApiResource)

instance HasComputedCreatedDate ApiGatewayRestApiResource Text where
    computedCreatedDate =
        to (\_  -> TF.Compute "created_date")

instance HasComputedId ApiGatewayRestApiResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedRootResourceId ApiGatewayRestApiResource Text where
    computedRootResourceId =
        to (\_  -> TF.Compute "root_resource_id")

apiGatewayRestApiResource :: TF.Resource TF.AWS ApiGatewayRestApiResource
apiGatewayRestApiResource =
    TF.newResource "aws_api_gateway_rest_api" $
        ApiGatewayRestApiResource {
            _binary_media_types = TF.Nil
            , _body = TF.Nil
            , _description = TF.Nil
            , _name = TF.Nil
            }

{- | The @aws_api_gateway_stage@ AWS resource.

Provides an API Gateway Stage.
-}
data ApiGatewayStageResource = ApiGatewayStageResource {
      _cache_cluster_enabled :: !(TF.Argument "cache_cluster_enabled" TF.Bool)
    {- ^ (Optional) Specifies whether a cache cluster is enabled for the stage -}
    , _cache_cluster_size :: !(TF.Argument "cache_cluster_size" Text)
    {- ^ (Optional) The size of the cache cluster for the stage, if enabled. Allowed values include @0.5@ , @1.6@ , @6.1@ , @13.5@ , @28.4@ , @58.2@ , @118@ and @237@ . -}
    , _client_certificate_id :: !(TF.Argument "client_certificate_id" Text)
    {- ^ (Optional) The identifier of a client certificate for the stage. -}
    , _deployment_id :: !(TF.Argument "deployment_id" Text)
    {- ^ (Required) The ID of the deployment that the stage points to -}
    , _description :: !(TF.Argument "description" Text)
    {- ^ (Optional) The description of the stage -}
    , _documentation_version :: !(TF.Argument "documentation_version" Text)
    {- ^ (Optional) The version of the associated API documentation -}
    , _rest_api_id :: !(TF.Argument "rest_api_id" Text)
    {- ^ (Required) The ID of the associated REST API -}
    , _stage_name :: !(TF.Argument "stage_name" Text)
    {- ^ (Required) The name of the stage -}
    , _variables :: !(TF.Argument "variables" Text)
    {- ^ (Optional) A map that defines the stage variables -}
    } deriving (Show, Eq)

instance TF.ToHCL ApiGatewayStageResource where
    toHCL ApiGatewayStageResource{..} = TF.block $ catMaybes
        [ TF.argument _cache_cluster_enabled
        , TF.argument _cache_cluster_size
        , TF.argument _client_certificate_id
        , TF.argument _deployment_id
        , TF.argument _description
        , TF.argument _documentation_version
        , TF.argument _rest_api_id
        , TF.argument _stage_name
        , TF.argument _variables
        ]

instance HasCacheClusterEnabled ApiGatewayStageResource TF.Bool where
    cacheClusterEnabled =
        lens (_cache_cluster_enabled :: ApiGatewayStageResource -> TF.Argument "cache_cluster_enabled" TF.Bool)
             (\s a -> s { _cache_cluster_enabled = a } :: ApiGatewayStageResource)

instance HasCacheClusterSize ApiGatewayStageResource Text where
    cacheClusterSize =
        lens (_cache_cluster_size :: ApiGatewayStageResource -> TF.Argument "cache_cluster_size" Text)
             (\s a -> s { _cache_cluster_size = a } :: ApiGatewayStageResource)

instance HasClientCertificateId ApiGatewayStageResource Text where
    clientCertificateId =
        lens (_client_certificate_id :: ApiGatewayStageResource -> TF.Argument "client_certificate_id" Text)
             (\s a -> s { _client_certificate_id = a } :: ApiGatewayStageResource)

instance HasDeploymentId ApiGatewayStageResource Text where
    deploymentId =
        lens (_deployment_id :: ApiGatewayStageResource -> TF.Argument "deployment_id" Text)
             (\s a -> s { _deployment_id = a } :: ApiGatewayStageResource)

instance HasDescription ApiGatewayStageResource Text where
    description =
        lens (_description :: ApiGatewayStageResource -> TF.Argument "description" Text)
             (\s a -> s { _description = a } :: ApiGatewayStageResource)

instance HasDocumentationVersion ApiGatewayStageResource Text where
    documentationVersion =
        lens (_documentation_version :: ApiGatewayStageResource -> TF.Argument "documentation_version" Text)
             (\s a -> s { _documentation_version = a } :: ApiGatewayStageResource)

instance HasRestApiId ApiGatewayStageResource Text where
    restApiId =
        lens (_rest_api_id :: ApiGatewayStageResource -> TF.Argument "rest_api_id" Text)
             (\s a -> s { _rest_api_id = a } :: ApiGatewayStageResource)

instance HasStageName ApiGatewayStageResource Text where
    stageName =
        lens (_stage_name :: ApiGatewayStageResource -> TF.Argument "stage_name" Text)
             (\s a -> s { _stage_name = a } :: ApiGatewayStageResource)

instance HasVariables ApiGatewayStageResource Text where
    variables =
        lens (_variables :: ApiGatewayStageResource -> TF.Argument "variables" Text)
             (\s a -> s { _variables = a } :: ApiGatewayStageResource)

apiGatewayStageResource :: TF.Resource TF.AWS ApiGatewayStageResource
apiGatewayStageResource =
    TF.newResource "aws_api_gateway_stage" $
        ApiGatewayStageResource {
            _cache_cluster_enabled = TF.Nil
            , _cache_cluster_size = TF.Nil
            , _client_certificate_id = TF.Nil
            , _deployment_id = TF.Nil
            , _description = TF.Nil
            , _documentation_version = TF.Nil
            , _rest_api_id = TF.Nil
            , _stage_name = TF.Nil
            , _variables = TF.Nil
            }

{- | The @aws_api_gateway_usage_plan_key@ AWS resource.

Provides an API Gateway Usage Plan Key.
-}
data ApiGatewayUsagePlanKeyResource = ApiGatewayUsagePlanKeyResource {
      _key_id :: !(TF.Argument "key_id" Text)
    {- ^ (Required) The identifier of the API key resource. -}
    , _key_type :: !(TF.Argument "key_type" Text)
    {- ^ (Required) The type of the API key resource. Currently, the valid key type is API_KEY. -}
    , _usage_plan_id :: !(TF.Argument "usage_plan_id" Text)
    {- ^ (Required) The Id of the usage plan resource representing to associate the key to. -}
    } deriving (Show, Eq)

instance TF.ToHCL ApiGatewayUsagePlanKeyResource where
    toHCL ApiGatewayUsagePlanKeyResource{..} = TF.block $ catMaybes
        [ TF.argument _key_id
        , TF.argument _key_type
        , TF.argument _usage_plan_id
        ]

instance HasKeyId ApiGatewayUsagePlanKeyResource Text where
    keyId =
        lens (_key_id :: ApiGatewayUsagePlanKeyResource -> TF.Argument "key_id" Text)
             (\s a -> s { _key_id = a } :: ApiGatewayUsagePlanKeyResource)

instance HasKeyType ApiGatewayUsagePlanKeyResource Text where
    keyType =
        lens (_key_type :: ApiGatewayUsagePlanKeyResource -> TF.Argument "key_type" Text)
             (\s a -> s { _key_type = a } :: ApiGatewayUsagePlanKeyResource)

instance HasUsagePlanId ApiGatewayUsagePlanKeyResource Text where
    usagePlanId =
        lens (_usage_plan_id :: ApiGatewayUsagePlanKeyResource -> TF.Argument "usage_plan_id" Text)
             (\s a -> s { _usage_plan_id = a } :: ApiGatewayUsagePlanKeyResource)

instance HasComputedId ApiGatewayUsagePlanKeyResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedKeyId ApiGatewayUsagePlanKeyResource Text where
    computedKeyId =
        to (\_  -> TF.Compute "key_id")

instance HasComputedKeyType ApiGatewayUsagePlanKeyResource Text where
    computedKeyType =
        to (\_  -> TF.Compute "key_type")

instance HasComputedName ApiGatewayUsagePlanKeyResource Text where
    computedName =
        to (\_  -> TF.Compute "name")

instance HasComputedUsagePlanId ApiGatewayUsagePlanKeyResource Text where
    computedUsagePlanId =
        to (\_  -> TF.Compute "usage_plan_id")

instance HasComputedValue ApiGatewayUsagePlanKeyResource Text where
    computedValue =
        to (\_  -> TF.Compute "value")

apiGatewayUsagePlanKeyResource :: TF.Resource TF.AWS ApiGatewayUsagePlanKeyResource
apiGatewayUsagePlanKeyResource =
    TF.newResource "aws_api_gateway_usage_plan_key" $
        ApiGatewayUsagePlanKeyResource {
            _key_id = TF.Nil
            , _key_type = TF.Nil
            , _usage_plan_id = TF.Nil
            }

{- | The @aws_api_gateway_usage_plan@ AWS resource.

Provides an API Gateway Usage Plan.
-}
data ApiGatewayUsagePlanResource = ApiGatewayUsagePlanResource {
      _api_stages :: !(TF.Argument "api_stages" Text)
    {- ^ (Optional) The associated <#api-stages-arguments> of the usage plan. -}
    , _description :: !(TF.Argument "description" Text)
    {- ^ (Required) The description of a usage plan. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the usage plan. -}
    , _product_code :: !(TF.Argument "product_code" Text)
    {- ^ (Optional) The AWS Markeplace product identifier to associate with the usage plan as a SaaS product on AWS Marketplace. -}
    , _quota_settings :: !(TF.Argument "quota_settings" Text)
    {- ^ (Optional) The <#quota-settings-arguments> of the usage plan. -}
    , _throttle_settings :: !(TF.Argument "throttle_settings" Text)
    {- ^ (Optional) The <#throttling-settings-arguments> of the usage plan. -}
    } deriving (Show, Eq)

instance TF.ToHCL ApiGatewayUsagePlanResource where
    toHCL ApiGatewayUsagePlanResource{..} = TF.block $ catMaybes
        [ TF.argument _api_stages
        , TF.argument _description
        , TF.argument _name
        , TF.argument _product_code
        , TF.argument _quota_settings
        , TF.argument _throttle_settings
        ]

instance HasApiStages ApiGatewayUsagePlanResource Text where
    apiStages =
        lens (_api_stages :: ApiGatewayUsagePlanResource -> TF.Argument "api_stages" Text)
             (\s a -> s { _api_stages = a } :: ApiGatewayUsagePlanResource)

instance HasDescription ApiGatewayUsagePlanResource Text where
    description =
        lens (_description :: ApiGatewayUsagePlanResource -> TF.Argument "description" Text)
             (\s a -> s { _description = a } :: ApiGatewayUsagePlanResource)

instance HasName ApiGatewayUsagePlanResource Text where
    name =
        lens (_name :: ApiGatewayUsagePlanResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: ApiGatewayUsagePlanResource)

instance HasProductCode ApiGatewayUsagePlanResource Text where
    productCode =
        lens (_product_code :: ApiGatewayUsagePlanResource -> TF.Argument "product_code" Text)
             (\s a -> s { _product_code = a } :: ApiGatewayUsagePlanResource)

instance HasQuotaSettings ApiGatewayUsagePlanResource Text where
    quotaSettings =
        lens (_quota_settings :: ApiGatewayUsagePlanResource -> TF.Argument "quota_settings" Text)
             (\s a -> s { _quota_settings = a } :: ApiGatewayUsagePlanResource)

instance HasThrottleSettings ApiGatewayUsagePlanResource Text where
    throttleSettings =
        lens (_throttle_settings :: ApiGatewayUsagePlanResource -> TF.Argument "throttle_settings" Text)
             (\s a -> s { _throttle_settings = a } :: ApiGatewayUsagePlanResource)

apiGatewayUsagePlanResource :: TF.Resource TF.AWS ApiGatewayUsagePlanResource
apiGatewayUsagePlanResource =
    TF.newResource "aws_api_gateway_usage_plan" $
        ApiGatewayUsagePlanResource {
            _api_stages = TF.Nil
            , _description = TF.Nil
            , _name = TF.Nil
            , _product_code = TF.Nil
            , _quota_settings = TF.Nil
            , _throttle_settings = TF.Nil
            }

{- | The @aws_app_cookie_stickiness_policy@ AWS resource.

Provides an application cookie stickiness policy, which allows an ELB to wed
its sticky cookie's expiration to a cookie generated by your application.
-}
data AppCookieStickinessPolicyResource = AppCookieStickinessPolicyResource {
      _cookie_name :: !(TF.Argument "cookie_name" Text)
    {- ^ (Required) The application cookie whose lifetime the ELB's cookie should follow. -}
    , _lb_port :: !(TF.Argument "lb_port" TF.Word16)
    {- ^ (Required) The load balancer port to which the policy should be applied. This must be an active listener on the load balancer. -}
    , _load_balancer :: !(TF.Argument "load_balancer" Text)
    {- ^ (Required) The name of load balancer to which the policy should be attached. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the stickiness policy. -}
    } deriving (Show, Eq)

instance TF.ToHCL AppCookieStickinessPolicyResource where
    toHCL AppCookieStickinessPolicyResource{..} = TF.block $ catMaybes
        [ TF.argument _cookie_name
        , TF.argument _lb_port
        , TF.argument _load_balancer
        , TF.argument _name
        ]

instance HasCookieName AppCookieStickinessPolicyResource Text where
    cookieName =
        lens (_cookie_name :: AppCookieStickinessPolicyResource -> TF.Argument "cookie_name" Text)
             (\s a -> s { _cookie_name = a } :: AppCookieStickinessPolicyResource)

instance HasLbPort AppCookieStickinessPolicyResource TF.Word16 where
    lbPort =
        lens (_lb_port :: AppCookieStickinessPolicyResource -> TF.Argument "lb_port" TF.Word16)
             (\s a -> s { _lb_port = a } :: AppCookieStickinessPolicyResource)

instance HasLoadBalancer AppCookieStickinessPolicyResource Text where
    loadBalancer =
        lens (_load_balancer :: AppCookieStickinessPolicyResource -> TF.Argument "load_balancer" Text)
             (\s a -> s { _load_balancer = a } :: AppCookieStickinessPolicyResource)

instance HasName AppCookieStickinessPolicyResource Text where
    name =
        lens (_name :: AppCookieStickinessPolicyResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: AppCookieStickinessPolicyResource)

instance HasComputedCookieName AppCookieStickinessPolicyResource Text where
    computedCookieName =
        to (\_  -> TF.Compute "cookie_name")

instance HasComputedId AppCookieStickinessPolicyResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedLbPort AppCookieStickinessPolicyResource TF.Word16 where
    computedLbPort =
        to (\_  -> TF.Compute "lb_port")

instance HasComputedLoadBalancer AppCookieStickinessPolicyResource Text where
    computedLoadBalancer =
        to (\_  -> TF.Compute "load_balancer")

instance HasComputedName AppCookieStickinessPolicyResource Text where
    computedName =
        to (\_  -> TF.Compute "name")

appCookieStickinessPolicyResource :: TF.Resource TF.AWS AppCookieStickinessPolicyResource
appCookieStickinessPolicyResource =
    TF.newResource "aws_app_cookie_stickiness_policy" $
        AppCookieStickinessPolicyResource {
            _cookie_name = TF.Nil
            , _lb_port = TF.Nil
            , _load_balancer = TF.Nil
            , _name = TF.Nil
            }

{- | The @aws_appautoscaling_policy@ AWS resource.

Provides an Application AutoScaling Policy resource.
-}
data AppautoscalingPolicyResource = AppautoscalingPolicyResource {
      _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the policy. -}
    , _policy_type :: !(TF.Argument "policy_type" Text)
    {- ^ (Optional) For DynamoDB, only @TargetTrackingScaling@ is supported. For any other service, only @StepScaling@ is supported. Defaults to @StepScaling@ . -}
    , _resource_id :: !(TF.Argument "resource_id" Text)
    {- ^ (Required) The resource type and unique identifier string for the resource associated with the scaling policy. Documentation can be found in the @ResourceId@ parameter at: <http://docs.aws.amazon.com/ApplicationAutoScaling/latest/APIReference/API_RegisterScalableTarget.html#API_RegisterScalableTarget_RequestParameters> -}
    , _scalable_dimension :: !(TF.Argument "scalable_dimension" Text)
    {- ^ (Required) The scalable dimension of the scalable target. Documentation can be found in the @ScalableDimension@ parameter at: <http://docs.aws.amazon.com/ApplicationAutoScaling/latest/APIReference/API_RegisterScalableTarget.html#API_RegisterScalableTarget_RequestParameters> -}
    , _service_namespace :: !(TF.Argument "service_namespace" Text)
    {- ^ (Required) The AWS service namespace of the scalable target. Documentation can be found in the @ServiceNamespace@ parameter at: <http://docs.aws.amazon.com/ApplicationAutoScaling/latest/APIReference/API_RegisterScalableTarget.html#API_RegisterScalableTarget_RequestParameters> -}
    , _step_scaling_policy_configuration :: !(TF.Argument "step_scaling_policy_configuration" Text)
    {- ^ (Optional) Step scaling policy configuration, requires @policy_type = "StepScaling"@ (default). See supported fields below. -}
    , _target_tracking_scaling_policy_configuration :: !(TF.Argument "target_tracking_scaling_policy_configuration" Text)
    {- ^ (Optional) A target tracking policy, requires @policy_type = "TargetTrackingScaling"@ . See supported fields below. -}
    } deriving (Show, Eq)

instance TF.ToHCL AppautoscalingPolicyResource where
    toHCL AppautoscalingPolicyResource{..} = TF.block $ catMaybes
        [ TF.argument _name
        , TF.argument _policy_type
        , TF.argument _resource_id
        , TF.argument _scalable_dimension
        , TF.argument _service_namespace
        , TF.argument _step_scaling_policy_configuration
        , TF.argument _target_tracking_scaling_policy_configuration
        ]

instance HasName AppautoscalingPolicyResource Text where
    name =
        lens (_name :: AppautoscalingPolicyResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: AppautoscalingPolicyResource)

instance HasPolicyType AppautoscalingPolicyResource Text where
    policyType =
        lens (_policy_type :: AppautoscalingPolicyResource -> TF.Argument "policy_type" Text)
             (\s a -> s { _policy_type = a } :: AppautoscalingPolicyResource)

instance HasResourceId AppautoscalingPolicyResource Text where
    resourceId =
        lens (_resource_id :: AppautoscalingPolicyResource -> TF.Argument "resource_id" Text)
             (\s a -> s { _resource_id = a } :: AppautoscalingPolicyResource)

instance HasScalableDimension AppautoscalingPolicyResource Text where
    scalableDimension =
        lens (_scalable_dimension :: AppautoscalingPolicyResource -> TF.Argument "scalable_dimension" Text)
             (\s a -> s { _scalable_dimension = a } :: AppautoscalingPolicyResource)

instance HasServiceNamespace AppautoscalingPolicyResource Text where
    serviceNamespace =
        lens (_service_namespace :: AppautoscalingPolicyResource -> TF.Argument "service_namespace" Text)
             (\s a -> s { _service_namespace = a } :: AppautoscalingPolicyResource)

instance HasStepScalingPolicyConfiguration AppautoscalingPolicyResource Text where
    stepScalingPolicyConfiguration =
        lens (_step_scaling_policy_configuration :: AppautoscalingPolicyResource -> TF.Argument "step_scaling_policy_configuration" Text)
             (\s a -> s { _step_scaling_policy_configuration = a } :: AppautoscalingPolicyResource)

instance HasTargetTrackingScalingPolicyConfiguration AppautoscalingPolicyResource Text where
    targetTrackingScalingPolicyConfiguration =
        lens (_target_tracking_scaling_policy_configuration :: AppautoscalingPolicyResource -> TF.Argument "target_tracking_scaling_policy_configuration" Text)
             (\s a -> s { _target_tracking_scaling_policy_configuration = a } :: AppautoscalingPolicyResource)

appautoscalingPolicyResource :: TF.Resource TF.AWS AppautoscalingPolicyResource
appautoscalingPolicyResource =
    TF.newResource "aws_appautoscaling_policy" $
        AppautoscalingPolicyResource {
            _name = TF.Nil
            , _policy_type = TF.Nil
            , _resource_id = TF.Nil
            , _scalable_dimension = TF.Nil
            , _service_namespace = TF.Nil
            , _step_scaling_policy_configuration = TF.Nil
            , _target_tracking_scaling_policy_configuration = TF.Nil
            }

{- | The @aws_appautoscaling_scheduled_action@ AWS resource.

Provides an Application AutoScaling ScheduledAction resource.
-}
data AppautoscalingScheduledActionResource = AppautoscalingScheduledActionResource {
      _end_time :: !(TF.Argument "end_time" Text)
    {- ^ (Optional) The date and time for the scheduled action to end. Specify the following format: 2006-01-02T15:04:05Z -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the scheduled action. -}
    , _resource_id :: !(TF.Argument "resource_id" Text)
    {- ^ (Required) The identifier of the resource associated with the scheduled action. Documentation can be found in the parameter at: <https://docs.aws.amazon.com/ApplicationAutoScaling/latest/APIReference/API_PutScheduledAction.html#ApplicationAutoScaling-PutScheduledAction-request-ResourceId> -}
    , _scalable_dimension :: !(TF.Argument "scalable_dimension" Text)
    {- ^ (Optional) The scalable dimension. Documentation can be found in the parameter at: <https://docs.aws.amazon.com/ApplicationAutoScaling/latest/APIReference/API_PutScheduledAction.html#ApplicationAutoScaling-PutScheduledAction-request-ScalableDimension> Example: ecs:service:DesiredCount -}
    , _scalable_target_action :: !(TF.Argument "scalable_target_action" Text)
    {- ^ (Optional) The new minimum and maximum capacity. You can set both values or just one. See <#scalable-target-action-arguments> -}
    , _schedule :: !(TF.Argument "schedule" Text)
    {- ^ (Optional) The schedule for this action. The following formats are supported: At expressions - at(yyyy-mm-ddThh:mm:ss), Rate expressions - rate(valueunit), Cron expressions - cron(fields). In UTC. Documentation can be found in the parameter at: <https://docs.aws.amazon.com/ApplicationAutoScaling/latest/APIReference/API_PutScheduledAction.html#ApplicationAutoScaling-PutScheduledAction-request-Schedule> -}
    , _service_namespace :: !(TF.Argument "service_namespace" Text)
    {- ^ (Required) The namespace of the AWS service. Documentation can be found in the parameter at: <https://docs.aws.amazon.com/ApplicationAutoScaling/latest/APIReference/API_PutScheduledAction.html#ApplicationAutoScaling-PutScheduledAction-request-ServiceNamespace> Example: ecs -}
    , _start_time :: !(TF.Argument "start_time" Text)
    {- ^ (Optional) The date and time for the scheduled action to start. Specify the following format: 2006-01-02T15:04:05Z -}
    } deriving (Show, Eq)

instance TF.ToHCL AppautoscalingScheduledActionResource where
    toHCL AppautoscalingScheduledActionResource{..} = TF.block $ catMaybes
        [ TF.argument _end_time
        , TF.argument _name
        , TF.argument _resource_id
        , TF.argument _scalable_dimension
        , TF.argument _scalable_target_action
        , TF.argument _schedule
        , TF.argument _service_namespace
        , TF.argument _start_time
        ]

instance HasEndTime AppautoscalingScheduledActionResource Text where
    endTime =
        lens (_end_time :: AppautoscalingScheduledActionResource -> TF.Argument "end_time" Text)
             (\s a -> s { _end_time = a } :: AppautoscalingScheduledActionResource)

instance HasName AppautoscalingScheduledActionResource Text where
    name =
        lens (_name :: AppautoscalingScheduledActionResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: AppautoscalingScheduledActionResource)

instance HasResourceId AppautoscalingScheduledActionResource Text where
    resourceId =
        lens (_resource_id :: AppautoscalingScheduledActionResource -> TF.Argument "resource_id" Text)
             (\s a -> s { _resource_id = a } :: AppautoscalingScheduledActionResource)

instance HasScalableDimension AppautoscalingScheduledActionResource Text where
    scalableDimension =
        lens (_scalable_dimension :: AppautoscalingScheduledActionResource -> TF.Argument "scalable_dimension" Text)
             (\s a -> s { _scalable_dimension = a } :: AppautoscalingScheduledActionResource)

instance HasScalableTargetAction AppautoscalingScheduledActionResource Text where
    scalableTargetAction =
        lens (_scalable_target_action :: AppautoscalingScheduledActionResource -> TF.Argument "scalable_target_action" Text)
             (\s a -> s { _scalable_target_action = a } :: AppautoscalingScheduledActionResource)

instance HasSchedule AppautoscalingScheduledActionResource Text where
    schedule =
        lens (_schedule :: AppautoscalingScheduledActionResource -> TF.Argument "schedule" Text)
             (\s a -> s { _schedule = a } :: AppautoscalingScheduledActionResource)

instance HasServiceNamespace AppautoscalingScheduledActionResource Text where
    serviceNamespace =
        lens (_service_namespace :: AppautoscalingScheduledActionResource -> TF.Argument "service_namespace" Text)
             (\s a -> s { _service_namespace = a } :: AppautoscalingScheduledActionResource)

instance HasStartTime AppautoscalingScheduledActionResource Text where
    startTime =
        lens (_start_time :: AppautoscalingScheduledActionResource -> TF.Argument "start_time" Text)
             (\s a -> s { _start_time = a } :: AppautoscalingScheduledActionResource)

appautoscalingScheduledActionResource :: TF.Resource TF.AWS AppautoscalingScheduledActionResource
appautoscalingScheduledActionResource =
    TF.newResource "aws_appautoscaling_scheduled_action" $
        AppautoscalingScheduledActionResource {
            _end_time = TF.Nil
            , _name = TF.Nil
            , _resource_id = TF.Nil
            , _scalable_dimension = TF.Nil
            , _scalable_target_action = TF.Nil
            , _schedule = TF.Nil
            , _service_namespace = TF.Nil
            , _start_time = TF.Nil
            }

{- | The @aws_appautoscaling_target@ AWS resource.

Provides an Application AutoScaling ScalableTarget resource.
-}
data AppautoscalingTargetResource = AppautoscalingTargetResource {
      _max_capacity :: !(TF.Argument "max_capacity" Text)
    {- ^ (Required) The max capacity of the scalable target. -}
    , _min_capacity :: !(TF.Argument "min_capacity" Text)
    {- ^ (Required) The min capacity of the scalable target. -}
    , _resource_id :: !(TF.Argument "resource_id" Text)
    {- ^ (Required) The resource type and unique identifier string for the resource associated with the scaling policy. Documentation can be found in the @ResourceId@ parameter at: <http://docs.aws.amazon.com/ApplicationAutoScaling/latest/APIReference/API_RegisterScalableTarget.html#API_RegisterScalableTarget_RequestParameters> -}
    , _role_arn :: !(TF.Argument "role_arn" Text)
    {- ^ (Optional) The ARN of the IAM role that allows Application AutoScaling to modify your scalable target on your behalf. -}
    , _scalable_dimension :: !(TF.Argument "scalable_dimension" Text)
    {- ^ (Required) The scalable dimension of the scalable target. Documentation can be found in the @ScalableDimension@ parameter at: <http://docs.aws.amazon.com/ApplicationAutoScaling/latest/APIReference/API_RegisterScalableTarget.html#API_RegisterScalableTarget_RequestParameters> -}
    , _service_namespace :: !(TF.Argument "service_namespace" Text)
    {- ^ (Required) The AWS service namespace of the scalable target. Documentation can be found in the @ServiceNamespace@ parameter at: <http://docs.aws.amazon.com/ApplicationAutoScaling/latest/APIReference/API_RegisterScalableTarget.html#API_RegisterScalableTarget_RequestParameters> -}
    } deriving (Show, Eq)

instance TF.ToHCL AppautoscalingTargetResource where
    toHCL AppautoscalingTargetResource{..} = TF.block $ catMaybes
        [ TF.argument _max_capacity
        , TF.argument _min_capacity
        , TF.argument _resource_id
        , TF.argument _role_arn
        , TF.argument _scalable_dimension
        , TF.argument _service_namespace
        ]

instance HasMaxCapacity AppautoscalingTargetResource Text where
    maxCapacity =
        lens (_max_capacity :: AppautoscalingTargetResource -> TF.Argument "max_capacity" Text)
             (\s a -> s { _max_capacity = a } :: AppautoscalingTargetResource)

instance HasMinCapacity AppautoscalingTargetResource Text where
    minCapacity =
        lens (_min_capacity :: AppautoscalingTargetResource -> TF.Argument "min_capacity" Text)
             (\s a -> s { _min_capacity = a } :: AppautoscalingTargetResource)

instance HasResourceId AppautoscalingTargetResource Text where
    resourceId =
        lens (_resource_id :: AppautoscalingTargetResource -> TF.Argument "resource_id" Text)
             (\s a -> s { _resource_id = a } :: AppautoscalingTargetResource)

instance HasRoleArn AppautoscalingTargetResource Text where
    roleArn =
        lens (_role_arn :: AppautoscalingTargetResource -> TF.Argument "role_arn" Text)
             (\s a -> s { _role_arn = a } :: AppautoscalingTargetResource)

instance HasScalableDimension AppautoscalingTargetResource Text where
    scalableDimension =
        lens (_scalable_dimension :: AppautoscalingTargetResource -> TF.Argument "scalable_dimension" Text)
             (\s a -> s { _scalable_dimension = a } :: AppautoscalingTargetResource)

instance HasServiceNamespace AppautoscalingTargetResource Text where
    serviceNamespace =
        lens (_service_namespace :: AppautoscalingTargetResource -> TF.Argument "service_namespace" Text)
             (\s a -> s { _service_namespace = a } :: AppautoscalingTargetResource)

appautoscalingTargetResource :: TF.Resource TF.AWS AppautoscalingTargetResource
appautoscalingTargetResource =
    TF.newResource "aws_appautoscaling_target" $
        AppautoscalingTargetResource {
            _max_capacity = TF.Nil
            , _min_capacity = TF.Nil
            , _resource_id = TF.Nil
            , _role_arn = TF.Nil
            , _scalable_dimension = TF.Nil
            , _service_namespace = TF.Nil
            }

{- | The @aws_athena_database@ AWS resource.

Provides a SSM resource data sync.
-}
data AthenaDatabaseResource = AthenaDatabaseResource {
      _name :: !(TF.Argument "name" Text)
    {- ^ (Required) Name for the configuration. -}
    , _s3_destination :: !(TF.Argument "s3_destination" Text)
    {- ^ (Required) Amazon S3 configuration details for the sync. -}
    } deriving (Show, Eq)

instance TF.ToHCL AthenaDatabaseResource where
    toHCL AthenaDatabaseResource{..} = TF.block $ catMaybes
        [ TF.argument _name
        , TF.argument _s3_destination
        ]

instance HasName AthenaDatabaseResource Text where
    name =
        lens (_name :: AthenaDatabaseResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: AthenaDatabaseResource)

instance HasS3Destination AthenaDatabaseResource Text where
    s3Destination =
        lens (_s3_destination :: AthenaDatabaseResource -> TF.Argument "s3_destination" Text)
             (\s a -> s { _s3_destination = a } :: AthenaDatabaseResource)

athenaDatabaseResource :: TF.Resource TF.AWS AthenaDatabaseResource
athenaDatabaseResource =
    TF.newResource "aws_athena_database" $
        AthenaDatabaseResource {
            _name = TF.Nil
            , _s3_destination = TF.Nil
            }

{- | The @aws_athena_named_query@ AWS resource.

Provides an Athena Named Query resource.
-}
data AthenaNamedQueryResource = AthenaNamedQueryResource {
      _database :: !(TF.Argument "database" Text)
    {- ^ (Required) The database to which the query belongs. -}
    , _description :: !(TF.Argument "description" Text)
    {- ^ (Optional) A brief explanation of the query. Maximum length of 1024. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The plain language name for the query. Maximum length of 128. -}
    , _query :: !(TF.Argument "query" Text)
    {- ^ (Required) The text of the query itself. In other words, all query statements. Maximum length of 262144. -}
    } deriving (Show, Eq)

instance TF.ToHCL AthenaNamedQueryResource where
    toHCL AthenaNamedQueryResource{..} = TF.block $ catMaybes
        [ TF.argument _database
        , TF.argument _description
        , TF.argument _name
        , TF.argument _query
        ]

instance HasDatabase AthenaNamedQueryResource Text where
    database =
        lens (_database :: AthenaNamedQueryResource -> TF.Argument "database" Text)
             (\s a -> s { _database = a } :: AthenaNamedQueryResource)

instance HasDescription AthenaNamedQueryResource Text where
    description =
        lens (_description :: AthenaNamedQueryResource -> TF.Argument "description" Text)
             (\s a -> s { _description = a } :: AthenaNamedQueryResource)

instance HasName AthenaNamedQueryResource Text where
    name =
        lens (_name :: AthenaNamedQueryResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: AthenaNamedQueryResource)

instance HasQuery AthenaNamedQueryResource Text where
    query =
        lens (_query :: AthenaNamedQueryResource -> TF.Argument "query" Text)
             (\s a -> s { _query = a } :: AthenaNamedQueryResource)

instance HasComputedId AthenaNamedQueryResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

athenaNamedQueryResource :: TF.Resource TF.AWS AthenaNamedQueryResource
athenaNamedQueryResource =
    TF.newResource "aws_athena_named_query" $
        AthenaNamedQueryResource {
            _database = TF.Nil
            , _description = TF.Nil
            , _name = TF.Nil
            , _query = TF.Nil
            }

{- | The @aws_autoscaling_attachment@ AWS resource.

Provides an AutoScaling Attachment resource. ~> NOTE on AutoScaling Groups
and ASG Attachments: Terraform currently provides both a standalone ASG
Attachment resource (describing an ASG attached to an ELB), and an
<autoscaling_group.html> with @load_balancers@ defined in-line. At this time
you cannot use an ASG with in-line load balancers in conjunction with an ASG
Attachment resource. Doing so will cause a conflict and will overwrite
attachments.
-}
data AutoscalingAttachmentResource = AutoscalingAttachmentResource {
      _alb_target_group_arn :: !(TF.Argument "alb_target_group_arn" Text)
    {- ^ (Optional) The ARN of an ALB Target Group. -}
    , _autoscaling_group_name :: !(TF.Argument "autoscaling_group_name" Text)
    {- ^ (Required) Name of ASG to associate with the ELB. -}
    , _elb :: !(TF.Argument "elb" Text)
    {- ^ (Optional) The name of the ELB. -}
    } deriving (Show, Eq)

instance TF.ToHCL AutoscalingAttachmentResource where
    toHCL AutoscalingAttachmentResource{..} = TF.block $ catMaybes
        [ TF.argument _alb_target_group_arn
        , TF.argument _autoscaling_group_name
        , TF.argument _elb
        ]

instance HasAlbTargetGroupArn AutoscalingAttachmentResource Text where
    albTargetGroupArn =
        lens (_alb_target_group_arn :: AutoscalingAttachmentResource -> TF.Argument "alb_target_group_arn" Text)
             (\s a -> s { _alb_target_group_arn = a } :: AutoscalingAttachmentResource)

instance HasAutoscalingGroupName AutoscalingAttachmentResource Text where
    autoscalingGroupName =
        lens (_autoscaling_group_name :: AutoscalingAttachmentResource -> TF.Argument "autoscaling_group_name" Text)
             (\s a -> s { _autoscaling_group_name = a } :: AutoscalingAttachmentResource)

instance HasElb AutoscalingAttachmentResource Text where
    elb =
        lens (_elb :: AutoscalingAttachmentResource -> TF.Argument "elb" Text)
             (\s a -> s { _elb = a } :: AutoscalingAttachmentResource)

autoscalingAttachmentResource :: TF.Resource TF.AWS AutoscalingAttachmentResource
autoscalingAttachmentResource =
    TF.newResource "aws_autoscaling_attachment" $
        AutoscalingAttachmentResource {
            _alb_target_group_arn = TF.Nil
            , _autoscaling_group_name = TF.Nil
            , _elb = TF.Nil
            }

{- | The @aws_autoscaling_group@ AWS resource.

Provides an AutoScaling Group resource.
-}
data AutoscalingGroupResource = AutoscalingGroupResource {
      _availability_zones :: !(TF.Argument "availability_zones" Text)
    {- ^ (Optional) A list of AZs to launch resources in. Required only if you do not specify any @vpc_zone_identifier@ -}
    , _default_cooldown :: !(TF.Argument "default_cooldown" Text)
    {- ^ (Optional) The amount of time, in seconds, after a scaling activity completes before another scaling activity can start. -}
    , _desired_capacity :: !(TF.Argument "desired_capacity" Text)
    {- ^ (Optional) The number of Amazon EC2 instances that should be running in the group. (See also <#waiting-for-capacity> below.) -}
    , _enabled_metrics :: !(TF.Argument "enabled_metrics" TF.Bool)
    {- ^ (Optional) A list of metrics to collect. The allowed values are @GroupMinSize@ , @GroupMaxSize@ , @GroupDesiredCapacity@ , @GroupInServiceInstances@ , @GroupPendingInstances@ , @GroupStandbyInstances@ , @GroupTerminatingInstances@ , @GroupTotalInstances@ . -}
    , _force_delete :: !(TF.Argument "force_delete" Text)
    {- ^ (Optional) Allows deleting the autoscaling group without waiting for all instances in the pool to terminate.  You can force an autoscaling group to delete even if it's in the process of scaling a resource. Normally, Terraform drains all the instances before deleting the group.  This bypasses that behavior and potentially leaves resources dangling. -}
    , _health_check_grace_period :: !(TF.Argument "health_check_grace_period" Text)
    {- ^ (Optional, Default: 300) Time (in seconds) after instance comes into service before checking health. -}
    , _health_check_type :: !(TF.Argument "health_check_type" Text)
    {- ^ (Optional) "EC2" or "ELB". Controls how health checking is done. -}
    , _initial_lifecycle_hook :: !(TF.Argument "initial_lifecycle_hook" Text)
    {- ^ (Optional) One or more <http://docs.aws.amazon.com/autoscaling/latest/userguide/lifecycle-hooks.html> to attach to the autoscaling group before instances are launched. The syntax is exactly the same as the separate </docs/providers/aws/r/autoscaling_lifecycle_hooks.html> resource, without the @autoscaling_group_name@ attribute. Please note that this will only work when creating a new autoscaling group. For all other use-cases, please use @aws_autoscaling_lifecycle_hook@ resource. -}
    , _launch_configuration :: !(TF.Argument "launch_configuration" Text)
    {- ^ (Required) The name of the launch configuration to use. -}
    , _load_balancers :: !(TF.Argument "load_balancers" Text)
    {- ^ (Optional) A list of elastic load balancer names to add to the autoscaling group names. -}
    , _max_size :: !(TF.Argument "max_size" Text)
    {- ^ (Required) The maximum size of the auto scale group. -}
    , _metrics_granularity :: !(TF.Argument "metrics_granularity" Text)
    {- ^ (Optional) The granularity to associate with the metrics to collect. The only valid value is @1Minute@ . Default is @1Minute@ . -}
    , _min_elb_capacity :: !(TF.Argument "min_elb_capacity" Text)
    {- ^ (Optional) Setting this causes Terraform to wait for this number of instances to show up healthy in the ELB only on creation. Updates will not wait on ELB instance number changes. (See also <#waiting-for-capacity> below.) -}
    , _min_size :: !(TF.Argument "min_size" Text)
    {- ^ (Required) The minimum size of the auto scale group. (See also <#waiting-for-capacity> below.) -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Optional) The name of the auto scaling group. By default generated by Terraform. -}
    , _name_prefix :: !(TF.Argument "name_prefix" Text)
    {- ^ (Optional) Creates a unique name beginning with the specified prefix. Conflicts with @name@ . -}
    , _placement_group :: !(TF.Argument "placement_group" Text)
    {- ^ (Optional) The name of the placement group into which you'll launch your instances, if any. -}
    , _protect_from_scale_in :: !(TF.Argument "protect_from_scale_in" Text)
    {- ^ (Optional) Allows setting instance protection. The autoscaling group will not select instances with this setting for terminination during scale in events. -}
    , _suspended_processes :: !(TF.Argument "suspended_processes" Text)
    {- ^ (Optional) A list of processes to suspend for the AutoScaling Group. The allowed values are @Launch@ , @Terminate@ , @HealthCheck@ , @ReplaceUnhealthy@ , @AZRebalance@ , @AlarmNotification@ , @ScheduledActions@ , @AddToLoadBalancer@ . Note that if you suspend either the @Launch@ or @Terminate@ process types, it can prevent your autoscaling group from functioning properly. -}
    , _tag :: !(TF.Argument "tag" Text)
    {- ^ (Optional) A list of tag blocks. Tags documented below. -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A list of tag blocks (maps). Tags documented below. -}
    , _target_group_arns :: !(TF.Argument "target_group_arns" Text)
    {- ^ (Optional) A list of @aws_alb_target_group@ ARNs, for use with Application Load Balancing -}
    , _termination_policies :: !(TF.Argument "termination_policies" Text)
    {- ^ (Optional) A list of policies to decide how the instances in the auto scale group should be terminated. The allowed values are @OldestInstance@ , @NewestInstance@ , @OldestLaunchConfiguration@ , @ClosestToNextInstanceHour@ , @Default@ . -}
    , _vpc_zone_identifier :: !(TF.Argument "vpc_zone_identifier" Text)
    {- ^ (Optional) A list of subnet IDs to launch resources in. -}
    , _wait_for_capacity_timeout :: !(TF.Argument "wait_for_capacity_timeout" Text)
    {- ^ (Default: "10m") A maximum <https://golang.org/pkg/time/#ParseDuration> that Terraform should wait for ASG instances to be healthy before timing out.  (See also <#waiting-for-capacity> below.) Setting this to "0" causes Terraform to skip all Capacity Waiting behavior. -}
    , _wait_for_elb_capacity :: !(TF.Argument "wait_for_elb_capacity" Text)
    {- ^ (Optional) Setting this will cause Terraform to wait for exactly this number of healthy instances in all attached load balancers on both create and update operations. (Takes precedence over @min_elb_capacity@ behavior.) (See also <#waiting-for-capacity> below.) -}
    } deriving (Show, Eq)

instance TF.ToHCL AutoscalingGroupResource where
    toHCL AutoscalingGroupResource{..} = TF.block $ catMaybes
        [ TF.argument _availability_zones
        , TF.argument _default_cooldown
        , TF.argument _desired_capacity
        , TF.argument _enabled_metrics
        , TF.argument _force_delete
        , TF.argument _health_check_grace_period
        , TF.argument _health_check_type
        , TF.argument _initial_lifecycle_hook
        , TF.argument _launch_configuration
        , TF.argument _load_balancers
        , TF.argument _max_size
        , TF.argument _metrics_granularity
        , TF.argument _min_elb_capacity
        , TF.argument _min_size
        , TF.argument _name
        , TF.argument _name_prefix
        , TF.argument _placement_group
        , TF.argument _protect_from_scale_in
        , TF.argument _suspended_processes
        , TF.argument _tag
        , TF.argument _tags
        , TF.argument _target_group_arns
        , TF.argument _termination_policies
        , TF.argument _vpc_zone_identifier
        , TF.argument _wait_for_capacity_timeout
        , TF.argument _wait_for_elb_capacity
        ]

instance HasAvailabilityZones AutoscalingGroupResource Text where
    availabilityZones =
        lens (_availability_zones :: AutoscalingGroupResource -> TF.Argument "availability_zones" Text)
             (\s a -> s { _availability_zones = a } :: AutoscalingGroupResource)

instance HasDefaultCooldown AutoscalingGroupResource Text where
    defaultCooldown =
        lens (_default_cooldown :: AutoscalingGroupResource -> TF.Argument "default_cooldown" Text)
             (\s a -> s { _default_cooldown = a } :: AutoscalingGroupResource)

instance HasDesiredCapacity AutoscalingGroupResource Text where
    desiredCapacity =
        lens (_desired_capacity :: AutoscalingGroupResource -> TF.Argument "desired_capacity" Text)
             (\s a -> s { _desired_capacity = a } :: AutoscalingGroupResource)

instance HasEnabledMetrics AutoscalingGroupResource TF.Bool where
    enabledMetrics =
        lens (_enabled_metrics :: AutoscalingGroupResource -> TF.Argument "enabled_metrics" TF.Bool)
             (\s a -> s { _enabled_metrics = a } :: AutoscalingGroupResource)

instance HasForceDelete AutoscalingGroupResource Text where
    forceDelete =
        lens (_force_delete :: AutoscalingGroupResource -> TF.Argument "force_delete" Text)
             (\s a -> s { _force_delete = a } :: AutoscalingGroupResource)

instance HasHealthCheckGracePeriod AutoscalingGroupResource Text where
    healthCheckGracePeriod =
        lens (_health_check_grace_period :: AutoscalingGroupResource -> TF.Argument "health_check_grace_period" Text)
             (\s a -> s { _health_check_grace_period = a } :: AutoscalingGroupResource)

instance HasHealthCheckType AutoscalingGroupResource Text where
    healthCheckType =
        lens (_health_check_type :: AutoscalingGroupResource -> TF.Argument "health_check_type" Text)
             (\s a -> s { _health_check_type = a } :: AutoscalingGroupResource)

instance HasInitialLifecycleHook AutoscalingGroupResource Text where
    initialLifecycleHook =
        lens (_initial_lifecycle_hook :: AutoscalingGroupResource -> TF.Argument "initial_lifecycle_hook" Text)
             (\s a -> s { _initial_lifecycle_hook = a } :: AutoscalingGroupResource)

instance HasLaunchConfiguration AutoscalingGroupResource Text where
    launchConfiguration =
        lens (_launch_configuration :: AutoscalingGroupResource -> TF.Argument "launch_configuration" Text)
             (\s a -> s { _launch_configuration = a } :: AutoscalingGroupResource)

instance HasLoadBalancers AutoscalingGroupResource Text where
    loadBalancers =
        lens (_load_balancers :: AutoscalingGroupResource -> TF.Argument "load_balancers" Text)
             (\s a -> s { _load_balancers = a } :: AutoscalingGroupResource)

instance HasMaxSize AutoscalingGroupResource Text where
    maxSize =
        lens (_max_size :: AutoscalingGroupResource -> TF.Argument "max_size" Text)
             (\s a -> s { _max_size = a } :: AutoscalingGroupResource)

instance HasMetricsGranularity AutoscalingGroupResource Text where
    metricsGranularity =
        lens (_metrics_granularity :: AutoscalingGroupResource -> TF.Argument "metrics_granularity" Text)
             (\s a -> s { _metrics_granularity = a } :: AutoscalingGroupResource)

instance HasMinElbCapacity AutoscalingGroupResource Text where
    minElbCapacity =
        lens (_min_elb_capacity :: AutoscalingGroupResource -> TF.Argument "min_elb_capacity" Text)
             (\s a -> s { _min_elb_capacity = a } :: AutoscalingGroupResource)

instance HasMinSize AutoscalingGroupResource Text where
    minSize =
        lens (_min_size :: AutoscalingGroupResource -> TF.Argument "min_size" Text)
             (\s a -> s { _min_size = a } :: AutoscalingGroupResource)

instance HasName AutoscalingGroupResource Text where
    name =
        lens (_name :: AutoscalingGroupResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: AutoscalingGroupResource)

instance HasNamePrefix AutoscalingGroupResource Text where
    namePrefix =
        lens (_name_prefix :: AutoscalingGroupResource -> TF.Argument "name_prefix" Text)
             (\s a -> s { _name_prefix = a } :: AutoscalingGroupResource)

instance HasPlacementGroup AutoscalingGroupResource Text where
    placementGroup =
        lens (_placement_group :: AutoscalingGroupResource -> TF.Argument "placement_group" Text)
             (\s a -> s { _placement_group = a } :: AutoscalingGroupResource)

instance HasProtectFromScaleIn AutoscalingGroupResource Text where
    protectFromScaleIn =
        lens (_protect_from_scale_in :: AutoscalingGroupResource -> TF.Argument "protect_from_scale_in" Text)
             (\s a -> s { _protect_from_scale_in = a } :: AutoscalingGroupResource)

instance HasSuspendedProcesses AutoscalingGroupResource Text where
    suspendedProcesses =
        lens (_suspended_processes :: AutoscalingGroupResource -> TF.Argument "suspended_processes" Text)
             (\s a -> s { _suspended_processes = a } :: AutoscalingGroupResource)

instance HasTag AutoscalingGroupResource Text where
    tag =
        lens (_tag :: AutoscalingGroupResource -> TF.Argument "tag" Text)
             (\s a -> s { _tag = a } :: AutoscalingGroupResource)

instance HasTags AutoscalingGroupResource TF.Tags where
    tags =
        lens (_tags :: AutoscalingGroupResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: AutoscalingGroupResource)

instance HasTargetGroupArns AutoscalingGroupResource Text where
    targetGroupArns =
        lens (_target_group_arns :: AutoscalingGroupResource -> TF.Argument "target_group_arns" Text)
             (\s a -> s { _target_group_arns = a } :: AutoscalingGroupResource)

instance HasTerminationPolicies AutoscalingGroupResource Text where
    terminationPolicies =
        lens (_termination_policies :: AutoscalingGroupResource -> TF.Argument "termination_policies" Text)
             (\s a -> s { _termination_policies = a } :: AutoscalingGroupResource)

instance HasVpcZoneIdentifier AutoscalingGroupResource Text where
    vpcZoneIdentifier =
        lens (_vpc_zone_identifier :: AutoscalingGroupResource -> TF.Argument "vpc_zone_identifier" Text)
             (\s a -> s { _vpc_zone_identifier = a } :: AutoscalingGroupResource)

instance HasWaitForCapacityTimeout AutoscalingGroupResource Text where
    waitForCapacityTimeout =
        lens (_wait_for_capacity_timeout :: AutoscalingGroupResource -> TF.Argument "wait_for_capacity_timeout" Text)
             (\s a -> s { _wait_for_capacity_timeout = a } :: AutoscalingGroupResource)

instance HasWaitForElbCapacity AutoscalingGroupResource Text where
    waitForElbCapacity =
        lens (_wait_for_elb_capacity :: AutoscalingGroupResource -> TF.Argument "wait_for_elb_capacity" Text)
             (\s a -> s { _wait_for_elb_capacity = a } :: AutoscalingGroupResource)

instance HasComputedArn AutoscalingGroupResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

instance HasComputedAvailabilityZones AutoscalingGroupResource Text where
    computedAvailabilityZones =
        to (\_  -> TF.Compute "availability_zones")

instance HasComputedDefaultCooldown AutoscalingGroupResource Text where
    computedDefaultCooldown =
        to (\_  -> TF.Compute "default_cooldown")

instance HasComputedDesiredCapacity AutoscalingGroupResource Text where
    computedDesiredCapacity =
        to (\_  -> TF.Compute "desired_capacity")

instance HasComputedHealthCheckGracePeriod AutoscalingGroupResource Text where
    computedHealthCheckGracePeriod =
        to (\_  -> TF.Compute "health_check_grace_period")

instance HasComputedHealthCheckType AutoscalingGroupResource Text where
    computedHealthCheckType =
        to (\_  -> TF.Compute "health_check_type")

instance HasComputedId AutoscalingGroupResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedLaunchConfiguration AutoscalingGroupResource Text where
    computedLaunchConfiguration =
        to (\_  -> TF.Compute "launch_configuration")

instance HasComputedLoadBalancers AutoscalingGroupResource Text where
    computedLoadBalancers =
        to (\_  -> TF.Compute "load_balancers")

instance HasComputedMaxSize AutoscalingGroupResource Text where
    computedMaxSize =
        to (\_  -> TF.Compute "max_size")

instance HasComputedMinSize AutoscalingGroupResource Text where
    computedMinSize =
        to (\_  -> TF.Compute "min_size")

instance HasComputedName AutoscalingGroupResource Text where
    computedName =
        to (\_  -> TF.Compute "name")

instance HasComputedTargetGroupArns AutoscalingGroupResource Text where
    computedTargetGroupArns =
        to (\_  -> TF.Compute "target_group_arns")

instance HasComputedVpcZoneIdentifier AutoscalingGroupResource Text where
    computedVpcZoneIdentifier =
        to (\_  -> TF.Compute "vpc_zone_identifier")

autoscalingGroupResource :: TF.Resource TF.AWS AutoscalingGroupResource
autoscalingGroupResource =
    TF.newResource "aws_autoscaling_group" $
        AutoscalingGroupResource {
            _availability_zones = TF.Nil
            , _default_cooldown = TF.Nil
            , _desired_capacity = TF.Nil
            , _enabled_metrics = TF.Nil
            , _force_delete = TF.Nil
            , _health_check_grace_period = TF.Nil
            , _health_check_type = TF.Nil
            , _initial_lifecycle_hook = TF.Nil
            , _launch_configuration = TF.Nil
            , _load_balancers = TF.Nil
            , _max_size = TF.Nil
            , _metrics_granularity = TF.Nil
            , _min_elb_capacity = TF.Nil
            , _min_size = TF.Nil
            , _name = TF.Nil
            , _name_prefix = TF.Nil
            , _placement_group = TF.Nil
            , _protect_from_scale_in = TF.Nil
            , _suspended_processes = TF.Nil
            , _tag = TF.Nil
            , _tags = TF.Nil
            , _target_group_arns = TF.Nil
            , _termination_policies = TF.Nil
            , _vpc_zone_identifier = TF.Nil
            , _wait_for_capacity_timeout = TF.Nil
            , _wait_for_elb_capacity = TF.Nil
            }

{- | The @aws_autoscaling_lifecycle_hook@ AWS resource.

Provides an AutoScaling Lifecycle Hook resource. ~> NOTE: Terraform has two
types of ways you can add lifecycle hooks - via the @initial_lifecycle_hook@
attribute from the </docs/providers/aws/r/autoscaling_group.html> resource,
or via this one. Hooks added via this resource will not be added until the
autoscaling group has been created, and depending on your
</docs/providers/aws/r/autoscaling_group.html#waiting-for-capacity>
settings, after the initial instances have been launched, creating
unintended behavior. If you need hooks to run on all instances, add them
with @initial_lifecycle_hook@ in
</docs/providers/aws/r/autoscaling_group.html> , but take care to not
duplicate those hooks with this resource.
-}
data AutoscalingLifecycleHookResource = AutoscalingLifecycleHookResource {
      _autoscaling_group_name :: !(TF.Argument "autoscaling_group_name" Text)
    {- ^ (Required) The name of the Auto Scaling group to which you want to assign the lifecycle hook -}
    , _default_result :: !(TF.Argument "default_result" Text)
    {- ^ (Optional) Defines the action the Auto Scaling group should take when the lifecycle hook timeout elapses or if an unexpected failure occurs. The value for this parameter can be either CONTINUE or ABANDON. The default value for this parameter is ABANDON. -}
    , _heartbeat_timeout :: !(TF.Argument "heartbeat_timeout" Text)
    {- ^ (Optional) Defines the amount of time, in seconds, that can elapse before the lifecycle hook times out. When the lifecycle hook times out, Auto Scaling performs the action defined in the DefaultResult parameter -}
    , _lifecycle_transition :: !(TF.Argument "lifecycle_transition" Text)
    {- ^ (Required) The instance state to which you want to attach the lifecycle hook. For a list of lifecycle hook types, see <https://docs.aws.amazon.com/cli/latest/reference/autoscaling/describe-lifecycle-hook-types.html#examples> -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the lifecycle hook. -}
    , _notification_metadata :: !(TF.Argument "notification_metadata" Text)
    {- ^ (Optional) Contains additional information that you want to include any time Auto Scaling sends a message to the notification target. -}
    , _notification_target_arn :: !(TF.Argument "notification_target_arn" Text)
    {- ^ (Optional) The ARN of the notification target that Auto Scaling will use to notify you when an instance is in the transition state for the lifecycle hook. This ARN target can be either an SQS queue or an SNS topic. -}
    , _role_arn :: !(TF.Argument "role_arn" Text)
    {- ^ (Optional) The ARN of the IAM role that allows the Auto Scaling group to publish to the specified notification target. -}
    } deriving (Show, Eq)

instance TF.ToHCL AutoscalingLifecycleHookResource where
    toHCL AutoscalingLifecycleHookResource{..} = TF.block $ catMaybes
        [ TF.argument _autoscaling_group_name
        , TF.argument _default_result
        , TF.argument _heartbeat_timeout
        , TF.argument _lifecycle_transition
        , TF.argument _name
        , TF.argument _notification_metadata
        , TF.argument _notification_target_arn
        , TF.argument _role_arn
        ]

instance HasAutoscalingGroupName AutoscalingLifecycleHookResource Text where
    autoscalingGroupName =
        lens (_autoscaling_group_name :: AutoscalingLifecycleHookResource -> TF.Argument "autoscaling_group_name" Text)
             (\s a -> s { _autoscaling_group_name = a } :: AutoscalingLifecycleHookResource)

instance HasDefaultResult AutoscalingLifecycleHookResource Text where
    defaultResult =
        lens (_default_result :: AutoscalingLifecycleHookResource -> TF.Argument "default_result" Text)
             (\s a -> s { _default_result = a } :: AutoscalingLifecycleHookResource)

instance HasHeartbeatTimeout AutoscalingLifecycleHookResource Text where
    heartbeatTimeout =
        lens (_heartbeat_timeout :: AutoscalingLifecycleHookResource -> TF.Argument "heartbeat_timeout" Text)
             (\s a -> s { _heartbeat_timeout = a } :: AutoscalingLifecycleHookResource)

instance HasLifecycleTransition AutoscalingLifecycleHookResource Text where
    lifecycleTransition =
        lens (_lifecycle_transition :: AutoscalingLifecycleHookResource -> TF.Argument "lifecycle_transition" Text)
             (\s a -> s { _lifecycle_transition = a } :: AutoscalingLifecycleHookResource)

instance HasName AutoscalingLifecycleHookResource Text where
    name =
        lens (_name :: AutoscalingLifecycleHookResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: AutoscalingLifecycleHookResource)

instance HasNotificationMetadata AutoscalingLifecycleHookResource Text where
    notificationMetadata =
        lens (_notification_metadata :: AutoscalingLifecycleHookResource -> TF.Argument "notification_metadata" Text)
             (\s a -> s { _notification_metadata = a } :: AutoscalingLifecycleHookResource)

instance HasNotificationTargetArn AutoscalingLifecycleHookResource Text where
    notificationTargetArn =
        lens (_notification_target_arn :: AutoscalingLifecycleHookResource -> TF.Argument "notification_target_arn" Text)
             (\s a -> s { _notification_target_arn = a } :: AutoscalingLifecycleHookResource)

instance HasRoleArn AutoscalingLifecycleHookResource Text where
    roleArn =
        lens (_role_arn :: AutoscalingLifecycleHookResource -> TF.Argument "role_arn" Text)
             (\s a -> s { _role_arn = a } :: AutoscalingLifecycleHookResource)

autoscalingLifecycleHookResource :: TF.Resource TF.AWS AutoscalingLifecycleHookResource
autoscalingLifecycleHookResource =
    TF.newResource "aws_autoscaling_lifecycle_hook" $
        AutoscalingLifecycleHookResource {
            _autoscaling_group_name = TF.Nil
            , _default_result = TF.Nil
            , _heartbeat_timeout = TF.Nil
            , _lifecycle_transition = TF.Nil
            , _name = TF.Nil
            , _notification_metadata = TF.Nil
            , _notification_target_arn = TF.Nil
            , _role_arn = TF.Nil
            }

{- | The @aws_autoscaling_notification@ AWS resource.

Provides an AutoScaling Group with Notification support, via SNS Topics.
Each of the @notifications@ map to a
<https://docs.aws.amazon.com/AutoScaling/latest/APIReference/API_DescribeNotificationConfigurations.html>
inside Amazon Web Services, and are applied to each AutoScaling Group you
supply.
-}
data AutoscalingNotificationResource = AutoscalingNotificationResource {
      _group_names :: !(TF.Argument "group_names" Text)
    {- ^ (Required) A list of AutoScaling Group Names -}
    , _notifications :: !(TF.Argument "notifications" Text)
    {- ^ (Required) A list of Notification Types that trigger notifications. Acceptable values are documented <https://docs.aws.amazon.com/AutoScaling/latest/APIReference/API_NotificationConfiguration.html> -}
    , _topic_arn :: !(TF.Argument "topic_arn" Text)
    {- ^ (Required) The Topic ARN for notifications to be sent through -}
    } deriving (Show, Eq)

instance TF.ToHCL AutoscalingNotificationResource where
    toHCL AutoscalingNotificationResource{..} = TF.block $ catMaybes
        [ TF.argument _group_names
        , TF.argument _notifications
        , TF.argument _topic_arn
        ]

instance HasGroupNames AutoscalingNotificationResource Text where
    groupNames =
        lens (_group_names :: AutoscalingNotificationResource -> TF.Argument "group_names" Text)
             (\s a -> s { _group_names = a } :: AutoscalingNotificationResource)

instance HasNotifications AutoscalingNotificationResource Text where
    notifications =
        lens (_notifications :: AutoscalingNotificationResource -> TF.Argument "notifications" Text)
             (\s a -> s { _notifications = a } :: AutoscalingNotificationResource)

instance HasTopicArn AutoscalingNotificationResource Text where
    topicArn =
        lens (_topic_arn :: AutoscalingNotificationResource -> TF.Argument "topic_arn" Text)
             (\s a -> s { _topic_arn = a } :: AutoscalingNotificationResource)

autoscalingNotificationResource :: TF.Resource TF.AWS AutoscalingNotificationResource
autoscalingNotificationResource =
    TF.newResource "aws_autoscaling_notification" $
        AutoscalingNotificationResource {
            _group_names = TF.Nil
            , _notifications = TF.Nil
            , _topic_arn = TF.Nil
            }

{- | The @aws_autoscaling_policy@ AWS resource.

Provides an AutoScaling Scaling Policy resource. ~> NOTE: You may want to
omit @desired_capacity@ attribute from attached @aws_autoscaling_group@ when
using autoscaling policies. It's good practice to pick either
<https://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/as-manual-scaling.html>
or
<https://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/as-scale-based-on-demand.html>
(policy-based) scaling.
-}
data AutoscalingPolicyResource = AutoscalingPolicyResource {
      _adjustment_type :: !(TF.Argument "adjustment_type" Text)
    {- ^ (Required) Specifies whether the adjustment is an absolute number or a percentage of the current capacity. Valid values are @ChangeInCapacity@ , @ExactCapacity@ , and @PercentChangeInCapacity@ . -}
    , _autoscaling_group_name :: !(TF.Argument "autoscaling_group_name" Text)
    {- ^ (Required) The name of the autoscaling group. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the policy. -}
    , _policy_type :: !(TF.Argument "policy_type" Text)
    {- ^ (Optional) The policy type, either "SimpleScaling" or "StepScaling". If this value isn't provided, AWS will default to "SimpleScaling." -}
    } deriving (Show, Eq)

instance TF.ToHCL AutoscalingPolicyResource where
    toHCL AutoscalingPolicyResource{..} = TF.block $ catMaybes
        [ TF.argument _adjustment_type
        , TF.argument _autoscaling_group_name
        , TF.argument _name
        , TF.argument _policy_type
        ]

instance HasAdjustmentType AutoscalingPolicyResource Text where
    adjustmentType =
        lens (_adjustment_type :: AutoscalingPolicyResource -> TF.Argument "adjustment_type" Text)
             (\s a -> s { _adjustment_type = a } :: AutoscalingPolicyResource)

instance HasAutoscalingGroupName AutoscalingPolicyResource Text where
    autoscalingGroupName =
        lens (_autoscaling_group_name :: AutoscalingPolicyResource -> TF.Argument "autoscaling_group_name" Text)
             (\s a -> s { _autoscaling_group_name = a } :: AutoscalingPolicyResource)

instance HasName AutoscalingPolicyResource Text where
    name =
        lens (_name :: AutoscalingPolicyResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: AutoscalingPolicyResource)

instance HasPolicyType AutoscalingPolicyResource Text where
    policyType =
        lens (_policy_type :: AutoscalingPolicyResource -> TF.Argument "policy_type" Text)
             (\s a -> s { _policy_type = a } :: AutoscalingPolicyResource)

instance HasComputedAdjustmentType AutoscalingPolicyResource Text where
    computedAdjustmentType =
        to (\_  -> TF.Compute "adjustment_type")

instance HasComputedArn AutoscalingPolicyResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

instance HasComputedAutoscalingGroupName AutoscalingPolicyResource Text where
    computedAutoscalingGroupName =
        to (\_  -> TF.Compute "autoscaling_group_name")

instance HasComputedName AutoscalingPolicyResource Text where
    computedName =
        to (\_  -> TF.Compute "name")

instance HasComputedPolicyType AutoscalingPolicyResource Text where
    computedPolicyType =
        to (\_  -> TF.Compute "policy_type")

autoscalingPolicyResource :: TF.Resource TF.AWS AutoscalingPolicyResource
autoscalingPolicyResource =
    TF.newResource "aws_autoscaling_policy" $
        AutoscalingPolicyResource {
            _adjustment_type = TF.Nil
            , _autoscaling_group_name = TF.Nil
            , _name = TF.Nil
            , _policy_type = TF.Nil
            }

{- | The @aws_autoscaling_schedule@ AWS resource.

Provides an AutoScaling Schedule resource.
-}
data AutoscalingScheduleResource = AutoscalingScheduleResource {
      _autoscaling_group_name :: !(TF.Argument "autoscaling_group_name" Text)
    {- ^ (Required) The name or Amazon Resource Name (ARN) of the Auto Scaling group. -}
    , _desired_capacity :: !(TF.Argument "desired_capacity" Text)
    {- ^ (Optional) The number of EC2 instances that should be running in the group. Default 0.  Set to -1 if you don't want to change the desired capacity at the scheduled time. -}
    , _end_time :: !(TF.Argument "end_time" Text)
    {- ^ (Optional) The time for this action to end, in "YYYY-MM-DDThh:mm:ssZ" format in UTC/GMT only (for example, 2014-06-01T00:00:00Z ). If you try to schedule your action in the past, Auto Scaling returns an error message. -}
    , _max_size :: !(TF.Argument "max_size" Text)
    {- ^ (Optional) The maximum size for the Auto Scaling group. Default 0. Set to -1 if you don't want to change the maximum size at the scheduled time. -}
    , _min_size :: !(TF.Argument "min_size" Text)
    {- ^ (Optional) The minimum size for the Auto Scaling group. Default 0. Set to -1 if you don't want to change the minimum size at the scheduled time. -}
    , _recurrence :: !(TF.Argument "recurrence" Text)
    {- ^ (Optional) The time when recurring future actions will start. Start time is specified by the user following the Unix cron syntax format. -}
    , _scheduled_action_name :: !(TF.Argument "scheduled_action_name" Text)
    {- ^ (Required) The name of this scaling action. -}
    , _start_time :: !(TF.Argument "start_time" Text)
    {- ^ (Optional) The time for this action to start, in "YYYY-MM-DDThh:mm:ssZ" format in UTC/GMT only (for example, 2014-06-01T00:00:00Z ). If you try to schedule your action in the past, Auto Scaling returns an error message. -}
    } deriving (Show, Eq)

instance TF.ToHCL AutoscalingScheduleResource where
    toHCL AutoscalingScheduleResource{..} = TF.block $ catMaybes
        [ TF.argument _autoscaling_group_name
        , TF.argument _desired_capacity
        , TF.argument _end_time
        , TF.argument _max_size
        , TF.argument _min_size
        , TF.argument _recurrence
        , TF.argument _scheduled_action_name
        , TF.argument _start_time
        ]

instance HasAutoscalingGroupName AutoscalingScheduleResource Text where
    autoscalingGroupName =
        lens (_autoscaling_group_name :: AutoscalingScheduleResource -> TF.Argument "autoscaling_group_name" Text)
             (\s a -> s { _autoscaling_group_name = a } :: AutoscalingScheduleResource)

instance HasDesiredCapacity AutoscalingScheduleResource Text where
    desiredCapacity =
        lens (_desired_capacity :: AutoscalingScheduleResource -> TF.Argument "desired_capacity" Text)
             (\s a -> s { _desired_capacity = a } :: AutoscalingScheduleResource)

instance HasEndTime AutoscalingScheduleResource Text where
    endTime =
        lens (_end_time :: AutoscalingScheduleResource -> TF.Argument "end_time" Text)
             (\s a -> s { _end_time = a } :: AutoscalingScheduleResource)

instance HasMaxSize AutoscalingScheduleResource Text where
    maxSize =
        lens (_max_size :: AutoscalingScheduleResource -> TF.Argument "max_size" Text)
             (\s a -> s { _max_size = a } :: AutoscalingScheduleResource)

instance HasMinSize AutoscalingScheduleResource Text where
    minSize =
        lens (_min_size :: AutoscalingScheduleResource -> TF.Argument "min_size" Text)
             (\s a -> s { _min_size = a } :: AutoscalingScheduleResource)

instance HasRecurrence AutoscalingScheduleResource Text where
    recurrence =
        lens (_recurrence :: AutoscalingScheduleResource -> TF.Argument "recurrence" Text)
             (\s a -> s { _recurrence = a } :: AutoscalingScheduleResource)

instance HasScheduledActionName AutoscalingScheduleResource Text where
    scheduledActionName =
        lens (_scheduled_action_name :: AutoscalingScheduleResource -> TF.Argument "scheduled_action_name" Text)
             (\s a -> s { _scheduled_action_name = a } :: AutoscalingScheduleResource)

instance HasStartTime AutoscalingScheduleResource Text where
    startTime =
        lens (_start_time :: AutoscalingScheduleResource -> TF.Argument "start_time" Text)
             (\s a -> s { _start_time = a } :: AutoscalingScheduleResource)

instance HasComputedArn AutoscalingScheduleResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

autoscalingScheduleResource :: TF.Resource TF.AWS AutoscalingScheduleResource
autoscalingScheduleResource =
    TF.newResource "aws_autoscaling_schedule" $
        AutoscalingScheduleResource {
            _autoscaling_group_name = TF.Nil
            , _desired_capacity = TF.Nil
            , _end_time = TF.Nil
            , _max_size = TF.Nil
            , _min_size = TF.Nil
            , _recurrence = TF.Nil
            , _scheduled_action_name = TF.Nil
            , _start_time = TF.Nil
            }

{- | The @aws_batch_compute_environment@ AWS resource.

Creates a AWS Batch compute environment. Compute environments contain the
Amazon ECS container instances that are used to run containerized batch
jobs. For information about AWS Batch, see
<http://docs.aws.amazon.com/batch/latest/userguide/what-is-batch.html> . For
information about compute environment, see
<http://docs.aws.amazon.com/batch/latest/userguide/compute_environments.html>
. ~> Note: To prevent a race condition during environment deletion, make
sure to set @depends_on@ to the related @aws_iam_role_policy_attachment@ ;
otherwise, the policy may be destroyed too soon and the compute environment
will then get stuck in the @DELETING@ state, see
<http://docs.aws.amazon.com/batch/latest/userguide/troubleshooting.html> .
-}
data BatchComputeEnvironmentResource = BatchComputeEnvironmentResource {
      _compute_environment_name :: !(TF.Argument "compute_environment_name" Text)
    {- ^ (Required) The name for your compute environment. Up to 128 letters (uppercase and lowercase), numbers, and underscores are allowed. -}
    , _compute_resources :: !(TF.Argument "compute_resources" Text)
    {- ^ (Optional) Details of the compute resources managed by the compute environment. This parameter is required for managed compute environments. See details below. -}
    , _service_role :: !(TF.Argument "service_role" Text)
    {- ^ (Required) The full Amazon Resource Name (ARN) of the IAM role that allows AWS Batch to make calls to other AWS services on your behalf. -}
    , _state :: !(TF.Argument "state" Text)
    {- ^ (Optional) The state of the compute environment. If the state is @ENABLED@ , then the compute environment accepts jobs from a queue and can scale out automatically based on queues. Valid items are @ENABLED@ or @DISABLED@ . Defaults to @ENABLED@ . -}
    , _type' :: !(TF.Argument "type" Text)
    {- ^ (Required) The type of the compute environment. Valid items are @MANAGED@ or @UNMANAGED@ . -}
    } deriving (Show, Eq)

instance TF.ToHCL BatchComputeEnvironmentResource where
    toHCL BatchComputeEnvironmentResource{..} = TF.block $ catMaybes
        [ TF.argument _compute_environment_name
        , TF.argument _compute_resources
        , TF.argument _service_role
        , TF.argument _state
        , TF.argument _type'
        ]

instance HasComputeEnvironmentName BatchComputeEnvironmentResource Text where
    computeEnvironmentName =
        lens (_compute_environment_name :: BatchComputeEnvironmentResource -> TF.Argument "compute_environment_name" Text)
             (\s a -> s { _compute_environment_name = a } :: BatchComputeEnvironmentResource)

instance HasComputeResources BatchComputeEnvironmentResource Text where
    computeResources =
        lens (_compute_resources :: BatchComputeEnvironmentResource -> TF.Argument "compute_resources" Text)
             (\s a -> s { _compute_resources = a } :: BatchComputeEnvironmentResource)

instance HasServiceRole BatchComputeEnvironmentResource Text where
    serviceRole =
        lens (_service_role :: BatchComputeEnvironmentResource -> TF.Argument "service_role" Text)
             (\s a -> s { _service_role = a } :: BatchComputeEnvironmentResource)

instance HasState BatchComputeEnvironmentResource Text where
    state =
        lens (_state :: BatchComputeEnvironmentResource -> TF.Argument "state" Text)
             (\s a -> s { _state = a } :: BatchComputeEnvironmentResource)

instance HasType' BatchComputeEnvironmentResource Text where
    type' =
        lens (_type' :: BatchComputeEnvironmentResource -> TF.Argument "type" Text)
             (\s a -> s { _type' = a } :: BatchComputeEnvironmentResource)

instance HasComputedArn BatchComputeEnvironmentResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

instance HasComputedEcsClusterArn BatchComputeEnvironmentResource Text where
    computedEcsClusterArn =
        to (\_  -> TF.Compute "ecs_cluster_arn")

instance HasComputedStatus BatchComputeEnvironmentResource Text where
    computedStatus =
        to (\_  -> TF.Compute "status")

instance HasComputedStatusReason BatchComputeEnvironmentResource Text where
    computedStatusReason =
        to (\_  -> TF.Compute "status_reason")

batchComputeEnvironmentResource :: TF.Resource TF.AWS BatchComputeEnvironmentResource
batchComputeEnvironmentResource =
    TF.newResource "aws_batch_compute_environment" $
        BatchComputeEnvironmentResource {
            _compute_environment_name = TF.Nil
            , _compute_resources = TF.Nil
            , _service_role = TF.Nil
            , _state = TF.Nil
            , _type' = TF.Nil
            }

{- | The @aws_batch_job_definition@ AWS resource.

Provides a Batch Job Definition resource.
-}
data BatchJobDefinitionResource = BatchJobDefinitionResource {
      _container_properties :: !(TF.Argument "container_properties" Text)
    {- ^ (Optional) A valid <http://docs.aws.amazon.com/batch/latest/APIReference/API_RegisterJobDefinition.html> provided as a single valid JSON document. This parameter is required if the @type@ parameter is @container@ . -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) Specifies the name of the job definition. -}
    , _parameters :: !(TF.Argument "parameters" Text)
    {- ^ (Optional) Specifies the parameter substitution placeholders to set in the job definition. -}
    , _retry_strategy :: !(TF.Argument "retry_strategy" Text)
    {- ^ (Optional) Specifies the retry strategy to use for failed jobs that are submitted with this job definition. Maximum number of @retry_strategy@ is @1@ .  Defined below. -}
    , _type' :: !(TF.Argument "type" Text)
    {- ^ (Required) The type of job definition.  Must be @container@ -}
    } deriving (Show, Eq)

instance TF.ToHCL BatchJobDefinitionResource where
    toHCL BatchJobDefinitionResource{..} = TF.block $ catMaybes
        [ TF.argument _container_properties
        , TF.argument _name
        , TF.argument _parameters
        , TF.argument _retry_strategy
        , TF.argument _type'
        ]

instance HasContainerProperties BatchJobDefinitionResource Text where
    containerProperties =
        lens (_container_properties :: BatchJobDefinitionResource -> TF.Argument "container_properties" Text)
             (\s a -> s { _container_properties = a } :: BatchJobDefinitionResource)

instance HasName BatchJobDefinitionResource Text where
    name =
        lens (_name :: BatchJobDefinitionResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: BatchJobDefinitionResource)

instance HasParameters BatchJobDefinitionResource Text where
    parameters =
        lens (_parameters :: BatchJobDefinitionResource -> TF.Argument "parameters" Text)
             (\s a -> s { _parameters = a } :: BatchJobDefinitionResource)

instance HasRetryStrategy BatchJobDefinitionResource Text where
    retryStrategy =
        lens (_retry_strategy :: BatchJobDefinitionResource -> TF.Argument "retry_strategy" Text)
             (\s a -> s { _retry_strategy = a } :: BatchJobDefinitionResource)

instance HasType' BatchJobDefinitionResource Text where
    type' =
        lens (_type' :: BatchJobDefinitionResource -> TF.Argument "type" Text)
             (\s a -> s { _type' = a } :: BatchJobDefinitionResource)

batchJobDefinitionResource :: TF.Resource TF.AWS BatchJobDefinitionResource
batchJobDefinitionResource =
    TF.newResource "aws_batch_job_definition" $
        BatchJobDefinitionResource {
            _container_properties = TF.Nil
            , _name = TF.Nil
            , _parameters = TF.Nil
            , _retry_strategy = TF.Nil
            , _type' = TF.Nil
            }

{- | The @aws_batch_job_queue@ AWS resource.

Provides a Batch Job Queue resource.
-}
data BatchJobQueueResource = BatchJobQueueResource {
      _compute_environments :: !(TF.Argument "compute_environments" Text)
    {- ^ (Required) Specifies the set of compute environments mapped to a job queue and their order.  The position of the compute environments in the list will dictate the order. You can associate up to 3 compute environments with a job queue. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) Specifies the name of the job queue. -}
    , _priority :: !(TF.Argument "priority" Text)
    {- ^ (Required) The priority of the job queue. Job queues with a higher priority are evaluated first when associated with same compute environment. -}
    , _state :: !(TF.Argument "state" Text)
    {- ^ (Required) The state of the job queue. Must be one of: @ENABLED@ or @DISABLED@ -}
    } deriving (Show, Eq)

instance TF.ToHCL BatchJobQueueResource where
    toHCL BatchJobQueueResource{..} = TF.block $ catMaybes
        [ TF.argument _compute_environments
        , TF.argument _name
        , TF.argument _priority
        , TF.argument _state
        ]

instance HasComputeEnvironments BatchJobQueueResource Text where
    computeEnvironments =
        lens (_compute_environments :: BatchJobQueueResource -> TF.Argument "compute_environments" Text)
             (\s a -> s { _compute_environments = a } :: BatchJobQueueResource)

instance HasName BatchJobQueueResource Text where
    name =
        lens (_name :: BatchJobQueueResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: BatchJobQueueResource)

instance HasPriority BatchJobQueueResource Text where
    priority =
        lens (_priority :: BatchJobQueueResource -> TF.Argument "priority" Text)
             (\s a -> s { _priority = a } :: BatchJobQueueResource)

instance HasState BatchJobQueueResource Text where
    state =
        lens (_state :: BatchJobQueueResource -> TF.Argument "state" Text)
             (\s a -> s { _state = a } :: BatchJobQueueResource)

instance HasComputedArn BatchJobQueueResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

batchJobQueueResource :: TF.Resource TF.AWS BatchJobQueueResource
batchJobQueueResource =
    TF.newResource "aws_batch_job_queue" $
        BatchJobQueueResource {
            _compute_environments = TF.Nil
            , _name = TF.Nil
            , _priority = TF.Nil
            , _state = TF.Nil
            }

{- | The @aws_cloudformation_stack@ AWS resource.

Provides a CloudFormation Stack resource.
-}
data CloudformationStackResource = CloudformationStackResource {
      _capabilities :: !(TF.Argument "capabilities" Text)
    {- ^ (Optional) A list of capabilities. Valid values: @CAPABILITY_IAM@ or @CAPABILITY_NAMED_IAM@ -}
    , _disable_rollback :: !(TF.Argument "disable_rollback" Text)
    {- ^ (Optional) Set to true to disable rollback of the stack if stack creation failed. Conflicts with @on_failure@ . -}
    , _iam_role_arn :: !(TF.Argument "iam_role_arn" Text)
    {- ^ (Optional) The ARN of an IAM role that AWS CloudFormation assumes to create the stack. If you don't specify a value, AWS CloudFormation uses the role that was previously associated with the stack. If no role is available, AWS CloudFormation uses a temporary session that is generated from your user credentials. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) Stack name. -}
    , _notification_arns :: !(TF.Argument "notification_arns" Text)
    {- ^ (Optional) A list of SNS topic ARNs to publish stack related events. -}
    , _on_failure :: !(TF.Argument "on_failure" Text)
    {- ^ (Optional) Action to be taken if stack creation fails. This must be one of: @DO_NOTHING@ , @ROLLBACK@ , or @DELETE@ . Conflicts with @disable_rollback@ . -}
    , _parameters :: !(TF.Argument "parameters" Text)
    {- ^ (Optional) A list of Parameter structures that specify input parameters for the stack. -}
    , _policy_body :: !(TF.Argument "policy_body" Text)
    {- ^ (Optional) Structure containing the stack policy body. Conflicts w/ @policy_url@ . -}
    , _policy_url :: !(TF.Argument "policy_url" Text)
    {- ^ (Optional) Location of a file containing the stack policy. Conflicts w/ @policy_body@ . -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A list of tags to associate with this stack. -}
    , _template_body :: !(TF.Argument "template_body" Text)
    {- ^ (Optional) Structure containing the template body (max size: 51,200 bytes). -}
    , _template_url :: !(TF.Argument "template_url" Text)
    {- ^ (Optional) Location of a file containing the template body (max size: 460,800 bytes). -}
    , _timeout_in_minutes :: !(TF.Argument "timeout_in_minutes" Text)
    {- ^ (Optional) The amount of time that can pass before the stack status becomes @CREATE_FAILED@ . -}
    } deriving (Show, Eq)

instance TF.ToHCL CloudformationStackResource where
    toHCL CloudformationStackResource{..} = TF.block $ catMaybes
        [ TF.argument _capabilities
        , TF.argument _disable_rollback
        , TF.argument _iam_role_arn
        , TF.argument _name
        , TF.argument _notification_arns
        , TF.argument _on_failure
        , TF.argument _parameters
        , TF.argument _policy_body
        , TF.argument _policy_url
        , TF.argument _tags
        , TF.argument _template_body
        , TF.argument _template_url
        , TF.argument _timeout_in_minutes
        ]

instance HasCapabilities CloudformationStackResource Text where
    capabilities =
        lens (_capabilities :: CloudformationStackResource -> TF.Argument "capabilities" Text)
             (\s a -> s { _capabilities = a } :: CloudformationStackResource)

instance HasDisableRollback CloudformationStackResource Text where
    disableRollback =
        lens (_disable_rollback :: CloudformationStackResource -> TF.Argument "disable_rollback" Text)
             (\s a -> s { _disable_rollback = a } :: CloudformationStackResource)

instance HasIamRoleArn CloudformationStackResource Text where
    iamRoleArn =
        lens (_iam_role_arn :: CloudformationStackResource -> TF.Argument "iam_role_arn" Text)
             (\s a -> s { _iam_role_arn = a } :: CloudformationStackResource)

instance HasName CloudformationStackResource Text where
    name =
        lens (_name :: CloudformationStackResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: CloudformationStackResource)

instance HasNotificationArns CloudformationStackResource Text where
    notificationArns =
        lens (_notification_arns :: CloudformationStackResource -> TF.Argument "notification_arns" Text)
             (\s a -> s { _notification_arns = a } :: CloudformationStackResource)

instance HasOnFailure CloudformationStackResource Text where
    onFailure =
        lens (_on_failure :: CloudformationStackResource -> TF.Argument "on_failure" Text)
             (\s a -> s { _on_failure = a } :: CloudformationStackResource)

instance HasParameters CloudformationStackResource Text where
    parameters =
        lens (_parameters :: CloudformationStackResource -> TF.Argument "parameters" Text)
             (\s a -> s { _parameters = a } :: CloudformationStackResource)

instance HasPolicyBody CloudformationStackResource Text where
    policyBody =
        lens (_policy_body :: CloudformationStackResource -> TF.Argument "policy_body" Text)
             (\s a -> s { _policy_body = a } :: CloudformationStackResource)

instance HasPolicyUrl CloudformationStackResource Text where
    policyUrl =
        lens (_policy_url :: CloudformationStackResource -> TF.Argument "policy_url" Text)
             (\s a -> s { _policy_url = a } :: CloudformationStackResource)

instance HasTags CloudformationStackResource TF.Tags where
    tags =
        lens (_tags :: CloudformationStackResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: CloudformationStackResource)

instance HasTemplateBody CloudformationStackResource Text where
    templateBody =
        lens (_template_body :: CloudformationStackResource -> TF.Argument "template_body" Text)
             (\s a -> s { _template_body = a } :: CloudformationStackResource)

instance HasTemplateUrl CloudformationStackResource Text where
    templateUrl =
        lens (_template_url :: CloudformationStackResource -> TF.Argument "template_url" Text)
             (\s a -> s { _template_url = a } :: CloudformationStackResource)

instance HasTimeoutInMinutes CloudformationStackResource Text where
    timeoutInMinutes =
        lens (_timeout_in_minutes :: CloudformationStackResource -> TF.Argument "timeout_in_minutes" Text)
             (\s a -> s { _timeout_in_minutes = a } :: CloudformationStackResource)

instance HasComputedId CloudformationStackResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedOutputs CloudformationStackResource Text where
    computedOutputs =
        to (\_  -> TF.Compute "outputs")

cloudformationStackResource :: TF.Resource TF.AWS CloudformationStackResource
cloudformationStackResource =
    TF.newResource "aws_cloudformation_stack" $
        CloudformationStackResource {
            _capabilities = TF.Nil
            , _disable_rollback = TF.Nil
            , _iam_role_arn = TF.Nil
            , _name = TF.Nil
            , _notification_arns = TF.Nil
            , _on_failure = TF.Nil
            , _parameters = TF.Nil
            , _policy_body = TF.Nil
            , _policy_url = TF.Nil
            , _tags = TF.Nil
            , _template_body = TF.Nil
            , _template_url = TF.Nil
            , _timeout_in_minutes = TF.Nil
            }

{- | The @aws_cloudfront_distribution@ AWS resource.

Creates an Amazon CloudFront web distribution. For information about
CloudFront distributions, see the
<http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Introduction.html>
. For specific information about creating CloudFront web distributions, see
the
<http://docs.aws.amazon.com/AmazonCloudFront/latest/APIReference/CreateDistribution.html>
page in the Amazon CloudFront API Reference. ~> NOTE: CloudFront
distributions take about 15 minutes to a deployed state after creation or
modification. During this time, deletes to resources will be blocked. If you
need to delete a distribution that is enabled and you do not want to wait,
you need to use the @retain_on_delete@ flag.
-}
data CloudfrontDistributionResource = CloudfrontDistributionResource {
      _aliases :: !(TF.Argument "aliases" Text)
    {- ^ (Optional) - Extra CNAMEs (alternate domain names), if any, for this distribution. -}
    , _cache_behavior :: !(TF.Argument "cache_behavior" Text)
    {- ^ (Optional) - A <#cache-behavior-arguments> resource for this distribution (multiples allowed). -}
    , _comment :: !(TF.Argument "comment" Text)
    {- ^ (Optional) - Any comments you want to include about the distribution. -}
    , _custom_error_response :: !(TF.Argument "custom_error_response" Text)
    {- ^ (Optional) - One or more <#custom-error-response-arguments> elements (multiples allowed). -}
    , _default_cache_behavior :: !(TF.Argument "default_cache_behavior" Text)
    {- ^ (Required) - The <#default-cache-behavior-arguments> for this distribution (maximum one). -}
    , _default_root_object :: !(TF.Argument "default_root_object" Text)
    {- ^ (Optional) - The object that you want CloudFront to return (for example, index.html) when an end user requests the root URL. -}
    , _enabled :: !(TF.Argument "enabled" TF.Bool)
    {- ^ (Required) - Whether the distribution is enabled to accept end user requests for content. -}
    , _http_version :: !(TF.Argument "http_version" Text)
    {- ^ (Optional) - The maximum HTTP version to support on the distribution. Allowed values are @http1.1@ and @http2@ . The default is @http2@ . -}
    , _is_ipv6_enabled :: !(TF.Argument "is_ipv6_enabled" TF.Bool)
    {- ^ (Optional) - Whether the IPv6 is enabled for the distribution. -}
    , _logging_config :: !(TF.Argument "logging_config" Text)
    {- ^ (Optional) - The <#logging-config-arguments> that controls how logs are written to your distribution (maximum one). -}
    , _origin :: !(TF.Argument "origin" Text)
    {- ^ (Required) - One or more <#origin-arguments> for this distribution (multiples allowed). -}
    , _price_class :: !(TF.Argument "price_class" Text)
    {- ^ (Optional) - The price class for this distribution. One of @PriceClass_All@ , @PriceClass_200@ , @PriceClass_100@ -}
    , _restrictions :: !(TF.Argument "restrictions" Text)
    {- ^ (Required) - The <#restrictions-arguments> for this distribution (maximum one). -}
    , _retain_on_delete :: !(TF.Argument "retain_on_delete" Text)
    {- ^ (Optional) - Disables the distribution instead of deleting it when destroying the resource through Terraform. If this is set, the distribution needs to be deleted manually afterwards. Default: @false@ . -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    , _viewer_certificate :: !(TF.Argument "viewer_certificate" Text)
    {- ^ (Required) - The <#viewer-certificate-arguments> for this distribution (maximum one). -}
    , _web_acl_id :: !(TF.Argument "web_acl_id" Text)
    {- ^ (Optional) - If you're using AWS WAF to filter CloudFront requests, the Id of the AWS WAF web ACL that is associated with the distribution. -}
    } deriving (Show, Eq)

instance TF.ToHCL CloudfrontDistributionResource where
    toHCL CloudfrontDistributionResource{..} = TF.block $ catMaybes
        [ TF.argument _aliases
        , TF.argument _cache_behavior
        , TF.argument _comment
        , TF.argument _custom_error_response
        , TF.argument _default_cache_behavior
        , TF.argument _default_root_object
        , TF.argument _enabled
        , TF.argument _http_version
        , TF.argument _is_ipv6_enabled
        , TF.argument _logging_config
        , TF.argument _origin
        , TF.argument _price_class
        , TF.argument _restrictions
        , TF.argument _retain_on_delete
        , TF.argument _tags
        , TF.argument _viewer_certificate
        , TF.argument _web_acl_id
        ]

instance HasAliases CloudfrontDistributionResource Text where
    aliases =
        lens (_aliases :: CloudfrontDistributionResource -> TF.Argument "aliases" Text)
             (\s a -> s { _aliases = a } :: CloudfrontDistributionResource)

instance HasCacheBehavior CloudfrontDistributionResource Text where
    cacheBehavior =
        lens (_cache_behavior :: CloudfrontDistributionResource -> TF.Argument "cache_behavior" Text)
             (\s a -> s { _cache_behavior = a } :: CloudfrontDistributionResource)

instance HasComment CloudfrontDistributionResource Text where
    comment =
        lens (_comment :: CloudfrontDistributionResource -> TF.Argument "comment" Text)
             (\s a -> s { _comment = a } :: CloudfrontDistributionResource)

instance HasCustomErrorResponse CloudfrontDistributionResource Text where
    customErrorResponse =
        lens (_custom_error_response :: CloudfrontDistributionResource -> TF.Argument "custom_error_response" Text)
             (\s a -> s { _custom_error_response = a } :: CloudfrontDistributionResource)

instance HasDefaultCacheBehavior CloudfrontDistributionResource Text where
    defaultCacheBehavior =
        lens (_default_cache_behavior :: CloudfrontDistributionResource -> TF.Argument "default_cache_behavior" Text)
             (\s a -> s { _default_cache_behavior = a } :: CloudfrontDistributionResource)

instance HasDefaultRootObject CloudfrontDistributionResource Text where
    defaultRootObject =
        lens (_default_root_object :: CloudfrontDistributionResource -> TF.Argument "default_root_object" Text)
             (\s a -> s { _default_root_object = a } :: CloudfrontDistributionResource)

instance HasEnabled CloudfrontDistributionResource TF.Bool where
    enabled =
        lens (_enabled :: CloudfrontDistributionResource -> TF.Argument "enabled" TF.Bool)
             (\s a -> s { _enabled = a } :: CloudfrontDistributionResource)

instance HasHttpVersion CloudfrontDistributionResource Text where
    httpVersion =
        lens (_http_version :: CloudfrontDistributionResource -> TF.Argument "http_version" Text)
             (\s a -> s { _http_version = a } :: CloudfrontDistributionResource)

instance HasIsIpv6Enabled CloudfrontDistributionResource TF.Bool where
    isIpv6Enabled =
        lens (_is_ipv6_enabled :: CloudfrontDistributionResource -> TF.Argument "is_ipv6_enabled" TF.Bool)
             (\s a -> s { _is_ipv6_enabled = a } :: CloudfrontDistributionResource)

instance HasLoggingConfig CloudfrontDistributionResource Text where
    loggingConfig =
        lens (_logging_config :: CloudfrontDistributionResource -> TF.Argument "logging_config" Text)
             (\s a -> s { _logging_config = a } :: CloudfrontDistributionResource)

instance HasOrigin CloudfrontDistributionResource Text where
    origin =
        lens (_origin :: CloudfrontDistributionResource -> TF.Argument "origin" Text)
             (\s a -> s { _origin = a } :: CloudfrontDistributionResource)

instance HasPriceClass CloudfrontDistributionResource Text where
    priceClass =
        lens (_price_class :: CloudfrontDistributionResource -> TF.Argument "price_class" Text)
             (\s a -> s { _price_class = a } :: CloudfrontDistributionResource)

instance HasRestrictions CloudfrontDistributionResource Text where
    restrictions =
        lens (_restrictions :: CloudfrontDistributionResource -> TF.Argument "restrictions" Text)
             (\s a -> s { _restrictions = a } :: CloudfrontDistributionResource)

instance HasRetainOnDelete CloudfrontDistributionResource Text where
    retainOnDelete =
        lens (_retain_on_delete :: CloudfrontDistributionResource -> TF.Argument "retain_on_delete" Text)
             (\s a -> s { _retain_on_delete = a } :: CloudfrontDistributionResource)

instance HasTags CloudfrontDistributionResource TF.Tags where
    tags =
        lens (_tags :: CloudfrontDistributionResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: CloudfrontDistributionResource)

instance HasViewerCertificate CloudfrontDistributionResource Text where
    viewerCertificate =
        lens (_viewer_certificate :: CloudfrontDistributionResource -> TF.Argument "viewer_certificate" Text)
             (\s a -> s { _viewer_certificate = a } :: CloudfrontDistributionResource)

instance HasWebAclId CloudfrontDistributionResource Text where
    webAclId =
        lens (_web_acl_id :: CloudfrontDistributionResource -> TF.Argument "web_acl_id" Text)
             (\s a -> s { _web_acl_id = a } :: CloudfrontDistributionResource)

cloudfrontDistributionResource :: TF.Resource TF.AWS CloudfrontDistributionResource
cloudfrontDistributionResource =
    TF.newResource "aws_cloudfront_distribution" $
        CloudfrontDistributionResource {
            _aliases = TF.Nil
            , _cache_behavior = TF.Nil
            , _comment = TF.Nil
            , _custom_error_response = TF.Nil
            , _default_cache_behavior = TF.Nil
            , _default_root_object = TF.Nil
            , _enabled = TF.Nil
            , _http_version = TF.Nil
            , _is_ipv6_enabled = TF.Nil
            , _logging_config = TF.Nil
            , _origin = TF.Nil
            , _price_class = TF.Nil
            , _restrictions = TF.Nil
            , _retain_on_delete = TF.Nil
            , _tags = TF.Nil
            , _viewer_certificate = TF.Nil
            , _web_acl_id = TF.Nil
            }

{- | The @aws_cloudfront_origin_access_identity@ AWS resource.

Creates an Amazon CloudFront origin access identity. For information about
CloudFront distributions, see the
<http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Introduction.html>
. For more information on generating origin access identities, see
<http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-restricting-access-to-s3.html>
.
-}
data CloudfrontOriginAccessIdentityResource = CloudfrontOriginAccessIdentityResource {
      _comment :: !(TF.Argument "comment" Text)
    {- ^ (Optional) - An optional comment for the origin access identity. -}
    } deriving (Show, Eq)

instance TF.ToHCL CloudfrontOriginAccessIdentityResource where
    toHCL CloudfrontOriginAccessIdentityResource{..} = TF.block $ catMaybes
        [ TF.argument _comment
        ]

instance HasComment CloudfrontOriginAccessIdentityResource Text where
    comment =
        lens (_comment :: CloudfrontOriginAccessIdentityResource -> TF.Argument "comment" Text)
             (\s a -> s { _comment = a } :: CloudfrontOriginAccessIdentityResource)

instance HasComputedCallerReference CloudfrontOriginAccessIdentityResource Text where
    computedCallerReference =
        to (\_  -> TF.Compute "caller_reference")

instance HasComputedCloudfrontAccessIdentityPath CloudfrontOriginAccessIdentityResource Text where
    computedCloudfrontAccessIdentityPath =
        to (\_  -> TF.Compute "cloudfront_access_identity_path")

instance HasComputedEtag CloudfrontOriginAccessIdentityResource Text where
    computedEtag =
        to (\_  -> TF.Compute "etag")

instance HasComputedIamArn CloudfrontOriginAccessIdentityResource Text where
    computedIamArn =
        to (\_  -> TF.Compute "iam_arn")

instance HasComputedId CloudfrontOriginAccessIdentityResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedS3CanonicalUserId CloudfrontOriginAccessIdentityResource Text where
    computedS3CanonicalUserId =
        to (\_  -> TF.Compute "s3_canonical_user_id")

cloudfrontOriginAccessIdentityResource :: TF.Resource TF.AWS CloudfrontOriginAccessIdentityResource
cloudfrontOriginAccessIdentityResource =
    TF.newResource "aws_cloudfront_origin_access_identity" $
        CloudfrontOriginAccessIdentityResource {
            _comment = TF.Nil
            }

{- | The @aws_cloudtrail@ AWS resource.

Provides a CloudTrail resource.
-}
data CloudtrailResource = CloudtrailResource {
      _cloud_watch_logs_group_arn :: !(TF.Argument "cloud_watch_logs_group_arn" Text)
    {- ^ (Optional) Specifies a log group name using an Amazon Resource Name (ARN), that represents the log group to which CloudTrail logs will be delivered. -}
    , _cloud_watch_logs_role_arn :: !(TF.Argument "cloud_watch_logs_role_arn" Text)
    {- ^ (Optional) Specifies the role for the CloudWatch Logs endpoint to assume to write to a users log group. -}
    , _enable_log_file_validation :: !(TF.Argument "enable_log_file_validation" TF.Bool)
    {- ^ (Optional) Specifies whether log file integrity validation is enabled. Defaults to @false@ . -}
    , _enable_logging :: !(TF.Argument "enable_logging" TF.Bool)
    {- ^ (Optional) Enables logging for the trail. Defaults to @true@ . Setting this to @false@ will pause logging. -}
    , _include_global_service_events :: !(TF.Argument "include_global_service_events" Text)
    {- ^ (Optional) Specifies whether the trail is publishing events from global services such as IAM to the log files. Defaults to @true@ . -}
    , _is_multi_region_trail :: !(TF.Argument "is_multi_region_trail" Text)
    {- ^ (Optional) Specifies whether the trail is created in the current region or in all regions. Defaults to @false@ . -}
    , _kms_key_id :: !(TF.Argument "kms_key_id" Text)
    {- ^ (Optional) Specifies the KMS key ARN to use to encrypt the logs delivered by CloudTrail. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) Specifies the name of the trail. -}
    , _s3_bucket_name :: !(TF.Argument "s3_bucket_name" Text)
    {- ^ (Required) Specifies the name of the S3 bucket designated for publishing log files. -}
    , _s3_key_prefix :: !(TF.Argument "s3_key_prefix" Text)
    {- ^ (Optional) Specifies the S3 key prefix that precedes the name of the bucket you have designated for log file delivery. -}
    , _sns_topic_name :: !(TF.Argument "sns_topic_name" Text)
    {- ^ (Optional) Specifies the name of the Amazon SNS topic defined for notification of log file delivery. -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the trail -}
    } deriving (Show, Eq)

instance TF.ToHCL CloudtrailResource where
    toHCL CloudtrailResource{..} = TF.block $ catMaybes
        [ TF.argument _cloud_watch_logs_group_arn
        , TF.argument _cloud_watch_logs_role_arn
        , TF.argument _enable_log_file_validation
        , TF.argument _enable_logging
        , TF.argument _include_global_service_events
        , TF.argument _is_multi_region_trail
        , TF.argument _kms_key_id
        , TF.argument _name
        , TF.argument _s3_bucket_name
        , TF.argument _s3_key_prefix
        , TF.argument _sns_topic_name
        , TF.argument _tags
        ]

instance HasCloudWatchLogsGroupArn CloudtrailResource Text where
    cloudWatchLogsGroupArn =
        lens (_cloud_watch_logs_group_arn :: CloudtrailResource -> TF.Argument "cloud_watch_logs_group_arn" Text)
             (\s a -> s { _cloud_watch_logs_group_arn = a } :: CloudtrailResource)

instance HasCloudWatchLogsRoleArn CloudtrailResource Text where
    cloudWatchLogsRoleArn =
        lens (_cloud_watch_logs_role_arn :: CloudtrailResource -> TF.Argument "cloud_watch_logs_role_arn" Text)
             (\s a -> s { _cloud_watch_logs_role_arn = a } :: CloudtrailResource)

instance HasEnableLogFileValidation CloudtrailResource TF.Bool where
    enableLogFileValidation =
        lens (_enable_log_file_validation :: CloudtrailResource -> TF.Argument "enable_log_file_validation" TF.Bool)
             (\s a -> s { _enable_log_file_validation = a } :: CloudtrailResource)

instance HasEnableLogging CloudtrailResource TF.Bool where
    enableLogging =
        lens (_enable_logging :: CloudtrailResource -> TF.Argument "enable_logging" TF.Bool)
             (\s a -> s { _enable_logging = a } :: CloudtrailResource)

instance HasIncludeGlobalServiceEvents CloudtrailResource Text where
    includeGlobalServiceEvents =
        lens (_include_global_service_events :: CloudtrailResource -> TF.Argument "include_global_service_events" Text)
             (\s a -> s { _include_global_service_events = a } :: CloudtrailResource)

instance HasIsMultiRegionTrail CloudtrailResource Text where
    isMultiRegionTrail =
        lens (_is_multi_region_trail :: CloudtrailResource -> TF.Argument "is_multi_region_trail" Text)
             (\s a -> s { _is_multi_region_trail = a } :: CloudtrailResource)

instance HasKmsKeyId CloudtrailResource Text where
    kmsKeyId =
        lens (_kms_key_id :: CloudtrailResource -> TF.Argument "kms_key_id" Text)
             (\s a -> s { _kms_key_id = a } :: CloudtrailResource)

instance HasName CloudtrailResource Text where
    name =
        lens (_name :: CloudtrailResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: CloudtrailResource)

instance HasS3BucketName CloudtrailResource Text where
    s3BucketName =
        lens (_s3_bucket_name :: CloudtrailResource -> TF.Argument "s3_bucket_name" Text)
             (\s a -> s { _s3_bucket_name = a } :: CloudtrailResource)

instance HasS3KeyPrefix CloudtrailResource Text where
    s3KeyPrefix =
        lens (_s3_key_prefix :: CloudtrailResource -> TF.Argument "s3_key_prefix" Text)
             (\s a -> s { _s3_key_prefix = a } :: CloudtrailResource)

instance HasSnsTopicName CloudtrailResource Text where
    snsTopicName =
        lens (_sns_topic_name :: CloudtrailResource -> TF.Argument "sns_topic_name" Text)
             (\s a -> s { _sns_topic_name = a } :: CloudtrailResource)

instance HasTags CloudtrailResource TF.Tags where
    tags =
        lens (_tags :: CloudtrailResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: CloudtrailResource)

instance HasComputedArn CloudtrailResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

instance HasComputedHomeRegion CloudtrailResource TF.Region where
    computedHomeRegion =
        to (\_  -> TF.Compute "home_region")

instance HasComputedId CloudtrailResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

cloudtrailResource :: TF.Resource TF.AWS CloudtrailResource
cloudtrailResource =
    TF.newResource "aws_cloudtrail" $
        CloudtrailResource {
            _cloud_watch_logs_group_arn = TF.Nil
            , _cloud_watch_logs_role_arn = TF.Nil
            , _enable_log_file_validation = TF.Nil
            , _enable_logging = TF.Nil
            , _include_global_service_events = TF.Nil
            , _is_multi_region_trail = TF.Nil
            , _kms_key_id = TF.Nil
            , _name = TF.Nil
            , _s3_bucket_name = TF.Nil
            , _s3_key_prefix = TF.Nil
            , _sns_topic_name = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_cloudwatch_dashboard@ AWS resource.

Provides a CloudWatch Dashboard resource.
-}
data CloudwatchDashboardResource = CloudwatchDashboardResource {
      _dashboard_body :: !(TF.Argument "dashboard_body" Text)
    {- ^ (Required) The detailed information about the dashboard, including what widgets are included and their location on the dashboard. You can read more about the body structure in the <https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/CloudWatch-Dashboard-Body-Structure.html> . -}
    , _dashboard_name :: !(TF.Argument "dashboard_name" Text)
    {- ^ (Required) The name of the dashboard. -}
    } deriving (Show, Eq)

instance TF.ToHCL CloudwatchDashboardResource where
    toHCL CloudwatchDashboardResource{..} = TF.block $ catMaybes
        [ TF.argument _dashboard_body
        , TF.argument _dashboard_name
        ]

instance HasDashboardBody CloudwatchDashboardResource Text where
    dashboardBody =
        lens (_dashboard_body :: CloudwatchDashboardResource -> TF.Argument "dashboard_body" Text)
             (\s a -> s { _dashboard_body = a } :: CloudwatchDashboardResource)

instance HasDashboardName CloudwatchDashboardResource Text where
    dashboardName =
        lens (_dashboard_name :: CloudwatchDashboardResource -> TF.Argument "dashboard_name" Text)
             (\s a -> s { _dashboard_name = a } :: CloudwatchDashboardResource)

instance HasComputedDashboardArn CloudwatchDashboardResource Text where
    computedDashboardArn =
        to (\_  -> TF.Compute "dashboard_arn")

cloudwatchDashboardResource :: TF.Resource TF.AWS CloudwatchDashboardResource
cloudwatchDashboardResource =
    TF.newResource "aws_cloudwatch_dashboard" $
        CloudwatchDashboardResource {
            _dashboard_body = TF.Nil
            , _dashboard_name = TF.Nil
            }

{- | The @aws_cloudwatch_event_permission@ AWS resource.

Provides a resource to create a CloudWatch Events permission to support
cross-account events in the current account default event bus.
-}
data CloudwatchEventPermissionResource = CloudwatchEventPermissionResource {
      _action :: !(TF.Argument "action" Text)
    {- ^ (Optional) The action that you are enabling the other account to perform. Defaults to @events:PutEvents@ . -}
    , _principal :: !(TF.Argument "principal" Text)
    {- ^ (Required) The 12-digit AWS account ID that you are permitting to put events to your default event bus. Specify @*@ to permit any account to put events to your default event bus. -}
    , _statement_id :: !(TF.Argument "statement_id" Text)
    {- ^ (Required) An identifier string for the external account that you are granting permissions to. -}
    } deriving (Show, Eq)

instance TF.ToHCL CloudwatchEventPermissionResource where
    toHCL CloudwatchEventPermissionResource{..} = TF.block $ catMaybes
        [ TF.argument _action
        , TF.argument _principal
        , TF.argument _statement_id
        ]

instance HasAction CloudwatchEventPermissionResource Text where
    action =
        lens (_action :: CloudwatchEventPermissionResource -> TF.Argument "action" Text)
             (\s a -> s { _action = a } :: CloudwatchEventPermissionResource)

instance HasPrincipal CloudwatchEventPermissionResource Text where
    principal =
        lens (_principal :: CloudwatchEventPermissionResource -> TF.Argument "principal" Text)
             (\s a -> s { _principal = a } :: CloudwatchEventPermissionResource)

instance HasStatementId CloudwatchEventPermissionResource Text where
    statementId =
        lens (_statement_id :: CloudwatchEventPermissionResource -> TF.Argument "statement_id" Text)
             (\s a -> s { _statement_id = a } :: CloudwatchEventPermissionResource)

instance HasComputedId CloudwatchEventPermissionResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

cloudwatchEventPermissionResource :: TF.Resource TF.AWS CloudwatchEventPermissionResource
cloudwatchEventPermissionResource =
    TF.newResource "aws_cloudwatch_event_permission" $
        CloudwatchEventPermissionResource {
            _action = TF.Nil
            , _principal = TF.Nil
            , _statement_id = TF.Nil
            }

{- | The @aws_cloudwatch_event_rule@ AWS resource.

Provides a CloudWatch Event Rule resource.
-}
data CloudwatchEventRuleResource = CloudwatchEventRuleResource {
      _description :: !(TF.Argument "description" Text)
    {- ^ (Optional) The description of the rule. -}
    , _event_pattern :: !(TF.Argument "event_pattern" Text)
    {- ^ (Required, if @schedule_expression@ isn't specified) Event pattern described a JSON object. See full documentation of <http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/CloudWatchEventsandEventPatterns.html> for details. -}
    , _is_enabled :: !(TF.Argument "is_enabled" TF.Bool)
    {- ^ (Optional) Whether the rule should be enabled (defaults to @true@ ). -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The rule's name. -}
    , _role_arn :: !(TF.Argument "role_arn" Text)
    {- ^ (Optional) The Amazon Resource Name (ARN) associated with the role that is used for target invocation. -}
    , _schedule_expression :: !(TF.Argument "schedule_expression" Text)
    {- ^ (Required, if @event_pattern@ isn't specified) The scheduling expression. For example, @cron(0 20 * * ? *)@ or @rate(5 minutes)@ . -}
    } deriving (Show, Eq)

instance TF.ToHCL CloudwatchEventRuleResource where
    toHCL CloudwatchEventRuleResource{..} = TF.block $ catMaybes
        [ TF.argument _description
        , TF.argument _event_pattern
        , TF.argument _is_enabled
        , TF.argument _name
        , TF.argument _role_arn
        , TF.argument _schedule_expression
        ]

instance HasDescription CloudwatchEventRuleResource Text where
    description =
        lens (_description :: CloudwatchEventRuleResource -> TF.Argument "description" Text)
             (\s a -> s { _description = a } :: CloudwatchEventRuleResource)

instance HasEventPattern CloudwatchEventRuleResource Text where
    eventPattern =
        lens (_event_pattern :: CloudwatchEventRuleResource -> TF.Argument "event_pattern" Text)
             (\s a -> s { _event_pattern = a } :: CloudwatchEventRuleResource)

instance HasIsEnabled CloudwatchEventRuleResource TF.Bool where
    isEnabled =
        lens (_is_enabled :: CloudwatchEventRuleResource -> TF.Argument "is_enabled" TF.Bool)
             (\s a -> s { _is_enabled = a } :: CloudwatchEventRuleResource)

instance HasName CloudwatchEventRuleResource Text where
    name =
        lens (_name :: CloudwatchEventRuleResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: CloudwatchEventRuleResource)

instance HasRoleArn CloudwatchEventRuleResource Text where
    roleArn =
        lens (_role_arn :: CloudwatchEventRuleResource -> TF.Argument "role_arn" Text)
             (\s a -> s { _role_arn = a } :: CloudwatchEventRuleResource)

instance HasScheduleExpression CloudwatchEventRuleResource Text where
    scheduleExpression =
        lens (_schedule_expression :: CloudwatchEventRuleResource -> TF.Argument "schedule_expression" Text)
             (\s a -> s { _schedule_expression = a } :: CloudwatchEventRuleResource)

instance HasComputedArn CloudwatchEventRuleResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

cloudwatchEventRuleResource :: TF.Resource TF.AWS CloudwatchEventRuleResource
cloudwatchEventRuleResource =
    TF.newResource "aws_cloudwatch_event_rule" $
        CloudwatchEventRuleResource {
            _description = TF.Nil
            , _event_pattern = TF.Nil
            , _is_enabled = TF.Nil
            , _name = TF.Nil
            , _role_arn = TF.Nil
            , _schedule_expression = TF.Nil
            }

{- | The @aws_cloudwatch_event_target@ AWS resource.

Provides a CloudWatch Event Target resource.
-}
data CloudwatchEventTargetResource = CloudwatchEventTargetResource {
      _arn :: !(TF.Argument "arn" Text)
    {- ^ (Required) The Amazon Resource Name (ARN) associated of the target. -}
    , _ecs_target :: !(TF.Argument "ecs_target" Text)
    {- ^ (Optional) Parameters used when you are using the rule to invoke Amazon ECS Task. Documented below. A maximum of 1 are allowed. -}
    , _input :: !(TF.Argument "input" Text)
    {- ^ (Optional) Valid JSON text passed to the target. -}
    , _input_path :: !(TF.Argument "input_path" Text)
    {- ^ (Optional) The value of the <http://goessner.net/articles/JsonPath/> that is used for extracting part of the matched event when passing it to the target. -}
    , _input_transformer :: !(TF.Argument "input_transformer" Text)
    {- ^ (Optional) Parameters used when you are providing a custom input to a target based on certain event data. -}
    , _role_arn :: !(TF.Argument "role_arn" Text)
    {- ^ (Optional) The Amazon Resource Name (ARN) of the IAM role to be used for this target when the rule is triggered. Required if @ecs_target@ is used. -}
    , _rule :: !(TF.Argument "rule" Text)
    {- ^ (Required) The name of the rule you want to add targets to. -}
    , _run_command_targets :: !(TF.Argument "run_command_targets" Text)
    {- ^ (Optional) Parameters used when you are using the rule to invoke Amazon EC2 Run Command. Documented below. A maximum of 5 are allowed. -}
    , _target_id :: !(TF.Argument "target_id" Text)
    {- ^ (Optional) The unique target assignment ID.  If missing, will generate a random, unique id. -}
    } deriving (Show, Eq)

instance TF.ToHCL CloudwatchEventTargetResource where
    toHCL CloudwatchEventTargetResource{..} = TF.block $ catMaybes
        [ TF.argument _arn
        , TF.argument _ecs_target
        , TF.argument _input
        , TF.argument _input_path
        , TF.argument _input_transformer
        , TF.argument _role_arn
        , TF.argument _rule
        , TF.argument _run_command_targets
        , TF.argument _target_id
        ]

instance HasArn CloudwatchEventTargetResource Text where
    arn =
        lens (_arn :: CloudwatchEventTargetResource -> TF.Argument "arn" Text)
             (\s a -> s { _arn = a } :: CloudwatchEventTargetResource)

instance HasEcsTarget CloudwatchEventTargetResource Text where
    ecsTarget =
        lens (_ecs_target :: CloudwatchEventTargetResource -> TF.Argument "ecs_target" Text)
             (\s a -> s { _ecs_target = a } :: CloudwatchEventTargetResource)

instance HasInput CloudwatchEventTargetResource Text where
    input =
        lens (_input :: CloudwatchEventTargetResource -> TF.Argument "input" Text)
             (\s a -> s { _input = a } :: CloudwatchEventTargetResource)

instance HasInputPath CloudwatchEventTargetResource Text where
    inputPath =
        lens (_input_path :: CloudwatchEventTargetResource -> TF.Argument "input_path" Text)
             (\s a -> s { _input_path = a } :: CloudwatchEventTargetResource)

instance HasInputTransformer CloudwatchEventTargetResource Text where
    inputTransformer =
        lens (_input_transformer :: CloudwatchEventTargetResource -> TF.Argument "input_transformer" Text)
             (\s a -> s { _input_transformer = a } :: CloudwatchEventTargetResource)

instance HasRoleArn CloudwatchEventTargetResource Text where
    roleArn =
        lens (_role_arn :: CloudwatchEventTargetResource -> TF.Argument "role_arn" Text)
             (\s a -> s { _role_arn = a } :: CloudwatchEventTargetResource)

instance HasRule CloudwatchEventTargetResource Text where
    rule =
        lens (_rule :: CloudwatchEventTargetResource -> TF.Argument "rule" Text)
             (\s a -> s { _rule = a } :: CloudwatchEventTargetResource)

instance HasRunCommandTargets CloudwatchEventTargetResource Text where
    runCommandTargets =
        lens (_run_command_targets :: CloudwatchEventTargetResource -> TF.Argument "run_command_targets" Text)
             (\s a -> s { _run_command_targets = a } :: CloudwatchEventTargetResource)

instance HasTargetId CloudwatchEventTargetResource Text where
    targetId =
        lens (_target_id :: CloudwatchEventTargetResource -> TF.Argument "target_id" Text)
             (\s a -> s { _target_id = a } :: CloudwatchEventTargetResource)

cloudwatchEventTargetResource :: TF.Resource TF.AWS CloudwatchEventTargetResource
cloudwatchEventTargetResource =
    TF.newResource "aws_cloudwatch_event_target" $
        CloudwatchEventTargetResource {
            _arn = TF.Nil
            , _ecs_target = TF.Nil
            , _input = TF.Nil
            , _input_path = TF.Nil
            , _input_transformer = TF.Nil
            , _role_arn = TF.Nil
            , _rule = TF.Nil
            , _run_command_targets = TF.Nil
            , _target_id = TF.Nil
            }

{- | The @aws_cloudwatch_log_destination_policy@ AWS resource.

Provides a CloudWatch Logs destination policy resource.
-}
data CloudwatchLogDestinationPolicyResource = CloudwatchLogDestinationPolicyResource {
      _access_policy :: !(TF.Argument "access_policy" Text)
    {- ^ (Required) The policy document. This is a JSON formatted string. -}
    , _destination_name :: !(TF.Argument "destination_name" Text)
    {- ^ (Required) A name for the subscription filter -}
    } deriving (Show, Eq)

instance TF.ToHCL CloudwatchLogDestinationPolicyResource where
    toHCL CloudwatchLogDestinationPolicyResource{..} = TF.block $ catMaybes
        [ TF.argument _access_policy
        , TF.argument _destination_name
        ]

instance HasAccessPolicy CloudwatchLogDestinationPolicyResource Text where
    accessPolicy =
        lens (_access_policy :: CloudwatchLogDestinationPolicyResource -> TF.Argument "access_policy" Text)
             (\s a -> s { _access_policy = a } :: CloudwatchLogDestinationPolicyResource)

instance HasDestinationName CloudwatchLogDestinationPolicyResource Text where
    destinationName =
        lens (_destination_name :: CloudwatchLogDestinationPolicyResource -> TF.Argument "destination_name" Text)
             (\s a -> s { _destination_name = a } :: CloudwatchLogDestinationPolicyResource)

cloudwatchLogDestinationPolicyResource :: TF.Resource TF.AWS CloudwatchLogDestinationPolicyResource
cloudwatchLogDestinationPolicyResource =
    TF.newResource "aws_cloudwatch_log_destination_policy" $
        CloudwatchLogDestinationPolicyResource {
            _access_policy = TF.Nil
            , _destination_name = TF.Nil
            }

{- | The @aws_cloudwatch_log_destination@ AWS resource.

Provides a CloudWatch Logs destination resource.
-}
data CloudwatchLogDestinationResource = CloudwatchLogDestinationResource {
      _name :: !(TF.Argument "name" Text)
    {- ^ (Required) A name for the log destination -}
    , _role_arn :: !(TF.Argument "role_arn" Text)
    {- ^ (Required) The ARN of an IAM role that grants Amazon CloudWatch Logs permissions to put data into the target -}
    , _target_arn :: !(TF.Argument "target_arn" Text)
    {- ^ (Required) The ARN of the target Amazon Kinesis stream or Amazon Lambda resource for the destination -}
    } deriving (Show, Eq)

instance TF.ToHCL CloudwatchLogDestinationResource where
    toHCL CloudwatchLogDestinationResource{..} = TF.block $ catMaybes
        [ TF.argument _name
        , TF.argument _role_arn
        , TF.argument _target_arn
        ]

instance HasName CloudwatchLogDestinationResource Text where
    name =
        lens (_name :: CloudwatchLogDestinationResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: CloudwatchLogDestinationResource)

instance HasRoleArn CloudwatchLogDestinationResource Text where
    roleArn =
        lens (_role_arn :: CloudwatchLogDestinationResource -> TF.Argument "role_arn" Text)
             (\s a -> s { _role_arn = a } :: CloudwatchLogDestinationResource)

instance HasTargetArn CloudwatchLogDestinationResource Text where
    targetArn =
        lens (_target_arn :: CloudwatchLogDestinationResource -> TF.Argument "target_arn" Text)
             (\s a -> s { _target_arn = a } :: CloudwatchLogDestinationResource)

instance HasComputedArn CloudwatchLogDestinationResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

cloudwatchLogDestinationResource :: TF.Resource TF.AWS CloudwatchLogDestinationResource
cloudwatchLogDestinationResource =
    TF.newResource "aws_cloudwatch_log_destination" $
        CloudwatchLogDestinationResource {
            _name = TF.Nil
            , _role_arn = TF.Nil
            , _target_arn = TF.Nil
            }

{- | The @aws_cloudwatch_log_group@ AWS resource.

Provides a CloudWatch Log Group resource.
-}
data CloudwatchLogGroupResource = CloudwatchLogGroupResource {
      _kms_key_id :: !(TF.Argument "kms_key_id" Text)
    {- ^ (Optional) The ARN of the KMS Key to use when encrypting log data. Please note, after the AWS KMS CMK is disassociated from the log group, AWS CloudWatch Logs stops encrypting newly ingested data for the log group. All previously ingested data remains encrypted, and AWS CloudWatch Logs requires permissions for the CMK whenever the encrypted data is requested. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Optional, Forces new resource) The name of the log group. If omitted, Terraform will assign a random, unique name. -}
    , _name_prefix :: !(TF.Argument "name_prefix" Text)
    {- ^ (Optional, Forces new resource) Creates a unique name beginning with the specified prefix. Conflicts with @name@ . -}
    , _retention_in_days :: !(TF.Argument "retention_in_days" Text)
    {- ^ (Optional) Specifies the number of days you want to retain log events in the specified log group. -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    } deriving (Show, Eq)

instance TF.ToHCL CloudwatchLogGroupResource where
    toHCL CloudwatchLogGroupResource{..} = TF.block $ catMaybes
        [ TF.argument _kms_key_id
        , TF.argument _name
        , TF.argument _name_prefix
        , TF.argument _retention_in_days
        , TF.argument _tags
        ]

instance HasKmsKeyId CloudwatchLogGroupResource Text where
    kmsKeyId =
        lens (_kms_key_id :: CloudwatchLogGroupResource -> TF.Argument "kms_key_id" Text)
             (\s a -> s { _kms_key_id = a } :: CloudwatchLogGroupResource)

instance HasName CloudwatchLogGroupResource Text where
    name =
        lens (_name :: CloudwatchLogGroupResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: CloudwatchLogGroupResource)

instance HasNamePrefix CloudwatchLogGroupResource Text where
    namePrefix =
        lens (_name_prefix :: CloudwatchLogGroupResource -> TF.Argument "name_prefix" Text)
             (\s a -> s { _name_prefix = a } :: CloudwatchLogGroupResource)

instance HasRetentionInDays CloudwatchLogGroupResource Text where
    retentionInDays =
        lens (_retention_in_days :: CloudwatchLogGroupResource -> TF.Argument "retention_in_days" Text)
             (\s a -> s { _retention_in_days = a } :: CloudwatchLogGroupResource)

instance HasTags CloudwatchLogGroupResource TF.Tags where
    tags =
        lens (_tags :: CloudwatchLogGroupResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: CloudwatchLogGroupResource)

instance HasComputedArn CloudwatchLogGroupResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

cloudwatchLogGroupResource :: TF.Resource TF.AWS CloudwatchLogGroupResource
cloudwatchLogGroupResource =
    TF.newResource "aws_cloudwatch_log_group" $
        CloudwatchLogGroupResource {
            _kms_key_id = TF.Nil
            , _name = TF.Nil
            , _name_prefix = TF.Nil
            , _retention_in_days = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_cloudwatch_log_metric_filter@ AWS resource.

Provides a CloudWatch Log Metric Filter resource.
-}
data CloudwatchLogMetricFilterResource = CloudwatchLogMetricFilterResource {
      _log_group_name :: !(TF.Argument "log_group_name" Text)
    {- ^ (Required) The name of the log group to associate the metric filter with. -}
    , _metric_transformation :: !(TF.Argument "metric_transformation" Text)
    {- ^ (Required) A block defining collection of information needed to define how metric data gets emitted. See below. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) A name for the metric filter. -}
    , _pattern :: !(TF.Argument "pattern" Text)
    {- ^ (Required) A valid <https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/FilterAndPatternSyntax.html> for extracting metric data out of ingested log events. -}
    } deriving (Show, Eq)

instance TF.ToHCL CloudwatchLogMetricFilterResource where
    toHCL CloudwatchLogMetricFilterResource{..} = TF.block $ catMaybes
        [ TF.argument _log_group_name
        , TF.argument _metric_transformation
        , TF.argument _name
        , TF.argument _pattern
        ]

instance HasLogGroupName CloudwatchLogMetricFilterResource Text where
    logGroupName =
        lens (_log_group_name :: CloudwatchLogMetricFilterResource -> TF.Argument "log_group_name" Text)
             (\s a -> s { _log_group_name = a } :: CloudwatchLogMetricFilterResource)

instance HasMetricTransformation CloudwatchLogMetricFilterResource Text where
    metricTransformation =
        lens (_metric_transformation :: CloudwatchLogMetricFilterResource -> TF.Argument "metric_transformation" Text)
             (\s a -> s { _metric_transformation = a } :: CloudwatchLogMetricFilterResource)

instance HasName CloudwatchLogMetricFilterResource Text where
    name =
        lens (_name :: CloudwatchLogMetricFilterResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: CloudwatchLogMetricFilterResource)

instance HasPattern CloudwatchLogMetricFilterResource Text where
    pattern =
        lens (_pattern :: CloudwatchLogMetricFilterResource -> TF.Argument "pattern" Text)
             (\s a -> s { _pattern = a } :: CloudwatchLogMetricFilterResource)

instance HasComputedId CloudwatchLogMetricFilterResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

cloudwatchLogMetricFilterResource :: TF.Resource TF.AWS CloudwatchLogMetricFilterResource
cloudwatchLogMetricFilterResource =
    TF.newResource "aws_cloudwatch_log_metric_filter" $
        CloudwatchLogMetricFilterResource {
            _log_group_name = TF.Nil
            , _metric_transformation = TF.Nil
            , _name = TF.Nil
            , _pattern = TF.Nil
            }

{- | The @aws_cloudwatch_log_resource_policy@ AWS resource.

Provides a resource to manage a CloudWatch log resource policy.
-}
data CloudwatchLogResourcePolicyResource = CloudwatchLogResourcePolicyResource {
      _policy_document :: !(TF.Argument "policy_document" Text)
    {- ^ (Required) Details of the resource policy, including the identity of the principal that is enabled to put logs to this account. This is formatted as a JSON string. Maximum length of 5120 characters. -}
    , _policy_name :: !(TF.Argument "policy_name" Text)
    {- ^ (Required) Name of the resource policy. -}
    } deriving (Show, Eq)

instance TF.ToHCL CloudwatchLogResourcePolicyResource where
    toHCL CloudwatchLogResourcePolicyResource{..} = TF.block $ catMaybes
        [ TF.argument _policy_document
        , TF.argument _policy_name
        ]

instance HasPolicyDocument CloudwatchLogResourcePolicyResource Text where
    policyDocument =
        lens (_policy_document :: CloudwatchLogResourcePolicyResource -> TF.Argument "policy_document" Text)
             (\s a -> s { _policy_document = a } :: CloudwatchLogResourcePolicyResource)

instance HasPolicyName CloudwatchLogResourcePolicyResource Text where
    policyName =
        lens (_policy_name :: CloudwatchLogResourcePolicyResource -> TF.Argument "policy_name" Text)
             (\s a -> s { _policy_name = a } :: CloudwatchLogResourcePolicyResource)

instance HasComputedId CloudwatchLogResourcePolicyResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

cloudwatchLogResourcePolicyResource :: TF.Resource TF.AWS CloudwatchLogResourcePolicyResource
cloudwatchLogResourcePolicyResource =
    TF.newResource "aws_cloudwatch_log_resource_policy" $
        CloudwatchLogResourcePolicyResource {
            _policy_document = TF.Nil
            , _policy_name = TF.Nil
            }

{- | The @aws_cloudwatch_log_stream@ AWS resource.

Provides a CloudWatch Log Stream resource.
-}
data CloudwatchLogStreamResource = CloudwatchLogStreamResource {
      _log_group_name :: !(TF.Argument "log_group_name" Text)
    {- ^ (Required) The name of the log group under which the log stream is to be created. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the log stream. Must not be longer than 512 characters and must not contain @:@ -}
    } deriving (Show, Eq)

instance TF.ToHCL CloudwatchLogStreamResource where
    toHCL CloudwatchLogStreamResource{..} = TF.block $ catMaybes
        [ TF.argument _log_group_name
        , TF.argument _name
        ]

instance HasLogGroupName CloudwatchLogStreamResource Text where
    logGroupName =
        lens (_log_group_name :: CloudwatchLogStreamResource -> TF.Argument "log_group_name" Text)
             (\s a -> s { _log_group_name = a } :: CloudwatchLogStreamResource)

instance HasName CloudwatchLogStreamResource Text where
    name =
        lens (_name :: CloudwatchLogStreamResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: CloudwatchLogStreamResource)

instance HasComputedArn CloudwatchLogStreamResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

cloudwatchLogStreamResource :: TF.Resource TF.AWS CloudwatchLogStreamResource
cloudwatchLogStreamResource =
    TF.newResource "aws_cloudwatch_log_stream" $
        CloudwatchLogStreamResource {
            _log_group_name = TF.Nil
            , _name = TF.Nil
            }

{- | The @aws_cloudwatch_log_subscription_filter@ AWS resource.

Provides a CloudWatch Logs subscription filter resource.
-}
data CloudwatchLogSubscriptionFilterResource = CloudwatchLogSubscriptionFilterResource {
      _destination_arn :: !(TF.Argument "destination_arn" Text)
    {- ^ (Required) The ARN of the destination to deliver matching log events to. Kinesis stream or Lambda function ARN. -}
    , _filter_pattern :: !(TF.Argument "filter_pattern" Text)
    {- ^ (Required) A valid CloudWatch Logs filter pattern for subscribing to a filtered stream of log events. -}
    , _log_group_name :: !(TF.Argument "log_group_name" Text)
    {- ^ (Required) The name of the log group to associate the subscription filter with -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) A name for the subscription filter -}
    , _role_arn :: !(TF.Argument "role_arn" Text)
    {- ^ (Optional) The ARN of an IAM role that grants Amazon CloudWatch Logs permissions to deliver ingested log events to the destination. If you use Lambda as a destination, you should skip this argument and use @aws_lambda_permission@ resource for granting access from CloudWatch logs to the destination Lambda function. -}
    } deriving (Show, Eq)

instance TF.ToHCL CloudwatchLogSubscriptionFilterResource where
    toHCL CloudwatchLogSubscriptionFilterResource{..} = TF.block $ catMaybes
        [ TF.argument _destination_arn
        , TF.argument _filter_pattern
        , TF.argument _log_group_name
        , TF.argument _name
        , TF.argument _role_arn
        ]

instance HasDestinationArn CloudwatchLogSubscriptionFilterResource Text where
    destinationArn =
        lens (_destination_arn :: CloudwatchLogSubscriptionFilterResource -> TF.Argument "destination_arn" Text)
             (\s a -> s { _destination_arn = a } :: CloudwatchLogSubscriptionFilterResource)

instance HasFilterPattern CloudwatchLogSubscriptionFilterResource Text where
    filterPattern =
        lens (_filter_pattern :: CloudwatchLogSubscriptionFilterResource -> TF.Argument "filter_pattern" Text)
             (\s a -> s { _filter_pattern = a } :: CloudwatchLogSubscriptionFilterResource)

instance HasLogGroupName CloudwatchLogSubscriptionFilterResource Text where
    logGroupName =
        lens (_log_group_name :: CloudwatchLogSubscriptionFilterResource -> TF.Argument "log_group_name" Text)
             (\s a -> s { _log_group_name = a } :: CloudwatchLogSubscriptionFilterResource)

instance HasName CloudwatchLogSubscriptionFilterResource Text where
    name =
        lens (_name :: CloudwatchLogSubscriptionFilterResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: CloudwatchLogSubscriptionFilterResource)

instance HasRoleArn CloudwatchLogSubscriptionFilterResource Text where
    roleArn =
        lens (_role_arn :: CloudwatchLogSubscriptionFilterResource -> TF.Argument "role_arn" Text)
             (\s a -> s { _role_arn = a } :: CloudwatchLogSubscriptionFilterResource)

instance HasComputedArn CloudwatchLogSubscriptionFilterResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

cloudwatchLogSubscriptionFilterResource :: TF.Resource TF.AWS CloudwatchLogSubscriptionFilterResource
cloudwatchLogSubscriptionFilterResource =
    TF.newResource "aws_cloudwatch_log_subscription_filter" $
        CloudwatchLogSubscriptionFilterResource {
            _destination_arn = TF.Nil
            , _filter_pattern = TF.Nil
            , _log_group_name = TF.Nil
            , _name = TF.Nil
            , _role_arn = TF.Nil
            }

{- | The @aws_cloudwatch_metric_alarm@ AWS resource.

Provides a CloudWatch Metric Alarm resource.
-}
data CloudwatchMetricAlarmResource = CloudwatchMetricAlarmResource {
      _actions_enabled :: !(TF.Argument "actions_enabled" TF.Bool)
    {- ^ (Optional) Indicates whether or not actions should be executed during any changes to the alarm's state. Defaults to @true@ . -}
    , _alarm_actions :: !(TF.Argument "alarm_actions" Text)
    {- ^ (Optional) The list of actions to execute when this alarm transitions into an ALARM state from any other state. Each action is specified as an Amazon Resource Number (ARN). -}
    , _alarm_description :: !(TF.Argument "alarm_description" Text)
    {- ^ (Optional) The description for the alarm. -}
    , _alarm_name :: !(TF.Argument "alarm_name" Text)
    {- ^ (Required) The descriptive name for the alarm. This name must be unique within the user's AWS account -}
    , _comparison_operator :: !(TF.Argument "comparison_operator" Text)
    {- ^ (Required) The arithmetic operation to use when comparing the specified Statistic and Threshold. The specified Statistic value is used as the first operand. Either of the following is supported: @GreaterThanOrEqualToThreshold@ , @GreaterThanThreshold@ , @LessThanThreshold@ , @LessThanOrEqualToThreshold@ . -}
    , _datapoints_to_alarm :: !(TF.Argument "datapoints_to_alarm" Text)
    {- ^ (Optional) The number of datapoints that must be breaching to trigger the alarm. -}
    , _dimensions :: !(TF.Argument "dimensions" Text)
    {- ^ (Optional) The dimensions for the alarm's associated metric.  For the list of available dimensions see the AWS documentation <http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/CW_Support_For_AWS.html> . -}
    , _evaluate_low_sample_count_percentiles :: !(TF.Argument "evaluate_low_sample_count_percentiles" Text)
    {- ^ (Optional) Used only for alarms based on percentiles. If you specify @ignore@ , the alarm state will not change during periods with too few data points to be statistically significant. If you specify @evaluate@ or omit this parameter, the alarm will always be evaluated and possibly change state no matter how many data points are available. The following values are supported: @ignore@ , and @evaluate@ . -}
    , _evaluation_periods :: !(TF.Argument "evaluation_periods" Text)
    {- ^ (Required) The number of periods over which data is compared to the specified threshold. -}
    , _extended_statistic :: !(TF.Argument "extended_statistic" Text)
    {- ^ (Optional) The percentile statistic for the metric associated with the alarm. Specify a value between p0.0 and p100. -}
    , _insufficient_data_actions :: !(TF.Argument "insufficient_data_actions" Text)
    {- ^ (Optional) The list of actions to execute when this alarm transitions into an INSUFFICIENT_DATA state from any other state. Each action is specified as an Amazon Resource Number (ARN). -}
    , _metric_name :: !(TF.Argument "metric_name" Text)
    {- ^ (Required) The name for the alarm's associated metric. See docs for <https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/CW_Support_For_AWS.html> . -}
    , _namespace :: !(TF.Argument "namespace" Text)
    {- ^ (Required) The namespace for the alarm's associated metric. See docs for the <https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/aws-namespaces.html> . See docs for <https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/CW_Support_For_AWS.html> . -}
    , _ok_actions :: !(TF.Argument "ok_actions" Text)
    {- ^ (Optional) The list of actions to execute when this alarm transitions into an OK state from any other state. Each action is specified as an Amazon Resource Number (ARN). -}
    , _period :: !(TF.Argument "period" Text)
    {- ^ (Required) The period in seconds over which the specified @statistic@ is applied. -}
    , _statistic :: !(TF.Argument "statistic" Text)
    {- ^ (Optional) The statistic to apply to the alarm's associated metric. Either of the following is supported: @SampleCount@ , @Average@ , @Sum@ , @Minimum@ , @Maximum@ -}
    , _threshold :: !(TF.Argument "threshold" Text)
    {- ^ (Required) The value against which the specified statistic is compared. -}
    , _treat_missing_data :: !(TF.Argument "treat_missing_data" Text)
    {- ^ (Optional) Sets how this alarm is to handle missing data points. The following values are supported: @missing@ , @ignore@ , @breaching@ and @notBreaching@ . Defaults to @missing@ . -}
    , _unit :: !(TF.Argument "unit" Text)
    {- ^ (Optional) The unit for the alarm's associated metric. -}
    } deriving (Show, Eq)

instance TF.ToHCL CloudwatchMetricAlarmResource where
    toHCL CloudwatchMetricAlarmResource{..} = TF.block $ catMaybes
        [ TF.argument _actions_enabled
        , TF.argument _alarm_actions
        , TF.argument _alarm_description
        , TF.argument _alarm_name
        , TF.argument _comparison_operator
        , TF.argument _datapoints_to_alarm
        , TF.argument _dimensions
        , TF.argument _evaluate_low_sample_count_percentiles
        , TF.argument _evaluation_periods
        , TF.argument _extended_statistic
        , TF.argument _insufficient_data_actions
        , TF.argument _metric_name
        , TF.argument _namespace
        , TF.argument _ok_actions
        , TF.argument _period
        , TF.argument _statistic
        , TF.argument _threshold
        , TF.argument _treat_missing_data
        , TF.argument _unit
        ]

instance HasActionsEnabled CloudwatchMetricAlarmResource TF.Bool where
    actionsEnabled =
        lens (_actions_enabled :: CloudwatchMetricAlarmResource -> TF.Argument "actions_enabled" TF.Bool)
             (\s a -> s { _actions_enabled = a } :: CloudwatchMetricAlarmResource)

instance HasAlarmActions CloudwatchMetricAlarmResource Text where
    alarmActions =
        lens (_alarm_actions :: CloudwatchMetricAlarmResource -> TF.Argument "alarm_actions" Text)
             (\s a -> s { _alarm_actions = a } :: CloudwatchMetricAlarmResource)

instance HasAlarmDescription CloudwatchMetricAlarmResource Text where
    alarmDescription =
        lens (_alarm_description :: CloudwatchMetricAlarmResource -> TF.Argument "alarm_description" Text)
             (\s a -> s { _alarm_description = a } :: CloudwatchMetricAlarmResource)

instance HasAlarmName CloudwatchMetricAlarmResource Text where
    alarmName =
        lens (_alarm_name :: CloudwatchMetricAlarmResource -> TF.Argument "alarm_name" Text)
             (\s a -> s { _alarm_name = a } :: CloudwatchMetricAlarmResource)

instance HasComparisonOperator CloudwatchMetricAlarmResource Text where
    comparisonOperator =
        lens (_comparison_operator :: CloudwatchMetricAlarmResource -> TF.Argument "comparison_operator" Text)
             (\s a -> s { _comparison_operator = a } :: CloudwatchMetricAlarmResource)

instance HasDatapointsToAlarm CloudwatchMetricAlarmResource Text where
    datapointsToAlarm =
        lens (_datapoints_to_alarm :: CloudwatchMetricAlarmResource -> TF.Argument "datapoints_to_alarm" Text)
             (\s a -> s { _datapoints_to_alarm = a } :: CloudwatchMetricAlarmResource)

instance HasDimensions CloudwatchMetricAlarmResource Text where
    dimensions =
        lens (_dimensions :: CloudwatchMetricAlarmResource -> TF.Argument "dimensions" Text)
             (\s a -> s { _dimensions = a } :: CloudwatchMetricAlarmResource)

instance HasEvaluateLowSampleCountPercentiles CloudwatchMetricAlarmResource Text where
    evaluateLowSampleCountPercentiles =
        lens (_evaluate_low_sample_count_percentiles :: CloudwatchMetricAlarmResource -> TF.Argument "evaluate_low_sample_count_percentiles" Text)
             (\s a -> s { _evaluate_low_sample_count_percentiles = a } :: CloudwatchMetricAlarmResource)

instance HasEvaluationPeriods CloudwatchMetricAlarmResource Text where
    evaluationPeriods =
        lens (_evaluation_periods :: CloudwatchMetricAlarmResource -> TF.Argument "evaluation_periods" Text)
             (\s a -> s { _evaluation_periods = a } :: CloudwatchMetricAlarmResource)

instance HasExtendedStatistic CloudwatchMetricAlarmResource Text where
    extendedStatistic =
        lens (_extended_statistic :: CloudwatchMetricAlarmResource -> TF.Argument "extended_statistic" Text)
             (\s a -> s { _extended_statistic = a } :: CloudwatchMetricAlarmResource)

instance HasInsufficientDataActions CloudwatchMetricAlarmResource Text where
    insufficientDataActions =
        lens (_insufficient_data_actions :: CloudwatchMetricAlarmResource -> TF.Argument "insufficient_data_actions" Text)
             (\s a -> s { _insufficient_data_actions = a } :: CloudwatchMetricAlarmResource)

instance HasMetricName CloudwatchMetricAlarmResource Text where
    metricName =
        lens (_metric_name :: CloudwatchMetricAlarmResource -> TF.Argument "metric_name" Text)
             (\s a -> s { _metric_name = a } :: CloudwatchMetricAlarmResource)

instance HasNamespace CloudwatchMetricAlarmResource Text where
    namespace =
        lens (_namespace :: CloudwatchMetricAlarmResource -> TF.Argument "namespace" Text)
             (\s a -> s { _namespace = a } :: CloudwatchMetricAlarmResource)

instance HasOkActions CloudwatchMetricAlarmResource Text where
    okActions =
        lens (_ok_actions :: CloudwatchMetricAlarmResource -> TF.Argument "ok_actions" Text)
             (\s a -> s { _ok_actions = a } :: CloudwatchMetricAlarmResource)

instance HasPeriod CloudwatchMetricAlarmResource Text where
    period =
        lens (_period :: CloudwatchMetricAlarmResource -> TF.Argument "period" Text)
             (\s a -> s { _period = a } :: CloudwatchMetricAlarmResource)

instance HasStatistic CloudwatchMetricAlarmResource Text where
    statistic =
        lens (_statistic :: CloudwatchMetricAlarmResource -> TF.Argument "statistic" Text)
             (\s a -> s { _statistic = a } :: CloudwatchMetricAlarmResource)

instance HasThreshold CloudwatchMetricAlarmResource Text where
    threshold =
        lens (_threshold :: CloudwatchMetricAlarmResource -> TF.Argument "threshold" Text)
             (\s a -> s { _threshold = a } :: CloudwatchMetricAlarmResource)

instance HasTreatMissingData CloudwatchMetricAlarmResource Text where
    treatMissingData =
        lens (_treat_missing_data :: CloudwatchMetricAlarmResource -> TF.Argument "treat_missing_data" Text)
             (\s a -> s { _treat_missing_data = a } :: CloudwatchMetricAlarmResource)

instance HasUnit CloudwatchMetricAlarmResource Text where
    unit =
        lens (_unit :: CloudwatchMetricAlarmResource -> TF.Argument "unit" Text)
             (\s a -> s { _unit = a } :: CloudwatchMetricAlarmResource)

instance HasComputedId CloudwatchMetricAlarmResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

cloudwatchMetricAlarmResource :: TF.Resource TF.AWS CloudwatchMetricAlarmResource
cloudwatchMetricAlarmResource =
    TF.newResource "aws_cloudwatch_metric_alarm" $
        CloudwatchMetricAlarmResource {
            _actions_enabled = TF.Nil
            , _alarm_actions = TF.Nil
            , _alarm_description = TF.Nil
            , _alarm_name = TF.Nil
            , _comparison_operator = TF.Nil
            , _datapoints_to_alarm = TF.Nil
            , _dimensions = TF.Nil
            , _evaluate_low_sample_count_percentiles = TF.Nil
            , _evaluation_periods = TF.Nil
            , _extended_statistic = TF.Nil
            , _insufficient_data_actions = TF.Nil
            , _metric_name = TF.Nil
            , _namespace = TF.Nil
            , _ok_actions = TF.Nil
            , _period = TF.Nil
            , _statistic = TF.Nil
            , _threshold = TF.Nil
            , _treat_missing_data = TF.Nil
            , _unit = TF.Nil
            }

{- | The @aws_codebuild_project@ AWS resource.

Provides a CodeBuild Project resource.
-}
data CodebuildProjectResource = CodebuildProjectResource {
      _artifacts :: !(TF.Argument "artifacts" Text)
    {- ^ (Required) Information about the project's build output artifacts. Artifact blocks are documented below. -}
    , _build_timeout :: !(TF.Argument "build_timeout" Text)
    {- ^ (Optional) How long in minutes, from 5 to 480 (8 hours), for AWS CodeBuild to wait until timing out any related build that does not get marked as completed. The default is 60 minutes. -}
    , _description :: !(TF.Argument "description" Text)
    {- ^ (Optional) A short description of the project. -}
    , _encryption_key :: !(TF.Argument "encryption_key" Text)
    {- ^ (Optional) The AWS Key Management Service (AWS KMS) customer master key (CMK) to be used for encrypting the build project's build output artifacts. -}
    , _environment :: !(TF.Argument "environment" Text)
    {- ^ (Required) Information about the project's build environment. Environment blocks are documented below. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The projects name. -}
    , _service_role :: !(TF.Argument "service_role" Text)
    {- ^ (Optional) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that enables AWS CodeBuild to interact with dependent AWS services on behalf of the AWS account. -}
    , _source :: !(TF.Argument "source" Text)
    {- ^ (Required) Information about the project's input source code. Source blocks are documented below. -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    } deriving (Show, Eq)

instance TF.ToHCL CodebuildProjectResource where
    toHCL CodebuildProjectResource{..} = TF.block $ catMaybes
        [ TF.argument _artifacts
        , TF.argument _build_timeout
        , TF.argument _description
        , TF.argument _encryption_key
        , TF.argument _environment
        , TF.argument _name
        , TF.argument _service_role
        , TF.argument _source
        , TF.argument _tags
        ]

instance HasArtifacts CodebuildProjectResource Text where
    artifacts =
        lens (_artifacts :: CodebuildProjectResource -> TF.Argument "artifacts" Text)
             (\s a -> s { _artifacts = a } :: CodebuildProjectResource)

instance HasBuildTimeout CodebuildProjectResource Text where
    buildTimeout =
        lens (_build_timeout :: CodebuildProjectResource -> TF.Argument "build_timeout" Text)
             (\s a -> s { _build_timeout = a } :: CodebuildProjectResource)

instance HasDescription CodebuildProjectResource Text where
    description =
        lens (_description :: CodebuildProjectResource -> TF.Argument "description" Text)
             (\s a -> s { _description = a } :: CodebuildProjectResource)

instance HasEncryptionKey CodebuildProjectResource Text where
    encryptionKey =
        lens (_encryption_key :: CodebuildProjectResource -> TF.Argument "encryption_key" Text)
             (\s a -> s { _encryption_key = a } :: CodebuildProjectResource)

instance HasEnvironment CodebuildProjectResource Text where
    environment =
        lens (_environment :: CodebuildProjectResource -> TF.Argument "environment" Text)
             (\s a -> s { _environment = a } :: CodebuildProjectResource)

instance HasName CodebuildProjectResource Text where
    name =
        lens (_name :: CodebuildProjectResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: CodebuildProjectResource)

instance HasServiceRole CodebuildProjectResource Text where
    serviceRole =
        lens (_service_role :: CodebuildProjectResource -> TF.Argument "service_role" Text)
             (\s a -> s { _service_role = a } :: CodebuildProjectResource)

instance HasSource CodebuildProjectResource Text where
    source =
        lens (_source :: CodebuildProjectResource -> TF.Argument "source" Text)
             (\s a -> s { _source = a } :: CodebuildProjectResource)

instance HasTags CodebuildProjectResource TF.Tags where
    tags =
        lens (_tags :: CodebuildProjectResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: CodebuildProjectResource)

instance HasComputedDescription CodebuildProjectResource Text where
    computedDescription =
        to (\_  -> TF.Compute "description")

instance HasComputedEncryptionKey CodebuildProjectResource Text where
    computedEncryptionKey =
        to (\_  -> TF.Compute "encryption_key")

instance HasComputedId CodebuildProjectResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedName CodebuildProjectResource Text where
    computedName =
        to (\_  -> TF.Compute "name")

instance HasComputedServiceRole CodebuildProjectResource Text where
    computedServiceRole =
        to (\_  -> TF.Compute "service_role")

codebuildProjectResource :: TF.Resource TF.AWS CodebuildProjectResource
codebuildProjectResource =
    TF.newResource "aws_codebuild_project" $
        CodebuildProjectResource {
            _artifacts = TF.Nil
            , _build_timeout = TF.Nil
            , _description = TF.Nil
            , _encryption_key = TF.Nil
            , _environment = TF.Nil
            , _name = TF.Nil
            , _service_role = TF.Nil
            , _source = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_codecommit_repository@ AWS resource.

Provides a CodeCommit Repository Resource. ~> NOTE on CodeCommit
Availability : The CodeCommit is not yet rolled out in all regions -
available regions are listed
<https://docs.aws.amazon.com/general/latest/gr/rande.html#codecommit_region>
.
-}
data CodecommitRepositoryResource = CodecommitRepositoryResource {
      _default_branch :: !(TF.Argument "default_branch" Text)
    {- ^ (Optional) The default branch of the repository. The branch specified here needs to exist. -}
    , _description :: !(TF.Argument "description" Text)
    {- ^ (Optional) The description of the repository. This needs to be less than 1000 characters -}
    , _repository_name :: !(TF.Argument "repository_name" Text)
    {- ^ (Required) The name for the repository. This needs to be less than 100 characters. -}
    } deriving (Show, Eq)

instance TF.ToHCL CodecommitRepositoryResource where
    toHCL CodecommitRepositoryResource{..} = TF.block $ catMaybes
        [ TF.argument _default_branch
        , TF.argument _description
        , TF.argument _repository_name
        ]

instance HasDefaultBranch CodecommitRepositoryResource Text where
    defaultBranch =
        lens (_default_branch :: CodecommitRepositoryResource -> TF.Argument "default_branch" Text)
             (\s a -> s { _default_branch = a } :: CodecommitRepositoryResource)

instance HasDescription CodecommitRepositoryResource Text where
    description =
        lens (_description :: CodecommitRepositoryResource -> TF.Argument "description" Text)
             (\s a -> s { _description = a } :: CodecommitRepositoryResource)

instance HasRepositoryName CodecommitRepositoryResource Text where
    repositoryName =
        lens (_repository_name :: CodecommitRepositoryResource -> TF.Argument "repository_name" Text)
             (\s a -> s { _repository_name = a } :: CodecommitRepositoryResource)

instance HasComputedArn CodecommitRepositoryResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

instance HasComputedCloneUrlHttp CodecommitRepositoryResource Text where
    computedCloneUrlHttp =
        to (\_  -> TF.Compute "clone_url_http")

instance HasComputedCloneUrlSsh CodecommitRepositoryResource Text where
    computedCloneUrlSsh =
        to (\_  -> TF.Compute "clone_url_ssh")

instance HasComputedRepositoryId CodecommitRepositoryResource Text where
    computedRepositoryId =
        to (\_  -> TF.Compute "repository_id")

codecommitRepositoryResource :: TF.Resource TF.AWS CodecommitRepositoryResource
codecommitRepositoryResource =
    TF.newResource "aws_codecommit_repository" $
        CodecommitRepositoryResource {
            _default_branch = TF.Nil
            , _description = TF.Nil
            , _repository_name = TF.Nil
            }

{- | The @aws_codecommit_trigger@ AWS resource.

Provides a CodeCommit Trigger Resource. ~> NOTE on CodeCommit : The
CodeCommit is not yet rolled out in all regions - available regions are
listed
<https://docs.aws.amazon.com/general/latest/gr/rande.html#codecommit_region>
.
-}
data CodecommitTriggerResource = CodecommitTriggerResource {
      _branches :: !(TF.Argument "branches" Text)
    {- ^ (Optional) The branches that will be included in the trigger configuration. If no branches are specified, the trigger will apply to all branches. -}
    , _custom_data :: !(TF.Argument "custom_data" Text)
    {- ^ (Optional) Any custom data associated with the trigger that will be included in the information sent to the target of the trigger. -}
    , _destination_arn :: !(TF.Argument "destination_arn" Text)
    {- ^ (Required) The ARN of the resource that is the target for a trigger. For example, the ARN of a topic in Amazon Simple Notification Service (SNS). -}
    , _events :: !(TF.Argument "events" Text)
    {- ^ (Required) The repository events that will cause the trigger to run actions in another service, such as sending a notification through Amazon Simple Notification Service (SNS). If no events are specified, the trigger will run for all repository events. Event types include: @all@ , @updateReference@ , @createReference@ , @deleteReference@ . -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the trigger. -}
    , _repository_name :: !(TF.Argument "repository_name" Text)
    {- ^ (Required) The name for the repository. This needs to be less than 100 characters. -}
    } deriving (Show, Eq)

instance TF.ToHCL CodecommitTriggerResource where
    toHCL CodecommitTriggerResource{..} = TF.block $ catMaybes
        [ TF.argument _branches
        , TF.argument _custom_data
        , TF.argument _destination_arn
        , TF.argument _events
        , TF.argument _name
        , TF.argument _repository_name
        ]

instance HasBranches CodecommitTriggerResource Text where
    branches =
        lens (_branches :: CodecommitTriggerResource -> TF.Argument "branches" Text)
             (\s a -> s { _branches = a } :: CodecommitTriggerResource)

instance HasCustomData CodecommitTriggerResource Text where
    customData =
        lens (_custom_data :: CodecommitTriggerResource -> TF.Argument "custom_data" Text)
             (\s a -> s { _custom_data = a } :: CodecommitTriggerResource)

instance HasDestinationArn CodecommitTriggerResource Text where
    destinationArn =
        lens (_destination_arn :: CodecommitTriggerResource -> TF.Argument "destination_arn" Text)
             (\s a -> s { _destination_arn = a } :: CodecommitTriggerResource)

instance HasEvents CodecommitTriggerResource Text where
    events =
        lens (_events :: CodecommitTriggerResource -> TF.Argument "events" Text)
             (\s a -> s { _events = a } :: CodecommitTriggerResource)

instance HasName CodecommitTriggerResource Text where
    name =
        lens (_name :: CodecommitTriggerResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: CodecommitTriggerResource)

instance HasRepositoryName CodecommitTriggerResource Text where
    repositoryName =
        lens (_repository_name :: CodecommitTriggerResource -> TF.Argument "repository_name" Text)
             (\s a -> s { _repository_name = a } :: CodecommitTriggerResource)

codecommitTriggerResource :: TF.Resource TF.AWS CodecommitTriggerResource
codecommitTriggerResource =
    TF.newResource "aws_codecommit_trigger" $
        CodecommitTriggerResource {
            _branches = TF.Nil
            , _custom_data = TF.Nil
            , _destination_arn = TF.Nil
            , _events = TF.Nil
            , _name = TF.Nil
            , _repository_name = TF.Nil
            }

{- | The @aws_codedeploy_app@ AWS resource.

Provides a CodeDeploy application to be used as a basis for deployments
-}
data CodedeployAppResource = CodedeployAppResource {
      _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the application. -}
    } deriving (Show, Eq)

instance TF.ToHCL CodedeployAppResource where
    toHCL CodedeployAppResource{..} = TF.block $ catMaybes
        [ TF.argument _name
        ]

instance HasName CodedeployAppResource Text where
    name =
        lens (_name :: CodedeployAppResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: CodedeployAppResource)

instance HasComputedId CodedeployAppResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedName CodedeployAppResource Text where
    computedName =
        to (\_  -> TF.Compute "name")

codedeployAppResource :: TF.Resource TF.AWS CodedeployAppResource
codedeployAppResource =
    TF.newResource "aws_codedeploy_app" $
        CodedeployAppResource {
            _name = TF.Nil
            }

{- | The @aws_codedeploy_deployment_config@ AWS resource.

Provides a CodeDeploy deployment config for an application
-}
data CodedeployDeploymentConfigResource = CodedeployDeploymentConfigResource {
      _deployment_config_name :: !(TF.Argument "deployment_config_name" Text)
    {- ^ (Required) The name of the deployment config. -}
    , _minimum_healthy_hosts :: !(TF.Argument "minimum_healthy_hosts" Text)
    {- ^ (Optional) A minimum_healthy_hosts block. Minimum Healthy Hosts are documented below. -}
    } deriving (Show, Eq)

instance TF.ToHCL CodedeployDeploymentConfigResource where
    toHCL CodedeployDeploymentConfigResource{..} = TF.block $ catMaybes
        [ TF.argument _deployment_config_name
        , TF.argument _minimum_healthy_hosts
        ]

instance HasDeploymentConfigName CodedeployDeploymentConfigResource Text where
    deploymentConfigName =
        lens (_deployment_config_name :: CodedeployDeploymentConfigResource -> TF.Argument "deployment_config_name" Text)
             (\s a -> s { _deployment_config_name = a } :: CodedeployDeploymentConfigResource)

instance HasMinimumHealthyHosts CodedeployDeploymentConfigResource Text where
    minimumHealthyHosts =
        lens (_minimum_healthy_hosts :: CodedeployDeploymentConfigResource -> TF.Argument "minimum_healthy_hosts" Text)
             (\s a -> s { _minimum_healthy_hosts = a } :: CodedeployDeploymentConfigResource)

instance HasComputedDeploymentConfigId CodedeployDeploymentConfigResource Text where
    computedDeploymentConfigId =
        to (\_  -> TF.Compute "deployment_config_id")

instance HasComputedId CodedeployDeploymentConfigResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

codedeployDeploymentConfigResource :: TF.Resource TF.AWS CodedeployDeploymentConfigResource
codedeployDeploymentConfigResource =
    TF.newResource "aws_codedeploy_deployment_config" $
        CodedeployDeploymentConfigResource {
            _deployment_config_name = TF.Nil
            , _minimum_healthy_hosts = TF.Nil
            }

{- | The @aws_codedeploy_deployment_group@ AWS resource.

Provides a CodeDeploy Deployment Group for a CodeDeploy Application
-}
data CodedeployDeploymentGroupResource = CodedeployDeploymentGroupResource {
      _alarm_configuration :: !(TF.Argument "alarm_configuration" Text)
    {- ^ (Optional) Information about alarms associated with the deployment group (documented below). -}
    , _app_name :: !(TF.Argument "app_name" Text)
    {- ^ (Required) The name of the application. -}
    , _auto_rollback_configuration :: !(TF.Argument "auto_rollback_configuration" Text)
    {- ^ (Optional) The automatic rollback configuration associated with the deployment group (documented below). -}
    , _autoscaling_groups :: !(TF.Argument "autoscaling_groups" Text)
    {- ^ (Optional) Autoscaling groups associated with the deployment group. -}
    , _blue_green_deployment_config :: !(TF.Argument "blue_green_deployment_config" Text)
    {- ^ (Optional) Information about blue/green deployment options for a deployment group (documented below). -}
    , _deployment_config_name :: !(TF.Argument "deployment_config_name" Text)
    {- ^ (Optional) The name of the group's deployment config. The default is "CodeDeployDefault.OneAtATime". -}
    , _deployment_group_name :: !(TF.Argument "deployment_group_name" Text)
    {- ^ (Required) The name of the deployment group. -}
    , _deployment_style :: !(TF.Argument "deployment_style" Text)
    {- ^ (Optional) Information about the type of deployment, either in-place or blue/green, you want to run and whether to route deployment traffic behind a load balancer (documented below). -}
    , _ec2_tag_filter :: !(TF.Argument "ec2_tag_filter" Text)
    {- ^ (Optional) Tag filters associated with the group. See the AWS docs for details. -}
    , _load_balancer_info :: !(TF.Argument "load_balancer_info" Text)
    {- ^ (Optional) Information about the load balancer to use in a blue/green deployment (documented below). -}
    , _on_premises_instance_tag_filter :: !(TF.Argument "on_premises_instance_tag_filter" Text)
    {- ^ (Optional) On premise tag filters associated with the group. See the AWS docs for details. -}
    , _service_role_arn :: !(TF.Argument "service_role_arn" Text)
    {- ^ (Required) The service role ARN that allows deployments. -}
    , _trigger_configuration :: !(TF.Argument "trigger_configuration" Text)
    {- ^ (Optional) Trigger Configurations for the deployment group (documented below). -}
    } deriving (Show, Eq)

instance TF.ToHCL CodedeployDeploymentGroupResource where
    toHCL CodedeployDeploymentGroupResource{..} = TF.block $ catMaybes
        [ TF.argument _alarm_configuration
        , TF.argument _app_name
        , TF.argument _auto_rollback_configuration
        , TF.argument _autoscaling_groups
        , TF.argument _blue_green_deployment_config
        , TF.argument _deployment_config_name
        , TF.argument _deployment_group_name
        , TF.argument _deployment_style
        , TF.argument _ec2_tag_filter
        , TF.argument _load_balancer_info
        , TF.argument _on_premises_instance_tag_filter
        , TF.argument _service_role_arn
        , TF.argument _trigger_configuration
        ]

instance HasAlarmConfiguration CodedeployDeploymentGroupResource Text where
    alarmConfiguration =
        lens (_alarm_configuration :: CodedeployDeploymentGroupResource -> TF.Argument "alarm_configuration" Text)
             (\s a -> s { _alarm_configuration = a } :: CodedeployDeploymentGroupResource)

instance HasAppName CodedeployDeploymentGroupResource Text where
    appName =
        lens (_app_name :: CodedeployDeploymentGroupResource -> TF.Argument "app_name" Text)
             (\s a -> s { _app_name = a } :: CodedeployDeploymentGroupResource)

instance HasAutoRollbackConfiguration CodedeployDeploymentGroupResource Text where
    autoRollbackConfiguration =
        lens (_auto_rollback_configuration :: CodedeployDeploymentGroupResource -> TF.Argument "auto_rollback_configuration" Text)
             (\s a -> s { _auto_rollback_configuration = a } :: CodedeployDeploymentGroupResource)

instance HasAutoscalingGroups CodedeployDeploymentGroupResource Text where
    autoscalingGroups =
        lens (_autoscaling_groups :: CodedeployDeploymentGroupResource -> TF.Argument "autoscaling_groups" Text)
             (\s a -> s { _autoscaling_groups = a } :: CodedeployDeploymentGroupResource)

instance HasBlueGreenDeploymentConfig CodedeployDeploymentGroupResource Text where
    blueGreenDeploymentConfig =
        lens (_blue_green_deployment_config :: CodedeployDeploymentGroupResource -> TF.Argument "blue_green_deployment_config" Text)
             (\s a -> s { _blue_green_deployment_config = a } :: CodedeployDeploymentGroupResource)

instance HasDeploymentConfigName CodedeployDeploymentGroupResource Text where
    deploymentConfigName =
        lens (_deployment_config_name :: CodedeployDeploymentGroupResource -> TF.Argument "deployment_config_name" Text)
             (\s a -> s { _deployment_config_name = a } :: CodedeployDeploymentGroupResource)

instance HasDeploymentGroupName CodedeployDeploymentGroupResource Text where
    deploymentGroupName =
        lens (_deployment_group_name :: CodedeployDeploymentGroupResource -> TF.Argument "deployment_group_name" Text)
             (\s a -> s { _deployment_group_name = a } :: CodedeployDeploymentGroupResource)

instance HasDeploymentStyle CodedeployDeploymentGroupResource Text where
    deploymentStyle =
        lens (_deployment_style :: CodedeployDeploymentGroupResource -> TF.Argument "deployment_style" Text)
             (\s a -> s { _deployment_style = a } :: CodedeployDeploymentGroupResource)

instance HasEc2TagFilter CodedeployDeploymentGroupResource Text where
    ec2TagFilter =
        lens (_ec2_tag_filter :: CodedeployDeploymentGroupResource -> TF.Argument "ec2_tag_filter" Text)
             (\s a -> s { _ec2_tag_filter = a } :: CodedeployDeploymentGroupResource)

instance HasLoadBalancerInfo CodedeployDeploymentGroupResource Text where
    loadBalancerInfo =
        lens (_load_balancer_info :: CodedeployDeploymentGroupResource -> TF.Argument "load_balancer_info" Text)
             (\s a -> s { _load_balancer_info = a } :: CodedeployDeploymentGroupResource)

instance HasOnPremisesInstanceTagFilter CodedeployDeploymentGroupResource Text where
    onPremisesInstanceTagFilter =
        lens (_on_premises_instance_tag_filter :: CodedeployDeploymentGroupResource -> TF.Argument "on_premises_instance_tag_filter" Text)
             (\s a -> s { _on_premises_instance_tag_filter = a } :: CodedeployDeploymentGroupResource)

instance HasServiceRoleArn CodedeployDeploymentGroupResource Text where
    serviceRoleArn =
        lens (_service_role_arn :: CodedeployDeploymentGroupResource -> TF.Argument "service_role_arn" Text)
             (\s a -> s { _service_role_arn = a } :: CodedeployDeploymentGroupResource)

instance HasTriggerConfiguration CodedeployDeploymentGroupResource Text where
    triggerConfiguration =
        lens (_trigger_configuration :: CodedeployDeploymentGroupResource -> TF.Argument "trigger_configuration" Text)
             (\s a -> s { _trigger_configuration = a } :: CodedeployDeploymentGroupResource)

codedeployDeploymentGroupResource :: TF.Resource TF.AWS CodedeployDeploymentGroupResource
codedeployDeploymentGroupResource =
    TF.newResource "aws_codedeploy_deployment_group" $
        CodedeployDeploymentGroupResource {
            _alarm_configuration = TF.Nil
            , _app_name = TF.Nil
            , _auto_rollback_configuration = TF.Nil
            , _autoscaling_groups = TF.Nil
            , _blue_green_deployment_config = TF.Nil
            , _deployment_config_name = TF.Nil
            , _deployment_group_name = TF.Nil
            , _deployment_style = TF.Nil
            , _ec2_tag_filter = TF.Nil
            , _load_balancer_info = TF.Nil
            , _on_premises_instance_tag_filter = TF.Nil
            , _service_role_arn = TF.Nil
            , _trigger_configuration = TF.Nil
            }

{- | The @aws_codepipeline@ AWS resource.

Provides a CodePipeline. ~> NOTE on @aws_codepipeline@ : - the
@GITHUB_TOKEN@ environment variable must be set if the GitHub provider is
specified.
-}
data CodepipelineResource = CodepipelineResource {
      _artifact_store :: !(TF.Argument "artifact_store" Text)
    {- ^ (Required) An artifact_store block. Artifact stores are documented below. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the pipeline. -}
    , _role_arn :: !(TF.Argument "role_arn" Text)
    {- ^ (Required) A service role Amazon Resource Name (ARN) that grants AWS CodePipeline permission to make calls to AWS services on your behalf. -}
    , _stage :: !(TF.Argument "stage" Text)
    {- ^ (Required) A stage block. Stages are documented below. -}
    } deriving (Show, Eq)

instance TF.ToHCL CodepipelineResource where
    toHCL CodepipelineResource{..} = TF.block $ catMaybes
        [ TF.argument _artifact_store
        , TF.argument _name
        , TF.argument _role_arn
        , TF.argument _stage
        ]

instance HasArtifactStore CodepipelineResource Text where
    artifactStore =
        lens (_artifact_store :: CodepipelineResource -> TF.Argument "artifact_store" Text)
             (\s a -> s { _artifact_store = a } :: CodepipelineResource)

instance HasName CodepipelineResource Text where
    name =
        lens (_name :: CodepipelineResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: CodepipelineResource)

instance HasRoleArn CodepipelineResource Text where
    roleArn =
        lens (_role_arn :: CodepipelineResource -> TF.Argument "role_arn" Text)
             (\s a -> s { _role_arn = a } :: CodepipelineResource)

instance HasStage CodepipelineResource Text where
    stage =
        lens (_stage :: CodepipelineResource -> TF.Argument "stage" Text)
             (\s a -> s { _stage = a } :: CodepipelineResource)

instance HasComputedArn CodepipelineResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

instance HasComputedId CodepipelineResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

codepipelineResource :: TF.Resource TF.AWS CodepipelineResource
codepipelineResource =
    TF.newResource "aws_codepipeline" $
        CodepipelineResource {
            _artifact_store = TF.Nil
            , _name = TF.Nil
            , _role_arn = TF.Nil
            , _stage = TF.Nil
            }

{- | The @aws_cognito_identity_pool@ AWS resource.

Provides an AWS Cognito Identity Pool.
-}
data CognitoIdentityPoolResource = CognitoIdentityPoolResource {
      _allow_unauthenticated_identities :: !(TF.Argument "allow_unauthenticated_identities" Text)
    {- ^ (Required) - Whether the identity pool supports unauthenticated logins or not. -}
    , _cognito_identity_providers :: !(TF.Argument "cognito_identity_providers" Text)
    {- ^ (Optional) - An array of <#cognito-identity-providers> and their client IDs. -}
    , _developer_provider_name :: !(TF.Argument "developer_provider_name" Text)
    {- ^ (Optional) - The "domain" by which Cognito will refer to your users. This name acts as a placeholder that allows your backend and the Cognito service to communicate about the developer provider. -}
    , _identity_pool_name :: !(TF.Argument "identity_pool_name" Text)
    {- ^ (Required) - The Cognito Identity Pool name. -}
    , _openid_connect_provider_arns :: !(TF.Argument "openid_connect_provider_arns" Text)
    {- ^ (Optional) - A list of OpendID Connect provider ARNs. -}
    , _saml_provider_arns :: !(TF.Argument "saml_provider_arns" Text)
    {- ^ (Optional) - An array of Amazon Resource Names (ARNs) of the SAML provider for your identity. -}
    , _supported_login_providers :: !(TF.Argument "supported_login_providers" Text)
    {- ^ (Optional) - Key-Value pairs mapping provider names to provider app IDs. -}
    } deriving (Show, Eq)

instance TF.ToHCL CognitoIdentityPoolResource where
    toHCL CognitoIdentityPoolResource{..} = TF.block $ catMaybes
        [ TF.argument _allow_unauthenticated_identities
        , TF.argument _cognito_identity_providers
        , TF.argument _developer_provider_name
        , TF.argument _identity_pool_name
        , TF.argument _openid_connect_provider_arns
        , TF.argument _saml_provider_arns
        , TF.argument _supported_login_providers
        ]

instance HasAllowUnauthenticatedIdentities CognitoIdentityPoolResource Text where
    allowUnauthenticatedIdentities =
        lens (_allow_unauthenticated_identities :: CognitoIdentityPoolResource -> TF.Argument "allow_unauthenticated_identities" Text)
             (\s a -> s { _allow_unauthenticated_identities = a } :: CognitoIdentityPoolResource)

instance HasCognitoIdentityProviders CognitoIdentityPoolResource Text where
    cognitoIdentityProviders =
        lens (_cognito_identity_providers :: CognitoIdentityPoolResource -> TF.Argument "cognito_identity_providers" Text)
             (\s a -> s { _cognito_identity_providers = a } :: CognitoIdentityPoolResource)

instance HasDeveloperProviderName CognitoIdentityPoolResource Text where
    developerProviderName =
        lens (_developer_provider_name :: CognitoIdentityPoolResource -> TF.Argument "developer_provider_name" Text)
             (\s a -> s { _developer_provider_name = a } :: CognitoIdentityPoolResource)

instance HasIdentityPoolName CognitoIdentityPoolResource Text where
    identityPoolName =
        lens (_identity_pool_name :: CognitoIdentityPoolResource -> TF.Argument "identity_pool_name" Text)
             (\s a -> s { _identity_pool_name = a } :: CognitoIdentityPoolResource)

instance HasOpenidConnectProviderArns CognitoIdentityPoolResource Text where
    openidConnectProviderArns =
        lens (_openid_connect_provider_arns :: CognitoIdentityPoolResource -> TF.Argument "openid_connect_provider_arns" Text)
             (\s a -> s { _openid_connect_provider_arns = a } :: CognitoIdentityPoolResource)

instance HasSamlProviderArns CognitoIdentityPoolResource Text where
    samlProviderArns =
        lens (_saml_provider_arns :: CognitoIdentityPoolResource -> TF.Argument "saml_provider_arns" Text)
             (\s a -> s { _saml_provider_arns = a } :: CognitoIdentityPoolResource)

instance HasSupportedLoginProviders CognitoIdentityPoolResource Text where
    supportedLoginProviders =
        lens (_supported_login_providers :: CognitoIdentityPoolResource -> TF.Argument "supported_login_providers" Text)
             (\s a -> s { _supported_login_providers = a } :: CognitoIdentityPoolResource)

cognitoIdentityPoolResource :: TF.Resource TF.AWS CognitoIdentityPoolResource
cognitoIdentityPoolResource =
    TF.newResource "aws_cognito_identity_pool" $
        CognitoIdentityPoolResource {
            _allow_unauthenticated_identities = TF.Nil
            , _cognito_identity_providers = TF.Nil
            , _developer_provider_name = TF.Nil
            , _identity_pool_name = TF.Nil
            , _openid_connect_provider_arns = TF.Nil
            , _saml_provider_arns = TF.Nil
            , _supported_login_providers = TF.Nil
            }

{- | The @aws_cognito_identity_pool_roles_attachment@ AWS resource.

Provides an AWS Cognito Identity Pool Roles Attachment.
-}
data CognitoIdentityPoolRolesAttachmentResource = CognitoIdentityPoolRolesAttachmentResource {
      _identity_pool_id :: !(TF.Argument "identity_pool_id" Text)
    {- ^ (Required) - An identity pool ID in the format REGION:GUID. -}
    , _role_mapping :: !(TF.Argument "role_mapping" Text)
    {- ^ (Optional) - A List of <#role-mappings> . -}
    , _roles :: !(TF.Argument "roles" Text)
    {- ^ (Required) - The map of roles associated with this pool. For a given role, the key will be either "authenticated" or "unauthenticated" and the value will be the Role ARN. -}
    } deriving (Show, Eq)

instance TF.ToHCL CognitoIdentityPoolRolesAttachmentResource where
    toHCL CognitoIdentityPoolRolesAttachmentResource{..} = TF.block $ catMaybes
        [ TF.argument _identity_pool_id
        , TF.argument _role_mapping
        , TF.argument _roles
        ]

instance HasIdentityPoolId CognitoIdentityPoolRolesAttachmentResource Text where
    identityPoolId =
        lens (_identity_pool_id :: CognitoIdentityPoolRolesAttachmentResource -> TF.Argument "identity_pool_id" Text)
             (\s a -> s { _identity_pool_id = a } :: CognitoIdentityPoolRolesAttachmentResource)

instance HasRoleMapping CognitoIdentityPoolRolesAttachmentResource Text where
    roleMapping =
        lens (_role_mapping :: CognitoIdentityPoolRolesAttachmentResource -> TF.Argument "role_mapping" Text)
             (\s a -> s { _role_mapping = a } :: CognitoIdentityPoolRolesAttachmentResource)

instance HasRoles CognitoIdentityPoolRolesAttachmentResource Text where
    roles =
        lens (_roles :: CognitoIdentityPoolRolesAttachmentResource -> TF.Argument "roles" Text)
             (\s a -> s { _roles = a } :: CognitoIdentityPoolRolesAttachmentResource)

cognitoIdentityPoolRolesAttachmentResource :: TF.Resource TF.AWS CognitoIdentityPoolRolesAttachmentResource
cognitoIdentityPoolRolesAttachmentResource =
    TF.newResource "aws_cognito_identity_pool_roles_attachment" $
        CognitoIdentityPoolRolesAttachmentResource {
            _identity_pool_id = TF.Nil
            , _role_mapping = TF.Nil
            , _roles = TF.Nil
            }

{- | The @aws_cognito_user_pool_client@ AWS resource.

Provides a Cognito User Pool Client resource.
-}
data CognitoUserPoolClientResource = CognitoUserPoolClientResource {
      _allowed_oauth_flows :: !(TF.Argument "allowed_oauth_flows" Text)
    {- ^ (Optional) List of allowed OAuth flows (code, implicit, client_credentials). -}
    , _allowed_oauth_flows_user_pool_client :: !(TF.Argument "allowed_oauth_flows_user_pool_client" Text)
    {- ^ (Optional) Whether the client is allowed to follow the OAuth protocol when interacting with Cognito user pools. -}
    , _allowed_oauth_scopes :: !(TF.Argument "allowed_oauth_scopes" Text)
    {- ^ (Optional) List of allowed OAuth scopes (phone, email, openid, Cognito). -}
    , _callback_urls :: !(TF.Argument "callback_urls" Text)
    {- ^ (Optional) List of allowed callback URLs for the identity providers. -}
    , _default_redirect_uri :: !(TF.Argument "default_redirect_uri" Text)
    {- ^ (Optional) The default redirect URI. Must be in the list of callback URLs. -}
    , _explicit_auth_flows :: !(TF.Argument "explicit_auth_flows" Text)
    {- ^ (Optional) List of authentication flows (ADMIN_NO_SRP_AUTH, CUSTOM_AUTH_FLOW_ONLY). -}
    , _generate_secret :: !(TF.Argument "generate_secret" Text)
    {- ^ (Optional) Should an application secret be generated. AWS JavaScript SDK requires this to be false. -}
    , _logout_urls :: !(TF.Argument "logout_urls" Text)
    {- ^ (Optional) List of allowed logout URLs for the identity providers. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the application client. -}
    , _read_attributes :: !(TF.Argument "read_attributes" Text)
    {- ^ (Optional) List of user pool attributes the application client can read from. -}
    , _refresh_token_validity :: !(TF.Argument "refresh_token_validity" Text)
    {- ^ (Optional) The time limit in days refresh tokens are valid for. -}
    , _supported_identity_providers :: !(TF.Argument "supported_identity_providers" Text)
    {- ^ (Optional) List of provider names for the identity providers that are supported on this client. -}
    , _user_pool_id :: !(TF.Argument "user_pool_id" Text)
    {- ^ (Required) The user pool the client belongs to. -}
    , _write_attributes :: !(TF.Argument "write_attributes" Text)
    {- ^ (Optional) List of user pool attributes the application client can write to. -}
    } deriving (Show, Eq)

instance TF.ToHCL CognitoUserPoolClientResource where
    toHCL CognitoUserPoolClientResource{..} = TF.block $ catMaybes
        [ TF.argument _allowed_oauth_flows
        , TF.argument _allowed_oauth_flows_user_pool_client
        , TF.argument _allowed_oauth_scopes
        , TF.argument _callback_urls
        , TF.argument _default_redirect_uri
        , TF.argument _explicit_auth_flows
        , TF.argument _generate_secret
        , TF.argument _logout_urls
        , TF.argument _name
        , TF.argument _read_attributes
        , TF.argument _refresh_token_validity
        , TF.argument _supported_identity_providers
        , TF.argument _user_pool_id
        , TF.argument _write_attributes
        ]

instance HasAllowedOauthFlows CognitoUserPoolClientResource Text where
    allowedOauthFlows =
        lens (_allowed_oauth_flows :: CognitoUserPoolClientResource -> TF.Argument "allowed_oauth_flows" Text)
             (\s a -> s { _allowed_oauth_flows = a } :: CognitoUserPoolClientResource)

instance HasAllowedOauthFlowsUserPoolClient CognitoUserPoolClientResource Text where
    allowedOauthFlowsUserPoolClient =
        lens (_allowed_oauth_flows_user_pool_client :: CognitoUserPoolClientResource -> TF.Argument "allowed_oauth_flows_user_pool_client" Text)
             (\s a -> s { _allowed_oauth_flows_user_pool_client = a } :: CognitoUserPoolClientResource)

instance HasAllowedOauthScopes CognitoUserPoolClientResource Text where
    allowedOauthScopes =
        lens (_allowed_oauth_scopes :: CognitoUserPoolClientResource -> TF.Argument "allowed_oauth_scopes" Text)
             (\s a -> s { _allowed_oauth_scopes = a } :: CognitoUserPoolClientResource)

instance HasCallbackUrls CognitoUserPoolClientResource Text where
    callbackUrls =
        lens (_callback_urls :: CognitoUserPoolClientResource -> TF.Argument "callback_urls" Text)
             (\s a -> s { _callback_urls = a } :: CognitoUserPoolClientResource)

instance HasDefaultRedirectUri CognitoUserPoolClientResource Text where
    defaultRedirectUri =
        lens (_default_redirect_uri :: CognitoUserPoolClientResource -> TF.Argument "default_redirect_uri" Text)
             (\s a -> s { _default_redirect_uri = a } :: CognitoUserPoolClientResource)

instance HasExplicitAuthFlows CognitoUserPoolClientResource Text where
    explicitAuthFlows =
        lens (_explicit_auth_flows :: CognitoUserPoolClientResource -> TF.Argument "explicit_auth_flows" Text)
             (\s a -> s { _explicit_auth_flows = a } :: CognitoUserPoolClientResource)

instance HasGenerateSecret CognitoUserPoolClientResource Text where
    generateSecret =
        lens (_generate_secret :: CognitoUserPoolClientResource -> TF.Argument "generate_secret" Text)
             (\s a -> s { _generate_secret = a } :: CognitoUserPoolClientResource)

instance HasLogoutUrls CognitoUserPoolClientResource Text where
    logoutUrls =
        lens (_logout_urls :: CognitoUserPoolClientResource -> TF.Argument "logout_urls" Text)
             (\s a -> s { _logout_urls = a } :: CognitoUserPoolClientResource)

instance HasName CognitoUserPoolClientResource Text where
    name =
        lens (_name :: CognitoUserPoolClientResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: CognitoUserPoolClientResource)

instance HasReadAttributes CognitoUserPoolClientResource Text where
    readAttributes =
        lens (_read_attributes :: CognitoUserPoolClientResource -> TF.Argument "read_attributes" Text)
             (\s a -> s { _read_attributes = a } :: CognitoUserPoolClientResource)

instance HasRefreshTokenValidity CognitoUserPoolClientResource Text where
    refreshTokenValidity =
        lens (_refresh_token_validity :: CognitoUserPoolClientResource -> TF.Argument "refresh_token_validity" Text)
             (\s a -> s { _refresh_token_validity = a } :: CognitoUserPoolClientResource)

instance HasSupportedIdentityProviders CognitoUserPoolClientResource Text where
    supportedIdentityProviders =
        lens (_supported_identity_providers :: CognitoUserPoolClientResource -> TF.Argument "supported_identity_providers" Text)
             (\s a -> s { _supported_identity_providers = a } :: CognitoUserPoolClientResource)

instance HasUserPoolId CognitoUserPoolClientResource Text where
    userPoolId =
        lens (_user_pool_id :: CognitoUserPoolClientResource -> TF.Argument "user_pool_id" Text)
             (\s a -> s { _user_pool_id = a } :: CognitoUserPoolClientResource)

instance HasWriteAttributes CognitoUserPoolClientResource Text where
    writeAttributes =
        lens (_write_attributes :: CognitoUserPoolClientResource -> TF.Argument "write_attributes" Text)
             (\s a -> s { _write_attributes = a } :: CognitoUserPoolClientResource)

instance HasComputedClientSecret CognitoUserPoolClientResource Text where
    computedClientSecret =
        to (\_  -> TF.Compute "client_secret")

instance HasComputedId CognitoUserPoolClientResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

cognitoUserPoolClientResource :: TF.Resource TF.AWS CognitoUserPoolClientResource
cognitoUserPoolClientResource =
    TF.newResource "aws_cognito_user_pool_client" $
        CognitoUserPoolClientResource {
            _allowed_oauth_flows = TF.Nil
            , _allowed_oauth_flows_user_pool_client = TF.Nil
            , _allowed_oauth_scopes = TF.Nil
            , _callback_urls = TF.Nil
            , _default_redirect_uri = TF.Nil
            , _explicit_auth_flows = TF.Nil
            , _generate_secret = TF.Nil
            , _logout_urls = TF.Nil
            , _name = TF.Nil
            , _read_attributes = TF.Nil
            , _refresh_token_validity = TF.Nil
            , _supported_identity_providers = TF.Nil
            , _user_pool_id = TF.Nil
            , _write_attributes = TF.Nil
            }

{- | The @aws_cognito_user_pool_domain@ AWS resource.

Provides a Cognito User Pool Domain resource.
-}
data CognitoUserPoolDomainResource = CognitoUserPoolDomainResource {
      _domain :: !(TF.Argument "domain" Text)
    {- ^ (Required) The domain string. -}
    , _user_pool_id :: !(TF.Argument "user_pool_id" Text)
    {- ^ (Required) The user pool ID. -}
    } deriving (Show, Eq)

instance TF.ToHCL CognitoUserPoolDomainResource where
    toHCL CognitoUserPoolDomainResource{..} = TF.block $ catMaybes
        [ TF.argument _domain
        , TF.argument _user_pool_id
        ]

instance HasDomain CognitoUserPoolDomainResource Text where
    domain =
        lens (_domain :: CognitoUserPoolDomainResource -> TF.Argument "domain" Text)
             (\s a -> s { _domain = a } :: CognitoUserPoolDomainResource)

instance HasUserPoolId CognitoUserPoolDomainResource Text where
    userPoolId =
        lens (_user_pool_id :: CognitoUserPoolDomainResource -> TF.Argument "user_pool_id" Text)
             (\s a -> s { _user_pool_id = a } :: CognitoUserPoolDomainResource)

instance HasComputedAwsAccountId CognitoUserPoolDomainResource Text where
    computedAwsAccountId =
        to (\_  -> TF.Compute "aws_account_id")

instance HasComputedCloudfrontDistributionArn CognitoUserPoolDomainResource Text where
    computedCloudfrontDistributionArn =
        to (\_  -> TF.Compute "cloudfront_distribution_arn")

instance HasComputedS3Bucket CognitoUserPoolDomainResource Text where
    computedS3Bucket =
        to (\_  -> TF.Compute "s3_bucket")

instance HasComputedVersion CognitoUserPoolDomainResource Text where
    computedVersion =
        to (\_  -> TF.Compute "version")

cognitoUserPoolDomainResource :: TF.Resource TF.AWS CognitoUserPoolDomainResource
cognitoUserPoolDomainResource =
    TF.newResource "aws_cognito_user_pool_domain" $
        CognitoUserPoolDomainResource {
            _domain = TF.Nil
            , _user_pool_id = TF.Nil
            }

{- | The @aws_cognito_user_pool@ AWS resource.

Provides a Cognito User Pool resource.
-}
data CognitoUserPoolResource = CognitoUserPoolResource {
      _admin_create_user_config :: !(TF.Argument "admin_create_user_config" Text)
    {- ^ (Optional) - The configuration for <#admin-create-user-config> requests. -}
    , _alias_attributes :: !(TF.Argument "alias_attributes" Text)
    {- ^ (Optional) Attributes supported as an alias for this user pool. Possible values: phone_number, email, or preferred_username. Conflicts with @username_attributes@ . -}
    , _auto_verified_attributes :: !(TF.Argument "auto_verified_attributes" Text)
    {- ^ (Optional) The attributes to be auto-verified. Possible values: email, phone_number. -}
    , _device_configuration :: !(TF.Argument "device_configuration" Text)
    {- ^ (Optional) - The configuration for the <#device-configuration> . -}
    , _email_configuration :: !(TF.Argument "email_configuration" Text)
    {- ^ (Optional) - The <#email-configuration> . -}
    , _email_verification_message :: !(TF.Argument "email_verification_message" Text)
    {- ^ (Optional) A string representing the email verification message. Must contain the @{####}@ placeholder. NOTE: - If @email_verification_message@ and @verification_message_template.email_message@ are specified and the values are different, either one is prioritized and updated. -}
    , _email_verification_subject :: !(TF.Argument "email_verification_subject" Text)
    {- ^ (Optional) A string representing the email verification subject. NOTE: - If @email_verification_subject@ and @verification_message_template.email_subject@ are specified and the values are different, either one is prioritized and updated. -}
    , _lambda_config :: !(TF.Argument "lambda_config" Text)
    {- ^ (Optional) - A container for the AWS <#lambda-configuration> associated with the user pool. -}
    , _mfa_configuration :: !(TF.Argument "mfa_configuration" Text)
    {- ^ (Optional, Default: OFF) Set to enable multi-factor authentication. Must be one of the following values (ON, OFF, OPTIONAL) -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the user pool. -}
    , _password_policy :: !(TF.Argument "password_policy" Text)
    {- ^ (Optional) - A container for information about the <#password-policy> . -}
    , _schema :: !(TF.Argument "schema" Text)
    {- ^ (Optional) - A container with the <#schema-attributes> of a user pool. Maximum of 50 attributes. -}
    , _sms_authentication_message :: !(TF.Argument "sms_authentication_message" Text)
    {- ^ (Optional) A string representing the SMS authentication message. -}
    , _sms_configuration :: !(TF.Argument "sms_configuration" Text)
    {- ^ (Optional) - The <#sms-configuration> . -}
    , _sms_verification_message :: !(TF.Argument "sms_verification_message" Text)
    {- ^ (Optional) A string representing the SMS verification message. -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the User Pool. -}
    , _username_attributes :: !(TF.Argument "username_attributes" Text)
    {- ^ (Optional) Specifies whether email addresses or phone numbers can be specified as usernames when a user signs up. Conflicts with @alias_attributes@ . -}
    , _verification_message_template :: !(TF.Argument "verification_message_template" Text)
    {- ^ (Optional) - The <#verification-message-template> configuration. -}
    } deriving (Show, Eq)

instance TF.ToHCL CognitoUserPoolResource where
    toHCL CognitoUserPoolResource{..} = TF.block $ catMaybes
        [ TF.argument _admin_create_user_config
        , TF.argument _alias_attributes
        , TF.argument _auto_verified_attributes
        , TF.argument _device_configuration
        , TF.argument _email_configuration
        , TF.argument _email_verification_message
        , TF.argument _email_verification_subject
        , TF.argument _lambda_config
        , TF.argument _mfa_configuration
        , TF.argument _name
        , TF.argument _password_policy
        , TF.argument _schema
        , TF.argument _sms_authentication_message
        , TF.argument _sms_configuration
        , TF.argument _sms_verification_message
        , TF.argument _tags
        , TF.argument _username_attributes
        , TF.argument _verification_message_template
        ]

instance HasAdminCreateUserConfig CognitoUserPoolResource Text where
    adminCreateUserConfig =
        lens (_admin_create_user_config :: CognitoUserPoolResource -> TF.Argument "admin_create_user_config" Text)
             (\s a -> s { _admin_create_user_config = a } :: CognitoUserPoolResource)

instance HasAliasAttributes CognitoUserPoolResource Text where
    aliasAttributes =
        lens (_alias_attributes :: CognitoUserPoolResource -> TF.Argument "alias_attributes" Text)
             (\s a -> s { _alias_attributes = a } :: CognitoUserPoolResource)

instance HasAutoVerifiedAttributes CognitoUserPoolResource Text where
    autoVerifiedAttributes =
        lens (_auto_verified_attributes :: CognitoUserPoolResource -> TF.Argument "auto_verified_attributes" Text)
             (\s a -> s { _auto_verified_attributes = a } :: CognitoUserPoolResource)

instance HasDeviceConfiguration CognitoUserPoolResource Text where
    deviceConfiguration =
        lens (_device_configuration :: CognitoUserPoolResource -> TF.Argument "device_configuration" Text)
             (\s a -> s { _device_configuration = a } :: CognitoUserPoolResource)

instance HasEmailConfiguration CognitoUserPoolResource Text where
    emailConfiguration =
        lens (_email_configuration :: CognitoUserPoolResource -> TF.Argument "email_configuration" Text)
             (\s a -> s { _email_configuration = a } :: CognitoUserPoolResource)

instance HasEmailVerificationMessage CognitoUserPoolResource Text where
    emailVerificationMessage =
        lens (_email_verification_message :: CognitoUserPoolResource -> TF.Argument "email_verification_message" Text)
             (\s a -> s { _email_verification_message = a } :: CognitoUserPoolResource)

instance HasEmailVerificationSubject CognitoUserPoolResource Text where
    emailVerificationSubject =
        lens (_email_verification_subject :: CognitoUserPoolResource -> TF.Argument "email_verification_subject" Text)
             (\s a -> s { _email_verification_subject = a } :: CognitoUserPoolResource)

instance HasLambdaConfig CognitoUserPoolResource Text where
    lambdaConfig =
        lens (_lambda_config :: CognitoUserPoolResource -> TF.Argument "lambda_config" Text)
             (\s a -> s { _lambda_config = a } :: CognitoUserPoolResource)

instance HasMfaConfiguration CognitoUserPoolResource Text where
    mfaConfiguration =
        lens (_mfa_configuration :: CognitoUserPoolResource -> TF.Argument "mfa_configuration" Text)
             (\s a -> s { _mfa_configuration = a } :: CognitoUserPoolResource)

instance HasName CognitoUserPoolResource Text where
    name =
        lens (_name :: CognitoUserPoolResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: CognitoUserPoolResource)

instance HasPasswordPolicy CognitoUserPoolResource Text where
    passwordPolicy =
        lens (_password_policy :: CognitoUserPoolResource -> TF.Argument "password_policy" Text)
             (\s a -> s { _password_policy = a } :: CognitoUserPoolResource)

instance HasSchema CognitoUserPoolResource Text where
    schema =
        lens (_schema :: CognitoUserPoolResource -> TF.Argument "schema" Text)
             (\s a -> s { _schema = a } :: CognitoUserPoolResource)

instance HasSmsAuthenticationMessage CognitoUserPoolResource Text where
    smsAuthenticationMessage =
        lens (_sms_authentication_message :: CognitoUserPoolResource -> TF.Argument "sms_authentication_message" Text)
             (\s a -> s { _sms_authentication_message = a } :: CognitoUserPoolResource)

instance HasSmsConfiguration CognitoUserPoolResource Text where
    smsConfiguration =
        lens (_sms_configuration :: CognitoUserPoolResource -> TF.Argument "sms_configuration" Text)
             (\s a -> s { _sms_configuration = a } :: CognitoUserPoolResource)

instance HasSmsVerificationMessage CognitoUserPoolResource Text where
    smsVerificationMessage =
        lens (_sms_verification_message :: CognitoUserPoolResource -> TF.Argument "sms_verification_message" Text)
             (\s a -> s { _sms_verification_message = a } :: CognitoUserPoolResource)

instance HasTags CognitoUserPoolResource TF.Tags where
    tags =
        lens (_tags :: CognitoUserPoolResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: CognitoUserPoolResource)

instance HasUsernameAttributes CognitoUserPoolResource Text where
    usernameAttributes =
        lens (_username_attributes :: CognitoUserPoolResource -> TF.Argument "username_attributes" Text)
             (\s a -> s { _username_attributes = a } :: CognitoUserPoolResource)

instance HasVerificationMessageTemplate CognitoUserPoolResource Text where
    verificationMessageTemplate =
        lens (_verification_message_template :: CognitoUserPoolResource -> TF.Argument "verification_message_template" Text)
             (\s a -> s { _verification_message_template = a } :: CognitoUserPoolResource)

cognitoUserPoolResource :: TF.Resource TF.AWS CognitoUserPoolResource
cognitoUserPoolResource =
    TF.newResource "aws_cognito_user_pool" $
        CognitoUserPoolResource {
            _admin_create_user_config = TF.Nil
            , _alias_attributes = TF.Nil
            , _auto_verified_attributes = TF.Nil
            , _device_configuration = TF.Nil
            , _email_configuration = TF.Nil
            , _email_verification_message = TF.Nil
            , _email_verification_subject = TF.Nil
            , _lambda_config = TF.Nil
            , _mfa_configuration = TF.Nil
            , _name = TF.Nil
            , _password_policy = TF.Nil
            , _schema = TF.Nil
            , _sms_authentication_message = TF.Nil
            , _sms_configuration = TF.Nil
            , _sms_verification_message = TF.Nil
            , _tags = TF.Nil
            , _username_attributes = TF.Nil
            , _verification_message_template = TF.Nil
            }

{- | The @aws_config_config_rule@ AWS resource.

Provides an AWS Config Rule. ~> Note: Config Rule requires an existing
</docs/providers/aws/r/config_configuration_recorder.html> to be present.
Use of @depends_on@ is recommended (as shown below) to avoid race
conditions.
-}
data ConfigConfigRuleResource = ConfigConfigRuleResource {
      _description :: !(TF.Argument "description" Text)
    {- ^ (Optional) Description of the rule -}
    , _input_parameters :: !(TF.Argument "input_parameters" Text)
    {- ^ (Optional) A string in JSON format that is passed to the AWS Config rule Lambda function. -}
    , _maximum_execution_frequency :: !(TF.Argument "maximum_execution_frequency" Text)
    {- ^ (Optional) The maximum frequency with which AWS Config runs evaluations for a rule. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the rule -}
    , _scope :: !(TF.Argument "scope" Text)
    {- ^ (Optional) Scope defines which resources can trigger an evaluation for the rule as documented below. -}
    , _source :: !(TF.Argument "source" Text)
    {- ^ (Required) Source specifies the rule owner, the rule identifier, and the notifications that cause the function to evaluate your AWS resources as documented below. -}
    } deriving (Show, Eq)

instance TF.ToHCL ConfigConfigRuleResource where
    toHCL ConfigConfigRuleResource{..} = TF.block $ catMaybes
        [ TF.argument _description
        , TF.argument _input_parameters
        , TF.argument _maximum_execution_frequency
        , TF.argument _name
        , TF.argument _scope
        , TF.argument _source
        ]

instance HasDescription ConfigConfigRuleResource Text where
    description =
        lens (_description :: ConfigConfigRuleResource -> TF.Argument "description" Text)
             (\s a -> s { _description = a } :: ConfigConfigRuleResource)

instance HasInputParameters ConfigConfigRuleResource Text where
    inputParameters =
        lens (_input_parameters :: ConfigConfigRuleResource -> TF.Argument "input_parameters" Text)
             (\s a -> s { _input_parameters = a } :: ConfigConfigRuleResource)

instance HasMaximumExecutionFrequency ConfigConfigRuleResource Text where
    maximumExecutionFrequency =
        lens (_maximum_execution_frequency :: ConfigConfigRuleResource -> TF.Argument "maximum_execution_frequency" Text)
             (\s a -> s { _maximum_execution_frequency = a } :: ConfigConfigRuleResource)

instance HasName ConfigConfigRuleResource Text where
    name =
        lens (_name :: ConfigConfigRuleResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: ConfigConfigRuleResource)

instance HasScope ConfigConfigRuleResource Text where
    scope =
        lens (_scope :: ConfigConfigRuleResource -> TF.Argument "scope" Text)
             (\s a -> s { _scope = a } :: ConfigConfigRuleResource)

instance HasSource ConfigConfigRuleResource Text where
    source =
        lens (_source :: ConfigConfigRuleResource -> TF.Argument "source" Text)
             (\s a -> s { _source = a } :: ConfigConfigRuleResource)

configConfigRuleResource :: TF.Resource TF.AWS ConfigConfigRuleResource
configConfigRuleResource =
    TF.newResource "aws_config_config_rule" $
        ConfigConfigRuleResource {
            _description = TF.Nil
            , _input_parameters = TF.Nil
            , _maximum_execution_frequency = TF.Nil
            , _name = TF.Nil
            , _scope = TF.Nil
            , _source = TF.Nil
            }

{- | The @aws_config_configuration_recorder@ AWS resource.

Provides an AWS Config Configuration Recorder. Please note that this
resource does not start the created recorder automatically. ~> Note:
Starting the Configuration Recorder requires a
</docs/providers/aws/r/config_delivery_channel.html> (while delivery channel
creation requires Configuration Recorder). This is why
</docs/providers/aws/r/config_configuration_recorder_status.html> is a
separate resource.
-}
data ConfigConfigurationRecorderResource = ConfigConfigurationRecorderResource {
      _name :: !(TF.Argument "name" Text)
    {- ^ (Optional) The name of the recorder. Defaults to @default@ . Changing it recreates the resource. -}
    , _recording_group :: !(TF.Argument "recording_group" Text)
    {- ^ (Optional) Recording group - see below. -}
    , _role_arn :: !(TF.Argument "role_arn" Text)
    {- ^ (Required) Amazon Resource Name (ARN) of the IAM role. used to make read or write requests to the delivery channel and to describe the AWS resources associated with the account. See <http://docs.aws.amazon.com/config/latest/developerguide/iamrole-permissions.html> for more details. -}
    } deriving (Show, Eq)

instance TF.ToHCL ConfigConfigurationRecorderResource where
    toHCL ConfigConfigurationRecorderResource{..} = TF.block $ catMaybes
        [ TF.argument _name
        , TF.argument _recording_group
        , TF.argument _role_arn
        ]

instance HasName ConfigConfigurationRecorderResource Text where
    name =
        lens (_name :: ConfigConfigurationRecorderResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: ConfigConfigurationRecorderResource)

instance HasRecordingGroup ConfigConfigurationRecorderResource Text where
    recordingGroup =
        lens (_recording_group :: ConfigConfigurationRecorderResource -> TF.Argument "recording_group" Text)
             (\s a -> s { _recording_group = a } :: ConfigConfigurationRecorderResource)

instance HasRoleArn ConfigConfigurationRecorderResource Text where
    roleArn =
        lens (_role_arn :: ConfigConfigurationRecorderResource -> TF.Argument "role_arn" Text)
             (\s a -> s { _role_arn = a } :: ConfigConfigurationRecorderResource)

configConfigurationRecorderResource :: TF.Resource TF.AWS ConfigConfigurationRecorderResource
configConfigurationRecorderResource =
    TF.newResource "aws_config_configuration_recorder" $
        ConfigConfigurationRecorderResource {
            _name = TF.Nil
            , _recording_group = TF.Nil
            , _role_arn = TF.Nil
            }

{- | The @aws_config_configuration_recorder_status@ AWS resource.

Manages status (recording / stopped) of an AWS Config Configuration
Recorder. ~> Note: Starting Configuration Recorder requires a
</docs/providers/aws/r/config_delivery_channel.html> to be present. Use of
@depends_on@ (as shown below) is recommended to avoid race conditions.
-}
data ConfigConfigurationRecorderStatusResource = ConfigConfigurationRecorderStatusResource {
      _is_enabled :: !(TF.Argument "is_enabled" TF.Bool)
    {- ^ (Required) Whether the configuration recorder should be enabled or disabled. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the recorder -}
    } deriving (Show, Eq)

instance TF.ToHCL ConfigConfigurationRecorderStatusResource where
    toHCL ConfigConfigurationRecorderStatusResource{..} = TF.block $ catMaybes
        [ TF.argument _is_enabled
        , TF.argument _name
        ]

instance HasIsEnabled ConfigConfigurationRecorderStatusResource TF.Bool where
    isEnabled =
        lens (_is_enabled :: ConfigConfigurationRecorderStatusResource -> TF.Argument "is_enabled" TF.Bool)
             (\s a -> s { _is_enabled = a } :: ConfigConfigurationRecorderStatusResource)

instance HasName ConfigConfigurationRecorderStatusResource Text where
    name =
        lens (_name :: ConfigConfigurationRecorderStatusResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: ConfigConfigurationRecorderStatusResource)

configConfigurationRecorderStatusResource :: TF.Resource TF.AWS ConfigConfigurationRecorderStatusResource
configConfigurationRecorderStatusResource =
    TF.newResource "aws_config_configuration_recorder_status" $
        ConfigConfigurationRecorderStatusResource {
            _is_enabled = TF.Nil
            , _name = TF.Nil
            }

{- | The @aws_config_delivery_channel@ AWS resource.

Provides an AWS Config Delivery Channel. ~> Note: Delivery Channel requires
a </docs/providers/aws/r/config_configuration_recorder.html> to be present.
Use of @depends_on@ (as shown below) is recommended to avoid race
conditions.
-}
data ConfigDeliveryChannelResource = ConfigDeliveryChannelResource {
      _name :: !(TF.Argument "name" Text)
    {- ^ (Optional) The name of the delivery channel. Defaults to @default@ . Changing it recreates the resource. -}
    , _s3_bucket_name :: !(TF.Argument "s3_bucket_name" Text)
    {- ^ (Required) The name of the S3 bucket used to store the configuration history. -}
    , _s3_key_prefix :: !(TF.Argument "s3_key_prefix" Text)
    {- ^ (Optional) The prefix for the specified S3 bucket. -}
    , _snapshot_delivery_properties :: !(TF.Argument "snapshot_delivery_properties" Text)
    {- ^ (Optional) Options for how AWS Config delivers configuration snapshots. See below -}
    , _sns_topic_arn :: !(TF.Argument "sns_topic_arn" Text)
    {- ^ (Optional) The ARN of the SNS topic that AWS Config delivers notifications to. -}
    } deriving (Show, Eq)

instance TF.ToHCL ConfigDeliveryChannelResource where
    toHCL ConfigDeliveryChannelResource{..} = TF.block $ catMaybes
        [ TF.argument _name
        , TF.argument _s3_bucket_name
        , TF.argument _s3_key_prefix
        , TF.argument _snapshot_delivery_properties
        , TF.argument _sns_topic_arn
        ]

instance HasName ConfigDeliveryChannelResource Text where
    name =
        lens (_name :: ConfigDeliveryChannelResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: ConfigDeliveryChannelResource)

instance HasS3BucketName ConfigDeliveryChannelResource Text where
    s3BucketName =
        lens (_s3_bucket_name :: ConfigDeliveryChannelResource -> TF.Argument "s3_bucket_name" Text)
             (\s a -> s { _s3_bucket_name = a } :: ConfigDeliveryChannelResource)

instance HasS3KeyPrefix ConfigDeliveryChannelResource Text where
    s3KeyPrefix =
        lens (_s3_key_prefix :: ConfigDeliveryChannelResource -> TF.Argument "s3_key_prefix" Text)
             (\s a -> s { _s3_key_prefix = a } :: ConfigDeliveryChannelResource)

instance HasSnapshotDeliveryProperties ConfigDeliveryChannelResource Text where
    snapshotDeliveryProperties =
        lens (_snapshot_delivery_properties :: ConfigDeliveryChannelResource -> TF.Argument "snapshot_delivery_properties" Text)
             (\s a -> s { _snapshot_delivery_properties = a } :: ConfigDeliveryChannelResource)

instance HasSnsTopicArn ConfigDeliveryChannelResource Text where
    snsTopicArn =
        lens (_sns_topic_arn :: ConfigDeliveryChannelResource -> TF.Argument "sns_topic_arn" Text)
             (\s a -> s { _sns_topic_arn = a } :: ConfigDeliveryChannelResource)

configDeliveryChannelResource :: TF.Resource TF.AWS ConfigDeliveryChannelResource
configDeliveryChannelResource =
    TF.newResource "aws_config_delivery_channel" $
        ConfigDeliveryChannelResource {
            _name = TF.Nil
            , _s3_bucket_name = TF.Nil
            , _s3_key_prefix = TF.Nil
            , _snapshot_delivery_properties = TF.Nil
            , _sns_topic_arn = TF.Nil
            }

{- | The @aws_customer_gateway@ AWS resource.

Provides a customer gateway inside a VPC. These objects can be connected to
VPN gateways via VPN connections, and allow you to establish tunnels between
your network and the VPC.
-}
data CustomerGatewayResource = CustomerGatewayResource {
      _bgp_asn :: !(TF.Argument "bgp_asn" Text)
    {- ^ (Required) The gateway's Border Gateway Protocol (BGP) Autonomous System Number (ASN). -}
    , _ip_address :: !(TF.Argument "ip_address" Text)
    {- ^ (Required) The IP address of the gateway's Internet-routable external interface. -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) Tags to apply to the gateway. -}
    , _type' :: !(TF.Argument "type" Text)
    {- ^ (Required) The type of customer gateway. The only type AWS supports at this time is "ipsec.1". -}
    } deriving (Show, Eq)

instance TF.ToHCL CustomerGatewayResource where
    toHCL CustomerGatewayResource{..} = TF.block $ catMaybes
        [ TF.argument _bgp_asn
        , TF.argument _ip_address
        , TF.argument _tags
        , TF.argument _type'
        ]

instance HasBgpAsn CustomerGatewayResource Text where
    bgpAsn =
        lens (_bgp_asn :: CustomerGatewayResource -> TF.Argument "bgp_asn" Text)
             (\s a -> s { _bgp_asn = a } :: CustomerGatewayResource)

instance HasIpAddress CustomerGatewayResource Text where
    ipAddress =
        lens (_ip_address :: CustomerGatewayResource -> TF.Argument "ip_address" Text)
             (\s a -> s { _ip_address = a } :: CustomerGatewayResource)

instance HasTags CustomerGatewayResource TF.Tags where
    tags =
        lens (_tags :: CustomerGatewayResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: CustomerGatewayResource)

instance HasType' CustomerGatewayResource Text where
    type' =
        lens (_type' :: CustomerGatewayResource -> TF.Argument "type" Text)
             (\s a -> s { _type' = a } :: CustomerGatewayResource)

instance HasComputedBgpAsn CustomerGatewayResource Text where
    computedBgpAsn =
        to (\_  -> TF.Compute "bgp_asn")

instance HasComputedId CustomerGatewayResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedIpAddress CustomerGatewayResource Text where
    computedIpAddress =
        to (\_  -> TF.Compute "ip_address")

instance HasComputedTags CustomerGatewayResource TF.Tags where
    computedTags =
        to (\_  -> TF.Compute "tags")

instance HasComputedType' CustomerGatewayResource Text where
    computedType' =
        to (\_  -> TF.Compute "type")

customerGatewayResource :: TF.Resource TF.AWS CustomerGatewayResource
customerGatewayResource =
    TF.newResource "aws_customer_gateway" $
        CustomerGatewayResource {
            _bgp_asn = TF.Nil
            , _ip_address = TF.Nil
            , _tags = TF.Nil
            , _type' = TF.Nil
            }

{- | The @aws_db_event_subscription@ AWS resource.

Provides a DB event subscription resource.
-}
data DbEventSubscriptionResource = DbEventSubscriptionResource {
      _enabled :: !(TF.Argument "enabled" TF.Bool)
    {- ^ (Optional) A boolean flag to enable/disable the subscription. Defaults to true. -}
    , _event_categories :: !(TF.Argument "event_categories" Text)
    {- ^ (Optional) A list of event categories for a SourceType that you want to subscribe to. See http://docs.aws.amazon.com/AmazonRDS/latest/UserGuide//USER_Events.html -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the DB event subscription. -}
    , _sns_topic :: !(TF.Argument "sns_topic" Text)
    {- ^ (Required) The SNS topic to send events to. -}
    , _source_ids :: !(TF.Argument "source_ids" Text)
    {- ^ (Optional) A list of identifiers of the event sources for which events will be returned. If not specified, then all sources are included in the response. If specified, a source_type must also be specified. -}
    , _source_type :: !(TF.Argument "source_type" Text)
    {- ^ (Optional) The type of source that will be generating the events. -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    } deriving (Show, Eq)

instance TF.ToHCL DbEventSubscriptionResource where
    toHCL DbEventSubscriptionResource{..} = TF.block $ catMaybes
        [ TF.argument _enabled
        , TF.argument _event_categories
        , TF.argument _name
        , TF.argument _sns_topic
        , TF.argument _source_ids
        , TF.argument _source_type
        , TF.argument _tags
        ]

instance HasEnabled DbEventSubscriptionResource TF.Bool where
    enabled =
        lens (_enabled :: DbEventSubscriptionResource -> TF.Argument "enabled" TF.Bool)
             (\s a -> s { _enabled = a } :: DbEventSubscriptionResource)

instance HasEventCategories DbEventSubscriptionResource Text where
    eventCategories =
        lens (_event_categories :: DbEventSubscriptionResource -> TF.Argument "event_categories" Text)
             (\s a -> s { _event_categories = a } :: DbEventSubscriptionResource)

instance HasName DbEventSubscriptionResource Text where
    name =
        lens (_name :: DbEventSubscriptionResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: DbEventSubscriptionResource)

instance HasSnsTopic DbEventSubscriptionResource Text where
    snsTopic =
        lens (_sns_topic :: DbEventSubscriptionResource -> TF.Argument "sns_topic" Text)
             (\s a -> s { _sns_topic = a } :: DbEventSubscriptionResource)

instance HasSourceIds DbEventSubscriptionResource Text where
    sourceIds =
        lens (_source_ids :: DbEventSubscriptionResource -> TF.Argument "source_ids" Text)
             (\s a -> s { _source_ids = a } :: DbEventSubscriptionResource)

instance HasSourceType DbEventSubscriptionResource Text where
    sourceType =
        lens (_source_type :: DbEventSubscriptionResource -> TF.Argument "source_type" Text)
             (\s a -> s { _source_type = a } :: DbEventSubscriptionResource)

instance HasTags DbEventSubscriptionResource TF.Tags where
    tags =
        lens (_tags :: DbEventSubscriptionResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: DbEventSubscriptionResource)

dbEventSubscriptionResource :: TF.Resource TF.AWS DbEventSubscriptionResource
dbEventSubscriptionResource =
    TF.newResource "aws_db_event_subscription" $
        DbEventSubscriptionResource {
            _enabled = TF.Nil
            , _event_categories = TF.Nil
            , _name = TF.Nil
            , _sns_topic = TF.Nil
            , _source_ids = TF.Nil
            , _source_type = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_db_instance@ AWS resource.

Provides an RDS instance resource.  A DB instance is an isolated database
environment in the cloud.  A DB instance can contain multiple user-created
databases. Changes to a DB instance can occur when you manually change a
parameter, such as @allocated_storage@ , and are reflected in the next
maintenance window. Because of this, Terraform may report a difference in
its planning phase because a modification has not yet taken place. You can
use the @apply_immediately@ flag to instruct the service to apply the change
immediately (see documentation below). When upgrading the major version of
an engine, @allow_major_version_upgrade@ must be set to @true@ . ~> Note:
using @apply_immediately@ can result in a brief downtime as the server
reboots. See the AWS Docs on
<https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_UpgradeDBInstance.Maintenance.html>
for more information. ~> Note: All arguments including the username and
password will be stored in the raw state as plain-text.
</docs/state/sensitive-data.html> .
-}
data DbInstanceResource = DbInstanceResource {
      _allocated_storage :: !(TF.Argument "allocated_storage" Text)
    {- ^ (Required unless a @snapshot_identifier@ or @replicate_source_db@ is provided) The allocated storage in gigabytes. -}
    , _allow_major_version_upgrade :: !(TF.Argument "allow_major_version_upgrade" Text)
    {- ^ (Optional) Indicates that major version upgrades are allowed. Changing this parameter does not result in an outage and the change is asynchronously applied as soon as possible. -}
    , _apply_immediately :: !(TF.Argument "apply_immediately" Text)
    {- ^ (Optional) Specifies whether any database modifications are applied immediately, or during the next maintenance window. Default is @false@ . See <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Overview.DBInstance.Modifying.html> for more information. -}
    , _auto_minor_version_upgrade :: !(TF.Argument "auto_minor_version_upgrade" Text)
    {- ^ (Optional) Indicates that minor engine upgrades will be applied automatically to the DB instance during the maintenance window. Defaults to true. -}
    , _availability_zone :: !(TF.Argument "availability_zone" TF.Zone)
    {- ^ (Optional) The AZ for the RDS instance. -}
    , _backup_retention_period :: !(TF.Argument "backup_retention_period" Text)
    {- ^ (Optional) The days to retain backups for. Must be @1@ or greater to be a source for a <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Overview.Replication.html> . -}
    , _backup_window :: !(TF.Argument "backup_window" Text)
    {- ^ (Optional) The daily time range (in UTC) during which automated backups are created if they are enabled. Example: "09:46-10:16". Must not overlap with @maintenance_window@ . -}
    , _character_set_name :: !(TF.Argument "character_set_name" Text)
    {- ^ (Optional) The character set name to use for DB encoding in Oracle instances. This can't be changed. See <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Appendix.OracleCharacterSets.html> for more information. -}
    , _copy_tags_to_snapshot :: !(TF.Argument "copy_tags_to_snapshot" Text)
    {- ^  (Optional, boolean) On delete, copy all Instance @tags@ to the final snapshot (if @final_snapshot_identifier@ is specified). Default is @false@ . -}
    , _db_subnet_group_name :: !(TF.Argument "db_subnet_group_name" Text)
    {- ^ (Optional) Name of DB subnet group. DB instance will be created in the VPC associated with the DB subnet group. If unspecified, will be created in the @default@ VPC, or in EC2 Classic, if available. -}
    , _engine :: !(TF.Argument "engine" Text)
    {- ^ (Required unless a @snapshot_identifier@ or @replicate_source_db@ is provided) The database engine to use. -}
    , _engine_version :: !(TF.Argument "engine_version" Text)
    {- ^ (Optional) The engine version to use. -}
    , _final_snapshot_identifier :: !(TF.Argument "final_snapshot_identifier" Text)
    {- ^ (Optional) The name of your final DB snapshot when this DB instance is deleted. If omitted, no final snapshot will be made. -}
    , _iam_database_authentication_enabled :: !(TF.Argument "iam_database_authentication_enabled" TF.Bool)
    {- ^ (Optional) Specifies whether or mappings of AWS Identity and Access Management (IAM) accounts to database accounts is enabled. -}
    , _identifier :: !(TF.Argument "identifier" Text)
    {- ^ (Optional, Forces new resource) The name of the RDS instance, if omitted, Terraform will assign a random, unique identifier. -}
    , _identifier_prefix :: !(TF.Argument "identifier_prefix" Text)
    {- ^ (Optional, Forces new resource) Creates a unique identifier beginning with the specified prefix. Conflicts with @identifer@ . -}
    , _instance_class :: !(TF.Argument "instance_class" Text)
    {- ^ (Required) The instance type of the RDS instance. -}
    , _iops :: !(TF.Argument "iops" Text)
    {- ^ (Optional) The amount of provisioned IOPS. Setting this implies a storage_type of "io1". -}
    , _kms_key_id :: !(TF.Argument "kms_key_id" Text)
    {- ^ (Optional) The ARN for the KMS encryption key. If creating an encrypted replica, set this to the destination KMS ARN. -}
    , _license_model :: !(TF.Argument "license_model" Text)
    {- ^ (Optional, but required for some DB engines, i.e. Oracle SE1) License model information for this DB instance. -}
    , _maintenance_window :: !(TF.Argument "maintenance_window" Text)
    {- ^ (Optional) The window to perform maintenance in. Syntax: "ddd:hh24:mi-ddd:hh24:mi". Eg: "Mon:00:00-Mon:03:00". See <http://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_UpgradeDBInstance.Maintenance.html#AdjustingTheMaintenanceWindow> for more information. -}
    , _monitoring_interval :: !(TF.Argument "monitoring_interval" Text)
    {- ^ (Optional) The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB instance. To disable collecting Enhanced Monitoring metrics, specify 0. The default is 0. Valid Values: 0, 1, 5, 10, 15, 30, 60. -}
    , _monitoring_role_arn :: !(TF.Argument "monitoring_role_arn" Text)
    {- ^ (Optional) The ARN for the IAM role that permits RDS to send enhanced monitoring metrics to CloudWatch Logs. You can find more information on the <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Monitoring.html> what IAM permissions are needed to allow Enhanced Monitoring for RDS Instances. -}
    , _multi_az :: !(TF.Argument "multi_az" Text)
    {- ^ (Optional) Specifies if the RDS instance is multi-AZ -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Optional) The name of the database to create when the DB instance is created. If this parameter is not specified, no database is created in the DB instance. Note that this does not apply for Oracle or SQL Server engines. See the <http://docs.aws.amazon.com/cli/latest/reference/rds/create-db-instance.html> for more details on what applies for those engines. -}
    , _option_group_name :: !(TF.Argument "option_group_name" Text)
    {- ^ (Optional) Name of the DB option group to associate. -}
    , _parameter_group_name :: !(TF.Argument "parameter_group_name" Text)
    {- ^ (Optional) Name of the DB parameter group to associate. -}
    , _password :: !(TF.Argument "password" Text)
    {- ^ (Required unless a @snapshot_identifier@ or @replicate_source_db@ is provided) Password for the master DB user. Note that this may show up in logs, and it will be stored in the state file. -}
    , _port :: !(TF.Argument "port" Text)
    {- ^ (Optional) The port on which the DB accepts connections. -}
    , _publicly_accessible :: !(TF.Argument "publicly_accessible" Text)
    {- ^ (Optional) Bool to control if instance is publicly accessible. Default is @false@ . -}
    , _replicate_source_db :: !(TF.Argument "replicate_source_db" Text)
    {- ^ (Optional) Specifies that this resource is a Replicate database, and to use this value as the source database. This correlates to the @identifier@ of another Amazon RDS Database to replicate. See <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Overview.Replication.html> and <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_ReadRepl.html> for more information on using Replication. -}
    , _security_group_names :: !(TF.Argument "security_group_names" Text)
    {- ^ (Optional/Deprecated) List of DB Security Groups to associate. Only used for <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_VPC.html#USER_VPC.FindDefaultVPC> . -}
    , _skip_final_snapshot :: !(TF.Argument "skip_final_snapshot" Text)
    {- ^ (Optional) Determines whether a final DB snapshot is created before the DB instance is deleted. If true is specified, no DBSnapshot is created. If false is specified, a DB snapshot is created before the DB instance is deleted, using the value from @final_snapshot_identifier@ . Default is @false@ . -}
    , _snapshot_identifier :: !(TF.Argument "snapshot_identifier" Text)
    {- ^ (Optional) Specifies whether or not to create this database from a snapshot. This correlates to the snapshot ID you'd find in the RDS console, e.g: rds:production-2015-06-26-06-05. -}
    , _storage_encrypted :: !(TF.Argument "storage_encrypted" Text)
    {- ^ (Optional) Specifies whether the DB instance is encrypted. The default is @false@ if not specified. -}
    , _storage_type :: !(TF.Argument "storage_type" Text)
    {- ^ (Optional) One of "standard" (magnetic), "gp2" (general purpose SSD), or "io1" (provisioned IOPS SSD). The default is "io1" if @iops@ is specified, "standard" if not. Note that this behaviour is different from the AWS web console, where the default is "gp2". -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    , _timezone :: !(TF.Argument "timezone" Text)
    {- ^ (Optional) Time zone of the DB instance. @timezone@ is currently only supported by Microsoft SQL Server. The @timezone@ can only be set on creation. See <http://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_SQLServer.html#SQLServer.Concepts.General.TimeZone> for more information. -}
    , _username :: !(TF.Argument "username" Text)
    {- ^ (Required unless a @snapshot_identifier@ or @replicate_source_db@ is provided) Username for the master DB user. -}
    , _vpc_security_group_ids :: !(TF.Argument "vpc_security_group_ids" Text)
    {- ^ (Optional) List of VPC security groups to associate. -}
    } deriving (Show, Eq)

instance TF.ToHCL DbInstanceResource where
    toHCL DbInstanceResource{..} = TF.block $ catMaybes
        [ TF.argument _allocated_storage
        , TF.argument _allow_major_version_upgrade
        , TF.argument _apply_immediately
        , TF.argument _auto_minor_version_upgrade
        , TF.argument _availability_zone
        , TF.argument _backup_retention_period
        , TF.argument _backup_window
        , TF.argument _character_set_name
        , TF.argument _copy_tags_to_snapshot
        , TF.argument _db_subnet_group_name
        , TF.argument _engine
        , TF.argument _engine_version
        , TF.argument _final_snapshot_identifier
        , TF.argument _iam_database_authentication_enabled
        , TF.argument _identifier
        , TF.argument _identifier_prefix
        , TF.argument _instance_class
        , TF.argument _iops
        , TF.argument _kms_key_id
        , TF.argument _license_model
        , TF.argument _maintenance_window
        , TF.argument _monitoring_interval
        , TF.argument _monitoring_role_arn
        , TF.argument _multi_az
        , TF.argument _name
        , TF.argument _option_group_name
        , TF.argument _parameter_group_name
        , TF.argument _password
        , TF.argument _port
        , TF.argument _publicly_accessible
        , TF.argument _replicate_source_db
        , TF.argument _security_group_names
        , TF.argument _skip_final_snapshot
        , TF.argument _snapshot_identifier
        , TF.argument _storage_encrypted
        , TF.argument _storage_type
        , TF.argument _tags
        , TF.argument _timezone
        , TF.argument _username
        , TF.argument _vpc_security_group_ids
        ]

instance HasAllocatedStorage DbInstanceResource Text where
    allocatedStorage =
        lens (_allocated_storage :: DbInstanceResource -> TF.Argument "allocated_storage" Text)
             (\s a -> s { _allocated_storage = a } :: DbInstanceResource)

instance HasAllowMajorVersionUpgrade DbInstanceResource Text where
    allowMajorVersionUpgrade =
        lens (_allow_major_version_upgrade :: DbInstanceResource -> TF.Argument "allow_major_version_upgrade" Text)
             (\s a -> s { _allow_major_version_upgrade = a } :: DbInstanceResource)

instance HasApplyImmediately DbInstanceResource Text where
    applyImmediately =
        lens (_apply_immediately :: DbInstanceResource -> TF.Argument "apply_immediately" Text)
             (\s a -> s { _apply_immediately = a } :: DbInstanceResource)

instance HasAutoMinorVersionUpgrade DbInstanceResource Text where
    autoMinorVersionUpgrade =
        lens (_auto_minor_version_upgrade :: DbInstanceResource -> TF.Argument "auto_minor_version_upgrade" Text)
             (\s a -> s { _auto_minor_version_upgrade = a } :: DbInstanceResource)

instance HasAvailabilityZone DbInstanceResource TF.Zone where
    availabilityZone =
        lens (_availability_zone :: DbInstanceResource -> TF.Argument "availability_zone" TF.Zone)
             (\s a -> s { _availability_zone = a } :: DbInstanceResource)

instance HasBackupRetentionPeriod DbInstanceResource Text where
    backupRetentionPeriod =
        lens (_backup_retention_period :: DbInstanceResource -> TF.Argument "backup_retention_period" Text)
             (\s a -> s { _backup_retention_period = a } :: DbInstanceResource)

instance HasBackupWindow DbInstanceResource Text where
    backupWindow =
        lens (_backup_window :: DbInstanceResource -> TF.Argument "backup_window" Text)
             (\s a -> s { _backup_window = a } :: DbInstanceResource)

instance HasCharacterSetName DbInstanceResource Text where
    characterSetName =
        lens (_character_set_name :: DbInstanceResource -> TF.Argument "character_set_name" Text)
             (\s a -> s { _character_set_name = a } :: DbInstanceResource)

instance HasCopyTagsToSnapshot DbInstanceResource Text where
    copyTagsToSnapshot =
        lens (_copy_tags_to_snapshot :: DbInstanceResource -> TF.Argument "copy_tags_to_snapshot" Text)
             (\s a -> s { _copy_tags_to_snapshot = a } :: DbInstanceResource)

instance HasDbSubnetGroupName DbInstanceResource Text where
    dbSubnetGroupName =
        lens (_db_subnet_group_name :: DbInstanceResource -> TF.Argument "db_subnet_group_name" Text)
             (\s a -> s { _db_subnet_group_name = a } :: DbInstanceResource)

instance HasEngine DbInstanceResource Text where
    engine =
        lens (_engine :: DbInstanceResource -> TF.Argument "engine" Text)
             (\s a -> s { _engine = a } :: DbInstanceResource)

instance HasEngineVersion DbInstanceResource Text where
    engineVersion =
        lens (_engine_version :: DbInstanceResource -> TF.Argument "engine_version" Text)
             (\s a -> s { _engine_version = a } :: DbInstanceResource)

instance HasFinalSnapshotIdentifier DbInstanceResource Text where
    finalSnapshotIdentifier =
        lens (_final_snapshot_identifier :: DbInstanceResource -> TF.Argument "final_snapshot_identifier" Text)
             (\s a -> s { _final_snapshot_identifier = a } :: DbInstanceResource)

instance HasIamDatabaseAuthenticationEnabled DbInstanceResource TF.Bool where
    iamDatabaseAuthenticationEnabled =
        lens (_iam_database_authentication_enabled :: DbInstanceResource -> TF.Argument "iam_database_authentication_enabled" TF.Bool)
             (\s a -> s { _iam_database_authentication_enabled = a } :: DbInstanceResource)

instance HasIdentifier DbInstanceResource Text where
    identifier =
        lens (_identifier :: DbInstanceResource -> TF.Argument "identifier" Text)
             (\s a -> s { _identifier = a } :: DbInstanceResource)

instance HasIdentifierPrefix DbInstanceResource Text where
    identifierPrefix =
        lens (_identifier_prefix :: DbInstanceResource -> TF.Argument "identifier_prefix" Text)
             (\s a -> s { _identifier_prefix = a } :: DbInstanceResource)

instance HasInstanceClass DbInstanceResource Text where
    instanceClass =
        lens (_instance_class :: DbInstanceResource -> TF.Argument "instance_class" Text)
             (\s a -> s { _instance_class = a } :: DbInstanceResource)

instance HasIops DbInstanceResource Text where
    iops =
        lens (_iops :: DbInstanceResource -> TF.Argument "iops" Text)
             (\s a -> s { _iops = a } :: DbInstanceResource)

instance HasKmsKeyId DbInstanceResource Text where
    kmsKeyId =
        lens (_kms_key_id :: DbInstanceResource -> TF.Argument "kms_key_id" Text)
             (\s a -> s { _kms_key_id = a } :: DbInstanceResource)

instance HasLicenseModel DbInstanceResource Text where
    licenseModel =
        lens (_license_model :: DbInstanceResource -> TF.Argument "license_model" Text)
             (\s a -> s { _license_model = a } :: DbInstanceResource)

instance HasMaintenanceWindow DbInstanceResource Text where
    maintenanceWindow =
        lens (_maintenance_window :: DbInstanceResource -> TF.Argument "maintenance_window" Text)
             (\s a -> s { _maintenance_window = a } :: DbInstanceResource)

instance HasMonitoringInterval DbInstanceResource Text where
    monitoringInterval =
        lens (_monitoring_interval :: DbInstanceResource -> TF.Argument "monitoring_interval" Text)
             (\s a -> s { _monitoring_interval = a } :: DbInstanceResource)

instance HasMonitoringRoleArn DbInstanceResource Text where
    monitoringRoleArn =
        lens (_monitoring_role_arn :: DbInstanceResource -> TF.Argument "monitoring_role_arn" Text)
             (\s a -> s { _monitoring_role_arn = a } :: DbInstanceResource)

instance HasMultiAz DbInstanceResource Text where
    multiAz =
        lens (_multi_az :: DbInstanceResource -> TF.Argument "multi_az" Text)
             (\s a -> s { _multi_az = a } :: DbInstanceResource)

instance HasName DbInstanceResource Text where
    name =
        lens (_name :: DbInstanceResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: DbInstanceResource)

instance HasOptionGroupName DbInstanceResource Text where
    optionGroupName =
        lens (_option_group_name :: DbInstanceResource -> TF.Argument "option_group_name" Text)
             (\s a -> s { _option_group_name = a } :: DbInstanceResource)

instance HasParameterGroupName DbInstanceResource Text where
    parameterGroupName =
        lens (_parameter_group_name :: DbInstanceResource -> TF.Argument "parameter_group_name" Text)
             (\s a -> s { _parameter_group_name = a } :: DbInstanceResource)

instance HasPassword DbInstanceResource Text where
    password =
        lens (_password :: DbInstanceResource -> TF.Argument "password" Text)
             (\s a -> s { _password = a } :: DbInstanceResource)

instance HasPort DbInstanceResource Text where
    port =
        lens (_port :: DbInstanceResource -> TF.Argument "port" Text)
             (\s a -> s { _port = a } :: DbInstanceResource)

instance HasPubliclyAccessible DbInstanceResource Text where
    publiclyAccessible =
        lens (_publicly_accessible :: DbInstanceResource -> TF.Argument "publicly_accessible" Text)
             (\s a -> s { _publicly_accessible = a } :: DbInstanceResource)

instance HasReplicateSourceDb DbInstanceResource Text where
    replicateSourceDb =
        lens (_replicate_source_db :: DbInstanceResource -> TF.Argument "replicate_source_db" Text)
             (\s a -> s { _replicate_source_db = a } :: DbInstanceResource)

instance HasSecurityGroupNames DbInstanceResource Text where
    securityGroupNames =
        lens (_security_group_names :: DbInstanceResource -> TF.Argument "security_group_names" Text)
             (\s a -> s { _security_group_names = a } :: DbInstanceResource)

instance HasSkipFinalSnapshot DbInstanceResource Text where
    skipFinalSnapshot =
        lens (_skip_final_snapshot :: DbInstanceResource -> TF.Argument "skip_final_snapshot" Text)
             (\s a -> s { _skip_final_snapshot = a } :: DbInstanceResource)

instance HasSnapshotIdentifier DbInstanceResource Text where
    snapshotIdentifier =
        lens (_snapshot_identifier :: DbInstanceResource -> TF.Argument "snapshot_identifier" Text)
             (\s a -> s { _snapshot_identifier = a } :: DbInstanceResource)

instance HasStorageEncrypted DbInstanceResource Text where
    storageEncrypted =
        lens (_storage_encrypted :: DbInstanceResource -> TF.Argument "storage_encrypted" Text)
             (\s a -> s { _storage_encrypted = a } :: DbInstanceResource)

instance HasStorageType DbInstanceResource Text where
    storageType =
        lens (_storage_type :: DbInstanceResource -> TF.Argument "storage_type" Text)
             (\s a -> s { _storage_type = a } :: DbInstanceResource)

instance HasTags DbInstanceResource TF.Tags where
    tags =
        lens (_tags :: DbInstanceResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: DbInstanceResource)

instance HasTimezone DbInstanceResource Text where
    timezone =
        lens (_timezone :: DbInstanceResource -> TF.Argument "timezone" Text)
             (\s a -> s { _timezone = a } :: DbInstanceResource)

instance HasUsername DbInstanceResource Text where
    username =
        lens (_username :: DbInstanceResource -> TF.Argument "username" Text)
             (\s a -> s { _username = a } :: DbInstanceResource)

instance HasVpcSecurityGroupIds DbInstanceResource Text where
    vpcSecurityGroupIds =
        lens (_vpc_security_group_ids :: DbInstanceResource -> TF.Argument "vpc_security_group_ids" Text)
             (\s a -> s { _vpc_security_group_ids = a } :: DbInstanceResource)

dbInstanceResource :: TF.Resource TF.AWS DbInstanceResource
dbInstanceResource =
    TF.newResource "aws_db_instance" $
        DbInstanceResource {
            _allocated_storage = TF.Nil
            , _allow_major_version_upgrade = TF.Nil
            , _apply_immediately = TF.Nil
            , _auto_minor_version_upgrade = TF.Nil
            , _availability_zone = TF.Nil
            , _backup_retention_period = TF.Nil
            , _backup_window = TF.Nil
            , _character_set_name = TF.Nil
            , _copy_tags_to_snapshot = TF.Nil
            , _db_subnet_group_name = TF.Nil
            , _engine = TF.Nil
            , _engine_version = TF.Nil
            , _final_snapshot_identifier = TF.Nil
            , _iam_database_authentication_enabled = TF.Nil
            , _identifier = TF.Nil
            , _identifier_prefix = TF.Nil
            , _instance_class = TF.Nil
            , _iops = TF.Nil
            , _kms_key_id = TF.Nil
            , _license_model = TF.Nil
            , _maintenance_window = TF.Nil
            , _monitoring_interval = TF.Nil
            , _monitoring_role_arn = TF.Nil
            , _multi_az = TF.Nil
            , _name = TF.Nil
            , _option_group_name = TF.Nil
            , _parameter_group_name = TF.Nil
            , _password = TF.Nil
            , _port = TF.Nil
            , _publicly_accessible = TF.Nil
            , _replicate_source_db = TF.Nil
            , _security_group_names = TF.Nil
            , _skip_final_snapshot = TF.Nil
            , _snapshot_identifier = TF.Nil
            , _storage_encrypted = TF.Nil
            , _storage_type = TF.Nil
            , _tags = TF.Nil
            , _timezone = TF.Nil
            , _username = TF.Nil
            , _vpc_security_group_ids = TF.Nil
            }

{- | The @aws_db_option_group@ AWS resource.

Provides an RDS DB option group resource.
-}
data DbOptionGroupResource = DbOptionGroupResource {
      _engine_name :: !(TF.Argument "engine_name" Text)
    {- ^ (Required) Specifies the name of the engine that this option group should be associated with. -}
    , _major_engine_version :: !(TF.Argument "major_engine_version" Text)
    {- ^ (Required) Specifies the major version of the engine that this option group should be associated with. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Optional, Forces new resource) The name of the option group. If omitted, Terraform will assign a random, unique name. Must be lowercase, to match as it is stored in AWS. -}
    , _name_prefix :: !(TF.Argument "name_prefix" Text)
    {- ^ (Optional, Forces new resource) Creates a unique name beginning with the specified prefix. Conflicts with @name@ . Must be lowercase, to match as it is stored in AWS. -}
    , _option :: !(TF.Argument "option" Text)
    {- ^ (Optional) A list of Options to apply. -}
    , _option_group_description :: !(TF.Argument "option_group_description" Text)
    {- ^ (Optional) The description of the option group. Defaults to "Managed by Terraform". -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    } deriving (Show, Eq)

instance TF.ToHCL DbOptionGroupResource where
    toHCL DbOptionGroupResource{..} = TF.block $ catMaybes
        [ TF.argument _engine_name
        , TF.argument _major_engine_version
        , TF.argument _name
        , TF.argument _name_prefix
        , TF.argument _option
        , TF.argument _option_group_description
        , TF.argument _tags
        ]

instance HasEngineName DbOptionGroupResource Text where
    engineName =
        lens (_engine_name :: DbOptionGroupResource -> TF.Argument "engine_name" Text)
             (\s a -> s { _engine_name = a } :: DbOptionGroupResource)

instance HasMajorEngineVersion DbOptionGroupResource Text where
    majorEngineVersion =
        lens (_major_engine_version :: DbOptionGroupResource -> TF.Argument "major_engine_version" Text)
             (\s a -> s { _major_engine_version = a } :: DbOptionGroupResource)

instance HasName DbOptionGroupResource Text where
    name =
        lens (_name :: DbOptionGroupResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: DbOptionGroupResource)

instance HasNamePrefix DbOptionGroupResource Text where
    namePrefix =
        lens (_name_prefix :: DbOptionGroupResource -> TF.Argument "name_prefix" Text)
             (\s a -> s { _name_prefix = a } :: DbOptionGroupResource)

instance HasOption DbOptionGroupResource Text where
    option =
        lens (_option :: DbOptionGroupResource -> TF.Argument "option" Text)
             (\s a -> s { _option = a } :: DbOptionGroupResource)

instance HasOptionGroupDescription DbOptionGroupResource Text where
    optionGroupDescription =
        lens (_option_group_description :: DbOptionGroupResource -> TF.Argument "option_group_description" Text)
             (\s a -> s { _option_group_description = a } :: DbOptionGroupResource)

instance HasTags DbOptionGroupResource TF.Tags where
    tags =
        lens (_tags :: DbOptionGroupResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: DbOptionGroupResource)

instance HasComputedArn DbOptionGroupResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

instance HasComputedId DbOptionGroupResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

dbOptionGroupResource :: TF.Resource TF.AWS DbOptionGroupResource
dbOptionGroupResource =
    TF.newResource "aws_db_option_group" $
        DbOptionGroupResource {
            _engine_name = TF.Nil
            , _major_engine_version = TF.Nil
            , _name = TF.Nil
            , _name_prefix = TF.Nil
            , _option = TF.Nil
            , _option_group_description = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_db_parameter_group@ AWS resource.

Provides an RDS DB parameter group resource.
-}
data DbParameterGroupResource = DbParameterGroupResource {
      _description :: !(TF.Argument "description" Text)
    {- ^ (Optional) The description of the DB parameter group. Defaults to "Managed by Terraform". -}
    , _family' :: !(TF.Argument "family" Text)
    {- ^ (Required) The family of the DB parameter group. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Optional, Forces new resource) The name of the DB parameter group. If omitted, Terraform will assign a random, unique name. -}
    , _name_prefix :: !(TF.Argument "name_prefix" Text)
    {- ^ (Optional, Forces new resource) Creates a unique name beginning with the specified prefix. Conflicts with @name@ . -}
    , _parameter :: !(TF.Argument "parameter" Text)
    {- ^ (Optional) A list of DB parameters to apply. Note that parameters may differ from a family to an other. Full list of all parameters can be discovered via <https://docs.aws.amazon.com/cli/latest/reference/rds/describe-db-parameters.html> after initial creation of the group. -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    } deriving (Show, Eq)

instance TF.ToHCL DbParameterGroupResource where
    toHCL DbParameterGroupResource{..} = TF.block $ catMaybes
        [ TF.argument _description
        , TF.argument _family'
        , TF.argument _name
        , TF.argument _name_prefix
        , TF.argument _parameter
        , TF.argument _tags
        ]

instance HasDescription DbParameterGroupResource Text where
    description =
        lens (_description :: DbParameterGroupResource -> TF.Argument "description" Text)
             (\s a -> s { _description = a } :: DbParameterGroupResource)

instance HasFamily' DbParameterGroupResource Text where
    family' =
        lens (_family' :: DbParameterGroupResource -> TF.Argument "family" Text)
             (\s a -> s { _family' = a } :: DbParameterGroupResource)

instance HasName DbParameterGroupResource Text where
    name =
        lens (_name :: DbParameterGroupResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: DbParameterGroupResource)

instance HasNamePrefix DbParameterGroupResource Text where
    namePrefix =
        lens (_name_prefix :: DbParameterGroupResource -> TF.Argument "name_prefix" Text)
             (\s a -> s { _name_prefix = a } :: DbParameterGroupResource)

instance HasParameter DbParameterGroupResource Text where
    parameter =
        lens (_parameter :: DbParameterGroupResource -> TF.Argument "parameter" Text)
             (\s a -> s { _parameter = a } :: DbParameterGroupResource)

instance HasTags DbParameterGroupResource TF.Tags where
    tags =
        lens (_tags :: DbParameterGroupResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: DbParameterGroupResource)

instance HasComputedArn DbParameterGroupResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

instance HasComputedId DbParameterGroupResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

dbParameterGroupResource :: TF.Resource TF.AWS DbParameterGroupResource
dbParameterGroupResource =
    TF.newResource "aws_db_parameter_group" $
        DbParameterGroupResource {
            _description = TF.Nil
            , _family' = TF.Nil
            , _name = TF.Nil
            , _name_prefix = TF.Nil
            , _parameter = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_db_security_group@ AWS resource.

Provides an RDS security group resource. This is only for DB instances in
the EC2-Classic Platform. For instances inside a VPC, use the
</docs/providers/aws/r/db_instance.html#vpc_security_group_ids> attribute
instead.
-}
data DbSecurityGroupResource = DbSecurityGroupResource {
      _description :: !(TF.Argument "description" Text)
    {- ^ (Optional) The description of the DB security group. Defaults to "Managed by Terraform". -}
    , _ingress :: !(TF.Argument "ingress" Text)
    {- ^ (Required) A list of ingress rules. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the DB security group. -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    } deriving (Show, Eq)

instance TF.ToHCL DbSecurityGroupResource where
    toHCL DbSecurityGroupResource{..} = TF.block $ catMaybes
        [ TF.argument _description
        , TF.argument _ingress
        , TF.argument _name
        , TF.argument _tags
        ]

instance HasDescription DbSecurityGroupResource Text where
    description =
        lens (_description :: DbSecurityGroupResource -> TF.Argument "description" Text)
             (\s a -> s { _description = a } :: DbSecurityGroupResource)

instance HasIngress DbSecurityGroupResource Text where
    ingress =
        lens (_ingress :: DbSecurityGroupResource -> TF.Argument "ingress" Text)
             (\s a -> s { _ingress = a } :: DbSecurityGroupResource)

instance HasName DbSecurityGroupResource Text where
    name =
        lens (_name :: DbSecurityGroupResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: DbSecurityGroupResource)

instance HasTags DbSecurityGroupResource TF.Tags where
    tags =
        lens (_tags :: DbSecurityGroupResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: DbSecurityGroupResource)

instance HasComputedArn DbSecurityGroupResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

instance HasComputedId DbSecurityGroupResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

dbSecurityGroupResource :: TF.Resource TF.AWS DbSecurityGroupResource
dbSecurityGroupResource =
    TF.newResource "aws_db_security_group" $
        DbSecurityGroupResource {
            _description = TF.Nil
            , _ingress = TF.Nil
            , _name = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_db_snapshot@ AWS resource.

Creates a Snapshot of an DB Instance.
-}
data DbSnapshotResource = DbSnapshotResource {
      _db_instance_identifier :: !(TF.Argument "db_instance_identifier" Text)
    {- ^ (Required) The DB Instance Identifier from which to take the snapshot. -}
    , _db_snapshot_identifier :: !(TF.Argument "db_snapshot_identifier" Text)
    {- ^ (Required) The Identifier for the snapshot. -}
    } deriving (Show, Eq)

instance TF.ToHCL DbSnapshotResource where
    toHCL DbSnapshotResource{..} = TF.block $ catMaybes
        [ TF.argument _db_instance_identifier
        , TF.argument _db_snapshot_identifier
        ]

instance HasDbInstanceIdentifier DbSnapshotResource Text where
    dbInstanceIdentifier =
        lens (_db_instance_identifier :: DbSnapshotResource -> TF.Argument "db_instance_identifier" Text)
             (\s a -> s { _db_instance_identifier = a } :: DbSnapshotResource)

instance HasDbSnapshotIdentifier DbSnapshotResource Text where
    dbSnapshotIdentifier =
        lens (_db_snapshot_identifier :: DbSnapshotResource -> TF.Argument "db_snapshot_identifier" Text)
             (\s a -> s { _db_snapshot_identifier = a } :: DbSnapshotResource)

instance HasComputedAllocatedStorage DbSnapshotResource Text where
    computedAllocatedStorage =
        to (\_  -> TF.Compute "allocated_storage")

instance HasComputedAvailabilityZone DbSnapshotResource TF.Zone where
    computedAvailabilityZone =
        to (\_  -> TF.Compute "availability_zone")

instance HasComputedDbSnapshotArn DbSnapshotResource Text where
    computedDbSnapshotArn =
        to (\_  -> TF.Compute "db_snapshot_arn")

instance HasComputedEncrypted DbSnapshotResource Text where
    computedEncrypted =
        to (\_  -> TF.Compute "encrypted")

instance HasComputedEngine DbSnapshotResource Text where
    computedEngine =
        to (\_  -> TF.Compute "engine")

instance HasComputedEngineVersion DbSnapshotResource Text where
    computedEngineVersion =
        to (\_  -> TF.Compute "engine_version")

instance HasComputedIops DbSnapshotResource Text where
    computedIops =
        to (\_  -> TF.Compute "iops")

instance HasComputedKmsKeyId DbSnapshotResource Text where
    computedKmsKeyId =
        to (\_  -> TF.Compute "kms_key_id")

instance HasComputedLicenseModel DbSnapshotResource Text where
    computedLicenseModel =
        to (\_  -> TF.Compute "license_model")

instance HasComputedOptionGroupName DbSnapshotResource Text where
    computedOptionGroupName =
        to (\_  -> TF.Compute "option_group_name")

instance HasComputedSourceDbSnapshotIdentifier DbSnapshotResource Text where
    computedSourceDbSnapshotIdentifier =
        to (\_  -> TF.Compute "source_db_snapshot_identifier")

instance HasComputedSourceRegion DbSnapshotResource TF.Region where
    computedSourceRegion =
        to (\_  -> TF.Compute "source_region")

instance HasComputedStatus DbSnapshotResource Text where
    computedStatus =
        to (\_  -> TF.Compute "status")

instance HasComputedStorageType DbSnapshotResource Text where
    computedStorageType =
        to (\_  -> TF.Compute "storage_type")

instance HasComputedVpcId DbSnapshotResource Text where
    computedVpcId =
        to (\_  -> TF.Compute "vpc_id")

dbSnapshotResource :: TF.Resource TF.AWS DbSnapshotResource
dbSnapshotResource =
    TF.newResource "aws_db_snapshot" $
        DbSnapshotResource {
            _db_instance_identifier = TF.Nil
            , _db_snapshot_identifier = TF.Nil
            }

{- | The @aws_db_subnet_group@ AWS resource.

Provides an RDS DB subnet group resource.
-}
data DbSubnetGroupResource = DbSubnetGroupResource {
      _description :: !(TF.Argument "description" Text)
    {- ^ (Optional) The description of the DB subnet group. Defaults to "Managed by Terraform". -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Optional, Forces new resource) The name of the DB subnet group. If omitted, Terraform will assign a random, unique name. -}
    , _name_prefix :: !(TF.Argument "name_prefix" Text)
    {- ^ (Optional, Forces new resource) Creates a unique name beginning with the specified prefix. Conflicts with @name@ . -}
    , _subnet_ids :: !(TF.Argument "subnet_ids" Text)
    {- ^ (Required) A list of VPC subnet IDs. -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    } deriving (Show, Eq)

instance TF.ToHCL DbSubnetGroupResource where
    toHCL DbSubnetGroupResource{..} = TF.block $ catMaybes
        [ TF.argument _description
        , TF.argument _name
        , TF.argument _name_prefix
        , TF.argument _subnet_ids
        , TF.argument _tags
        ]

instance HasDescription DbSubnetGroupResource Text where
    description =
        lens (_description :: DbSubnetGroupResource -> TF.Argument "description" Text)
             (\s a -> s { _description = a } :: DbSubnetGroupResource)

instance HasName DbSubnetGroupResource Text where
    name =
        lens (_name :: DbSubnetGroupResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: DbSubnetGroupResource)

instance HasNamePrefix DbSubnetGroupResource Text where
    namePrefix =
        lens (_name_prefix :: DbSubnetGroupResource -> TF.Argument "name_prefix" Text)
             (\s a -> s { _name_prefix = a } :: DbSubnetGroupResource)

instance HasSubnetIds DbSubnetGroupResource Text where
    subnetIds =
        lens (_subnet_ids :: DbSubnetGroupResource -> TF.Argument "subnet_ids" Text)
             (\s a -> s { _subnet_ids = a } :: DbSubnetGroupResource)

instance HasTags DbSubnetGroupResource TF.Tags where
    tags =
        lens (_tags :: DbSubnetGroupResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: DbSubnetGroupResource)

instance HasComputedArn DbSubnetGroupResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

instance HasComputedId DbSubnetGroupResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

dbSubnetGroupResource :: TF.Resource TF.AWS DbSubnetGroupResource
dbSubnetGroupResource =
    TF.newResource "aws_db_subnet_group" $
        DbSubnetGroupResource {
            _description = TF.Nil
            , _name = TF.Nil
            , _name_prefix = TF.Nil
            , _subnet_ids = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_default_network_acl@ AWS resource.

Provides a resource to manage the default AWS Network ACL. VPC Only. Each
VPC created in AWS comes with a Default Network ACL that can be managed, but
not destroyed. This is an advanced resource , and has special caveats to be
aware of when using it. Please read this document in its entirety before
using this resource. The @aws_default_network_acl@ behaves differently from
normal resources, in that Terraform does not create this resource, but
instead attempts to "adopt" it into management. We can do this because each
VPC created has a Default Network ACL that cannot be destroyed, and is
created with a known set of default rules. When Terraform first adopts the
Default Network ACL, it immediately removes all rules in the ACL . It then
proceeds to create any rules specified in the configuration. This step is
required so that only the rules specified in the configuration are created.
This resource treats its inline rules as absolute; only the rules defined
inline are created, and any additions/removals external to this resource
will result in diffs being shown. For these reasons, this resource is
incompatible with the @aws_network_acl_rule@ resource. For more information
about Network ACLs, see the AWS Documentation on
<http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_ACLs.html> .
-}
data DefaultNetworkAclResource = DefaultNetworkAclResource {
      _default_network_acl_id :: !(TF.Argument "default_network_acl_id" Text)
    {- ^ (Required) The Network ACL ID to manage. This attribute is exported from @aws_vpc@ , or manually found via the AWS Console. -}
    , _egress :: !(TF.Argument "egress" Text)
    {- ^ (Optional) Specifies an egress rule. Parameters defined below. -}
    , _ingress :: !(TF.Argument "ingress" Text)
    {- ^ (Optional) Specifies an ingress rule. Parameters defined below. -}
    , _subnet_ids :: !(TF.Argument "subnet_ids" Text)
    {- ^ (Optional) A list of Subnet IDs to apply the ACL to. See the notes below on managing Subnets in the Default Network ACL -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    } deriving (Show, Eq)

instance TF.ToHCL DefaultNetworkAclResource where
    toHCL DefaultNetworkAclResource{..} = TF.block $ catMaybes
        [ TF.argument _default_network_acl_id
        , TF.argument _egress
        , TF.argument _ingress
        , TF.argument _subnet_ids
        , TF.argument _tags
        ]

instance HasDefaultNetworkAclId DefaultNetworkAclResource Text where
    defaultNetworkAclId =
        lens (_default_network_acl_id :: DefaultNetworkAclResource -> TF.Argument "default_network_acl_id" Text)
             (\s a -> s { _default_network_acl_id = a } :: DefaultNetworkAclResource)

instance HasEgress DefaultNetworkAclResource Text where
    egress =
        lens (_egress :: DefaultNetworkAclResource -> TF.Argument "egress" Text)
             (\s a -> s { _egress = a } :: DefaultNetworkAclResource)

instance HasIngress DefaultNetworkAclResource Text where
    ingress =
        lens (_ingress :: DefaultNetworkAclResource -> TF.Argument "ingress" Text)
             (\s a -> s { _ingress = a } :: DefaultNetworkAclResource)

instance HasSubnetIds DefaultNetworkAclResource Text where
    subnetIds =
        lens (_subnet_ids :: DefaultNetworkAclResource -> TF.Argument "subnet_ids" Text)
             (\s a -> s { _subnet_ids = a } :: DefaultNetworkAclResource)

instance HasTags DefaultNetworkAclResource TF.Tags where
    tags =
        lens (_tags :: DefaultNetworkAclResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: DefaultNetworkAclResource)

defaultNetworkAclResource :: TF.Resource TF.AWS DefaultNetworkAclResource
defaultNetworkAclResource =
    TF.newResource "aws_default_network_acl" $
        DefaultNetworkAclResource {
            _default_network_acl_id = TF.Nil
            , _egress = TF.Nil
            , _ingress = TF.Nil
            , _subnet_ids = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_default_route_table@ AWS resource.

Provides a resource to manage a Default VPC Routing Table. Each VPC created
in AWS comes with a Default Route Table that can be managed, but not
destroyed. This is an advanced resource , and has special caveats to be
aware of when using it. Please read this document in its entirety before
using this resource. It is recommended you do not use both
@aws_default_route_table@ to manage the default route table and use the
@aws_main_route_table_association@ , due to possible conflict in routes. The
@aws_default_route_table@ behaves differently from normal resources, in that
Terraform does not create this resource, but instead attempts to "adopt" it
into management. We can do this because each VPC created has a Default Route
Table that cannot be destroyed, and is created with a single route. When
Terraform first adopts the Default Route Table, it immediately removes all
defined routes . It then proceeds to create any routes specified in the
configuration. This step is required so that only the routes specified in
the configuration present in the Default Route Table. For more information
about Route Tables, see the AWS Documentation on
<http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Route_Tables.html#Route_Replacing_Main_Table>
. For more information about managing normal Route Tables in Terraform, see
our documentation on </docs/providers/aws/r/route_table.html> . ~> NOTE on
Route Tables and Routes: Terraform currently provides both a standalone
<route.html> and a Route Table resource with routes defined in-line. At this
time you cannot use a Route Table with in-line routes in conjunction with
any Route resources. Doing so will cause a conflict of rule settings and
will overwrite routes.
-}
data DefaultRouteTableResource = DefaultRouteTableResource {
      _default_route_table_id :: !(TF.Argument "default_route_table_id" Text)
    {- ^ (Required) The ID of the Default Routing Table. -}
    , _propagating_vgws :: !(TF.Argument "propagating_vgws" Text)
    {- ^ (Optional) A list of virtual gateways for propagation. -}
    , _route :: !(TF.Argument "route" Text)
    {- ^ (Optional) A list of route objects. Their keys are documented below. -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    } deriving (Show, Eq)

instance TF.ToHCL DefaultRouteTableResource where
    toHCL DefaultRouteTableResource{..} = TF.block $ catMaybes
        [ TF.argument _default_route_table_id
        , TF.argument _propagating_vgws
        , TF.argument _route
        , TF.argument _tags
        ]

instance HasDefaultRouteTableId DefaultRouteTableResource Text where
    defaultRouteTableId =
        lens (_default_route_table_id :: DefaultRouteTableResource -> TF.Argument "default_route_table_id" Text)
             (\s a -> s { _default_route_table_id = a } :: DefaultRouteTableResource)

instance HasPropagatingVgws DefaultRouteTableResource Text where
    propagatingVgws =
        lens (_propagating_vgws :: DefaultRouteTableResource -> TF.Argument "propagating_vgws" Text)
             (\s a -> s { _propagating_vgws = a } :: DefaultRouteTableResource)

instance HasRoute DefaultRouteTableResource Text where
    route =
        lens (_route :: DefaultRouteTableResource -> TF.Argument "route" Text)
             (\s a -> s { _route = a } :: DefaultRouteTableResource)

instance HasTags DefaultRouteTableResource TF.Tags where
    tags =
        lens (_tags :: DefaultRouteTableResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: DefaultRouteTableResource)

instance HasComputedId DefaultRouteTableResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

defaultRouteTableResource :: TF.Resource TF.AWS DefaultRouteTableResource
defaultRouteTableResource =
    TF.newResource "aws_default_route_table" $
        DefaultRouteTableResource {
            _default_route_table_id = TF.Nil
            , _propagating_vgws = TF.Nil
            , _route = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_default_security_group@ AWS resource.

Provides a resource to manage the default AWS Security Group. For EC2
Classic accounts, each region comes with a Default Security Group.
Additionally, each VPC created in AWS comes with a Default Security Group
that can be managed, but not destroyed. This is an advanced resource , and
has special caveats to be aware of when using it. Please read this document
in its entirety before using this resource. The @aws_default_security_group@
behaves differently from normal resources, in that Terraform does not create
this resource, but instead "adopts" it into management. We can do this
because these default security groups cannot be destroyed, and are created
with a known set of default ingress/egress rules. When Terraform first
adopts the Default Security Group, it immediately removes all ingress and
egress rules in the Security Group . It then proceeds to create any rules
specified in the configuration. This step is required so that only the rules
specified in the configuration are created. This resource treats it's inline
rules as absolute; only the rules defined inline are created, and any
additions/removals external to this resource will result in diff shown. For
these reasons, this resource is incompatible with the
@aws_security_group_rule@ resource. For more information about Default
Security Groups, see the AWS Documentation on
<http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-network-security.html#default-security-group>
.
-}
data DefaultSecurityGroupResource = DefaultSecurityGroupResource {
      _egress :: !(TF.Argument "egress" Text)
    {- ^ (Optional, VPC only) Can be specified multiple times for each egress rule. Each egress block supports fields documented below. -}
    , _ingress :: !(TF.Argument "ingress" Text)
    {- ^ (Optional) Can be specified multiple times for each ingress rule. Each ingress block supports fields documented below. -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    , _vpc_id :: !(TF.Argument "vpc_id" Text)
    {- ^ (Optional, Forces new resource) The VPC ID. Note that changing the @vpc_id@ will not restore any default security group rules that were modified, added, or removed. It will be left in it's current state -}
    } deriving (Show, Eq)

instance TF.ToHCL DefaultSecurityGroupResource where
    toHCL DefaultSecurityGroupResource{..} = TF.block $ catMaybes
        [ TF.argument _egress
        , TF.argument _ingress
        , TF.argument _tags
        , TF.argument _vpc_id
        ]

instance HasEgress DefaultSecurityGroupResource Text where
    egress =
        lens (_egress :: DefaultSecurityGroupResource -> TF.Argument "egress" Text)
             (\s a -> s { _egress = a } :: DefaultSecurityGroupResource)

instance HasIngress DefaultSecurityGroupResource Text where
    ingress =
        lens (_ingress :: DefaultSecurityGroupResource -> TF.Argument "ingress" Text)
             (\s a -> s { _ingress = a } :: DefaultSecurityGroupResource)

instance HasTags DefaultSecurityGroupResource TF.Tags where
    tags =
        lens (_tags :: DefaultSecurityGroupResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: DefaultSecurityGroupResource)

instance HasVpcId DefaultSecurityGroupResource Text where
    vpcId =
        lens (_vpc_id :: DefaultSecurityGroupResource -> TF.Argument "vpc_id" Text)
             (\s a -> s { _vpc_id = a } :: DefaultSecurityGroupResource)

defaultSecurityGroupResource :: TF.Resource TF.AWS DefaultSecurityGroupResource
defaultSecurityGroupResource =
    TF.newResource "aws_default_security_group" $
        DefaultSecurityGroupResource {
            _egress = TF.Nil
            , _ingress = TF.Nil
            , _tags = TF.Nil
            , _vpc_id = TF.Nil
            }

{- | The @aws_default_subnet@ AWS resource.

Provides a resource to manage a
<http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/default-vpc.html#default-vpc-basics>
in the current region. The @aws_default_subnet@ behaves differently from
normal resources, in that Terraform does not create this resource, but
instead "adopts" it into management.
-}
data DefaultSubnetResource = DefaultSubnetResource {
      _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    } deriving (Show, Eq)

instance TF.ToHCL DefaultSubnetResource where
    toHCL DefaultSubnetResource{..} = TF.block $ catMaybes
        [ TF.argument _tags
        ]

instance HasTags DefaultSubnetResource TF.Tags where
    tags =
        lens (_tags :: DefaultSubnetResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: DefaultSubnetResource)

defaultSubnetResource :: TF.Resource TF.AWS DefaultSubnetResource
defaultSubnetResource =
    TF.newResource "aws_default_subnet" $
        DefaultSubnetResource {
            _tags = TF.Nil
            }

{- | The @aws_default_vpc_dhcp_options@ AWS resource.

Provides a resource to manage the
<http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_DHCP_Options.html#AmazonDNS>
in the current region. Each AWS region comes with a default set of DHCP
options. This is an advanced resource , and has special caveats to be aware
of when using it. Please read this document in its entirety before using
this resource. The @aws_default_vpc_dhcp_options@ behaves differently from
normal resources, in that Terraform does not create this resource, but
instead "adopts" it into management.
-}
data DefaultVpcDhcpOptionsResource = DefaultVpcDhcpOptionsResource {
      _netbios_name_servers :: !(TF.Argument "netbios_name_servers" Text)
    {- ^ (Optional) List of NETBIOS name servers. -}
    , _netbios_node_type :: !(TF.Argument "netbios_node_type" Text)
    {- ^ (Optional) The NetBIOS node type (1, 2, 4, or 8). AWS recommends to specify 2 since broadcast and multicast are not supported in their network. For more information about these node types, see <http://www.ietf.org/rfc/rfc2132.txt> . -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    } deriving (Show, Eq)

instance TF.ToHCL DefaultVpcDhcpOptionsResource where
    toHCL DefaultVpcDhcpOptionsResource{..} = TF.block $ catMaybes
        [ TF.argument _netbios_name_servers
        , TF.argument _netbios_node_type
        , TF.argument _tags
        ]

instance HasNetbiosNameServers DefaultVpcDhcpOptionsResource Text where
    netbiosNameServers =
        lens (_netbios_name_servers :: DefaultVpcDhcpOptionsResource -> TF.Argument "netbios_name_servers" Text)
             (\s a -> s { _netbios_name_servers = a } :: DefaultVpcDhcpOptionsResource)

instance HasNetbiosNodeType DefaultVpcDhcpOptionsResource Text where
    netbiosNodeType =
        lens (_netbios_node_type :: DefaultVpcDhcpOptionsResource -> TF.Argument "netbios_node_type" Text)
             (\s a -> s { _netbios_node_type = a } :: DefaultVpcDhcpOptionsResource)

instance HasTags DefaultVpcDhcpOptionsResource TF.Tags where
    tags =
        lens (_tags :: DefaultVpcDhcpOptionsResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: DefaultVpcDhcpOptionsResource)

defaultVpcDhcpOptionsResource :: TF.Resource TF.AWS DefaultVpcDhcpOptionsResource
defaultVpcDhcpOptionsResource =
    TF.newResource "aws_default_vpc_dhcp_options" $
        DefaultVpcDhcpOptionsResource {
            _netbios_name_servers = TF.Nil
            , _netbios_node_type = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_default_vpc@ AWS resource.

Provides a resource to manage the
<http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/default-vpc.html> in
the current region. For AWS accounts created after 2013-12-04, each region
comes with a Default VPC. This is an advanced resource , and has special
caveats to be aware of when using it. Please read this document in its
entirety before using this resource. The @aws_default_vpc@ behaves
differently from normal resources, in that Terraform does not create this
resource, but instead "adopts" it into management.
-}
data DefaultVpcResource = DefaultVpcResource {
      _enable_classiclink :: !(TF.Argument "enable_classiclink" TF.Bool)
    {- ^ (Optional) A boolean flag to enable/disable ClassicLink for the VPC. Only valid in regions and accounts that support EC2 Classic. See the <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/vpc-classiclink.html> for more information. Defaults false. -}
    , _enable_dns_hostnames :: !(TF.Argument "enable_dns_hostnames" TF.Bool)
    {- ^ (Optional) A boolean flag to enable/disable DNS hostnames in the VPC. Defaults false. -}
    , _enable_dns_support :: !(TF.Argument "enable_dns_support" TF.Bool)
    {- ^ (Optional) A boolean flag to enable/disable DNS support in the VPC. Defaults true. -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    } deriving (Show, Eq)

instance TF.ToHCL DefaultVpcResource where
    toHCL DefaultVpcResource{..} = TF.block $ catMaybes
        [ TF.argument _enable_classiclink
        , TF.argument _enable_dns_hostnames
        , TF.argument _enable_dns_support
        , TF.argument _tags
        ]

instance HasEnableClassiclink DefaultVpcResource TF.Bool where
    enableClassiclink =
        lens (_enable_classiclink :: DefaultVpcResource -> TF.Argument "enable_classiclink" TF.Bool)
             (\s a -> s { _enable_classiclink = a } :: DefaultVpcResource)

instance HasEnableDnsHostnames DefaultVpcResource TF.Bool where
    enableDnsHostnames =
        lens (_enable_dns_hostnames :: DefaultVpcResource -> TF.Argument "enable_dns_hostnames" TF.Bool)
             (\s a -> s { _enable_dns_hostnames = a } :: DefaultVpcResource)

instance HasEnableDnsSupport DefaultVpcResource TF.Bool where
    enableDnsSupport =
        lens (_enable_dns_support :: DefaultVpcResource -> TF.Argument "enable_dns_support" TF.Bool)
             (\s a -> s { _enable_dns_support = a } :: DefaultVpcResource)

instance HasTags DefaultVpcResource TF.Tags where
    tags =
        lens (_tags :: DefaultVpcResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: DefaultVpcResource)

defaultVpcResource :: TF.Resource TF.AWS DefaultVpcResource
defaultVpcResource =
    TF.newResource "aws_default_vpc" $
        DefaultVpcResource {
            _enable_classiclink = TF.Nil
            , _enable_dns_hostnames = TF.Nil
            , _enable_dns_support = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_devicefarm_project@ AWS resource.

Provides a resource to manage AWS Device Farm Projects. Please keep in mind
that this feature is only supported on the "us-west-2" region. This resource
will error if you try to create a project in another region. For more
information about Device Farm Projects, see the AWS Documentation on
<http://docs.aws.amazon.com/devicefarm/latest/APIReference/API_GetProject.html>
.
-}
data DevicefarmProjectResource = DevicefarmProjectResource {
      _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the project -}
    } deriving (Show, Eq)

instance TF.ToHCL DevicefarmProjectResource where
    toHCL DevicefarmProjectResource{..} = TF.block $ catMaybes
        [ TF.argument _name
        ]

instance HasName DevicefarmProjectResource Text where
    name =
        lens (_name :: DevicefarmProjectResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: DevicefarmProjectResource)

instance HasComputedArn DevicefarmProjectResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

devicefarmProjectResource :: TF.Resource TF.AWS DevicefarmProjectResource
devicefarmProjectResource =
    TF.newResource "aws_devicefarm_project" $
        DevicefarmProjectResource {
            _name = TF.Nil
            }

{- | The @aws_directory_service_directory@ AWS resource.

Provides a Simple or Managed Microsoft directory in AWS Directory Service.
~> Note: All arguments including the password and customer username will be
stored in the raw state as plain-text. </docs/state/sensitive-data.html> .
-}
data DirectoryServiceDirectoryResource = DirectoryServiceDirectoryResource {
      _alias :: !(TF.Argument "alias" Text)
    {- ^ (Optional) The alias for the directory (must be unique amongst all aliases in AWS). Required for @enable_sso@ . -}
    , _connect_settings :: !(TF.Argument "connect_settings" Text)
    {- ^ (Required for @ADConnector@ ) Connector related information about the directory. Fields documented below. -}
    , _description :: !(TF.Argument "description" Text)
    {- ^ (Optional) A textual description for the directory. -}
    , _enable_sso :: !(TF.Argument "enable_sso" TF.Bool)
    {- ^ (Optional) Whether to enable single-sign on for the directory. Requires @alias@ . Defaults to @false@ . -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The fully qualified name for the directory, such as @corp.example.com@ -}
    , _password :: !(TF.Argument "password" Text)
    {- ^ (Required) The password for the directory administrator or connector user. -}
    , _short_name :: !(TF.Argument "short_name" Text)
    {- ^ (Optional) The short name of the directory, such as @CORP@ . -}
    , _size :: !(TF.Argument "size" Text)
    {- ^ (Required for @SimpleAD@ and @ADConnector@ ) The size of the directory ( @Small@ or @Large@ are accepted values). -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    , _type' :: !(TF.Argument "type" Text)
    {- ^ (Optional) - The directory type ( @SimpleAD@ or @MicrosoftAD@ are accepted values). Defaults to @SimpleAD@ . -}
    , _vpc_settings :: !(TF.Argument "vpc_settings" Text)
    {- ^ (Required for @SimpleAD@ and @MicrosoftAD@ ) VPC related information about the directory. Fields documented below. -}
    } deriving (Show, Eq)

instance TF.ToHCL DirectoryServiceDirectoryResource where
    toHCL DirectoryServiceDirectoryResource{..} = TF.block $ catMaybes
        [ TF.argument _alias
        , TF.argument _connect_settings
        , TF.argument _description
        , TF.argument _enable_sso
        , TF.argument _name
        , TF.argument _password
        , TF.argument _short_name
        , TF.argument _size
        , TF.argument _tags
        , TF.argument _type'
        , TF.argument _vpc_settings
        ]

instance HasAlias DirectoryServiceDirectoryResource Text where
    alias =
        lens (_alias :: DirectoryServiceDirectoryResource -> TF.Argument "alias" Text)
             (\s a -> s { _alias = a } :: DirectoryServiceDirectoryResource)

instance HasConnectSettings DirectoryServiceDirectoryResource Text where
    connectSettings =
        lens (_connect_settings :: DirectoryServiceDirectoryResource -> TF.Argument "connect_settings" Text)
             (\s a -> s { _connect_settings = a } :: DirectoryServiceDirectoryResource)

instance HasDescription DirectoryServiceDirectoryResource Text where
    description =
        lens (_description :: DirectoryServiceDirectoryResource -> TF.Argument "description" Text)
             (\s a -> s { _description = a } :: DirectoryServiceDirectoryResource)

instance HasEnableSso DirectoryServiceDirectoryResource TF.Bool where
    enableSso =
        lens (_enable_sso :: DirectoryServiceDirectoryResource -> TF.Argument "enable_sso" TF.Bool)
             (\s a -> s { _enable_sso = a } :: DirectoryServiceDirectoryResource)

instance HasName DirectoryServiceDirectoryResource Text where
    name =
        lens (_name :: DirectoryServiceDirectoryResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: DirectoryServiceDirectoryResource)

instance HasPassword DirectoryServiceDirectoryResource Text where
    password =
        lens (_password :: DirectoryServiceDirectoryResource -> TF.Argument "password" Text)
             (\s a -> s { _password = a } :: DirectoryServiceDirectoryResource)

instance HasShortName DirectoryServiceDirectoryResource Text where
    shortName =
        lens (_short_name :: DirectoryServiceDirectoryResource -> TF.Argument "short_name" Text)
             (\s a -> s { _short_name = a } :: DirectoryServiceDirectoryResource)

instance HasSize DirectoryServiceDirectoryResource Text where
    size =
        lens (_size :: DirectoryServiceDirectoryResource -> TF.Argument "size" Text)
             (\s a -> s { _size = a } :: DirectoryServiceDirectoryResource)

instance HasTags DirectoryServiceDirectoryResource TF.Tags where
    tags =
        lens (_tags :: DirectoryServiceDirectoryResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: DirectoryServiceDirectoryResource)

instance HasType' DirectoryServiceDirectoryResource Text where
    type' =
        lens (_type' :: DirectoryServiceDirectoryResource -> TF.Argument "type" Text)
             (\s a -> s { _type' = a } :: DirectoryServiceDirectoryResource)

instance HasVpcSettings DirectoryServiceDirectoryResource Text where
    vpcSettings =
        lens (_vpc_settings :: DirectoryServiceDirectoryResource -> TF.Argument "vpc_settings" Text)
             (\s a -> s { _vpc_settings = a } :: DirectoryServiceDirectoryResource)

instance HasComputedAccessUrl DirectoryServiceDirectoryResource Text where
    computedAccessUrl =
        to (\_  -> TF.Compute "access_url")

instance HasComputedDnsIpAddresses DirectoryServiceDirectoryResource Text where
    computedDnsIpAddresses =
        to (\_  -> TF.Compute "dns_ip_addresses")

instance HasComputedId DirectoryServiceDirectoryResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedSecurityGroupId DirectoryServiceDirectoryResource Text where
    computedSecurityGroupId =
        to (\_  -> TF.Compute "security_group_id")

directoryServiceDirectoryResource :: TF.Resource TF.AWS DirectoryServiceDirectoryResource
directoryServiceDirectoryResource =
    TF.newResource "aws_directory_service_directory" $
        DirectoryServiceDirectoryResource {
            _alias = TF.Nil
            , _connect_settings = TF.Nil
            , _description = TF.Nil
            , _enable_sso = TF.Nil
            , _name = TF.Nil
            , _password = TF.Nil
            , _short_name = TF.Nil
            , _size = TF.Nil
            , _tags = TF.Nil
            , _type' = TF.Nil
            , _vpc_settings = TF.Nil
            }

{- | The @aws_dms_certificate@ AWS resource.

Provides a DMS (Data Migration Service) certificate resource. DMS
certificates can be created, deleted, and imported. ~> Note: All arguments
including the PEM encoded certificate will be stored in the raw state as
plain-text. </docs/state/sensitive-data.html> .
-}
data DmsCertificateResource = DmsCertificateResource {
      _certificate_id :: !(TF.Argument "certificate_id" Text)
    {- ^ (Required) The certificate identifier. -}
    , _certificate_pem :: !(TF.Argument "certificate_pem" Text)
    {- ^ (Optional) The contents of the .pem X.509 certificate file for the certificate. Either @certificate_pem@ or @certificate_wallet@ must be set. -}
    , _certificate_wallet :: !(TF.Argument "certificate_wallet" Text)
    {- ^ (Optional) The contents of the Oracle Wallet certificate for use with SSL. Either @certificate_pem@ or @certificate_wallet@ must be set. -}
    } deriving (Show, Eq)

instance TF.ToHCL DmsCertificateResource where
    toHCL DmsCertificateResource{..} = TF.block $ catMaybes
        [ TF.argument _certificate_id
        , TF.argument _certificate_pem
        , TF.argument _certificate_wallet
        ]

instance HasCertificateId DmsCertificateResource Text where
    certificateId =
        lens (_certificate_id :: DmsCertificateResource -> TF.Argument "certificate_id" Text)
             (\s a -> s { _certificate_id = a } :: DmsCertificateResource)

instance HasCertificatePem DmsCertificateResource Text where
    certificatePem =
        lens (_certificate_pem :: DmsCertificateResource -> TF.Argument "certificate_pem" Text)
             (\s a -> s { _certificate_pem = a } :: DmsCertificateResource)

instance HasCertificateWallet DmsCertificateResource Text where
    certificateWallet =
        lens (_certificate_wallet :: DmsCertificateResource -> TF.Argument "certificate_wallet" Text)
             (\s a -> s { _certificate_wallet = a } :: DmsCertificateResource)

instance HasComputedCertificateArn DmsCertificateResource Text where
    computedCertificateArn =
        to (\_  -> TF.Compute "certificate_arn")

dmsCertificateResource :: TF.Resource TF.AWS DmsCertificateResource
dmsCertificateResource =
    TF.newResource "aws_dms_certificate" $
        DmsCertificateResource {
            _certificate_id = TF.Nil
            , _certificate_pem = TF.Nil
            , _certificate_wallet = TF.Nil
            }

{- | The @aws_dms_endpoint@ AWS resource.

Provides a DMS (Data Migration Service) endpoint resource. DMS endpoints can
be created, updated, deleted, and imported. ~> Note: All arguments including
the password will be stored in the raw state as plain-text.
</docs/state/sensitive-data.html> .
-}
data DmsEndpointResource = DmsEndpointResource {
      _certificate_arn :: !(TF.Argument "certificate_arn" Text)
    {- ^ (Optional, Default: empty string) The Amazon Resource Name (ARN) for the certificate. -}
    , _database_name :: !(TF.Argument "database_name" Text)
    {- ^ (Optional) The name of the endpoint database. -}
    , _endpoint_id :: !(TF.Argument "endpoint_id" Text)
    {- ^ (Required) The database endpoint identifier. -}
    , _endpoint_type :: !(TF.Argument "endpoint_type" Text)
    {- ^ (Required) The type of endpoint. Can be one of @source | target@ . -}
    , _engine_name :: !(TF.Argument "engine_name" Text)
    {- ^ (Required) The type of engine for the endpoint. Can be one of @mysql | oracle | postgres | mariadb | aurora | redshift | sybase | sqlserver | dynamodb@ . -}
    , _extra_connection_attributes :: !(TF.Argument "extra_connection_attributes" Text)
    {- ^ (Optional) Additional attributes associated with the connection. For available attributes see <http://docs.aws.amazon.com/dms/latest/userguide/CHAP_Introduction.ConnectionAttributes.html> . -}
    , _kms_key_arn :: !(TF.Argument "kms_key_arn" Text)
    {- ^ (Optional) The Amazon Resource Name (ARN) for the KMS key that will be used to encrypt the connection parameters. If you do not specify a value for @kms_key_arn@ , then AWS DMS will use your default encryption key. AWS KMS creates the default encryption key for your AWS account. Your AWS account has a different default encryption key for each AWS region. -}
    , _password :: !(TF.Argument "password" Text)
    {- ^ (Optional) The password to be used to login to the endpoint database. -}
    , _port :: !(TF.Argument "port" Text)
    {- ^ (Optional) The port used by the endpoint database. -}
    , _server_name :: !(TF.Argument "server_name" Text)
    {- ^ (Optional) The host name of the server. -}
    , _service_access_role :: !(TF.Argument "service_access_role" Text)
    {- ^ (Optional) The Amazon Resource Name (ARN) used by the service access IAM role for dynamodb endpoints. -}
    , _ssl_mode :: !(TF.Argument "ssl_mode" Text)
    {- ^ (Optional, Default: none) The SSL mode to use for the connection. Can be one of @none | require | verify-ca | verify-full@ -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    , _username :: !(TF.Argument "username" Text)
    {- ^ (Optional) The user name to be used to login to the endpoint database. -}
    } deriving (Show, Eq)

instance TF.ToHCL DmsEndpointResource where
    toHCL DmsEndpointResource{..} = TF.block $ catMaybes
        [ TF.argument _certificate_arn
        , TF.argument _database_name
        , TF.argument _endpoint_id
        , TF.argument _endpoint_type
        , TF.argument _engine_name
        , TF.argument _extra_connection_attributes
        , TF.argument _kms_key_arn
        , TF.argument _password
        , TF.argument _port
        , TF.argument _server_name
        , TF.argument _service_access_role
        , TF.argument _ssl_mode
        , TF.argument _tags
        , TF.argument _username
        ]

instance HasCertificateArn DmsEndpointResource Text where
    certificateArn =
        lens (_certificate_arn :: DmsEndpointResource -> TF.Argument "certificate_arn" Text)
             (\s a -> s { _certificate_arn = a } :: DmsEndpointResource)

instance HasDatabaseName DmsEndpointResource Text where
    databaseName =
        lens (_database_name :: DmsEndpointResource -> TF.Argument "database_name" Text)
             (\s a -> s { _database_name = a } :: DmsEndpointResource)

instance HasEndpointId DmsEndpointResource Text where
    endpointId =
        lens (_endpoint_id :: DmsEndpointResource -> TF.Argument "endpoint_id" Text)
             (\s a -> s { _endpoint_id = a } :: DmsEndpointResource)

instance HasEndpointType DmsEndpointResource Text where
    endpointType =
        lens (_endpoint_type :: DmsEndpointResource -> TF.Argument "endpoint_type" Text)
             (\s a -> s { _endpoint_type = a } :: DmsEndpointResource)

instance HasEngineName DmsEndpointResource Text where
    engineName =
        lens (_engine_name :: DmsEndpointResource -> TF.Argument "engine_name" Text)
             (\s a -> s { _engine_name = a } :: DmsEndpointResource)

instance HasExtraConnectionAttributes DmsEndpointResource Text where
    extraConnectionAttributes =
        lens (_extra_connection_attributes :: DmsEndpointResource -> TF.Argument "extra_connection_attributes" Text)
             (\s a -> s { _extra_connection_attributes = a } :: DmsEndpointResource)

instance HasKmsKeyArn DmsEndpointResource Text where
    kmsKeyArn =
        lens (_kms_key_arn :: DmsEndpointResource -> TF.Argument "kms_key_arn" Text)
             (\s a -> s { _kms_key_arn = a } :: DmsEndpointResource)

instance HasPassword DmsEndpointResource Text where
    password =
        lens (_password :: DmsEndpointResource -> TF.Argument "password" Text)
             (\s a -> s { _password = a } :: DmsEndpointResource)

instance HasPort DmsEndpointResource Text where
    port =
        lens (_port :: DmsEndpointResource -> TF.Argument "port" Text)
             (\s a -> s { _port = a } :: DmsEndpointResource)

instance HasServerName DmsEndpointResource Text where
    serverName =
        lens (_server_name :: DmsEndpointResource -> TF.Argument "server_name" Text)
             (\s a -> s { _server_name = a } :: DmsEndpointResource)

instance HasServiceAccessRole DmsEndpointResource Text where
    serviceAccessRole =
        lens (_service_access_role :: DmsEndpointResource -> TF.Argument "service_access_role" Text)
             (\s a -> s { _service_access_role = a } :: DmsEndpointResource)

instance HasSslMode DmsEndpointResource Text where
    sslMode =
        lens (_ssl_mode :: DmsEndpointResource -> TF.Argument "ssl_mode" Text)
             (\s a -> s { _ssl_mode = a } :: DmsEndpointResource)

instance HasTags DmsEndpointResource TF.Tags where
    tags =
        lens (_tags :: DmsEndpointResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: DmsEndpointResource)

instance HasUsername DmsEndpointResource Text where
    username =
        lens (_username :: DmsEndpointResource -> TF.Argument "username" Text)
             (\s a -> s { _username = a } :: DmsEndpointResource)

instance HasComputedEndpointArn DmsEndpointResource Text where
    computedEndpointArn =
        to (\_  -> TF.Compute "endpoint_arn")

dmsEndpointResource :: TF.Resource TF.AWS DmsEndpointResource
dmsEndpointResource =
    TF.newResource "aws_dms_endpoint" $
        DmsEndpointResource {
            _certificate_arn = TF.Nil
            , _database_name = TF.Nil
            , _endpoint_id = TF.Nil
            , _endpoint_type = TF.Nil
            , _engine_name = TF.Nil
            , _extra_connection_attributes = TF.Nil
            , _kms_key_arn = TF.Nil
            , _password = TF.Nil
            , _port = TF.Nil
            , _server_name = TF.Nil
            , _service_access_role = TF.Nil
            , _ssl_mode = TF.Nil
            , _tags = TF.Nil
            , _username = TF.Nil
            }

{- | The @aws_dms_replication_instance@ AWS resource.

Provides a DMS (Data Migration Service) replication instance resource. DMS
replication instances can be created, updated, deleted, and imported.
-}
data DmsReplicationInstanceResource = DmsReplicationInstanceResource {
      _allocated_storage :: !(TF.Argument "allocated_storage" Text)
    {- ^ (Optional, Default: 50, Min: 5, Max: 6144) The amount of storage (in gigabytes) to be initially allocated for the replication instance. -}
    , _apply_immediately :: !(TF.Argument "apply_immediately" Text)
    {- ^ (Optional, Default: false) Indicates whether the changes should be applied immediately or during the next maintenance window. Only used when updating an existing resource. -}
    , _auto_minor_version_upgrade :: !(TF.Argument "auto_minor_version_upgrade" Text)
    {- ^ (Optional, Default: false) Indicates that minor engine upgrades will be applied automatically to the replication instance during the maintenance window. -}
    , _availability_zone :: !(TF.Argument "availability_zone" TF.Zone)
    {- ^ (Optional) The EC2 Availability Zone that the replication instance will be created in. -}
    , _engine_version :: !(TF.Argument "engine_version" Text)
    {- ^ (Optional) The engine version number of the replication instance. -}
    , _kms_key_arn :: !(TF.Argument "kms_key_arn" Text)
    {- ^ (Optional) The Amazon Resource Name (ARN) for the KMS key that will be used to encrypt the connection parameters. If you do not specify a value for @kms_key_arn@ , then AWS DMS will use your default encryption key. AWS KMS creates the default encryption key for your AWS account. Your AWS account has a different default encryption key for each AWS region. -}
    , _multi_az :: !(TF.Argument "multi_az" Text)
    {- ^ (Optional) Specifies if the replication instance is a multi-az deployment. You cannot set the @availability_zone@ parameter if the @multi_az@ parameter is set to @true@ . -}
    , _preferred_maintenance_window :: !(TF.Argument "preferred_maintenance_window" Text)
    {- ^ (Optional) The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC). -}
    , _publicly_accessible :: !(TF.Argument "publicly_accessible" Text)
    {- ^ (Optional, Default: false) Specifies the accessibility options for the replication instance. A value of true represents an instance with a public IP address. A value of false represents an instance with a private IP address. -}
    , _replication_instance_class :: !(TF.Argument "replication_instance_class" Text)
    {- ^ (Required) The compute and memory capacity of the replication instance as specified by the replication instance class. Can be one of @dms.t2.micro | dms.t2.small | dms.t2.medium | dms.t2.large | dms.c4.large | dms.c4.xlarge | dms.c4.2xlarge | dms.c4.4xlarge@ -}
    , _replication_instance_id :: !(TF.Argument "replication_instance_id" Text)
    {- ^ (Required) The replication instance identifier. This parameter is stored as a lowercase string. -}
    , _replication_subnet_group_id :: !(TF.Argument "replication_subnet_group_id" Text)
    {- ^ (Optional) A subnet group to associate with the replication instance. -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    , _vpc_security_group_ids :: !(TF.Argument "vpc_security_group_ids" Text)
    {- ^ (Optional) A list of VPC security group IDs to be used with the replication instance. The VPC security groups must work with the VPC containing the replication instance. -}
    } deriving (Show, Eq)

instance TF.ToHCL DmsReplicationInstanceResource where
    toHCL DmsReplicationInstanceResource{..} = TF.block $ catMaybes
        [ TF.argument _allocated_storage
        , TF.argument _apply_immediately
        , TF.argument _auto_minor_version_upgrade
        , TF.argument _availability_zone
        , TF.argument _engine_version
        , TF.argument _kms_key_arn
        , TF.argument _multi_az
        , TF.argument _preferred_maintenance_window
        , TF.argument _publicly_accessible
        , TF.argument _replication_instance_class
        , TF.argument _replication_instance_id
        , TF.argument _replication_subnet_group_id
        , TF.argument _tags
        , TF.argument _vpc_security_group_ids
        ]

instance HasAllocatedStorage DmsReplicationInstanceResource Text where
    allocatedStorage =
        lens (_allocated_storage :: DmsReplicationInstanceResource -> TF.Argument "allocated_storage" Text)
             (\s a -> s { _allocated_storage = a } :: DmsReplicationInstanceResource)

instance HasApplyImmediately DmsReplicationInstanceResource Text where
    applyImmediately =
        lens (_apply_immediately :: DmsReplicationInstanceResource -> TF.Argument "apply_immediately" Text)
             (\s a -> s { _apply_immediately = a } :: DmsReplicationInstanceResource)

instance HasAutoMinorVersionUpgrade DmsReplicationInstanceResource Text where
    autoMinorVersionUpgrade =
        lens (_auto_minor_version_upgrade :: DmsReplicationInstanceResource -> TF.Argument "auto_minor_version_upgrade" Text)
             (\s a -> s { _auto_minor_version_upgrade = a } :: DmsReplicationInstanceResource)

instance HasAvailabilityZone DmsReplicationInstanceResource TF.Zone where
    availabilityZone =
        lens (_availability_zone :: DmsReplicationInstanceResource -> TF.Argument "availability_zone" TF.Zone)
             (\s a -> s { _availability_zone = a } :: DmsReplicationInstanceResource)

instance HasEngineVersion DmsReplicationInstanceResource Text where
    engineVersion =
        lens (_engine_version :: DmsReplicationInstanceResource -> TF.Argument "engine_version" Text)
             (\s a -> s { _engine_version = a } :: DmsReplicationInstanceResource)

instance HasKmsKeyArn DmsReplicationInstanceResource Text where
    kmsKeyArn =
        lens (_kms_key_arn :: DmsReplicationInstanceResource -> TF.Argument "kms_key_arn" Text)
             (\s a -> s { _kms_key_arn = a } :: DmsReplicationInstanceResource)

instance HasMultiAz DmsReplicationInstanceResource Text where
    multiAz =
        lens (_multi_az :: DmsReplicationInstanceResource -> TF.Argument "multi_az" Text)
             (\s a -> s { _multi_az = a } :: DmsReplicationInstanceResource)

instance HasPreferredMaintenanceWindow DmsReplicationInstanceResource Text where
    preferredMaintenanceWindow =
        lens (_preferred_maintenance_window :: DmsReplicationInstanceResource -> TF.Argument "preferred_maintenance_window" Text)
             (\s a -> s { _preferred_maintenance_window = a } :: DmsReplicationInstanceResource)

instance HasPubliclyAccessible DmsReplicationInstanceResource Text where
    publiclyAccessible =
        lens (_publicly_accessible :: DmsReplicationInstanceResource -> TF.Argument "publicly_accessible" Text)
             (\s a -> s { _publicly_accessible = a } :: DmsReplicationInstanceResource)

instance HasReplicationInstanceClass DmsReplicationInstanceResource Text where
    replicationInstanceClass =
        lens (_replication_instance_class :: DmsReplicationInstanceResource -> TF.Argument "replication_instance_class" Text)
             (\s a -> s { _replication_instance_class = a } :: DmsReplicationInstanceResource)

instance HasReplicationInstanceId DmsReplicationInstanceResource Text where
    replicationInstanceId =
        lens (_replication_instance_id :: DmsReplicationInstanceResource -> TF.Argument "replication_instance_id" Text)
             (\s a -> s { _replication_instance_id = a } :: DmsReplicationInstanceResource)

instance HasReplicationSubnetGroupId DmsReplicationInstanceResource Text where
    replicationSubnetGroupId =
        lens (_replication_subnet_group_id :: DmsReplicationInstanceResource -> TF.Argument "replication_subnet_group_id" Text)
             (\s a -> s { _replication_subnet_group_id = a } :: DmsReplicationInstanceResource)

instance HasTags DmsReplicationInstanceResource TF.Tags where
    tags =
        lens (_tags :: DmsReplicationInstanceResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: DmsReplicationInstanceResource)

instance HasVpcSecurityGroupIds DmsReplicationInstanceResource Text where
    vpcSecurityGroupIds =
        lens (_vpc_security_group_ids :: DmsReplicationInstanceResource -> TF.Argument "vpc_security_group_ids" Text)
             (\s a -> s { _vpc_security_group_ids = a } :: DmsReplicationInstanceResource)

instance HasComputedReplicationInstanceArn DmsReplicationInstanceResource Text where
    computedReplicationInstanceArn =
        to (\_  -> TF.Compute "replication_instance_arn")

instance HasComputedReplicationInstancePrivateIps DmsReplicationInstanceResource Text where
    computedReplicationInstancePrivateIps =
        to (\_  -> TF.Compute "replication_instance_private_ips")

instance HasComputedReplicationInstancePublicIps DmsReplicationInstanceResource Text where
    computedReplicationInstancePublicIps =
        to (\_  -> TF.Compute "replication_instance_public_ips")

dmsReplicationInstanceResource :: TF.Resource TF.AWS DmsReplicationInstanceResource
dmsReplicationInstanceResource =
    TF.newResource "aws_dms_replication_instance" $
        DmsReplicationInstanceResource {
            _allocated_storage = TF.Nil
            , _apply_immediately = TF.Nil
            , _auto_minor_version_upgrade = TF.Nil
            , _availability_zone = TF.Nil
            , _engine_version = TF.Nil
            , _kms_key_arn = TF.Nil
            , _multi_az = TF.Nil
            , _preferred_maintenance_window = TF.Nil
            , _publicly_accessible = TF.Nil
            , _replication_instance_class = TF.Nil
            , _replication_instance_id = TF.Nil
            , _replication_subnet_group_id = TF.Nil
            , _tags = TF.Nil
            , _vpc_security_group_ids = TF.Nil
            }

{- | The @aws_dms_replication_subnet_group@ AWS resource.

Provides a DMS (Data Migration Service) replication subnet group resource.
DMS replication subnet groups can be created, updated, deleted, and
imported.
-}
data DmsReplicationSubnetGroupResource = DmsReplicationSubnetGroupResource {
      _replication_subnet_group_description :: !(TF.Argument "replication_subnet_group_description" Text)
    {- ^ (Required) The description for the subnet group. -}
    , _replication_subnet_group_id :: !(TF.Argument "replication_subnet_group_id" Text)
    {- ^ (Required) The name for the replication subnet group. This value is stored as a lowercase string. -}
    , _subnet_ids :: !(TF.Argument "subnet_ids" Text)
    {- ^ (Required) A list of the EC2 subnet IDs for the subnet group. -}
    } deriving (Show, Eq)

instance TF.ToHCL DmsReplicationSubnetGroupResource where
    toHCL DmsReplicationSubnetGroupResource{..} = TF.block $ catMaybes
        [ TF.argument _replication_subnet_group_description
        , TF.argument _replication_subnet_group_id
        , TF.argument _subnet_ids
        ]

instance HasReplicationSubnetGroupDescription DmsReplicationSubnetGroupResource Text where
    replicationSubnetGroupDescription =
        lens (_replication_subnet_group_description :: DmsReplicationSubnetGroupResource -> TF.Argument "replication_subnet_group_description" Text)
             (\s a -> s { _replication_subnet_group_description = a } :: DmsReplicationSubnetGroupResource)

instance HasReplicationSubnetGroupId DmsReplicationSubnetGroupResource Text where
    replicationSubnetGroupId =
        lens (_replication_subnet_group_id :: DmsReplicationSubnetGroupResource -> TF.Argument "replication_subnet_group_id" Text)
             (\s a -> s { _replication_subnet_group_id = a } :: DmsReplicationSubnetGroupResource)

instance HasSubnetIds DmsReplicationSubnetGroupResource Text where
    subnetIds =
        lens (_subnet_ids :: DmsReplicationSubnetGroupResource -> TF.Argument "subnet_ids" Text)
             (\s a -> s { _subnet_ids = a } :: DmsReplicationSubnetGroupResource)

instance HasComputedVpcId DmsReplicationSubnetGroupResource Text where
    computedVpcId =
        to (\_  -> TF.Compute "vpc_id")

dmsReplicationSubnetGroupResource :: TF.Resource TF.AWS DmsReplicationSubnetGroupResource
dmsReplicationSubnetGroupResource =
    TF.newResource "aws_dms_replication_subnet_group" $
        DmsReplicationSubnetGroupResource {
            _replication_subnet_group_description = TF.Nil
            , _replication_subnet_group_id = TF.Nil
            , _subnet_ids = TF.Nil
            }

{- | The @aws_dms_replication_task@ AWS resource.

Provides a DMS (Data Migration Service) replication task resource. DMS
replication tasks can be created, updated, deleted, and imported.
-}
data DmsReplicationTaskResource = DmsReplicationTaskResource {
      _cdc_start_time :: !(TF.Argument "cdc_start_time" Text)
    {- ^ (Optional) The Unix timestamp integer for the start of the Change Data Capture (CDC) operation. -}
    , _migration_type :: !(TF.Argument "migration_type" Text)
    {- ^ (Required) The migration type. Can be one of @full-load | cdc | full-load-and-cdc@ . -}
    , _replication_instance_arn :: !(TF.Argument "replication_instance_arn" Text)
    {- ^ (Required) The Amazon Resource Name (ARN) of the replication instance. -}
    , _replication_task_id :: !(TF.Argument "replication_task_id" Text)
    {- ^ (Required) The replication task identifier. -}
    , _replication_task_settings :: !(TF.Argument "replication_task_settings" Text)
    {- ^ (Optional) An escaped JSON string that contains the task settings. For a complete list of task settings, see <http://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.CustomizingTasks.TaskSettings.html> . -}
    , _source_endpoint_arn :: !(TF.Argument "source_endpoint_arn" Text)
    {- ^ (Required) The Amazon Resource Name (ARN) string that uniquely identifies the source endpoint. -}
    , _table_mappings :: !(TF.Argument "table_mappings" Text)
    {- ^ (Required) An escaped JSON string that contains the table mappings. For information on table mapping see <http://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.CustomizingTasks.TableMapping.html> -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    , _target_endpoint_arn :: !(TF.Argument "target_endpoint_arn" Text)
    {- ^ (Required) The Amazon Resource Name (ARN) string that uniquely identifies the target endpoint. -}
    } deriving (Show, Eq)

instance TF.ToHCL DmsReplicationTaskResource where
    toHCL DmsReplicationTaskResource{..} = TF.block $ catMaybes
        [ TF.argument _cdc_start_time
        , TF.argument _migration_type
        , TF.argument _replication_instance_arn
        , TF.argument _replication_task_id
        , TF.argument _replication_task_settings
        , TF.argument _source_endpoint_arn
        , TF.argument _table_mappings
        , TF.argument _tags
        , TF.argument _target_endpoint_arn
        ]

instance HasCdcStartTime DmsReplicationTaskResource Text where
    cdcStartTime =
        lens (_cdc_start_time :: DmsReplicationTaskResource -> TF.Argument "cdc_start_time" Text)
             (\s a -> s { _cdc_start_time = a } :: DmsReplicationTaskResource)

instance HasMigrationType DmsReplicationTaskResource Text where
    migrationType =
        lens (_migration_type :: DmsReplicationTaskResource -> TF.Argument "migration_type" Text)
             (\s a -> s { _migration_type = a } :: DmsReplicationTaskResource)

instance HasReplicationInstanceArn DmsReplicationTaskResource Text where
    replicationInstanceArn =
        lens (_replication_instance_arn :: DmsReplicationTaskResource -> TF.Argument "replication_instance_arn" Text)
             (\s a -> s { _replication_instance_arn = a } :: DmsReplicationTaskResource)

instance HasReplicationTaskId DmsReplicationTaskResource Text where
    replicationTaskId =
        lens (_replication_task_id :: DmsReplicationTaskResource -> TF.Argument "replication_task_id" Text)
             (\s a -> s { _replication_task_id = a } :: DmsReplicationTaskResource)

instance HasReplicationTaskSettings DmsReplicationTaskResource Text where
    replicationTaskSettings =
        lens (_replication_task_settings :: DmsReplicationTaskResource -> TF.Argument "replication_task_settings" Text)
             (\s a -> s { _replication_task_settings = a } :: DmsReplicationTaskResource)

instance HasSourceEndpointArn DmsReplicationTaskResource Text where
    sourceEndpointArn =
        lens (_source_endpoint_arn :: DmsReplicationTaskResource -> TF.Argument "source_endpoint_arn" Text)
             (\s a -> s { _source_endpoint_arn = a } :: DmsReplicationTaskResource)

instance HasTableMappings DmsReplicationTaskResource Text where
    tableMappings =
        lens (_table_mappings :: DmsReplicationTaskResource -> TF.Argument "table_mappings" Text)
             (\s a -> s { _table_mappings = a } :: DmsReplicationTaskResource)

instance HasTags DmsReplicationTaskResource TF.Tags where
    tags =
        lens (_tags :: DmsReplicationTaskResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: DmsReplicationTaskResource)

instance HasTargetEndpointArn DmsReplicationTaskResource Text where
    targetEndpointArn =
        lens (_target_endpoint_arn :: DmsReplicationTaskResource -> TF.Argument "target_endpoint_arn" Text)
             (\s a -> s { _target_endpoint_arn = a } :: DmsReplicationTaskResource)

instance HasComputedReplicationTaskArn DmsReplicationTaskResource Text where
    computedReplicationTaskArn =
        to (\_  -> TF.Compute "replication_task_arn")

dmsReplicationTaskResource :: TF.Resource TF.AWS DmsReplicationTaskResource
dmsReplicationTaskResource =
    TF.newResource "aws_dms_replication_task" $
        DmsReplicationTaskResource {
            _cdc_start_time = TF.Nil
            , _migration_type = TF.Nil
            , _replication_instance_arn = TF.Nil
            , _replication_task_id = TF.Nil
            , _replication_task_settings = TF.Nil
            , _source_endpoint_arn = TF.Nil
            , _table_mappings = TF.Nil
            , _tags = TF.Nil
            , _target_endpoint_arn = TF.Nil
            }

{- | The @aws_dx_connection_association@ AWS resource.

Associates a Direct Connect Connection with a LAG.
-}
data DxConnectionAssociationResource = DxConnectionAssociationResource {
      _connection_id :: !(TF.Argument "connection_id" Text)
    {- ^ (Required) The ID of the connection. -}
    , _lag_id :: !(TF.Argument "lag_id" Text)
    {- ^ (Required) The ID of the LAG with which to associate the connection. -}
    } deriving (Show, Eq)

instance TF.ToHCL DxConnectionAssociationResource where
    toHCL DxConnectionAssociationResource{..} = TF.block $ catMaybes
        [ TF.argument _connection_id
        , TF.argument _lag_id
        ]

instance HasConnectionId DxConnectionAssociationResource Text where
    connectionId =
        lens (_connection_id :: DxConnectionAssociationResource -> TF.Argument "connection_id" Text)
             (\s a -> s { _connection_id = a } :: DxConnectionAssociationResource)

instance HasLagId DxConnectionAssociationResource Text where
    lagId =
        lens (_lag_id :: DxConnectionAssociationResource -> TF.Argument "lag_id" Text)
             (\s a -> s { _lag_id = a } :: DxConnectionAssociationResource)

dxConnectionAssociationResource :: TF.Resource TF.AWS DxConnectionAssociationResource
dxConnectionAssociationResource =
    TF.newResource "aws_dx_connection_association" $
        DxConnectionAssociationResource {
            _connection_id = TF.Nil
            , _lag_id = TF.Nil
            }

{- | The @aws_dx_connection@ AWS resource.

Provides a Connection of Direct Connect.
-}
data DxConnectionResource = DxConnectionResource {
      _bandwidth :: !(TF.Argument "bandwidth" Text)
    {- ^ (Required) The bandwidth of the connection. Available values: 1Gbps, 10Gbps. Case sensitive. -}
    , _location :: !(TF.Argument "location" Text)
    {- ^ (Required) The AWS Direct Connect location where the connection is located. See <https://docs.aws.amazon.com/directconnect/latest/APIReference/API_DescribeLocations.html> for the list of AWS Direct Connect locations. Use @locationCode@ . -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the connection. -}
    } deriving (Show, Eq)

instance TF.ToHCL DxConnectionResource where
    toHCL DxConnectionResource{..} = TF.block $ catMaybes
        [ TF.argument _bandwidth
        , TF.argument _location
        , TF.argument _name
        ]

instance HasBandwidth DxConnectionResource Text where
    bandwidth =
        lens (_bandwidth :: DxConnectionResource -> TF.Argument "bandwidth" Text)
             (\s a -> s { _bandwidth = a } :: DxConnectionResource)

instance HasLocation DxConnectionResource Text where
    location =
        lens (_location :: DxConnectionResource -> TF.Argument "location" Text)
             (\s a -> s { _location = a } :: DxConnectionResource)

instance HasName DxConnectionResource Text where
    name =
        lens (_name :: DxConnectionResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: DxConnectionResource)

instance HasComputedId DxConnectionResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

dxConnectionResource :: TF.Resource TF.AWS DxConnectionResource
dxConnectionResource =
    TF.newResource "aws_dx_connection" $
        DxConnectionResource {
            _bandwidth = TF.Nil
            , _location = TF.Nil
            , _name = TF.Nil
            }

{- | The @aws_dx_lag@ AWS resource.

Provides a Direct Connect LAG.
-}
data DxLagResource = DxLagResource {
      _connections_bandwidth :: !(TF.Argument "connections_bandwidth" Text)
    {- ^ (Required) The bandwidth of the individual physical connections bundled by the LAG. Available values: 1Gbps, 10Gbps. Case sensitive. -}
    , _force_destroy :: !(TF.Argument "force_destroy" Text)
    {- ^ (Optional, Default:false) A boolean that indicates all connections associated with the LAG should be deleted so that the LAG can be destroyed without error. These objects are not recoverable. -}
    , _location :: !(TF.Argument "location" Text)
    {- ^ (Required) The AWS Direct Connect location in which the LAG should be allocated. See <https://docs.aws.amazon.com/directconnect/latest/APIReference/API_DescribeLocations.html> for the list of AWS Direct Connect locations. Use @locationCode@ . -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the LAG. -}
    , _number_of_connections :: !(TF.Argument "number_of_connections" Text)
    {- ^ (Required) The number of physical connections initially provisioned and bundled by the LAG. -}
    } deriving (Show, Eq)

instance TF.ToHCL DxLagResource where
    toHCL DxLagResource{..} = TF.block $ catMaybes
        [ TF.argument _connections_bandwidth
        , TF.argument _force_destroy
        , TF.argument _location
        , TF.argument _name
        , TF.argument _number_of_connections
        ]

instance HasConnectionsBandwidth DxLagResource Text where
    connectionsBandwidth =
        lens (_connections_bandwidth :: DxLagResource -> TF.Argument "connections_bandwidth" Text)
             (\s a -> s { _connections_bandwidth = a } :: DxLagResource)

instance HasForceDestroy DxLagResource Text where
    forceDestroy =
        lens (_force_destroy :: DxLagResource -> TF.Argument "force_destroy" Text)
             (\s a -> s { _force_destroy = a } :: DxLagResource)

instance HasLocation DxLagResource Text where
    location =
        lens (_location :: DxLagResource -> TF.Argument "location" Text)
             (\s a -> s { _location = a } :: DxLagResource)

instance HasName DxLagResource Text where
    name =
        lens (_name :: DxLagResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: DxLagResource)

instance HasNumberOfConnections DxLagResource Text where
    numberOfConnections =
        lens (_number_of_connections :: DxLagResource -> TF.Argument "number_of_connections" Text)
             (\s a -> s { _number_of_connections = a } :: DxLagResource)

instance HasComputedId DxLagResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

dxLagResource :: TF.Resource TF.AWS DxLagResource
dxLagResource =
    TF.newResource "aws_dx_lag" $
        DxLagResource {
            _connections_bandwidth = TF.Nil
            , _force_destroy = TF.Nil
            , _location = TF.Nil
            , _name = TF.Nil
            , _number_of_connections = TF.Nil
            }

{- | The @aws_dynamodb_table@ AWS resource.

Provides a DynamoDB table resource ~> Note: It is recommended to use
@lifecycle@  </docs/configuration/resources.html#ignore_changes> for
@read_capacity@ and/or @write_capacity@ if there's
</docs/providers/aws/r/appautoscaling_policy.html> attached to the table.
-}
data DynamodbTableResource = DynamodbTableResource {
      _attribute :: !(TF.Argument "attribute" TF.DynamoTableAttributes)
    {- ^ (Required) Define an attribute, has two properties: -}
    , _global_secondary_index :: !(TF.Argument "global_secondary_index" Text)
    {- ^ (Optional) Describe a GSO for the table; subject to the normal limits on the number of GSIs, projected attributes, etc. -}
    , _hash_key :: !(TF.Argument "hash_key" Text)
    {- ^ (Required, Forces new resource) The attribute to use as the hash key (the attribute must also be defined as an attribute record -}
    , _local_secondary_index :: !(TF.Argument "local_secondary_index" Text)
    {- ^ (Optional, Forces new resource) Describe an LSI on the table; these can only be allocated at creation so you cannot change this definition after you have created the resource. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the table, this needs to be unique within a region. -}
    , _range_key :: !(TF.Argument "range_key" Text)
    {- ^ (Optional, Forces new resource) The attribute to use as the range key (must also be defined) -}
    , _read_capacity :: !(TF.Argument "read_capacity" TF.Natural)
    {- ^ (Required) The number of read units for this table -}
    , _stream_enabled :: !(TF.Argument "stream_enabled" TF.Bool)
    {- ^ (Optional) Indicates whether Streams are to be enabled (true) or disabled (false). -}
    , _stream_view_type :: !(TF.Argument "stream_view_type" Text)
    {- ^ (Optional) When an item in the table is modified, StreamViewType determines what information is written to the table's stream. Valid values are @KEYS_ONLY@ , @NEW_IMAGE@ , @OLD_IMAGE@ , @NEW_AND_OLD_IMAGES@ . -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A map of tags to populate on the created table. -}
    , _ttl :: !(TF.Argument "ttl" Text)
    {- ^ (Optional) Defines ttl, has two properties, and can only be specified once: -}
    , _write_capacity :: !(TF.Argument "write_capacity" TF.Natural)
    {- ^ (Required) The number of write units for this table -}
    } deriving (Show, Eq)

instance TF.ToHCL DynamodbTableResource where
    toHCL DynamodbTableResource{..} = TF.block $ catMaybes
        [ TF.argument _attribute
        , TF.argument _global_secondary_index
        , TF.argument _hash_key
        , TF.argument _local_secondary_index
        , TF.argument _name
        , TF.argument _range_key
        , TF.argument _read_capacity
        , TF.argument _stream_enabled
        , TF.argument _stream_view_type
        , TF.argument _tags
        , TF.argument _ttl
        , TF.argument _write_capacity
        ]

instance HasAttribute DynamodbTableResource TF.DynamoTableAttributes where
    attribute =
        lens (_attribute :: DynamodbTableResource -> TF.Argument "attribute" TF.DynamoTableAttributes)
             (\s a -> s { _attribute = a } :: DynamodbTableResource)

instance HasGlobalSecondaryIndex DynamodbTableResource Text where
    globalSecondaryIndex =
        lens (_global_secondary_index :: DynamodbTableResource -> TF.Argument "global_secondary_index" Text)
             (\s a -> s { _global_secondary_index = a } :: DynamodbTableResource)

instance HasHashKey DynamodbTableResource Text where
    hashKey =
        lens (_hash_key :: DynamodbTableResource -> TF.Argument "hash_key" Text)
             (\s a -> s { _hash_key = a } :: DynamodbTableResource)

instance HasLocalSecondaryIndex DynamodbTableResource Text where
    localSecondaryIndex =
        lens (_local_secondary_index :: DynamodbTableResource -> TF.Argument "local_secondary_index" Text)
             (\s a -> s { _local_secondary_index = a } :: DynamodbTableResource)

instance HasName DynamodbTableResource Text where
    name =
        lens (_name :: DynamodbTableResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: DynamodbTableResource)

instance HasRangeKey DynamodbTableResource Text where
    rangeKey =
        lens (_range_key :: DynamodbTableResource -> TF.Argument "range_key" Text)
             (\s a -> s { _range_key = a } :: DynamodbTableResource)

instance HasReadCapacity DynamodbTableResource TF.Natural where
    readCapacity =
        lens (_read_capacity :: DynamodbTableResource -> TF.Argument "read_capacity" TF.Natural)
             (\s a -> s { _read_capacity = a } :: DynamodbTableResource)

instance HasStreamEnabled DynamodbTableResource TF.Bool where
    streamEnabled =
        lens (_stream_enabled :: DynamodbTableResource -> TF.Argument "stream_enabled" TF.Bool)
             (\s a -> s { _stream_enabled = a } :: DynamodbTableResource)

instance HasStreamViewType DynamodbTableResource Text where
    streamViewType =
        lens (_stream_view_type :: DynamodbTableResource -> TF.Argument "stream_view_type" Text)
             (\s a -> s { _stream_view_type = a } :: DynamodbTableResource)

instance HasTags DynamodbTableResource TF.Tags where
    tags =
        lens (_tags :: DynamodbTableResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: DynamodbTableResource)

instance HasTtl DynamodbTableResource Text where
    ttl =
        lens (_ttl :: DynamodbTableResource -> TF.Argument "ttl" Text)
             (\s a -> s { _ttl = a } :: DynamodbTableResource)

instance HasWriteCapacity DynamodbTableResource TF.Natural where
    writeCapacity =
        lens (_write_capacity :: DynamodbTableResource -> TF.Argument "write_capacity" TF.Natural)
             (\s a -> s { _write_capacity = a } :: DynamodbTableResource)

dynamodbTableResource :: TF.Resource TF.AWS DynamodbTableResource
dynamodbTableResource =
    TF.newResource "aws_dynamodb_table" $
        DynamodbTableResource {
            _attribute = TF.Nil
            , _global_secondary_index = TF.Nil
            , _hash_key = TF.Nil
            , _local_secondary_index = TF.Nil
            , _name = TF.Nil
            , _range_key = TF.Nil
            , _read_capacity = TF.Nil
            , _stream_enabled = TF.Nil
            , _stream_view_type = TF.Nil
            , _tags = TF.Nil
            , _ttl = TF.Nil
            , _write_capacity = TF.Nil
            }

{- | The @aws_ebs_snapshot@ AWS resource.

Creates a Snapshot of an EBS Volume.
-}
data EbsSnapshotResource = EbsSnapshotResource {
      _description :: !(TF.Argument "description" Text)
    {- ^ (Optional) A description of what the snapshot is. -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the snapshot -}
    , _volume_id :: !(TF.Argument "volume_id" Text)
    {- ^ (Required) The Volume ID of which to make a snapshot. -}
    } deriving (Show, Eq)

instance TF.ToHCL EbsSnapshotResource where
    toHCL EbsSnapshotResource{..} = TF.block $ catMaybes
        [ TF.argument _description
        , TF.argument _tags
        , TF.argument _volume_id
        ]

instance HasDescription EbsSnapshotResource Text where
    description =
        lens (_description :: EbsSnapshotResource -> TF.Argument "description" Text)
             (\s a -> s { _description = a } :: EbsSnapshotResource)

instance HasTags EbsSnapshotResource TF.Tags where
    tags =
        lens (_tags :: EbsSnapshotResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: EbsSnapshotResource)

instance HasVolumeId EbsSnapshotResource Text where
    volumeId =
        lens (_volume_id :: EbsSnapshotResource -> TF.Argument "volume_id" Text)
             (\s a -> s { _volume_id = a } :: EbsSnapshotResource)

instance HasComputedDataEncryptionKeyId EbsSnapshotResource Text where
    computedDataEncryptionKeyId =
        to (\_  -> TF.Compute "data_encryption_key_id")

instance HasComputedEncrypted EbsSnapshotResource Text where
    computedEncrypted =
        to (\_  -> TF.Compute "encrypted")

instance HasComputedId EbsSnapshotResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedKmsKeyId EbsSnapshotResource Text where
    computedKmsKeyId =
        to (\_  -> TF.Compute "kms_key_id")

instance HasComputedOwnerAlias EbsSnapshotResource Text where
    computedOwnerAlias =
        to (\_  -> TF.Compute "owner_alias")

instance HasComputedOwnerId EbsSnapshotResource Text where
    computedOwnerId =
        to (\_  -> TF.Compute "owner_id")

instance HasComputedTags EbsSnapshotResource TF.Tags where
    computedTags =
        to (\_  -> TF.Compute "tags")

instance HasComputedVolumeSize EbsSnapshotResource Text where
    computedVolumeSize =
        to (\_  -> TF.Compute "volume_size")

ebsSnapshotResource :: TF.Resource TF.AWS EbsSnapshotResource
ebsSnapshotResource =
    TF.newResource "aws_ebs_snapshot" $
        EbsSnapshotResource {
            _description = TF.Nil
            , _tags = TF.Nil
            , _volume_id = TF.Nil
            }

{- | The @aws_ebs_volume@ AWS resource.

Manages a single EBS volume.
-}
data EbsVolumeResource = EbsVolumeResource {
      _availability_zone :: !(TF.Argument "availability_zone" TF.Zone)
    {- ^ (Required) The AZ where the EBS volume will exist. -}
    , _encrypted :: !(TF.Argument "encrypted" Text)
    {- ^ (Optional) If true, the disk will be encrypted. -}
    , _iops :: !(TF.Argument "iops" Text)
    {- ^ (Optional) The amount of IOPS to provision for the disk. -}
    , _kms_key_id :: !(TF.Argument "kms_key_id" Text)
    {- ^ (Optional) The ARN for the KMS encryption key. When specifying @kms_key_id@ , @encrypted@ needs to be set to true. -}
    , _size :: !(TF.Argument "size" Text)
    {- ^ (Optional) The size of the drive in GiBs. -}
    , _snapshot_id :: !(TF.Argument "snapshot_id" Text)
    {- ^ (Optional) A snapshot to base the EBS volume off of. -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    , _type' :: !(TF.Argument "type" Text)
    {- ^ (Optional) The type of EBS volume. Can be "standard", "gp2", "io1", "sc1" or "st1" (Default: "standard"). -}
    } deriving (Show, Eq)

instance TF.ToHCL EbsVolumeResource where
    toHCL EbsVolumeResource{..} = TF.block $ catMaybes
        [ TF.argument _availability_zone
        , TF.argument _encrypted
        , TF.argument _iops
        , TF.argument _kms_key_id
        , TF.argument _size
        , TF.argument _snapshot_id
        , TF.argument _tags
        , TF.argument _type'
        ]

instance HasAvailabilityZone EbsVolumeResource TF.Zone where
    availabilityZone =
        lens (_availability_zone :: EbsVolumeResource -> TF.Argument "availability_zone" TF.Zone)
             (\s a -> s { _availability_zone = a } :: EbsVolumeResource)

instance HasEncrypted EbsVolumeResource Text where
    encrypted =
        lens (_encrypted :: EbsVolumeResource -> TF.Argument "encrypted" Text)
             (\s a -> s { _encrypted = a } :: EbsVolumeResource)

instance HasIops EbsVolumeResource Text where
    iops =
        lens (_iops :: EbsVolumeResource -> TF.Argument "iops" Text)
             (\s a -> s { _iops = a } :: EbsVolumeResource)

instance HasKmsKeyId EbsVolumeResource Text where
    kmsKeyId =
        lens (_kms_key_id :: EbsVolumeResource -> TF.Argument "kms_key_id" Text)
             (\s a -> s { _kms_key_id = a } :: EbsVolumeResource)

instance HasSize EbsVolumeResource Text where
    size =
        lens (_size :: EbsVolumeResource -> TF.Argument "size" Text)
             (\s a -> s { _size = a } :: EbsVolumeResource)

instance HasSnapshotId EbsVolumeResource Text where
    snapshotId =
        lens (_snapshot_id :: EbsVolumeResource -> TF.Argument "snapshot_id" Text)
             (\s a -> s { _snapshot_id = a } :: EbsVolumeResource)

instance HasTags EbsVolumeResource TF.Tags where
    tags =
        lens (_tags :: EbsVolumeResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: EbsVolumeResource)

instance HasType' EbsVolumeResource Text where
    type' =
        lens (_type' :: EbsVolumeResource -> TF.Argument "type" Text)
             (\s a -> s { _type' = a } :: EbsVolumeResource)

instance HasComputedArn EbsVolumeResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

instance HasComputedId EbsVolumeResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

ebsVolumeResource :: TF.Resource TF.AWS EbsVolumeResource
ebsVolumeResource =
    TF.newResource "aws_ebs_volume" $
        EbsVolumeResource {
            _availability_zone = TF.Nil
            , _encrypted = TF.Nil
            , _iops = TF.Nil
            , _kms_key_id = TF.Nil
            , _size = TF.Nil
            , _snapshot_id = TF.Nil
            , _tags = TF.Nil
            , _type' = TF.Nil
            }

{- | The @aws_ecr_lifecycle_policy@ AWS resource.

Provides an ECR lifecycle policy.
-}
data EcrLifecyclePolicyResource = EcrLifecyclePolicyResource {
      _policy :: !(TF.Argument "policy" Text)
    {- ^ (Required) The policy document. This is a JSON formatted string. See more details about <http://docs.aws.amazon.com/ja_jp/AmazonECR/latest/userguide/LifecyclePolicies.html#lifecycle_policy_parameters> in the official AWS docs. -}
    , _repository :: !(TF.Argument "repository" Text)
    {- ^ (Required) Name of the repository to apply the policy. -}
    } deriving (Show, Eq)

instance TF.ToHCL EcrLifecyclePolicyResource where
    toHCL EcrLifecyclePolicyResource{..} = TF.block $ catMaybes
        [ TF.argument _policy
        , TF.argument _repository
        ]

instance HasPolicy EcrLifecyclePolicyResource Text where
    policy =
        lens (_policy :: EcrLifecyclePolicyResource -> TF.Argument "policy" Text)
             (\s a -> s { _policy = a } :: EcrLifecyclePolicyResource)

instance HasRepository EcrLifecyclePolicyResource Text where
    repository =
        lens (_repository :: EcrLifecyclePolicyResource -> TF.Argument "repository" Text)
             (\s a -> s { _repository = a } :: EcrLifecyclePolicyResource)

instance HasComputedRegistryId EcrLifecyclePolicyResource Text where
    computedRegistryId =
        to (\_  -> TF.Compute "registry_id")

instance HasComputedRepository EcrLifecyclePolicyResource Text where
    computedRepository =
        to (\_  -> TF.Compute "repository")

ecrLifecyclePolicyResource :: TF.Resource TF.AWS EcrLifecyclePolicyResource
ecrLifecyclePolicyResource =
    TF.newResource "aws_ecr_lifecycle_policy" $
        EcrLifecyclePolicyResource {
            _policy = TF.Nil
            , _repository = TF.Nil
            }

{- | The @aws_ecr_repository_policy@ AWS resource.

Provides an ECR repository policy. Note that currently only one policy may
be applied to a repository. ~> NOTE on ECR Availability : The EC2 Container
Registry is not yet rolled out in all regions - available regions are listed
<https://docs.aws.amazon.com/general/latest/gr/rande.html#ecr_region> .
-}
data EcrRepositoryPolicyResource = EcrRepositoryPolicyResource {
      _policy :: !(TF.Argument "policy" Text)
    {- ^ (Required) The policy document. This is a JSON formatted string. -}
    , _repository :: !(TF.Argument "repository" Text)
    {- ^ (Required) Name of the repository to apply the policy. -}
    } deriving (Show, Eq)

instance TF.ToHCL EcrRepositoryPolicyResource where
    toHCL EcrRepositoryPolicyResource{..} = TF.block $ catMaybes
        [ TF.argument _policy
        , TF.argument _repository
        ]

instance HasPolicy EcrRepositoryPolicyResource Text where
    policy =
        lens (_policy :: EcrRepositoryPolicyResource -> TF.Argument "policy" Text)
             (\s a -> s { _policy = a } :: EcrRepositoryPolicyResource)

instance HasRepository EcrRepositoryPolicyResource Text where
    repository =
        lens (_repository :: EcrRepositoryPolicyResource -> TF.Argument "repository" Text)
             (\s a -> s { _repository = a } :: EcrRepositoryPolicyResource)

instance HasComputedRegistryId EcrRepositoryPolicyResource Text where
    computedRegistryId =
        to (\_  -> TF.Compute "registry_id")

instance HasComputedRepository EcrRepositoryPolicyResource Text where
    computedRepository =
        to (\_  -> TF.Compute "repository")

ecrRepositoryPolicyResource :: TF.Resource TF.AWS EcrRepositoryPolicyResource
ecrRepositoryPolicyResource =
    TF.newResource "aws_ecr_repository_policy" $
        EcrRepositoryPolicyResource {
            _policy = TF.Nil
            , _repository = TF.Nil
            }

{- | The @aws_ecr_repository@ AWS resource.

Provides an EC2 Container Registry Repository. ~> NOTE on ECR Availability :
The EC2 Container Registry is not yet rolled out in all regions - available
regions are listed
<https://docs.aws.amazon.com/general/latest/gr/rande.html#ecr_region> .
-}
data EcrRepositoryResource = EcrRepositoryResource {
      _name :: !(TF.Argument "name" Text)
    {- ^ (Required) Name of the repository. -}
    } deriving (Show, Eq)

instance TF.ToHCL EcrRepositoryResource where
    toHCL EcrRepositoryResource{..} = TF.block $ catMaybes
        [ TF.argument _name
        ]

instance HasName EcrRepositoryResource Text where
    name =
        lens (_name :: EcrRepositoryResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: EcrRepositoryResource)

instance HasComputedArn EcrRepositoryResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

instance HasComputedName EcrRepositoryResource Text where
    computedName =
        to (\_  -> TF.Compute "name")

instance HasComputedRegistryId EcrRepositoryResource Text where
    computedRegistryId =
        to (\_  -> TF.Compute "registry_id")

instance HasComputedRepositoryUrl EcrRepositoryResource Text where
    computedRepositoryUrl =
        to (\_  -> TF.Compute "repository_url")

ecrRepositoryResource :: TF.Resource TF.AWS EcrRepositoryResource
ecrRepositoryResource =
    TF.newResource "aws_ecr_repository" $
        EcrRepositoryResource {
            _name = TF.Nil
            }

{- | The @aws_ecs_cluster@ AWS resource.

Provides an ECS cluster.
-}
data EcsClusterResource = EcsClusterResource {
      _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the cluster (up to 255 letters, numbers, hyphens, and underscores) -}
    } deriving (Show, Eq)

instance TF.ToHCL EcsClusterResource where
    toHCL EcsClusterResource{..} = TF.block $ catMaybes
        [ TF.argument _name
        ]

instance HasName EcsClusterResource Text where
    name =
        lens (_name :: EcsClusterResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: EcsClusterResource)

instance HasComputedArn EcsClusterResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

instance HasComputedId EcsClusterResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

ecsClusterResource :: TF.Resource TF.AWS EcsClusterResource
ecsClusterResource =
    TF.newResource "aws_ecs_cluster" $
        EcsClusterResource {
            _name = TF.Nil
            }

{- | The @aws_ecs_service@ AWS resource.

-> Note: To prevent a race condition during service deletion, make sure to
set @depends_on@ to the related @aws_iam_role_policy@ ; otherwise, the
policy may be destroyed too soon and the ECS service will then get stuck in
the @DRAINING@ state. Provides an ECS service - effectively a task that is
expected to run until an error occurs or a user terminates it (typically a
webserver or a database). See
<https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs_services.html>
.
-}
data EcsServiceResource = EcsServiceResource {
      _cluster :: !(TF.Argument "cluster" Text)
    {- ^ (Optional) ARN of an ECS cluster -}
    , _deployment_maximum_percent :: !(TF.Argument "deployment_maximum_percent" Text)
    {- ^ (Optional) The upper limit (as a percentage of the service's desiredCount) of the number of running tasks that can be running in a service during a deployment. -}
    , _deployment_minimum_healthy_percent :: !(TF.Argument "deployment_minimum_healthy_percent" Text)
    {- ^ (Optional) The lower limit (as a percentage of the service's desiredCount) of the number of running tasks that must remain running and healthy in a service during a deployment. -}
    , _desired_count :: !(TF.Argument "desired_count" Text)
    {- ^ (Required) The number of instances of the task definition to place and keep running -}
    , _health_check_grace_period_seconds :: !(TF.Argument "health_check_grace_period_seconds" Text)
    {- ^ (Optional) Seconds to ignore failing load balancer health checks on newly instantiated tasks to prevent premature shutdown, up to 1800. Only valid for services configured to use load balancers. -}
    , _iam_role :: !(TF.Argument "iam_role" Text)
    {- ^ (Optional) The ARN of IAM role that allows your Amazon ECS container agent to make calls to your load balancer on your behalf. This parameter is only required if you are using a load balancer with your service. -}
    , _launch_type :: !(TF.Argument "launch_type" Text)
    {- ^ (Optional) The launch type on which to run your service. The valid values are @EC2@ and @FARGATE@ . Defaults to @EC2@ . -}
    , _load_balancer :: !(TF.Argument "load_balancer" Text)
    {- ^ (Optional) A load balancer block. Load balancers documented below. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the service (up to 255 letters, numbers, hyphens, and underscores) -}
    , _network_configuration :: !(TF.Argument "network_configuration" Text)
    {- ^ (Optional) The network configuration for the service. This parameter is required for task definitions that use the awsvpc network mode to receive their own Elastic Network Interface, and it is not supported for other network modes. -}
    , _placement_constraints :: !(TF.Argument "placement_constraints" Text)
    {- ^ (Optional) rules that are taken into consideration during task placement. Maximum number of @placement_constraints@ is @10@ . Defined below. -}
    , _placement_strategy :: !(TF.Argument "placement_strategy" Text)
    {- ^ (Optional) Service level strategy rules that are taken into consideration during task placement. The maximum number of @placement_strategy@ blocks is @5@ . Defined below. -}
    , _task_definition :: !(TF.Argument "task_definition" Text)
    {- ^ (Required) The family and revision ( @family:revision@ ) or full ARN of the task definition that you want to run in your service. -}
    } deriving (Show, Eq)

instance TF.ToHCL EcsServiceResource where
    toHCL EcsServiceResource{..} = TF.block $ catMaybes
        [ TF.argument _cluster
        , TF.argument _deployment_maximum_percent
        , TF.argument _deployment_minimum_healthy_percent
        , TF.argument _desired_count
        , TF.argument _health_check_grace_period_seconds
        , TF.argument _iam_role
        , TF.argument _launch_type
        , TF.argument _load_balancer
        , TF.argument _name
        , TF.argument _network_configuration
        , TF.argument _placement_constraints
        , TF.argument _placement_strategy
        , TF.argument _task_definition
        ]

instance HasCluster EcsServiceResource Text where
    cluster =
        lens (_cluster :: EcsServiceResource -> TF.Argument "cluster" Text)
             (\s a -> s { _cluster = a } :: EcsServiceResource)

instance HasDeploymentMaximumPercent EcsServiceResource Text where
    deploymentMaximumPercent =
        lens (_deployment_maximum_percent :: EcsServiceResource -> TF.Argument "deployment_maximum_percent" Text)
             (\s a -> s { _deployment_maximum_percent = a } :: EcsServiceResource)

instance HasDeploymentMinimumHealthyPercent EcsServiceResource Text where
    deploymentMinimumHealthyPercent =
        lens (_deployment_minimum_healthy_percent :: EcsServiceResource -> TF.Argument "deployment_minimum_healthy_percent" Text)
             (\s a -> s { _deployment_minimum_healthy_percent = a } :: EcsServiceResource)

instance HasDesiredCount EcsServiceResource Text where
    desiredCount =
        lens (_desired_count :: EcsServiceResource -> TF.Argument "desired_count" Text)
             (\s a -> s { _desired_count = a } :: EcsServiceResource)

instance HasHealthCheckGracePeriodSeconds EcsServiceResource Text where
    healthCheckGracePeriodSeconds =
        lens (_health_check_grace_period_seconds :: EcsServiceResource -> TF.Argument "health_check_grace_period_seconds" Text)
             (\s a -> s { _health_check_grace_period_seconds = a } :: EcsServiceResource)

instance HasIamRole EcsServiceResource Text where
    iamRole =
        lens (_iam_role :: EcsServiceResource -> TF.Argument "iam_role" Text)
             (\s a -> s { _iam_role = a } :: EcsServiceResource)

instance HasLaunchType EcsServiceResource Text where
    launchType =
        lens (_launch_type :: EcsServiceResource -> TF.Argument "launch_type" Text)
             (\s a -> s { _launch_type = a } :: EcsServiceResource)

instance HasLoadBalancer EcsServiceResource Text where
    loadBalancer =
        lens (_load_balancer :: EcsServiceResource -> TF.Argument "load_balancer" Text)
             (\s a -> s { _load_balancer = a } :: EcsServiceResource)

instance HasName EcsServiceResource Text where
    name =
        lens (_name :: EcsServiceResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: EcsServiceResource)

instance HasNetworkConfiguration EcsServiceResource Text where
    networkConfiguration =
        lens (_network_configuration :: EcsServiceResource -> TF.Argument "network_configuration" Text)
             (\s a -> s { _network_configuration = a } :: EcsServiceResource)

instance HasPlacementConstraints EcsServiceResource Text where
    placementConstraints =
        lens (_placement_constraints :: EcsServiceResource -> TF.Argument "placement_constraints" Text)
             (\s a -> s { _placement_constraints = a } :: EcsServiceResource)

instance HasPlacementStrategy EcsServiceResource Text where
    placementStrategy =
        lens (_placement_strategy :: EcsServiceResource -> TF.Argument "placement_strategy" Text)
             (\s a -> s { _placement_strategy = a } :: EcsServiceResource)

instance HasTaskDefinition EcsServiceResource Text where
    taskDefinition =
        lens (_task_definition :: EcsServiceResource -> TF.Argument "task_definition" Text)
             (\s a -> s { _task_definition = a } :: EcsServiceResource)

ecsServiceResource :: TF.Resource TF.AWS EcsServiceResource
ecsServiceResource =
    TF.newResource "aws_ecs_service" $
        EcsServiceResource {
            _cluster = TF.Nil
            , _deployment_maximum_percent = TF.Nil
            , _deployment_minimum_healthy_percent = TF.Nil
            , _desired_count = TF.Nil
            , _health_check_grace_period_seconds = TF.Nil
            , _iam_role = TF.Nil
            , _launch_type = TF.Nil
            , _load_balancer = TF.Nil
            , _name = TF.Nil
            , _network_configuration = TF.Nil
            , _placement_constraints = TF.Nil
            , _placement_strategy = TF.Nil
            , _task_definition = TF.Nil
            }

{- | The @aws_ecs_task_definition@ AWS resource.

Provides an ECS task definition to be used in @aws_ecs_service@ .
-}
data EcsTaskDefinitionResource = EcsTaskDefinitionResource {
      _container_definitions :: !(TF.Argument "container_definitions" Text)
    {- ^ (Required) A list of valid [container definitions] (http://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html) provided as a single valid JSON document. Please note that you should only provide values that are part of the container definition document. For a detailed description of what parameters are available, see the [Task Definition Parameters] (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definition_parameters.html) section from the official <https://docs.aws.amazon.com/AmazonECS/latest/developerguide> . -}
    , _family' :: !(TF.Argument "family" Text)
    {- ^ (Required) A unique name for your task definition. -}
    } deriving (Show, Eq)

instance TF.ToHCL EcsTaskDefinitionResource where
    toHCL EcsTaskDefinitionResource{..} = TF.block $ catMaybes
        [ TF.argument _container_definitions
        , TF.argument _family'
        ]

instance HasContainerDefinitions EcsTaskDefinitionResource Text where
    containerDefinitions =
        lens (_container_definitions :: EcsTaskDefinitionResource -> TF.Argument "container_definitions" Text)
             (\s a -> s { _container_definitions = a } :: EcsTaskDefinitionResource)

instance HasFamily' EcsTaskDefinitionResource Text where
    family' =
        lens (_family' :: EcsTaskDefinitionResource -> TF.Argument "family" Text)
             (\s a -> s { _family' = a } :: EcsTaskDefinitionResource)

ecsTaskDefinitionResource :: TF.Resource TF.AWS EcsTaskDefinitionResource
ecsTaskDefinitionResource =
    TF.newResource "aws_ecs_task_definition" $
        EcsTaskDefinitionResource {
            _container_definitions = TF.Nil
            , _family' = TF.Nil
            }

{- | The @aws_efs_file_system@ AWS resource.

Provides an Elastic File System (EFS) resource.
-}
data EfsFileSystemResource = EfsFileSystemResource {
      _creation_token :: !(TF.Argument "creation_token" Text)
    {- ^ (Optional) A unique name (a maximum of 64 characters are allowed) used as reference when creating the Elastic File System to ensure idempotent file system creation. By default generated by Terraform. See [Elastic File System] (http://docs.aws.amazon.com/efs/latest/ug/) user guide for more information. -}
    , _encrypted :: !(TF.Argument "encrypted" Text)
    {- ^ (Optional) If true, the disk will be encrypted. -}
    , _kms_key_id :: !(TF.Argument "kms_key_id" Text)
    {- ^ (Optional) The ARN for the KMS encryption key. When specifying kms_key_id, encrypted needs to be set to true. -}
    , _performance_mode :: !(TF.Argument "performance_mode" Text)
    {- ^ (Optional) The file system performance mode. Can be either @"generalPurpose"@ or @"maxIO"@ (Default: @"generalPurpose"@ ). -}
    , _reference_name :: !(TF.Argument "reference_name" Text)
    {- ^ - DEPRECATED (Optional) A reference name used when creating the @Creation Token@ which Amazon EFS uses to ensure idempotent file system creation. By default generated by Terraform. -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the file system. -}
    } deriving (Show, Eq)

instance TF.ToHCL EfsFileSystemResource where
    toHCL EfsFileSystemResource{..} = TF.block $ catMaybes
        [ TF.argument _creation_token
        , TF.argument _encrypted
        , TF.argument _kms_key_id
        , TF.argument _performance_mode
        , TF.argument _reference_name
        , TF.argument _tags
        ]

instance HasCreationToken EfsFileSystemResource Text where
    creationToken =
        lens (_creation_token :: EfsFileSystemResource -> TF.Argument "creation_token" Text)
             (\s a -> s { _creation_token = a } :: EfsFileSystemResource)

instance HasEncrypted EfsFileSystemResource Text where
    encrypted =
        lens (_encrypted :: EfsFileSystemResource -> TF.Argument "encrypted" Text)
             (\s a -> s { _encrypted = a } :: EfsFileSystemResource)

instance HasKmsKeyId EfsFileSystemResource Text where
    kmsKeyId =
        lens (_kms_key_id :: EfsFileSystemResource -> TF.Argument "kms_key_id" Text)
             (\s a -> s { _kms_key_id = a } :: EfsFileSystemResource)

instance HasPerformanceMode EfsFileSystemResource Text where
    performanceMode =
        lens (_performance_mode :: EfsFileSystemResource -> TF.Argument "performance_mode" Text)
             (\s a -> s { _performance_mode = a } :: EfsFileSystemResource)

instance HasReferenceName EfsFileSystemResource Text where
    referenceName =
        lens (_reference_name :: EfsFileSystemResource -> TF.Argument "reference_name" Text)
             (\s a -> s { _reference_name = a } :: EfsFileSystemResource)

instance HasTags EfsFileSystemResource TF.Tags where
    tags =
        lens (_tags :: EfsFileSystemResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: EfsFileSystemResource)

instance HasComputedDnsName EfsFileSystemResource Text where
    computedDnsName =
        to (\_  -> TF.Compute "dns_name")

instance HasComputedId EfsFileSystemResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedKmsKeyId EfsFileSystemResource Text where
    computedKmsKeyId =
        to (\_  -> TF.Compute "kms_key_id")

efsFileSystemResource :: TF.Resource TF.AWS EfsFileSystemResource
efsFileSystemResource =
    TF.newResource "aws_efs_file_system" $
        EfsFileSystemResource {
            _creation_token = TF.Nil
            , _encrypted = TF.Nil
            , _kms_key_id = TF.Nil
            , _performance_mode = TF.Nil
            , _reference_name = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_efs_mount_target@ AWS resource.

Provides an Elastic File System (EFS) mount target.
-}
data EfsMountTargetResource = EfsMountTargetResource {
      _file_system_id :: !(TF.Argument "file_system_id" Text)
    {- ^ (Required) The ID of the file system for which the mount target is intended. -}
    , _ip_address :: !(TF.Argument "ip_address" Text)
    {- ^ (Optional) The address (within the address range of the specified subnet) at which the file system may be mounted via the mount target. -}
    , _security_groups :: !(TF.Argument "security_groups" Text)
    {- ^ (Optional) A list of up to 5 VPC security group IDs (that must be for the same VPC as subnet specified) in effect for the mount target. -}
    , _subnet_id :: !(TF.Argument "subnet_id" Text)
    {- ^ (Required) The ID of the subnet to add the mount target in. -}
    } deriving (Show, Eq)

instance TF.ToHCL EfsMountTargetResource where
    toHCL EfsMountTargetResource{..} = TF.block $ catMaybes
        [ TF.argument _file_system_id
        , TF.argument _ip_address
        , TF.argument _security_groups
        , TF.argument _subnet_id
        ]

instance HasFileSystemId EfsMountTargetResource Text where
    fileSystemId =
        lens (_file_system_id :: EfsMountTargetResource -> TF.Argument "file_system_id" Text)
             (\s a -> s { _file_system_id = a } :: EfsMountTargetResource)

instance HasIpAddress EfsMountTargetResource Text where
    ipAddress =
        lens (_ip_address :: EfsMountTargetResource -> TF.Argument "ip_address" Text)
             (\s a -> s { _ip_address = a } :: EfsMountTargetResource)

instance HasSecurityGroups EfsMountTargetResource Text where
    securityGroups =
        lens (_security_groups :: EfsMountTargetResource -> TF.Argument "security_groups" Text)
             (\s a -> s { _security_groups = a } :: EfsMountTargetResource)

instance HasSubnetId EfsMountTargetResource Text where
    subnetId =
        lens (_subnet_id :: EfsMountTargetResource -> TF.Argument "subnet_id" Text)
             (\s a -> s { _subnet_id = a } :: EfsMountTargetResource)

instance HasComputedDnsName EfsMountTargetResource Text where
    computedDnsName =
        to (\_  -> TF.Compute "dns_name")

instance HasComputedId EfsMountTargetResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedNetworkInterfaceId EfsMountTargetResource Text where
    computedNetworkInterfaceId =
        to (\_  -> TF.Compute "network_interface_id")

efsMountTargetResource :: TF.Resource TF.AWS EfsMountTargetResource
efsMountTargetResource =
    TF.newResource "aws_efs_mount_target" $
        EfsMountTargetResource {
            _file_system_id = TF.Nil
            , _ip_address = TF.Nil
            , _security_groups = TF.Nil
            , _subnet_id = TF.Nil
            }

{- | The @aws_egress_only_internet_gateway@ AWS resource.

[IPv6 only] Creates an egress-only Internet gateway for your VPC. An
egress-only Internet gateway is used to enable outbound communication over
IPv6 from instances in your VPC to the Internet, and prevents hosts outside
of your VPC from initiating an IPv6 connection with your instance.
-}
data EgressOnlyInternetGatewayResource = EgressOnlyInternetGatewayResource {
      _vpc_id :: !(TF.Argument "vpc_id" Text)
    {- ^ (Required) The VPC ID to create in. -}
    } deriving (Show, Eq)

instance TF.ToHCL EgressOnlyInternetGatewayResource where
    toHCL EgressOnlyInternetGatewayResource{..} = TF.block $ catMaybes
        [ TF.argument _vpc_id
        ]

instance HasVpcId EgressOnlyInternetGatewayResource Text where
    vpcId =
        lens (_vpc_id :: EgressOnlyInternetGatewayResource -> TF.Argument "vpc_id" Text)
             (\s a -> s { _vpc_id = a } :: EgressOnlyInternetGatewayResource)

instance HasComputedId EgressOnlyInternetGatewayResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

egressOnlyInternetGatewayResource :: TF.Resource TF.AWS EgressOnlyInternetGatewayResource
egressOnlyInternetGatewayResource =
    TF.newResource "aws_egress_only_internet_gateway" $
        EgressOnlyInternetGatewayResource {
            _vpc_id = TF.Nil
            }

{- | The @aws_eip_association@ AWS resource.

Provides an AWS EIP Association as a top level resource, to associate and
disassociate Elastic IPs from AWS Instances and Network Interfaces. ~> NOTE:
@aws_eip_association@ is useful in scenarios where EIPs are either
pre-existing or distributed to customers or users and therefore cannot be
changed.
-}
data EipAssociationResource = EipAssociationResource {
      _allocation_id :: !(TF.Argument "allocation_id" Text)
    {- ^ (Optional) The allocation ID. This is required for EC2-VPC. -}
    , _allow_reassociation :: !(TF.Argument "allow_reassociation" Text)
    {- ^ (Optional, Boolean) Whether to allow an Elastic IP to be re-associated. Defaults to @true@ in VPC. -}
    , _instance_id :: !(TF.Argument "instance_id" Text)
    {- ^ (Optional) The ID of the instance. This is required for EC2-Classic. For EC2-VPC, you can specify either the instance ID or the network interface ID, but not both. The operation fails if you specify an instance ID unless exactly one network interface is attached. -}
    , _network_interface_id :: !(TF.Argument "network_interface_id" Text)
    {- ^ (Optional) The ID of the network interface. If the instance has more than one network interface, you must specify a network interface ID. -}
    , _private_ip_address :: !(TF.Argument "private_ip_address" Text)
    {- ^ (Optional) The primary or secondary private IP address to associate with the Elastic IP address. If no private IP address is specified, the Elastic IP address is associated with the primary private IP address. -}
    , _public_ip :: !(TF.Argument "public_ip" Text)
    {- ^ (Optional) The Elastic IP address. This is required for EC2-Classic. -}
    } deriving (Show, Eq)

instance TF.ToHCL EipAssociationResource where
    toHCL EipAssociationResource{..} = TF.block $ catMaybes
        [ TF.argument _allocation_id
        , TF.argument _allow_reassociation
        , TF.argument _instance_id
        , TF.argument _network_interface_id
        , TF.argument _private_ip_address
        , TF.argument _public_ip
        ]

instance HasAllocationId EipAssociationResource Text where
    allocationId =
        lens (_allocation_id :: EipAssociationResource -> TF.Argument "allocation_id" Text)
             (\s a -> s { _allocation_id = a } :: EipAssociationResource)

instance HasAllowReassociation EipAssociationResource Text where
    allowReassociation =
        lens (_allow_reassociation :: EipAssociationResource -> TF.Argument "allow_reassociation" Text)
             (\s a -> s { _allow_reassociation = a } :: EipAssociationResource)

instance HasInstanceId EipAssociationResource Text where
    instanceId =
        lens (_instance_id :: EipAssociationResource -> TF.Argument "instance_id" Text)
             (\s a -> s { _instance_id = a } :: EipAssociationResource)

instance HasNetworkInterfaceId EipAssociationResource Text where
    networkInterfaceId =
        lens (_network_interface_id :: EipAssociationResource -> TF.Argument "network_interface_id" Text)
             (\s a -> s { _network_interface_id = a } :: EipAssociationResource)

instance HasPrivateIpAddress EipAssociationResource Text where
    privateIpAddress =
        lens (_private_ip_address :: EipAssociationResource -> TF.Argument "private_ip_address" Text)
             (\s a -> s { _private_ip_address = a } :: EipAssociationResource)

instance HasPublicIp EipAssociationResource Text where
    publicIp =
        lens (_public_ip :: EipAssociationResource -> TF.Argument "public_ip" Text)
             (\s a -> s { _public_ip = a } :: EipAssociationResource)

instance HasComputedAllocationId EipAssociationResource Text where
    computedAllocationId =
        to (\_  -> TF.Compute "allocation_id")

instance HasComputedAssociationId EipAssociationResource Text where
    computedAssociationId =
        to (\_  -> TF.Compute "association_id")

instance HasComputedInstanceId EipAssociationResource Text where
    computedInstanceId =
        to (\_  -> TF.Compute "instance_id")

instance HasComputedNetworkInterfaceId EipAssociationResource Text where
    computedNetworkInterfaceId =
        to (\_  -> TF.Compute "network_interface_id")

instance HasComputedPrivateIpAddress EipAssociationResource Text where
    computedPrivateIpAddress =
        to (\_  -> TF.Compute "private_ip_address")

instance HasComputedPublicIp EipAssociationResource Text where
    computedPublicIp =
        to (\_  -> TF.Compute "public_ip")

eipAssociationResource :: TF.Resource TF.AWS EipAssociationResource
eipAssociationResource =
    TF.newResource "aws_eip_association" $
        EipAssociationResource {
            _allocation_id = TF.Nil
            , _allow_reassociation = TF.Nil
            , _instance_id = TF.Nil
            , _network_interface_id = TF.Nil
            , _private_ip_address = TF.Nil
            , _public_ip = TF.Nil
            }

{- | The @aws_eip@ AWS resource.

Provides an Elastic IP resource. ~> Note: EIP may require IGW to exist prior
to association. Use @depends_on@ to set an explicit dependency on the IGW.
-}
data EipResource = EipResource {
      _associate_with_private_ip :: !(TF.Argument "associate_with_private_ip" Text)
    {- ^ (Optional) A user specified primary or secondary private IP address to associate with the Elastic IP address. If no private IP address is specified, the Elastic IP address is associated with the primary private IP address. -}
    , _instance' :: !(TF.Argument "instance" Text)
    {- ^ (Optional) EC2 instance ID. -}
    , _network_interface :: !(TF.Argument "network_interface" Text)
    {- ^ (Optional) Network interface ID to associate with. -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    , _vpc :: !(TF.Argument "vpc" Text)
    {- ^ (Optional) Boolean if the EIP is in a VPC or not. -}
    } deriving (Show, Eq)

instance TF.ToHCL EipResource where
    toHCL EipResource{..} = TF.block $ catMaybes
        [ TF.argument _associate_with_private_ip
        , TF.argument _instance'
        , TF.argument _network_interface
        , TF.argument _tags
        , TF.argument _vpc
        ]

instance HasAssociateWithPrivateIp EipResource Text where
    associateWithPrivateIp =
        lens (_associate_with_private_ip :: EipResource -> TF.Argument "associate_with_private_ip" Text)
             (\s a -> s { _associate_with_private_ip = a } :: EipResource)

instance HasInstance' EipResource Text where
    instance' =
        lens (_instance' :: EipResource -> TF.Argument "instance" Text)
             (\s a -> s { _instance' = a } :: EipResource)

instance HasNetworkInterface EipResource Text where
    networkInterface =
        lens (_network_interface :: EipResource -> TF.Argument "network_interface" Text)
             (\s a -> s { _network_interface = a } :: EipResource)

instance HasTags EipResource TF.Tags where
    tags =
        lens (_tags :: EipResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: EipResource)

instance HasVpc EipResource Text where
    vpc =
        lens (_vpc :: EipResource -> TF.Argument "vpc" Text)
             (\s a -> s { _vpc = a } :: EipResource)

instance HasComputedAssociateWithPrivateIp EipResource Text where
    computedAssociateWithPrivateIp =
        to (\_  -> TF.Compute "associate_with_private_ip")

instance HasComputedId EipResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedInstance' EipResource Text where
    computedInstance' =
        to (\_  -> TF.Compute "instance")

instance HasComputedNetworkInterface EipResource Text where
    computedNetworkInterface =
        to (\_  -> TF.Compute "network_interface")

instance HasComputedPrivateIp EipResource Text where
    computedPrivateIp =
        to (\_  -> TF.Compute "private_ip")

instance HasComputedPublicIp EipResource Text where
    computedPublicIp =
        to (\_  -> TF.Compute "public_ip")

eipResource :: TF.Resource TF.AWS EipResource
eipResource =
    TF.newResource "aws_eip" $
        EipResource {
            _associate_with_private_ip = TF.Nil
            , _instance' = TF.Nil
            , _network_interface = TF.Nil
            , _tags = TF.Nil
            , _vpc = TF.Nil
            }

{- | The @aws_elastic_beanstalk_application@ AWS resource.

Provides an Elastic Beanstalk Application Resource. Elastic Beanstalk allows
you to deploy and manage applications in the AWS cloud without worrying
about the infrastructure that runs those applications. This resource creates
an application that has one configuration template named @default@ , and no
application versions
-}
data ElasticBeanstalkApplicationResource = ElasticBeanstalkApplicationResource {
      _description :: !(TF.Argument "description" Text)
    {- ^ (Optional) Short description of the application -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the application, must be unique within your account -}
    } deriving (Show, Eq)

instance TF.ToHCL ElasticBeanstalkApplicationResource where
    toHCL ElasticBeanstalkApplicationResource{..} = TF.block $ catMaybes
        [ TF.argument _description
        , TF.argument _name
        ]

instance HasDescription ElasticBeanstalkApplicationResource Text where
    description =
        lens (_description :: ElasticBeanstalkApplicationResource -> TF.Argument "description" Text)
             (\s a -> s { _description = a } :: ElasticBeanstalkApplicationResource)

instance HasName ElasticBeanstalkApplicationResource Text where
    name =
        lens (_name :: ElasticBeanstalkApplicationResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: ElasticBeanstalkApplicationResource)

elasticBeanstalkApplicationResource :: TF.Resource TF.AWS ElasticBeanstalkApplicationResource
elasticBeanstalkApplicationResource =
    TF.newResource "aws_elastic_beanstalk_application" $
        ElasticBeanstalkApplicationResource {
            _description = TF.Nil
            , _name = TF.Nil
            }

{- | The @aws_elastic_beanstalk_application_version@ AWS resource.

Provides an Elastic Beanstalk Application Version Resource. Elastic
Beanstalk allows you to deploy and manage applications in the AWS cloud
without worrying about the infrastructure that runs those applications. This
resource creates a Beanstalk Application Version that can be deployed to a
Beanstalk Environment. ~> NOTE on Application Version Resource: When using
the Application Version resource with multiple
<elastic_beanstalk_environment.html> it is possible that an error may be
returned when attempting to delete an Application Version while it is still
in use by a different environment. To work around this you can:
-}
data ElasticBeanstalkApplicationVersionResource = ElasticBeanstalkApplicationVersionResource {
      _application :: !(TF.Argument "application" Text)
    {- ^ (Required) Name of the Beanstalk Application the version is associated with. -}
    , _bucket :: !(TF.Argument "bucket" Text)
    {- ^ (Required) S3 bucket that contains the Application Version source bundle. -}
    , _description :: !(TF.Argument "description" Text)
    {- ^ (Optional) Short description of the Application Version. -}
    , _force_delete :: !(TF.Argument "force_delete" Text)
    {- ^ (Optional) On delete, force an Application Version to be deleted when it may be in use by multiple Elastic Beanstalk Environments. -}
    , _key :: !(TF.Argument "key" Text)
    {- ^ (Required) S3 object that is the Application Version source bundle. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) A unique name for the this Application Version. -}
    } deriving (Show, Eq)

instance TF.ToHCL ElasticBeanstalkApplicationVersionResource where
    toHCL ElasticBeanstalkApplicationVersionResource{..} = TF.block $ catMaybes
        [ TF.argument _application
        , TF.argument _bucket
        , TF.argument _description
        , TF.argument _force_delete
        , TF.argument _key
        , TF.argument _name
        ]

instance HasApplication ElasticBeanstalkApplicationVersionResource Text where
    application =
        lens (_application :: ElasticBeanstalkApplicationVersionResource -> TF.Argument "application" Text)
             (\s a -> s { _application = a } :: ElasticBeanstalkApplicationVersionResource)

instance HasBucket ElasticBeanstalkApplicationVersionResource Text where
    bucket =
        lens (_bucket :: ElasticBeanstalkApplicationVersionResource -> TF.Argument "bucket" Text)
             (\s a -> s { _bucket = a } :: ElasticBeanstalkApplicationVersionResource)

instance HasDescription ElasticBeanstalkApplicationVersionResource Text where
    description =
        lens (_description :: ElasticBeanstalkApplicationVersionResource -> TF.Argument "description" Text)
             (\s a -> s { _description = a } :: ElasticBeanstalkApplicationVersionResource)

instance HasForceDelete ElasticBeanstalkApplicationVersionResource Text where
    forceDelete =
        lens (_force_delete :: ElasticBeanstalkApplicationVersionResource -> TF.Argument "force_delete" Text)
             (\s a -> s { _force_delete = a } :: ElasticBeanstalkApplicationVersionResource)

instance HasKey ElasticBeanstalkApplicationVersionResource Text where
    key =
        lens (_key :: ElasticBeanstalkApplicationVersionResource -> TF.Argument "key" Text)
             (\s a -> s { _key = a } :: ElasticBeanstalkApplicationVersionResource)

instance HasName ElasticBeanstalkApplicationVersionResource Text where
    name =
        lens (_name :: ElasticBeanstalkApplicationVersionResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: ElasticBeanstalkApplicationVersionResource)

instance HasComputedName ElasticBeanstalkApplicationVersionResource Text where
    computedName =
        to (\_  -> TF.Compute "name")

elasticBeanstalkApplicationVersionResource :: TF.Resource TF.AWS ElasticBeanstalkApplicationVersionResource
elasticBeanstalkApplicationVersionResource =
    TF.newResource "aws_elastic_beanstalk_application_version" $
        ElasticBeanstalkApplicationVersionResource {
            _application = TF.Nil
            , _bucket = TF.Nil
            , _description = TF.Nil
            , _force_delete = TF.Nil
            , _key = TF.Nil
            , _name = TF.Nil
            }

{- | The @aws_elastic_beanstalk_configuration_template@ AWS resource.

Provides an Elastic Beanstalk Configuration Template, which are associated
with a specific application and are used to deploy different versions of the
application with the same configuration settings.
-}
data ElasticBeanstalkConfigurationTemplateResource = ElasticBeanstalkConfigurationTemplateResource {
      _application :: !(TF.Argument "application" Text)
    {- ^  (Required) name of the application to associate with this configuration template -}
    , _description :: !(TF.Argument "description" Text)
    {- ^ (Optional) Short description of the Template -}
    , _environment_id :: !(TF.Argument "environment_id" Text)
    {- ^  (Optional) The ID of the environment used with this configuration template -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) A unique name for this Template. -}
    , _setting :: !(TF.Argument "setting" Text)
    {- ^ (Optional) Option settings to configure the new Environment. These override specific values that are set as defaults. The format is detailed below in <#option-settings> -}
    , _solution_stack_name :: !(TF.Argument "solution_stack_name" Text)
    {- ^ (Optional) A solution stack to base your Template off of. Example stacks can be found in the <https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/concepts.platforms.html> -}
    } deriving (Show, Eq)

instance TF.ToHCL ElasticBeanstalkConfigurationTemplateResource where
    toHCL ElasticBeanstalkConfigurationTemplateResource{..} = TF.block $ catMaybes
        [ TF.argument _application
        , TF.argument _description
        , TF.argument _environment_id
        , TF.argument _name
        , TF.argument _setting
        , TF.argument _solution_stack_name
        ]

instance HasApplication ElasticBeanstalkConfigurationTemplateResource Text where
    application =
        lens (_application :: ElasticBeanstalkConfigurationTemplateResource -> TF.Argument "application" Text)
             (\s a -> s { _application = a } :: ElasticBeanstalkConfigurationTemplateResource)

instance HasDescription ElasticBeanstalkConfigurationTemplateResource Text where
    description =
        lens (_description :: ElasticBeanstalkConfigurationTemplateResource -> TF.Argument "description" Text)
             (\s a -> s { _description = a } :: ElasticBeanstalkConfigurationTemplateResource)

instance HasEnvironmentId ElasticBeanstalkConfigurationTemplateResource Text where
    environmentId =
        lens (_environment_id :: ElasticBeanstalkConfigurationTemplateResource -> TF.Argument "environment_id" Text)
             (\s a -> s { _environment_id = a } :: ElasticBeanstalkConfigurationTemplateResource)

instance HasName ElasticBeanstalkConfigurationTemplateResource Text where
    name =
        lens (_name :: ElasticBeanstalkConfigurationTemplateResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: ElasticBeanstalkConfigurationTemplateResource)

instance HasSetting ElasticBeanstalkConfigurationTemplateResource Text where
    setting =
        lens (_setting :: ElasticBeanstalkConfigurationTemplateResource -> TF.Argument "setting" Text)
             (\s a -> s { _setting = a } :: ElasticBeanstalkConfigurationTemplateResource)

instance HasSolutionStackName ElasticBeanstalkConfigurationTemplateResource Text where
    solutionStackName =
        lens (_solution_stack_name :: ElasticBeanstalkConfigurationTemplateResource -> TF.Argument "solution_stack_name" Text)
             (\s a -> s { _solution_stack_name = a } :: ElasticBeanstalkConfigurationTemplateResource)

elasticBeanstalkConfigurationTemplateResource :: TF.Resource TF.AWS ElasticBeanstalkConfigurationTemplateResource
elasticBeanstalkConfigurationTemplateResource =
    TF.newResource "aws_elastic_beanstalk_configuration_template" $
        ElasticBeanstalkConfigurationTemplateResource {
            _application = TF.Nil
            , _description = TF.Nil
            , _environment_id = TF.Nil
            , _name = TF.Nil
            , _setting = TF.Nil
            , _solution_stack_name = TF.Nil
            }

{- | The @aws_elastic_beanstalk_environment@ AWS resource.

Provides an Elastic Beanstalk Environment Resource. Elastic Beanstalk allows
you to deploy and manage applications in the AWS cloud without worrying
about the infrastructure that runs those applications. Environments are
often things such as @development@ , @integration@ , or @production@ .
-}
data ElasticBeanstalkEnvironmentResource = ElasticBeanstalkEnvironmentResource {
      _application :: !(TF.Argument "application" Text)
    {- ^  (Required) Name of the application that contains the version to be deployed -}
    , _cname_prefix :: !(TF.Argument "cname_prefix" Text)
    {- ^ (Optional) Prefix to use for the fully qualified DNS name of the Environment. -}
    , _description :: !(TF.Argument "description" Text)
    {- ^ (Optional) Short description of the Environment -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) A unique name for this Environment. This name is used in the application URL -}
    , _poll_interval :: !(TF.Argument "poll_interval" Text)
    {- ^ The time between polling the AWS API to check if changes have been applied. Use this to adjust the rate of API calls for any @create@ or @update@ action. Minimum @10s@ , maximum @180s@ . Omit this to use the default behavior, which is an exponential backoff -}
    , _setting :: !(TF.Argument "setting" Text)
    {- ^ (Optional) Option settings to configure the new Environment. These override specific values that are set as defaults. The format is detailed below in <#option-settings> -}
    , _solution_stack_name :: !(TF.Argument "solution_stack_name" Text)
    {- ^ (Optional) A solution stack to base your environment off of. Example stacks can be found in the <https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/concepts.platforms.html> -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A set of tags to apply to the Environment. Note: at this time the Elastic Beanstalk API does not provide a programatic way of changing these tags after initial application -}
    , _template_name :: !(TF.Argument "template_name" Text)
    {- ^  (Optional) The name of the Elastic Beanstalk Configuration template to use in deployment -}
    , _tier :: !(TF.Argument "tier" Text)
    {- ^ (Optional) Elastic Beanstalk Environment tier. Valid values are @Worker@ or @WebServer@ . If tier is left blank @WebServer@ will be used. -}
    , _version_label :: !(TF.Argument "version_label" Text)
    {- ^ (Optional) The name of the Elastic Beanstalk Application Version to use in deployment. -}
    , _wait_for_ready_timeout :: !(TF.Argument "wait_for_ready_timeout" Text)
    {- ^ - (Default: @20m@ ) The maximum <https://golang.org/pkg/time/#ParseDuration> that Terraform should wait for an Elastic Beanstalk Environment to be in a ready state before timing out. -}
    } deriving (Show, Eq)

instance TF.ToHCL ElasticBeanstalkEnvironmentResource where
    toHCL ElasticBeanstalkEnvironmentResource{..} = TF.block $ catMaybes
        [ TF.argument _application
        , TF.argument _cname_prefix
        , TF.argument _description
        , TF.argument _name
        , TF.argument _poll_interval
        , TF.argument _setting
        , TF.argument _solution_stack_name
        , TF.argument _tags
        , TF.argument _template_name
        , TF.argument _tier
        , TF.argument _version_label
        , TF.argument _wait_for_ready_timeout
        ]

instance HasApplication ElasticBeanstalkEnvironmentResource Text where
    application =
        lens (_application :: ElasticBeanstalkEnvironmentResource -> TF.Argument "application" Text)
             (\s a -> s { _application = a } :: ElasticBeanstalkEnvironmentResource)

instance HasCnamePrefix ElasticBeanstalkEnvironmentResource Text where
    cnamePrefix =
        lens (_cname_prefix :: ElasticBeanstalkEnvironmentResource -> TF.Argument "cname_prefix" Text)
             (\s a -> s { _cname_prefix = a } :: ElasticBeanstalkEnvironmentResource)

instance HasDescription ElasticBeanstalkEnvironmentResource Text where
    description =
        lens (_description :: ElasticBeanstalkEnvironmentResource -> TF.Argument "description" Text)
             (\s a -> s { _description = a } :: ElasticBeanstalkEnvironmentResource)

instance HasName ElasticBeanstalkEnvironmentResource Text where
    name =
        lens (_name :: ElasticBeanstalkEnvironmentResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: ElasticBeanstalkEnvironmentResource)

instance HasPollInterval ElasticBeanstalkEnvironmentResource Text where
    pollInterval =
        lens (_poll_interval :: ElasticBeanstalkEnvironmentResource -> TF.Argument "poll_interval" Text)
             (\s a -> s { _poll_interval = a } :: ElasticBeanstalkEnvironmentResource)

instance HasSetting ElasticBeanstalkEnvironmentResource Text where
    setting =
        lens (_setting :: ElasticBeanstalkEnvironmentResource -> TF.Argument "setting" Text)
             (\s a -> s { _setting = a } :: ElasticBeanstalkEnvironmentResource)

instance HasSolutionStackName ElasticBeanstalkEnvironmentResource Text where
    solutionStackName =
        lens (_solution_stack_name :: ElasticBeanstalkEnvironmentResource -> TF.Argument "solution_stack_name" Text)
             (\s a -> s { _solution_stack_name = a } :: ElasticBeanstalkEnvironmentResource)

instance HasTags ElasticBeanstalkEnvironmentResource TF.Tags where
    tags =
        lens (_tags :: ElasticBeanstalkEnvironmentResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: ElasticBeanstalkEnvironmentResource)

instance HasTemplateName ElasticBeanstalkEnvironmentResource Text where
    templateName =
        lens (_template_name :: ElasticBeanstalkEnvironmentResource -> TF.Argument "template_name" Text)
             (\s a -> s { _template_name = a } :: ElasticBeanstalkEnvironmentResource)

instance HasTier ElasticBeanstalkEnvironmentResource Text where
    tier =
        lens (_tier :: ElasticBeanstalkEnvironmentResource -> TF.Argument "tier" Text)
             (\s a -> s { _tier = a } :: ElasticBeanstalkEnvironmentResource)

instance HasVersionLabel ElasticBeanstalkEnvironmentResource Text where
    versionLabel =
        lens (_version_label :: ElasticBeanstalkEnvironmentResource -> TF.Argument "version_label" Text)
             (\s a -> s { _version_label = a } :: ElasticBeanstalkEnvironmentResource)

instance HasWaitForReadyTimeout ElasticBeanstalkEnvironmentResource Text where
    waitForReadyTimeout =
        lens (_wait_for_ready_timeout :: ElasticBeanstalkEnvironmentResource -> TF.Argument "wait_for_ready_timeout" Text)
             (\s a -> s { _wait_for_ready_timeout = a } :: ElasticBeanstalkEnvironmentResource)

elasticBeanstalkEnvironmentResource :: TF.Resource TF.AWS ElasticBeanstalkEnvironmentResource
elasticBeanstalkEnvironmentResource =
    TF.newResource "aws_elastic_beanstalk_environment" $
        ElasticBeanstalkEnvironmentResource {
            _application = TF.Nil
            , _cname_prefix = TF.Nil
            , _description = TF.Nil
            , _name = TF.Nil
            , _poll_interval = TF.Nil
            , _setting = TF.Nil
            , _solution_stack_name = TF.Nil
            , _tags = TF.Nil
            , _template_name = TF.Nil
            , _tier = TF.Nil
            , _version_label = TF.Nil
            , _wait_for_ready_timeout = TF.Nil
            }

{- | The @aws_elasticache_cluster@ AWS resource.

Provides an ElastiCache Cluster resource. Changes to a Cache Cluster can
occur when you manually change a parameter, such as @node_type@ , and are
reflected in the next maintenance window. Because of this, Terraform may
report a difference in its planning phase because a modification has not yet
taken place. You can use the @apply_immediately@ flag to instruct the
service to apply the change immediately (see documentation below). ~> Note:
using @apply_immediately@ can result in a brief downtime as the server
reboots. See the AWS Docs on
<https://docs.aws.amazon.com/AmazonElastiCache/latest/UserGuide/Clusters.Modify.html>
for more information.
-}
data ElasticacheClusterResource = ElasticacheClusterResource {
      _apply_immediately :: !(TF.Argument "apply_immediately" Text)
    {- ^ (Optional) Specifies whether any database modifications are applied immediately, or during the next maintenance window. Default is @false@ . See <https://docs.aws.amazon.com/AmazonElastiCache/latest/APIReference/API_ModifyCacheCluster.html> (Available since v0.6.0) -}
    , _availability_zone :: !(TF.Argument "availability_zone" TF.Zone)
    {- ^ (Optional) The Availability Zone for the cache cluster. If you want to create cache nodes in multi-az, use @availability_zones@ -}
    , _availability_zones :: !(TF.Argument "availability_zones" Text)
    {- ^ (Optional, Memcached only) List of Availability Zones in which the cache nodes will be created. If you want to create cache nodes in single-az, use @availability_zone@ -}
    , _az_mode :: !(TF.Argument "az_mode" Text)
    {- ^ (Optional, Memcached only) Specifies whether the nodes in this Memcached node group are created in a single Availability Zone or created across multiple Availability Zones in the cluster's region. Valid values for this parameter are @single-az@ or @cross-az@ , default is @single-az@ . If you want to choose @cross-az@ , @num_cache_nodes@ must be greater than @1@ -}
    , _cluster_id :: !(TF.Argument "cluster_id" Text)
    {- ^  (Required) Group identifier. ElastiCache converts this name to lowercase -}
    , _engine :: !(TF.Argument "engine" Text)
    {- ^  (Required) Name of the cache engine to be used for this cache cluster. Valid values for this parameter are @memcached@ or @redis@ -}
    , _engine_version :: !(TF.Argument "engine_version" Text)
    {- ^  (Optional) Version number of the cache engine to be used. See <https://docs.aws.amazon.com/AmazonElastiCache/latest/UserGuide/SelectEngine.html> in the AWS Documentation center for supported versions -}
    , _maintenance_window :: !(TF.Argument "maintenance_window" Text)
    {- ^ (Optional) Specifies the weekly time range for when maintenance on the cache cluster is performed. The format is @ddd:hh24:mi-ddd:hh24:mi@ (24H Clock UTC). The minimum maintenance window is a 60 minute period. Example: @sun:05:00-sun:09:00@ -}
    , _node_type :: !(TF.Argument "node_type" Text)
    {- ^  (Required) The compute and memory capacity of the nodes. See <https://aws.amazon.com/elasticache/details#Available_Cache_Node_Types> for supported node types -}
    , _notification_topic_arn :: !(TF.Argument "notification_topic_arn" Text)
    {- ^ (Optional) An Amazon Resource Name (ARN) of an SNS topic to send ElastiCache notifications to. Example: @arn:aws:sns:us-east-1:012345678999:my_sns_topic@ -}
    , _num_cache_nodes :: !(TF.Argument "num_cache_nodes" Text)
    {- ^  (Required) The initial number of cache nodes that the cache cluster will have. For Redis, this value must be 1. For Memcache, this value must be between 1 and 20. If this number is reduced on subsequent runs, the highest numbered nodes will be removed. -}
    , _parameter_group_name :: !(TF.Argument "parameter_group_name" Text)
    {- ^  (Required) Name of the parameter group to associate with this cache cluster -}
    , _port :: !(TF.Argument "port" Text)
    {- ^  (Required) The port number on which each of the cache nodes will accept connections. For Memcache the default is 11211, and for Redis the default port is 6379. -}
    , _security_group_ids :: !(TF.Argument "security_group_ids" Text)
    {- ^  (Optional, VPC only) One or more VPC security groups associated with the cache cluster -}
    , _security_group_names :: !(TF.Argument "security_group_names" Text)
    {- ^  (Optional, EC2 Classic only) List of security group names to associate with this cache cluster -}
    , _snapshot_arns :: !(TF.Argument "snapshot_arns" Text)
    {- ^ (Optional) A single-element string list containing an Amazon Resource Name (ARN) of a Redis RDB snapshot file stored in Amazon S3. Example: @arn:aws:s3:::my_bucket/snapshot1.rdb@ -}
    , _snapshot_name :: !(TF.Argument "snapshot_name" Text)
    {- ^ (Optional) The name of a snapshot from which to restore data into the new node group.  Changing the @snapshot_name@ forces a new resource. -}
    , _snapshot_retention_limit :: !(TF.Argument "snapshot_retention_limit" Text)
    {- ^ (Optional, Redis only) The number of days for which ElastiCache will retain automatic cache cluster snapshots before deleting them. For example, if you set SnapshotRetentionLimit to 5, then a snapshot that was taken today will be retained for 5 days before being deleted. If the value of SnapshotRetentionLimit is set to zero (0), backups are turned off. Please note that setting a @snapshot_retention_limit@ is not supported on cache.t1.micro or cache.t2.* cache nodes -}
    , _snapshot_window :: !(TF.Argument "snapshot_window" Text)
    {- ^ (Optional, Redis only) The daily time range (in UTC) during which ElastiCache will begin taking a daily snapshot of your cache cluster. Example: 05:00-09:00 -}
    , _subnet_group_name :: !(TF.Argument "subnet_group_name" Text)
    {- ^  (Optional, VPC only) Name of the subnet group to be used for the cache cluster. -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource -}
    } deriving (Show, Eq)

instance TF.ToHCL ElasticacheClusterResource where
    toHCL ElasticacheClusterResource{..} = TF.block $ catMaybes
        [ TF.argument _apply_immediately
        , TF.argument _availability_zone
        , TF.argument _availability_zones
        , TF.argument _az_mode
        , TF.argument _cluster_id
        , TF.argument _engine
        , TF.argument _engine_version
        , TF.argument _maintenance_window
        , TF.argument _node_type
        , TF.argument _notification_topic_arn
        , TF.argument _num_cache_nodes
        , TF.argument _parameter_group_name
        , TF.argument _port
        , TF.argument _security_group_ids
        , TF.argument _security_group_names
        , TF.argument _snapshot_arns
        , TF.argument _snapshot_name
        , TF.argument _snapshot_retention_limit
        , TF.argument _snapshot_window
        , TF.argument _subnet_group_name
        , TF.argument _tags
        ]

instance HasApplyImmediately ElasticacheClusterResource Text where
    applyImmediately =
        lens (_apply_immediately :: ElasticacheClusterResource -> TF.Argument "apply_immediately" Text)
             (\s a -> s { _apply_immediately = a } :: ElasticacheClusterResource)

instance HasAvailabilityZone ElasticacheClusterResource TF.Zone where
    availabilityZone =
        lens (_availability_zone :: ElasticacheClusterResource -> TF.Argument "availability_zone" TF.Zone)
             (\s a -> s { _availability_zone = a } :: ElasticacheClusterResource)

instance HasAvailabilityZones ElasticacheClusterResource Text where
    availabilityZones =
        lens (_availability_zones :: ElasticacheClusterResource -> TF.Argument "availability_zones" Text)
             (\s a -> s { _availability_zones = a } :: ElasticacheClusterResource)

instance HasAzMode ElasticacheClusterResource Text where
    azMode =
        lens (_az_mode :: ElasticacheClusterResource -> TF.Argument "az_mode" Text)
             (\s a -> s { _az_mode = a } :: ElasticacheClusterResource)

instance HasClusterId ElasticacheClusterResource Text where
    clusterId =
        lens (_cluster_id :: ElasticacheClusterResource -> TF.Argument "cluster_id" Text)
             (\s a -> s { _cluster_id = a } :: ElasticacheClusterResource)

instance HasEngine ElasticacheClusterResource Text where
    engine =
        lens (_engine :: ElasticacheClusterResource -> TF.Argument "engine" Text)
             (\s a -> s { _engine = a } :: ElasticacheClusterResource)

instance HasEngineVersion ElasticacheClusterResource Text where
    engineVersion =
        lens (_engine_version :: ElasticacheClusterResource -> TF.Argument "engine_version" Text)
             (\s a -> s { _engine_version = a } :: ElasticacheClusterResource)

instance HasMaintenanceWindow ElasticacheClusterResource Text where
    maintenanceWindow =
        lens (_maintenance_window :: ElasticacheClusterResource -> TF.Argument "maintenance_window" Text)
             (\s a -> s { _maintenance_window = a } :: ElasticacheClusterResource)

instance HasNodeType ElasticacheClusterResource Text where
    nodeType =
        lens (_node_type :: ElasticacheClusterResource -> TF.Argument "node_type" Text)
             (\s a -> s { _node_type = a } :: ElasticacheClusterResource)

instance HasNotificationTopicArn ElasticacheClusterResource Text where
    notificationTopicArn =
        lens (_notification_topic_arn :: ElasticacheClusterResource -> TF.Argument "notification_topic_arn" Text)
             (\s a -> s { _notification_topic_arn = a } :: ElasticacheClusterResource)

instance HasNumCacheNodes ElasticacheClusterResource Text where
    numCacheNodes =
        lens (_num_cache_nodes :: ElasticacheClusterResource -> TF.Argument "num_cache_nodes" Text)
             (\s a -> s { _num_cache_nodes = a } :: ElasticacheClusterResource)

instance HasParameterGroupName ElasticacheClusterResource Text where
    parameterGroupName =
        lens (_parameter_group_name :: ElasticacheClusterResource -> TF.Argument "parameter_group_name" Text)
             (\s a -> s { _parameter_group_name = a } :: ElasticacheClusterResource)

instance HasPort ElasticacheClusterResource Text where
    port =
        lens (_port :: ElasticacheClusterResource -> TF.Argument "port" Text)
             (\s a -> s { _port = a } :: ElasticacheClusterResource)

instance HasSecurityGroupIds ElasticacheClusterResource Text where
    securityGroupIds =
        lens (_security_group_ids :: ElasticacheClusterResource -> TF.Argument "security_group_ids" Text)
             (\s a -> s { _security_group_ids = a } :: ElasticacheClusterResource)

instance HasSecurityGroupNames ElasticacheClusterResource Text where
    securityGroupNames =
        lens (_security_group_names :: ElasticacheClusterResource -> TF.Argument "security_group_names" Text)
             (\s a -> s { _security_group_names = a } :: ElasticacheClusterResource)

instance HasSnapshotArns ElasticacheClusterResource Text where
    snapshotArns =
        lens (_snapshot_arns :: ElasticacheClusterResource -> TF.Argument "snapshot_arns" Text)
             (\s a -> s { _snapshot_arns = a } :: ElasticacheClusterResource)

instance HasSnapshotName ElasticacheClusterResource Text where
    snapshotName =
        lens (_snapshot_name :: ElasticacheClusterResource -> TF.Argument "snapshot_name" Text)
             (\s a -> s { _snapshot_name = a } :: ElasticacheClusterResource)

instance HasSnapshotRetentionLimit ElasticacheClusterResource Text where
    snapshotRetentionLimit =
        lens (_snapshot_retention_limit :: ElasticacheClusterResource -> TF.Argument "snapshot_retention_limit" Text)
             (\s a -> s { _snapshot_retention_limit = a } :: ElasticacheClusterResource)

instance HasSnapshotWindow ElasticacheClusterResource Text where
    snapshotWindow =
        lens (_snapshot_window :: ElasticacheClusterResource -> TF.Argument "snapshot_window" Text)
             (\s a -> s { _snapshot_window = a } :: ElasticacheClusterResource)

instance HasSubnetGroupName ElasticacheClusterResource Text where
    subnetGroupName =
        lens (_subnet_group_name :: ElasticacheClusterResource -> TF.Argument "subnet_group_name" Text)
             (\s a -> s { _subnet_group_name = a } :: ElasticacheClusterResource)

instance HasTags ElasticacheClusterResource TF.Tags where
    tags =
        lens (_tags :: ElasticacheClusterResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: ElasticacheClusterResource)

instance HasComputedCacheNodes ElasticacheClusterResource Text where
    computedCacheNodes =
        to (\_  -> TF.Compute "cache_nodes")

instance HasComputedClusterAddress ElasticacheClusterResource Text where
    computedClusterAddress =
        to (\_  -> TF.Compute "cluster_address")

instance HasComputedConfigurationEndpoint ElasticacheClusterResource Text where
    computedConfigurationEndpoint =
        to (\_  -> TF.Compute "configuration_endpoint")

elasticacheClusterResource :: TF.Resource TF.AWS ElasticacheClusterResource
elasticacheClusterResource =
    TF.newResource "aws_elasticache_cluster" $
        ElasticacheClusterResource {
            _apply_immediately = TF.Nil
            , _availability_zone = TF.Nil
            , _availability_zones = TF.Nil
            , _az_mode = TF.Nil
            , _cluster_id = TF.Nil
            , _engine = TF.Nil
            , _engine_version = TF.Nil
            , _maintenance_window = TF.Nil
            , _node_type = TF.Nil
            , _notification_topic_arn = TF.Nil
            , _num_cache_nodes = TF.Nil
            , _parameter_group_name = TF.Nil
            , _port = TF.Nil
            , _security_group_ids = TF.Nil
            , _security_group_names = TF.Nil
            , _snapshot_arns = TF.Nil
            , _snapshot_name = TF.Nil
            , _snapshot_retention_limit = TF.Nil
            , _snapshot_window = TF.Nil
            , _subnet_group_name = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_elasticache_parameter_group@ AWS resource.

Provides an ElastiCache parameter group resource.
-}
data ElasticacheParameterGroupResource = ElasticacheParameterGroupResource {
      _description :: !(TF.Argument "description" Text)
    {- ^ (Optional) The description of the ElastiCache parameter group. Defaults to "Managed by Terraform". -}
    , _family' :: !(TF.Argument "family" Text)
    {- ^ (Required) The family of the ElastiCache parameter group. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the ElastiCache parameter group. -}
    , _parameter :: !(TF.Argument "parameter" Text)
    {- ^ (Optional) A list of ElastiCache parameters to apply. -}
    } deriving (Show, Eq)

instance TF.ToHCL ElasticacheParameterGroupResource where
    toHCL ElasticacheParameterGroupResource{..} = TF.block $ catMaybes
        [ TF.argument _description
        , TF.argument _family'
        , TF.argument _name
        , TF.argument _parameter
        ]

instance HasDescription ElasticacheParameterGroupResource Text where
    description =
        lens (_description :: ElasticacheParameterGroupResource -> TF.Argument "description" Text)
             (\s a -> s { _description = a } :: ElasticacheParameterGroupResource)

instance HasFamily' ElasticacheParameterGroupResource Text where
    family' =
        lens (_family' :: ElasticacheParameterGroupResource -> TF.Argument "family" Text)
             (\s a -> s { _family' = a } :: ElasticacheParameterGroupResource)

instance HasName ElasticacheParameterGroupResource Text where
    name =
        lens (_name :: ElasticacheParameterGroupResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: ElasticacheParameterGroupResource)

instance HasParameter ElasticacheParameterGroupResource Text where
    parameter =
        lens (_parameter :: ElasticacheParameterGroupResource -> TF.Argument "parameter" Text)
             (\s a -> s { _parameter = a } :: ElasticacheParameterGroupResource)

instance HasComputedId ElasticacheParameterGroupResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

elasticacheParameterGroupResource :: TF.Resource TF.AWS ElasticacheParameterGroupResource
elasticacheParameterGroupResource =
    TF.newResource "aws_elasticache_parameter_group" $
        ElasticacheParameterGroupResource {
            _description = TF.Nil
            , _family' = TF.Nil
            , _name = TF.Nil
            , _parameter = TF.Nil
            }

{- | The @aws_elasticache_replication_group@ AWS resource.

Provides an ElastiCache Replication Group resource.
-}
data ElasticacheReplicationGroupResource = ElasticacheReplicationGroupResource {
      _apply_immediately :: !(TF.Argument "apply_immediately" Text)
    {- ^ (Optional) Specifies whether any modifications are applied immediately, or during the next maintenance window. Default is @false@ . -}
    , _at_rest_encryption_enabled :: !(TF.Argument "at_rest_encryption_enabled" TF.Bool)
    {- ^ (Optional) Whether to enable encryption at rest. -}
    , _auth_token :: !(TF.Argument "auth_token" Text)
    {- ^ (Optional) The password used to access a password protected server. Can be specified only if @transit_encryption_enabled = true@ . -}
    , _auto_minor_version_upgrade :: !(TF.Argument "auto_minor_version_upgrade" Text)
    {- ^ (Optional) Specifies whether a minor engine upgrades will be applied automatically to the underlying Cache Cluster instances during the maintenance window. Defaults to @true@ . -}
    , _automatic_failover_enabled :: !(TF.Argument "automatic_failover_enabled" TF.Bool)
    {- ^ (Optional) Specifies whether a read-only replica will be automatically promoted to read/write primary if the existing primary fails. Defaults to @false@ . -}
    , _availability_zones :: !(TF.Argument "availability_zones" Text)
    {- ^ (Optional) A list of EC2 availability zones in which the replication group's cache clusters will be created. The order of the availability zones in the list is not important. -}
    , _cluster_mode :: !(TF.Argument "cluster_mode" Text)
    {- ^ (Optional) Create a native redis cluster. @automatic_failover_enabled@ must be set to true. Cluster Mode documented below. Only 1 @cluster_mode@ block is allowed. -}
    , _engine :: !(TF.Argument "engine" Text)
    {- ^ (Optional) The name of the cache engine to be used for the clusters in this replication group. e.g. @redis@ -}
    , _engine_version :: !(TF.Argument "engine_version" Text)
    {- ^ (Optional) The version number of the cache engine to be used for the cache clusters in this replication group. -}
    , _maintenance_window :: !(TF.Argument "maintenance_window" Text)
    {- ^ (Optional) Specifies the weekly time range for when maintenance on the cache cluster is performed. The format is @ddd:hh24:mi-ddd:hh24:mi@ (24H Clock UTC). The minimum maintenance window is a 60 minute period. Example: @sun:05:00-sun:09:00@ -}
    , _node_type :: !(TF.Argument "node_type" Text)
    {- ^ (Required) The compute and memory capacity of the nodes in the node group. -}
    , _notification_topic_arn :: !(TF.Argument "notification_topic_arn" Text)
    {- ^ (Optional) An Amazon Resource Name (ARN) of an SNS topic to send ElastiCache notifications to. Example: @arn:aws:sns:us-east-1:012345678999:my_sns_topic@ -}
    , _number_cache_clusters :: !(TF.Argument "number_cache_clusters" Text)
    {- ^ (Required) The number of cache clusters this replication group will have. If Multi-AZ is enabled , the value of this parameter must be at least 2. Changing this number will force a new resource -}
    , _parameter_group_name :: !(TF.Argument "parameter_group_name" Text)
    {- ^ (Optional) The name of the parameter group to associate with this replication group. If this argument is omitted, the default cache parameter group for the specified engine is used. -}
    , _port :: !(TF.Argument "port" Text)
    {- ^  (Required) The port number on which each of the cache nodes will accept connections. For Memcache the default is 11211, and for Redis the default port is 6379. -}
    , _replication_group_description :: !(TF.Argument "replication_group_description" Text)
    {- ^  (Required) A user-created description for the replication group. -}
    , _replication_group_id :: !(TF.Argument "replication_group_id" Text)
    {- ^  (Required) The replication group identifier. This parameter is stored as a lowercase string. -}
    , _security_group_ids :: !(TF.Argument "security_group_ids" Text)
    {- ^ (Optional) One or more Amazon VPC security groups associated with this replication group. Use this parameter only when you are creating a replication group in an Amazon Virtual Private Cloud -}
    , _security_group_names :: !(TF.Argument "security_group_names" Text)
    {- ^ (Optional) A list of cache security group names to associate with this replication group. -}
    , _snapshot_arns :: !(TF.Argument "snapshot_arns" Text)
    {- ^ (Optional) A single-element string list containing an Amazon Resource Name (ARN) of a Redis RDB snapshot file stored in Amazon S3. Example: @arn:aws:s3:::my_bucket/snapshot1.rdb@ -}
    , _snapshot_name :: !(TF.Argument "snapshot_name" Text)
    {- ^ (Optional) The name of a snapshot from which to restore data into the new node group. Changing the @snapshot_name@ forces a new resource. -}
    , _snapshot_retention_limit :: !(TF.Argument "snapshot_retention_limit" Text)
    {- ^ (Optional, Redis only) The number of days for which ElastiCache will retain automatic cache cluster snapshots before deleting them. For example, if you set SnapshotRetentionLimit to 5, then a snapshot that was taken today will be retained for 5 days before being deleted. If the value of SnapshotRetentionLimit is set to zero (0), backups are turned off. Please note that setting a @snapshot_retention_limit@ is not supported on cache.t1.micro or cache.t2.* cache nodes -}
    , _snapshot_window :: !(TF.Argument "snapshot_window" Text)
    {- ^ (Optional, Redis only) The daily time range (in UTC) during which ElastiCache will begin taking a daily snapshot of your cache cluster. The minimum snapshot window is a 60 minute period. Example: @05:00-09:00@ -}
    , _subnet_group_name :: !(TF.Argument "subnet_group_name" Text)
    {- ^ (Optional) The name of the cache subnet group to be used for the replication group. -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource -}
    , _transit_encryption_enabled :: !(TF.Argument "transit_encryption_enabled" TF.Bool)
    {- ^ (Optional) Whether to enable encryption in transit. -}
    } deriving (Show, Eq)

instance TF.ToHCL ElasticacheReplicationGroupResource where
    toHCL ElasticacheReplicationGroupResource{..} = TF.block $ catMaybes
        [ TF.argument _apply_immediately
        , TF.argument _at_rest_encryption_enabled
        , TF.argument _auth_token
        , TF.argument _auto_minor_version_upgrade
        , TF.argument _automatic_failover_enabled
        , TF.argument _availability_zones
        , TF.argument _cluster_mode
        , TF.argument _engine
        , TF.argument _engine_version
        , TF.argument _maintenance_window
        , TF.argument _node_type
        , TF.argument _notification_topic_arn
        , TF.argument _number_cache_clusters
        , TF.argument _parameter_group_name
        , TF.argument _port
        , TF.argument _replication_group_description
        , TF.argument _replication_group_id
        , TF.argument _security_group_ids
        , TF.argument _security_group_names
        , TF.argument _snapshot_arns
        , TF.argument _snapshot_name
        , TF.argument _snapshot_retention_limit
        , TF.argument _snapshot_window
        , TF.argument _subnet_group_name
        , TF.argument _tags
        , TF.argument _transit_encryption_enabled
        ]

instance HasApplyImmediately ElasticacheReplicationGroupResource Text where
    applyImmediately =
        lens (_apply_immediately :: ElasticacheReplicationGroupResource -> TF.Argument "apply_immediately" Text)
             (\s a -> s { _apply_immediately = a } :: ElasticacheReplicationGroupResource)

instance HasAtRestEncryptionEnabled ElasticacheReplicationGroupResource TF.Bool where
    atRestEncryptionEnabled =
        lens (_at_rest_encryption_enabled :: ElasticacheReplicationGroupResource -> TF.Argument "at_rest_encryption_enabled" TF.Bool)
             (\s a -> s { _at_rest_encryption_enabled = a } :: ElasticacheReplicationGroupResource)

instance HasAuthToken ElasticacheReplicationGroupResource Text where
    authToken =
        lens (_auth_token :: ElasticacheReplicationGroupResource -> TF.Argument "auth_token" Text)
             (\s a -> s { _auth_token = a } :: ElasticacheReplicationGroupResource)

instance HasAutoMinorVersionUpgrade ElasticacheReplicationGroupResource Text where
    autoMinorVersionUpgrade =
        lens (_auto_minor_version_upgrade :: ElasticacheReplicationGroupResource -> TF.Argument "auto_minor_version_upgrade" Text)
             (\s a -> s { _auto_minor_version_upgrade = a } :: ElasticacheReplicationGroupResource)

instance HasAutomaticFailoverEnabled ElasticacheReplicationGroupResource TF.Bool where
    automaticFailoverEnabled =
        lens (_automatic_failover_enabled :: ElasticacheReplicationGroupResource -> TF.Argument "automatic_failover_enabled" TF.Bool)
             (\s a -> s { _automatic_failover_enabled = a } :: ElasticacheReplicationGroupResource)

instance HasAvailabilityZones ElasticacheReplicationGroupResource Text where
    availabilityZones =
        lens (_availability_zones :: ElasticacheReplicationGroupResource -> TF.Argument "availability_zones" Text)
             (\s a -> s { _availability_zones = a } :: ElasticacheReplicationGroupResource)

instance HasClusterMode ElasticacheReplicationGroupResource Text where
    clusterMode =
        lens (_cluster_mode :: ElasticacheReplicationGroupResource -> TF.Argument "cluster_mode" Text)
             (\s a -> s { _cluster_mode = a } :: ElasticacheReplicationGroupResource)

instance HasEngine ElasticacheReplicationGroupResource Text where
    engine =
        lens (_engine :: ElasticacheReplicationGroupResource -> TF.Argument "engine" Text)
             (\s a -> s { _engine = a } :: ElasticacheReplicationGroupResource)

instance HasEngineVersion ElasticacheReplicationGroupResource Text where
    engineVersion =
        lens (_engine_version :: ElasticacheReplicationGroupResource -> TF.Argument "engine_version" Text)
             (\s a -> s { _engine_version = a } :: ElasticacheReplicationGroupResource)

instance HasMaintenanceWindow ElasticacheReplicationGroupResource Text where
    maintenanceWindow =
        lens (_maintenance_window :: ElasticacheReplicationGroupResource -> TF.Argument "maintenance_window" Text)
             (\s a -> s { _maintenance_window = a } :: ElasticacheReplicationGroupResource)

instance HasNodeType ElasticacheReplicationGroupResource Text where
    nodeType =
        lens (_node_type :: ElasticacheReplicationGroupResource -> TF.Argument "node_type" Text)
             (\s a -> s { _node_type = a } :: ElasticacheReplicationGroupResource)

instance HasNotificationTopicArn ElasticacheReplicationGroupResource Text where
    notificationTopicArn =
        lens (_notification_topic_arn :: ElasticacheReplicationGroupResource -> TF.Argument "notification_topic_arn" Text)
             (\s a -> s { _notification_topic_arn = a } :: ElasticacheReplicationGroupResource)

instance HasNumberCacheClusters ElasticacheReplicationGroupResource Text where
    numberCacheClusters =
        lens (_number_cache_clusters :: ElasticacheReplicationGroupResource -> TF.Argument "number_cache_clusters" Text)
             (\s a -> s { _number_cache_clusters = a } :: ElasticacheReplicationGroupResource)

instance HasParameterGroupName ElasticacheReplicationGroupResource Text where
    parameterGroupName =
        lens (_parameter_group_name :: ElasticacheReplicationGroupResource -> TF.Argument "parameter_group_name" Text)
             (\s a -> s { _parameter_group_name = a } :: ElasticacheReplicationGroupResource)

instance HasPort ElasticacheReplicationGroupResource Text where
    port =
        lens (_port :: ElasticacheReplicationGroupResource -> TF.Argument "port" Text)
             (\s a -> s { _port = a } :: ElasticacheReplicationGroupResource)

instance HasReplicationGroupDescription ElasticacheReplicationGroupResource Text where
    replicationGroupDescription =
        lens (_replication_group_description :: ElasticacheReplicationGroupResource -> TF.Argument "replication_group_description" Text)
             (\s a -> s { _replication_group_description = a } :: ElasticacheReplicationGroupResource)

instance HasReplicationGroupId ElasticacheReplicationGroupResource Text where
    replicationGroupId =
        lens (_replication_group_id :: ElasticacheReplicationGroupResource -> TF.Argument "replication_group_id" Text)
             (\s a -> s { _replication_group_id = a } :: ElasticacheReplicationGroupResource)

instance HasSecurityGroupIds ElasticacheReplicationGroupResource Text where
    securityGroupIds =
        lens (_security_group_ids :: ElasticacheReplicationGroupResource -> TF.Argument "security_group_ids" Text)
             (\s a -> s { _security_group_ids = a } :: ElasticacheReplicationGroupResource)

instance HasSecurityGroupNames ElasticacheReplicationGroupResource Text where
    securityGroupNames =
        lens (_security_group_names :: ElasticacheReplicationGroupResource -> TF.Argument "security_group_names" Text)
             (\s a -> s { _security_group_names = a } :: ElasticacheReplicationGroupResource)

instance HasSnapshotArns ElasticacheReplicationGroupResource Text where
    snapshotArns =
        lens (_snapshot_arns :: ElasticacheReplicationGroupResource -> TF.Argument "snapshot_arns" Text)
             (\s a -> s { _snapshot_arns = a } :: ElasticacheReplicationGroupResource)

instance HasSnapshotName ElasticacheReplicationGroupResource Text where
    snapshotName =
        lens (_snapshot_name :: ElasticacheReplicationGroupResource -> TF.Argument "snapshot_name" Text)
             (\s a -> s { _snapshot_name = a } :: ElasticacheReplicationGroupResource)

instance HasSnapshotRetentionLimit ElasticacheReplicationGroupResource Text where
    snapshotRetentionLimit =
        lens (_snapshot_retention_limit :: ElasticacheReplicationGroupResource -> TF.Argument "snapshot_retention_limit" Text)
             (\s a -> s { _snapshot_retention_limit = a } :: ElasticacheReplicationGroupResource)

instance HasSnapshotWindow ElasticacheReplicationGroupResource Text where
    snapshotWindow =
        lens (_snapshot_window :: ElasticacheReplicationGroupResource -> TF.Argument "snapshot_window" Text)
             (\s a -> s { _snapshot_window = a } :: ElasticacheReplicationGroupResource)

instance HasSubnetGroupName ElasticacheReplicationGroupResource Text where
    subnetGroupName =
        lens (_subnet_group_name :: ElasticacheReplicationGroupResource -> TF.Argument "subnet_group_name" Text)
             (\s a -> s { _subnet_group_name = a } :: ElasticacheReplicationGroupResource)

instance HasTags ElasticacheReplicationGroupResource TF.Tags where
    tags =
        lens (_tags :: ElasticacheReplicationGroupResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: ElasticacheReplicationGroupResource)

instance HasTransitEncryptionEnabled ElasticacheReplicationGroupResource TF.Bool where
    transitEncryptionEnabled =
        lens (_transit_encryption_enabled :: ElasticacheReplicationGroupResource -> TF.Argument "transit_encryption_enabled" TF.Bool)
             (\s a -> s { _transit_encryption_enabled = a } :: ElasticacheReplicationGroupResource)

instance HasComputedConfigurationEndpointAddress ElasticacheReplicationGroupResource Text where
    computedConfigurationEndpointAddress =
        to (\_  -> TF.Compute "configuration_endpoint_address")

instance HasComputedId ElasticacheReplicationGroupResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedPrimaryEndpointAddress ElasticacheReplicationGroupResource Text where
    computedPrimaryEndpointAddress =
        to (\_  -> TF.Compute "primary_endpoint_address")

elasticacheReplicationGroupResource :: TF.Resource TF.AWS ElasticacheReplicationGroupResource
elasticacheReplicationGroupResource =
    TF.newResource "aws_elasticache_replication_group" $
        ElasticacheReplicationGroupResource {
            _apply_immediately = TF.Nil
            , _at_rest_encryption_enabled = TF.Nil
            , _auth_token = TF.Nil
            , _auto_minor_version_upgrade = TF.Nil
            , _automatic_failover_enabled = TF.Nil
            , _availability_zones = TF.Nil
            , _cluster_mode = TF.Nil
            , _engine = TF.Nil
            , _engine_version = TF.Nil
            , _maintenance_window = TF.Nil
            , _node_type = TF.Nil
            , _notification_topic_arn = TF.Nil
            , _number_cache_clusters = TF.Nil
            , _parameter_group_name = TF.Nil
            , _port = TF.Nil
            , _replication_group_description = TF.Nil
            , _replication_group_id = TF.Nil
            , _security_group_ids = TF.Nil
            , _security_group_names = TF.Nil
            , _snapshot_arns = TF.Nil
            , _snapshot_name = TF.Nil
            , _snapshot_retention_limit = TF.Nil
            , _snapshot_window = TF.Nil
            , _subnet_group_name = TF.Nil
            , _tags = TF.Nil
            , _transit_encryption_enabled = TF.Nil
            }

{- | The @aws_elasticache_security_group@ AWS resource.

Provides an ElastiCache Security Group to control access to one or more
cache clusters. ~> NOTE: ElastiCache Security Groups are for use only when
working with an ElastiCache cluster outside of a VPC. If you are using a
VPC, see the <elasticache_subnet_group.html> .
-}
data ElasticacheSecurityGroupResource = ElasticacheSecurityGroupResource {
      _description :: !(TF.Argument "description" Text)
    {- ^  (Optional) description for the cache security group. Defaults to "Managed by Terraform". -}
    , _name :: !(TF.Argument "name" Text)
    {- ^  (Required) Name for the cache security group. This value is stored as a lowercase string. -}
    , _security_group_names :: !(TF.Argument "security_group_names" Text)
    {- ^  (Required) List of EC2 security group names to be authorized for ingress to the cache security group -}
    } deriving (Show, Eq)

instance TF.ToHCL ElasticacheSecurityGroupResource where
    toHCL ElasticacheSecurityGroupResource{..} = TF.block $ catMaybes
        [ TF.argument _description
        , TF.argument _name
        , TF.argument _security_group_names
        ]

instance HasDescription ElasticacheSecurityGroupResource Text where
    description =
        lens (_description :: ElasticacheSecurityGroupResource -> TF.Argument "description" Text)
             (\s a -> s { _description = a } :: ElasticacheSecurityGroupResource)

instance HasName ElasticacheSecurityGroupResource Text where
    name =
        lens (_name :: ElasticacheSecurityGroupResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: ElasticacheSecurityGroupResource)

instance HasSecurityGroupNames ElasticacheSecurityGroupResource Text where
    securityGroupNames =
        lens (_security_group_names :: ElasticacheSecurityGroupResource -> TF.Argument "security_group_names" Text)
             (\s a -> s { _security_group_names = a } :: ElasticacheSecurityGroupResource)

elasticacheSecurityGroupResource :: TF.Resource TF.AWS ElasticacheSecurityGroupResource
elasticacheSecurityGroupResource =
    TF.newResource "aws_elasticache_security_group" $
        ElasticacheSecurityGroupResource {
            _description = TF.Nil
            , _name = TF.Nil
            , _security_group_names = TF.Nil
            }

{- | The @aws_elasticache_subnet_group@ AWS resource.

Provides an ElastiCache Subnet Group resource. ~> NOTE: ElastiCache Subnet
Groups are only for use when working with an ElastiCache cluster inside of a
VPC. If you are on EC2 Classic, see the <elasticache_security_group.html> .
-}
data ElasticacheSubnetGroupResource = ElasticacheSubnetGroupResource {
      _description :: !(TF.Argument "description" Text)
    {- ^  (Optional) Description for the cache subnet group. Defaults to "Managed by Terraform". -}
    , _name :: !(TF.Argument "name" Text)
    {- ^  (Required) Name for the cache subnet group. Elasticache converts this name to lowercase. -}
    , _subnet_ids :: !(TF.Argument "subnet_ids" Text)
    {- ^  (Required) List of VPC Subnet IDs for the cache subnet group -}
    } deriving (Show, Eq)

instance TF.ToHCL ElasticacheSubnetGroupResource where
    toHCL ElasticacheSubnetGroupResource{..} = TF.block $ catMaybes
        [ TF.argument _description
        , TF.argument _name
        , TF.argument _subnet_ids
        ]

instance HasDescription ElasticacheSubnetGroupResource Text where
    description =
        lens (_description :: ElasticacheSubnetGroupResource -> TF.Argument "description" Text)
             (\s a -> s { _description = a } :: ElasticacheSubnetGroupResource)

instance HasName ElasticacheSubnetGroupResource Text where
    name =
        lens (_name :: ElasticacheSubnetGroupResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: ElasticacheSubnetGroupResource)

instance HasSubnetIds ElasticacheSubnetGroupResource Text where
    subnetIds =
        lens (_subnet_ids :: ElasticacheSubnetGroupResource -> TF.Argument "subnet_ids" Text)
             (\s a -> s { _subnet_ids = a } :: ElasticacheSubnetGroupResource)

elasticacheSubnetGroupResource :: TF.Resource TF.AWS ElasticacheSubnetGroupResource
elasticacheSubnetGroupResource =
    TF.newResource "aws_elasticache_subnet_group" $
        ElasticacheSubnetGroupResource {
            _description = TF.Nil
            , _name = TF.Nil
            , _subnet_ids = TF.Nil
            }

{- | The @aws_elasticsearch_domain_policy@ AWS resource.

Allows setting policy to an ElasticSearch domain while referencing domain
attributes (e.g. ARN)
-}
data ElasticsearchDomainPolicyResource = ElasticsearchDomainPolicyResource {
      _access_policies :: !(TF.Argument "access_policies" Text)
    {- ^ (Optional) IAM policy document specifying the access policies for the domain -}
    , _domain_name :: !(TF.Argument "domain_name" Text)
    {- ^ (Required) Name of the domain. -}
    } deriving (Show, Eq)

instance TF.ToHCL ElasticsearchDomainPolicyResource where
    toHCL ElasticsearchDomainPolicyResource{..} = TF.block $ catMaybes
        [ TF.argument _access_policies
        , TF.argument _domain_name
        ]

instance HasAccessPolicies ElasticsearchDomainPolicyResource Text where
    accessPolicies =
        lens (_access_policies :: ElasticsearchDomainPolicyResource -> TF.Argument "access_policies" Text)
             (\s a -> s { _access_policies = a } :: ElasticsearchDomainPolicyResource)

instance HasDomainName ElasticsearchDomainPolicyResource Text where
    domainName =
        lens (_domain_name :: ElasticsearchDomainPolicyResource -> TF.Argument "domain_name" Text)
             (\s a -> s { _domain_name = a } :: ElasticsearchDomainPolicyResource)

elasticsearchDomainPolicyResource :: TF.Resource TF.AWS ElasticsearchDomainPolicyResource
elasticsearchDomainPolicyResource =
    TF.newResource "aws_elasticsearch_domain_policy" $
        ElasticsearchDomainPolicyResource {
            _access_policies = TF.Nil
            , _domain_name = TF.Nil
            }

{- | The @aws_elasticsearch_domain@ AWS resource.


-}
data ElasticsearchDomainResource = ElasticsearchDomainResource {
      _access_policies :: !(TF.Argument "access_policies" Text)
    {- ^ (Optional) IAM policy document specifying the access policies for the domain -}
    , _advanced_options :: !(TF.Argument "advanced_options" Text)
    {- ^ (Optional) Key-value string pairs to specify advanced configuration options. -}
    , _cluster_config :: !(TF.Argument "cluster_config" Text)
    {- ^ (Optional) Cluster configuration of the domain, see below. -}
    , _domain_name :: !(TF.Argument "domain_name" Text)
    {- ^ (Required) Name of the domain. -}
    , _ebs_options :: !(TF.Argument "ebs_options" Text)
    {- ^ (Optional) EBS related options, may be required based on chosen <https://aws.amazon.com/elasticsearch-service/pricing/> . See below. -}
    , _elasticsearch_version :: !(TF.Argument "elasticsearch_version" Text)
    {- ^ (Optional) The version of ElasticSearch to deploy. Defaults to @1.5@ -}
    , _encrypt_at_rest :: !(TF.Argument "encrypt_at_rest" Text)
    {- ^ (Optional) Encrypt at rest options. Only available for <http://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/aes-supported-instance-types.html> . See below. -}
    , _log_publishing_options :: !(TF.Argument "log_publishing_options" Text)
    {- ^ (Optional) Options for publishing slow logs to CloudWatch Logs. -}
    , _snapshot_options :: !(TF.Argument "snapshot_options" Text)
    {- ^ (Optional) Snapshot related options, see below. -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource -}
    , _vpc_options :: !(TF.Argument "vpc_options" Text)
    {- ^ (Optional) VPC related options, see below. Adding or removing this configuration forces a new resource ( <https://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-vpc.html#es-vpc-limitations> ). -}
    } deriving (Show, Eq)

instance TF.ToHCL ElasticsearchDomainResource where
    toHCL ElasticsearchDomainResource{..} = TF.block $ catMaybes
        [ TF.argument _access_policies
        , TF.argument _advanced_options
        , TF.argument _cluster_config
        , TF.argument _domain_name
        , TF.argument _ebs_options
        , TF.argument _elasticsearch_version
        , TF.argument _encrypt_at_rest
        , TF.argument _log_publishing_options
        , TF.argument _snapshot_options
        , TF.argument _tags
        , TF.argument _vpc_options
        ]

instance HasAccessPolicies ElasticsearchDomainResource Text where
    accessPolicies =
        lens (_access_policies :: ElasticsearchDomainResource -> TF.Argument "access_policies" Text)
             (\s a -> s { _access_policies = a } :: ElasticsearchDomainResource)

instance HasAdvancedOptions ElasticsearchDomainResource Text where
    advancedOptions =
        lens (_advanced_options :: ElasticsearchDomainResource -> TF.Argument "advanced_options" Text)
             (\s a -> s { _advanced_options = a } :: ElasticsearchDomainResource)

instance HasClusterConfig ElasticsearchDomainResource Text where
    clusterConfig =
        lens (_cluster_config :: ElasticsearchDomainResource -> TF.Argument "cluster_config" Text)
             (\s a -> s { _cluster_config = a } :: ElasticsearchDomainResource)

instance HasDomainName ElasticsearchDomainResource Text where
    domainName =
        lens (_domain_name :: ElasticsearchDomainResource -> TF.Argument "domain_name" Text)
             (\s a -> s { _domain_name = a } :: ElasticsearchDomainResource)

instance HasEbsOptions ElasticsearchDomainResource Text where
    ebsOptions =
        lens (_ebs_options :: ElasticsearchDomainResource -> TF.Argument "ebs_options" Text)
             (\s a -> s { _ebs_options = a } :: ElasticsearchDomainResource)

instance HasElasticsearchVersion ElasticsearchDomainResource Text where
    elasticsearchVersion =
        lens (_elasticsearch_version :: ElasticsearchDomainResource -> TF.Argument "elasticsearch_version" Text)
             (\s a -> s { _elasticsearch_version = a } :: ElasticsearchDomainResource)

instance HasEncryptAtRest ElasticsearchDomainResource Text where
    encryptAtRest =
        lens (_encrypt_at_rest :: ElasticsearchDomainResource -> TF.Argument "encrypt_at_rest" Text)
             (\s a -> s { _encrypt_at_rest = a } :: ElasticsearchDomainResource)

instance HasLogPublishingOptions ElasticsearchDomainResource Text where
    logPublishingOptions =
        lens (_log_publishing_options :: ElasticsearchDomainResource -> TF.Argument "log_publishing_options" Text)
             (\s a -> s { _log_publishing_options = a } :: ElasticsearchDomainResource)

instance HasSnapshotOptions ElasticsearchDomainResource Text where
    snapshotOptions =
        lens (_snapshot_options :: ElasticsearchDomainResource -> TF.Argument "snapshot_options" Text)
             (\s a -> s { _snapshot_options = a } :: ElasticsearchDomainResource)

instance HasTags ElasticsearchDomainResource TF.Tags where
    tags =
        lens (_tags :: ElasticsearchDomainResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: ElasticsearchDomainResource)

instance HasVpcOptions ElasticsearchDomainResource Text where
    vpcOptions =
        lens (_vpc_options :: ElasticsearchDomainResource -> TF.Argument "vpc_options" Text)
             (\s a -> s { _vpc_options = a } :: ElasticsearchDomainResource)

instance HasComputedArn ElasticsearchDomainResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

instance HasComputedDomainId ElasticsearchDomainResource Text where
    computedDomainId =
        to (\_  -> TF.Compute "domain_id")

instance HasComputedEndpoint ElasticsearchDomainResource Text where
    computedEndpoint =
        to (\_  -> TF.Compute "endpoint")

instance HasComputedKibanaEndpoint ElasticsearchDomainResource Text where
    computedKibanaEndpoint =
        to (\_  -> TF.Compute "kibana_endpoint")

instance HasComputedVpcOptions0AvailabilityZones ElasticsearchDomainResource Text where
    computedVpcOptions0AvailabilityZones =
        to (\_  -> TF.Compute "vpc_options.0.availability_zones")

instance HasComputedVpcOptions0VpcId ElasticsearchDomainResource Text where
    computedVpcOptions0VpcId =
        to (\_  -> TF.Compute "vpc_options.0.vpc_id")

elasticsearchDomainResource :: TF.Resource TF.AWS ElasticsearchDomainResource
elasticsearchDomainResource =
    TF.newResource "aws_elasticsearch_domain" $
        ElasticsearchDomainResource {
            _access_policies = TF.Nil
            , _advanced_options = TF.Nil
            , _cluster_config = TF.Nil
            , _domain_name = TF.Nil
            , _ebs_options = TF.Nil
            , _elasticsearch_version = TF.Nil
            , _encrypt_at_rest = TF.Nil
            , _log_publishing_options = TF.Nil
            , _snapshot_options = TF.Nil
            , _tags = TF.Nil
            , _vpc_options = TF.Nil
            }

{- | The @aws_elastictranscoder_pipeline@ AWS resource.

Provides an Elastic Transcoder pipeline resource.
-}
data ElastictranscoderPipelineResource = ElastictranscoderPipelineResource {
      _aws_kms_key_arn :: !(TF.Argument "aws_kms_key_arn" Text)
    {- ^ (Optional) The AWS Key Management Service (AWS KMS) key that you want to use with this pipeline. -}
    , _content_config :: !(TF.Argument "content_config" Text)
    {- ^ (Optional) The ContentConfig object specifies information about the Amazon S3 bucket in which you want Elastic Transcoder to save transcoded files and playlists. (documented below) -}
    , _content_config_permissions :: !(TF.Argument "content_config_permissions" Text)
    {- ^ (Optional) The permissions for the @content_config@ object. (documented below) -}
    , _input_bucket :: !(TF.Argument "input_bucket" Text)
    {- ^ (Required) The Amazon S3 bucket in which you saved the media files that you want to transcode and the graphics that you want to use as watermarks. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Optional, Forces new resource) The name of the pipeline. Maximum 40 characters -}
    , _notifications :: !(TF.Argument "notifications" Text)
    {- ^ (Optional) The Amazon Simple Notification Service (Amazon SNS) topic that you want to notify to report job status. (documented below) -}
    , _output_bucket :: !(TF.Argument "output_bucket" Text)
    {- ^ (Optional) The Amazon S3 bucket in which you want Elastic Transcoder to save the transcoded files. -}
    , _role :: !(TF.Argument "role" Text)
    {- ^ (Required) The IAM Amazon Resource Name (ARN) for the role that you want Elastic Transcoder to use to transcode jobs for this pipeline. -}
    , _thumbnail_config :: !(TF.Argument "thumbnail_config" Text)
    {- ^ (Optional) The ThumbnailConfig object specifies information about the Amazon S3 bucket in which you want Elastic Transcoder to save thumbnail files. (documented below) -}
    , _thumbnail_config_permissions :: !(TF.Argument "thumbnail_config_permissions" Text)
    {- ^ (Optional) The permissions for the @thumbnail_config@ object. (documented below) -}
    } deriving (Show, Eq)

instance TF.ToHCL ElastictranscoderPipelineResource where
    toHCL ElastictranscoderPipelineResource{..} = TF.block $ catMaybes
        [ TF.argument _aws_kms_key_arn
        , TF.argument _content_config
        , TF.argument _content_config_permissions
        , TF.argument _input_bucket
        , TF.argument _name
        , TF.argument _notifications
        , TF.argument _output_bucket
        , TF.argument _role
        , TF.argument _thumbnail_config
        , TF.argument _thumbnail_config_permissions
        ]

instance HasAwsKmsKeyArn ElastictranscoderPipelineResource Text where
    awsKmsKeyArn =
        lens (_aws_kms_key_arn :: ElastictranscoderPipelineResource -> TF.Argument "aws_kms_key_arn" Text)
             (\s a -> s { _aws_kms_key_arn = a } :: ElastictranscoderPipelineResource)

instance HasContentConfig ElastictranscoderPipelineResource Text where
    contentConfig =
        lens (_content_config :: ElastictranscoderPipelineResource -> TF.Argument "content_config" Text)
             (\s a -> s { _content_config = a } :: ElastictranscoderPipelineResource)

instance HasContentConfigPermissions ElastictranscoderPipelineResource Text where
    contentConfigPermissions =
        lens (_content_config_permissions :: ElastictranscoderPipelineResource -> TF.Argument "content_config_permissions" Text)
             (\s a -> s { _content_config_permissions = a } :: ElastictranscoderPipelineResource)

instance HasInputBucket ElastictranscoderPipelineResource Text where
    inputBucket =
        lens (_input_bucket :: ElastictranscoderPipelineResource -> TF.Argument "input_bucket" Text)
             (\s a -> s { _input_bucket = a } :: ElastictranscoderPipelineResource)

instance HasName ElastictranscoderPipelineResource Text where
    name =
        lens (_name :: ElastictranscoderPipelineResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: ElastictranscoderPipelineResource)

instance HasNotifications ElastictranscoderPipelineResource Text where
    notifications =
        lens (_notifications :: ElastictranscoderPipelineResource -> TF.Argument "notifications" Text)
             (\s a -> s { _notifications = a } :: ElastictranscoderPipelineResource)

instance HasOutputBucket ElastictranscoderPipelineResource Text where
    outputBucket =
        lens (_output_bucket :: ElastictranscoderPipelineResource -> TF.Argument "output_bucket" Text)
             (\s a -> s { _output_bucket = a } :: ElastictranscoderPipelineResource)

instance HasRole ElastictranscoderPipelineResource Text where
    role =
        lens (_role :: ElastictranscoderPipelineResource -> TF.Argument "role" Text)
             (\s a -> s { _role = a } :: ElastictranscoderPipelineResource)

instance HasThumbnailConfig ElastictranscoderPipelineResource Text where
    thumbnailConfig =
        lens (_thumbnail_config :: ElastictranscoderPipelineResource -> TF.Argument "thumbnail_config" Text)
             (\s a -> s { _thumbnail_config = a } :: ElastictranscoderPipelineResource)

instance HasThumbnailConfigPermissions ElastictranscoderPipelineResource Text where
    thumbnailConfigPermissions =
        lens (_thumbnail_config_permissions :: ElastictranscoderPipelineResource -> TF.Argument "thumbnail_config_permissions" Text)
             (\s a -> s { _thumbnail_config_permissions = a } :: ElastictranscoderPipelineResource)

elastictranscoderPipelineResource :: TF.Resource TF.AWS ElastictranscoderPipelineResource
elastictranscoderPipelineResource =
    TF.newResource "aws_elastictranscoder_pipeline" $
        ElastictranscoderPipelineResource {
            _aws_kms_key_arn = TF.Nil
            , _content_config = TF.Nil
            , _content_config_permissions = TF.Nil
            , _input_bucket = TF.Nil
            , _name = TF.Nil
            , _notifications = TF.Nil
            , _output_bucket = TF.Nil
            , _role = TF.Nil
            , _thumbnail_config = TF.Nil
            , _thumbnail_config_permissions = TF.Nil
            }

{- | The @aws_elastictranscoder_preset@ AWS resource.

Provides an Elastic Transcoder preset resource.
-}
data ElastictranscoderPresetResource = ElastictranscoderPresetResource {
      _audio :: !(TF.Argument "audio" Text)
    {- ^ (Optional, Forces new resource) Audio parameters object (documented below). -}
    , _audio_codec_options :: !(TF.Argument "audio_codec_options" Text)
    {- ^ (Optional, Forces new resource) Codec options for the audio parameters (documented below) -}
    , _container :: !(TF.Argument "container" Text)
    {- ^ (Required, Forces new resource) The container type for the output file. Valid values are @flac@ , @flv@ , @fmp4@ , @gif@ , @mp3@ , @mp4@ , @mpg@ , @mxf@ , @oga@ , @ogg@ , @ts@ , and @webm@ . -}
    , _description :: !(TF.Argument "description" Text)
    {- ^ (Optional, Forces new resource) A description of the preset (maximum 255 characters) -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Optional, Forces new resource) The name of the preset. (maximum 40 characters) -}
    , _thumbnails :: !(TF.Argument "thumbnails" Text)
    {- ^ (Optional, Forces new resource) Thumbnail parameters object (documented below) -}
    , _video :: !(TF.Argument "video" Text)
    {- ^ (Optional, Forces new resource) Video parameters object (documented below) -}
    , _video_codec_options :: !(TF.Argument "video_codec_options" Text)
    {- ^ (Optional, Forces new resource) Codec options for the video parameters -}
    , _video_watermarks :: !(TF.Argument "video_watermarks" Text)
    {- ^ (Optional, Forces new resource) Watermark parameters for the video parameters (documented below) -}
    } deriving (Show, Eq)

instance TF.ToHCL ElastictranscoderPresetResource where
    toHCL ElastictranscoderPresetResource{..} = TF.block $ catMaybes
        [ TF.argument _audio
        , TF.argument _audio_codec_options
        , TF.argument _container
        , TF.argument _description
        , TF.argument _name
        , TF.argument _thumbnails
        , TF.argument _video
        , TF.argument _video_codec_options
        , TF.argument _video_watermarks
        ]

instance HasAudio ElastictranscoderPresetResource Text where
    audio =
        lens (_audio :: ElastictranscoderPresetResource -> TF.Argument "audio" Text)
             (\s a -> s { _audio = a } :: ElastictranscoderPresetResource)

instance HasAudioCodecOptions ElastictranscoderPresetResource Text where
    audioCodecOptions =
        lens (_audio_codec_options :: ElastictranscoderPresetResource -> TF.Argument "audio_codec_options" Text)
             (\s a -> s { _audio_codec_options = a } :: ElastictranscoderPresetResource)

instance HasContainer ElastictranscoderPresetResource Text where
    container =
        lens (_container :: ElastictranscoderPresetResource -> TF.Argument "container" Text)
             (\s a -> s { _container = a } :: ElastictranscoderPresetResource)

instance HasDescription ElastictranscoderPresetResource Text where
    description =
        lens (_description :: ElastictranscoderPresetResource -> TF.Argument "description" Text)
             (\s a -> s { _description = a } :: ElastictranscoderPresetResource)

instance HasName ElastictranscoderPresetResource Text where
    name =
        lens (_name :: ElastictranscoderPresetResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: ElastictranscoderPresetResource)

instance HasThumbnails ElastictranscoderPresetResource Text where
    thumbnails =
        lens (_thumbnails :: ElastictranscoderPresetResource -> TF.Argument "thumbnails" Text)
             (\s a -> s { _thumbnails = a } :: ElastictranscoderPresetResource)

instance HasVideo ElastictranscoderPresetResource Text where
    video =
        lens (_video :: ElastictranscoderPresetResource -> TF.Argument "video" Text)
             (\s a -> s { _video = a } :: ElastictranscoderPresetResource)

instance HasVideoCodecOptions ElastictranscoderPresetResource Text where
    videoCodecOptions =
        lens (_video_codec_options :: ElastictranscoderPresetResource -> TF.Argument "video_codec_options" Text)
             (\s a -> s { _video_codec_options = a } :: ElastictranscoderPresetResource)

instance HasVideoWatermarks ElastictranscoderPresetResource Text where
    videoWatermarks =
        lens (_video_watermarks :: ElastictranscoderPresetResource -> TF.Argument "video_watermarks" Text)
             (\s a -> s { _video_watermarks = a } :: ElastictranscoderPresetResource)

elastictranscoderPresetResource :: TF.Resource TF.AWS ElastictranscoderPresetResource
elastictranscoderPresetResource =
    TF.newResource "aws_elastictranscoder_preset" $
        ElastictranscoderPresetResource {
            _audio = TF.Nil
            , _audio_codec_options = TF.Nil
            , _container = TF.Nil
            , _description = TF.Nil
            , _name = TF.Nil
            , _thumbnails = TF.Nil
            , _video = TF.Nil
            , _video_codec_options = TF.Nil
            , _video_watermarks = TF.Nil
            }

{- | The @aws_elb_attachment@ AWS resource.

Provides an Elastic Load Balancer Attachment resource. ~> NOTE on ELB
Instances and ELB Attachments: Terraform currently provides both a
standalone ELB Attachment resource (describing an instance attached to an
ELB), and an <elb.html> with @instances@ defined in-line. At this time you
cannot use an ELB with in-line instances in conjunction with an ELB
Attachment resource. Doing so will cause a conflict and will overwrite
attachments.
-}
data ElbAttachmentResource = ElbAttachmentResource {
      _elb :: !(TF.Argument "elb" Text)
    {- ^ (Required) The name of the ELB. -}
    , _instance' :: !(TF.Argument "instance" Text)
    {- ^ (Required) Instance ID to place in the ELB pool. -}
    } deriving (Show, Eq)

instance TF.ToHCL ElbAttachmentResource where
    toHCL ElbAttachmentResource{..} = TF.block $ catMaybes
        [ TF.argument _elb
        , TF.argument _instance'
        ]

instance HasElb ElbAttachmentResource Text where
    elb =
        lens (_elb :: ElbAttachmentResource -> TF.Argument "elb" Text)
             (\s a -> s { _elb = a } :: ElbAttachmentResource)

instance HasInstance' ElbAttachmentResource Text where
    instance' =
        lens (_instance' :: ElbAttachmentResource -> TF.Argument "instance" Text)
             (\s a -> s { _instance' = a } :: ElbAttachmentResource)

elbAttachmentResource :: TF.Resource TF.AWS ElbAttachmentResource
elbAttachmentResource =
    TF.newResource "aws_elb_attachment" $
        ElbAttachmentResource {
            _elb = TF.Nil
            , _instance' = TF.Nil
            }

{- | The @aws_elb_load_balancer_backend_server_policy@ AWS resource.

Attaches a load balancer policy to an ELB backend server.
-}
data ElbLoadBalancerBackendServerPolicyResource = ElbLoadBalancerBackendServerPolicyResource {
      _instance_port :: !(TF.Argument "instance_port" TF.Word16)
    {- ^ (Required) The instance port to apply the policy to. -}
    , _load_balancer_name :: !(TF.Argument "load_balancer_name" Text)
    {- ^ (Required) The load balancer to attach the policy to. -}
    , _policy_names :: !(TF.Argument "policy_names" Text)
    {- ^ (Required) List of Policy Names to apply to the backend server. -}
    } deriving (Show, Eq)

instance TF.ToHCL ElbLoadBalancerBackendServerPolicyResource where
    toHCL ElbLoadBalancerBackendServerPolicyResource{..} = TF.block $ catMaybes
        [ TF.argument _instance_port
        , TF.argument _load_balancer_name
        , TF.argument _policy_names
        ]

instance HasInstancePort ElbLoadBalancerBackendServerPolicyResource TF.Word16 where
    instancePort =
        lens (_instance_port :: ElbLoadBalancerBackendServerPolicyResource -> TF.Argument "instance_port" TF.Word16)
             (\s a -> s { _instance_port = a } :: ElbLoadBalancerBackendServerPolicyResource)

instance HasLoadBalancerName ElbLoadBalancerBackendServerPolicyResource Text where
    loadBalancerName =
        lens (_load_balancer_name :: ElbLoadBalancerBackendServerPolicyResource -> TF.Argument "load_balancer_name" Text)
             (\s a -> s { _load_balancer_name = a } :: ElbLoadBalancerBackendServerPolicyResource)

instance HasPolicyNames ElbLoadBalancerBackendServerPolicyResource Text where
    policyNames =
        lens (_policy_names :: ElbLoadBalancerBackendServerPolicyResource -> TF.Argument "policy_names" Text)
             (\s a -> s { _policy_names = a } :: ElbLoadBalancerBackendServerPolicyResource)

instance HasComputedId ElbLoadBalancerBackendServerPolicyResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedInstancePort ElbLoadBalancerBackendServerPolicyResource TF.Word16 where
    computedInstancePort =
        to (\_  -> TF.Compute "instance_port")

instance HasComputedLoadBalancerName ElbLoadBalancerBackendServerPolicyResource Text where
    computedLoadBalancerName =
        to (\_  -> TF.Compute "load_balancer_name")

elbLoadBalancerBackendServerPolicyResource :: TF.Resource TF.AWS ElbLoadBalancerBackendServerPolicyResource
elbLoadBalancerBackendServerPolicyResource =
    TF.newResource "aws_elb_load_balancer_backend_server_policy" $
        ElbLoadBalancerBackendServerPolicyResource {
            _instance_port = TF.Nil
            , _load_balancer_name = TF.Nil
            , _policy_names = TF.Nil
            }

{- | The @aws_elb_load_balancer_listener_policy@ AWS resource.

Attaches a load balancer policy to an ELB Listener.
-}
data ElbLoadBalancerListenerPolicyResource = ElbLoadBalancerListenerPolicyResource {
      _load_balancer_name :: !(TF.Argument "load_balancer_name" Text)
    {- ^ (Required) The load balancer to attach the policy to. -}
    , _load_balancer_port :: !(TF.Argument "load_balancer_port" TF.Word16)
    {- ^ (Required) The load balancer listener port to apply the policy to. -}
    , _policy_names :: !(TF.Argument "policy_names" Text)
    {- ^ (Required) List of Policy Names to apply to the backend server. -}
    } deriving (Show, Eq)

instance TF.ToHCL ElbLoadBalancerListenerPolicyResource where
    toHCL ElbLoadBalancerListenerPolicyResource{..} = TF.block $ catMaybes
        [ TF.argument _load_balancer_name
        , TF.argument _load_balancer_port
        , TF.argument _policy_names
        ]

instance HasLoadBalancerName ElbLoadBalancerListenerPolicyResource Text where
    loadBalancerName =
        lens (_load_balancer_name :: ElbLoadBalancerListenerPolicyResource -> TF.Argument "load_balancer_name" Text)
             (\s a -> s { _load_balancer_name = a } :: ElbLoadBalancerListenerPolicyResource)

instance HasLoadBalancerPort ElbLoadBalancerListenerPolicyResource TF.Word16 where
    loadBalancerPort =
        lens (_load_balancer_port :: ElbLoadBalancerListenerPolicyResource -> TF.Argument "load_balancer_port" TF.Word16)
             (\s a -> s { _load_balancer_port = a } :: ElbLoadBalancerListenerPolicyResource)

instance HasPolicyNames ElbLoadBalancerListenerPolicyResource Text where
    policyNames =
        lens (_policy_names :: ElbLoadBalancerListenerPolicyResource -> TF.Argument "policy_names" Text)
             (\s a -> s { _policy_names = a } :: ElbLoadBalancerListenerPolicyResource)

instance HasComputedId ElbLoadBalancerListenerPolicyResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedLoadBalancerName ElbLoadBalancerListenerPolicyResource Text where
    computedLoadBalancerName =
        to (\_  -> TF.Compute "load_balancer_name")

instance HasComputedLoadBalancerPort ElbLoadBalancerListenerPolicyResource TF.Word16 where
    computedLoadBalancerPort =
        to (\_  -> TF.Compute "load_balancer_port")

elbLoadBalancerListenerPolicyResource :: TF.Resource TF.AWS ElbLoadBalancerListenerPolicyResource
elbLoadBalancerListenerPolicyResource =
    TF.newResource "aws_elb_load_balancer_listener_policy" $
        ElbLoadBalancerListenerPolicyResource {
            _load_balancer_name = TF.Nil
            , _load_balancer_port = TF.Nil
            , _policy_names = TF.Nil
            }

{- | The @aws_elb_load_balancer_policy@ AWS resource.

Provides a load balancer policy, which can be attached to an ELB listener or
backend server.
-}
data ElbLoadBalancerPolicyResource = ElbLoadBalancerPolicyResource {
      _load_balancer_name :: !(TF.Argument "load_balancer_name" Text)
    {- ^ (Required) The load balancer on which the policy is defined. -}
    , _policy_attribute :: !(TF.Argument "policy_attribute" Text)
    {- ^ (Optional) Policy attribute to apply to the policy. -}
    , _policy_name :: !(TF.Argument "policy_name" Text)
    {- ^ (Required) The name of the load balancer policy. -}
    , _policy_type_name :: !(TF.Argument "policy_type_name" Text)
    {- ^ (Required) The policy type. -}
    } deriving (Show, Eq)

instance TF.ToHCL ElbLoadBalancerPolicyResource where
    toHCL ElbLoadBalancerPolicyResource{..} = TF.block $ catMaybes
        [ TF.argument _load_balancer_name
        , TF.argument _policy_attribute
        , TF.argument _policy_name
        , TF.argument _policy_type_name
        ]

instance HasLoadBalancerName ElbLoadBalancerPolicyResource Text where
    loadBalancerName =
        lens (_load_balancer_name :: ElbLoadBalancerPolicyResource -> TF.Argument "load_balancer_name" Text)
             (\s a -> s { _load_balancer_name = a } :: ElbLoadBalancerPolicyResource)

instance HasPolicyAttribute ElbLoadBalancerPolicyResource Text where
    policyAttribute =
        lens (_policy_attribute :: ElbLoadBalancerPolicyResource -> TF.Argument "policy_attribute" Text)
             (\s a -> s { _policy_attribute = a } :: ElbLoadBalancerPolicyResource)

instance HasPolicyName ElbLoadBalancerPolicyResource Text where
    policyName =
        lens (_policy_name :: ElbLoadBalancerPolicyResource -> TF.Argument "policy_name" Text)
             (\s a -> s { _policy_name = a } :: ElbLoadBalancerPolicyResource)

instance HasPolicyTypeName ElbLoadBalancerPolicyResource Text where
    policyTypeName =
        lens (_policy_type_name :: ElbLoadBalancerPolicyResource -> TF.Argument "policy_type_name" Text)
             (\s a -> s { _policy_type_name = a } :: ElbLoadBalancerPolicyResource)

instance HasComputedId ElbLoadBalancerPolicyResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedLoadBalancerName ElbLoadBalancerPolicyResource Text where
    computedLoadBalancerName =
        to (\_  -> TF.Compute "load_balancer_name")

instance HasComputedPolicyName ElbLoadBalancerPolicyResource Text where
    computedPolicyName =
        to (\_  -> TF.Compute "policy_name")

instance HasComputedPolicyTypeName ElbLoadBalancerPolicyResource Text where
    computedPolicyTypeName =
        to (\_  -> TF.Compute "policy_type_name")

elbLoadBalancerPolicyResource :: TF.Resource TF.AWS ElbLoadBalancerPolicyResource
elbLoadBalancerPolicyResource =
    TF.newResource "aws_elb_load_balancer_policy" $
        ElbLoadBalancerPolicyResource {
            _load_balancer_name = TF.Nil
            , _policy_attribute = TF.Nil
            , _policy_name = TF.Nil
            , _policy_type_name = TF.Nil
            }

{- | The @aws_elb@ AWS resource.

Provides an Elastic Load Balancer resource, also known as a "Classic Load
Balancer" after the release of </docs/providers/aws/r/lb.html> . ~> NOTE on
ELB Instances and ELB Attachments: Terraform currently provides both a
standalone <elb_attachment.html> (describing an instance attached to an
ELB), and an ELB resource with @instances@ defined in-line. At this time you
cannot use an ELB with in-line instances in conjunction with a ELB
Attachment resources. Doing so will cause a conflict and will overwrite
attachments.
-}
data ElbResource = ElbResource {
      _access_logs :: !(TF.Argument "access_logs" Text)
    {- ^ (Optional) An Access Logs block. Access Logs documented below. -}
    , _availability_zones :: !(TF.Argument "availability_zones" Text)
    {- ^ (Required for an EC2-classic ELB) The AZ's to serve traffic in. -}
    , _connection_draining :: !(TF.Argument "connection_draining" Text)
    {- ^ (Optional) Boolean to enable connection draining. Default: @false@ -}
    , _connection_draining_timeout :: !(TF.Argument "connection_draining_timeout" Text)
    {- ^ (Optional) The time in seconds to allow for connections to drain. Default: @300@ -}
    , _cross_zone_load_balancing :: !(TF.Argument "cross_zone_load_balancing" Text)
    {- ^ (Optional) Enable cross-zone load balancing. Default: @true@ -}
    , _health_check :: !(TF.Argument "health_check" Text)
    {- ^ (Optional) A health_check block. Health Check documented below. -}
    , _idle_timeout :: !(TF.Argument "idle_timeout" Text)
    {- ^ (Optional) The time in seconds that the connection is allowed to be idle. Default: @60@ -}
    , _instances :: !(TF.Argument "instances" Text)
    {- ^ (Optional) A list of instance ids to place in the ELB pool. -}
    , _internal :: !(TF.Argument "internal" Text)
    {- ^ (Optional) If true, ELB will be an internal ELB. -}
    , _listener :: !(TF.Argument "listener" Text)
    {- ^ (Required) A list of listener blocks. Listeners documented below. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Optional) The name of the ELB. By default generated by Terraform. -}
    , _name_prefix :: !(TF.Argument "name_prefix" Text)
    {- ^ (Optional, Forces new resource) Creates a unique name beginning with the specified prefix. Conflicts with @name@ . -}
    , _security_groups :: !(TF.Argument "security_groups" Text)
    {- ^ (Optional) A list of security group IDs to assign to the ELB. Only valid if creating an ELB within a VPC -}
    , _subnets :: !(TF.Argument "subnets" Text)
    {- ^ (Required for a VPC ELB) A list of subnet IDs to attach to the ELB. -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    } deriving (Show, Eq)

instance TF.ToHCL ElbResource where
    toHCL ElbResource{..} = TF.block $ catMaybes
        [ TF.argument _access_logs
        , TF.argument _availability_zones
        , TF.argument _connection_draining
        , TF.argument _connection_draining_timeout
        , TF.argument _cross_zone_load_balancing
        , TF.argument _health_check
        , TF.argument _idle_timeout
        , TF.argument _instances
        , TF.argument _internal
        , TF.argument _listener
        , TF.argument _name
        , TF.argument _name_prefix
        , TF.argument _security_groups
        , TF.argument _subnets
        , TF.argument _tags
        ]

instance HasAccessLogs ElbResource Text where
    accessLogs =
        lens (_access_logs :: ElbResource -> TF.Argument "access_logs" Text)
             (\s a -> s { _access_logs = a } :: ElbResource)

instance HasAvailabilityZones ElbResource Text where
    availabilityZones =
        lens (_availability_zones :: ElbResource -> TF.Argument "availability_zones" Text)
             (\s a -> s { _availability_zones = a } :: ElbResource)

instance HasConnectionDraining ElbResource Text where
    connectionDraining =
        lens (_connection_draining :: ElbResource -> TF.Argument "connection_draining" Text)
             (\s a -> s { _connection_draining = a } :: ElbResource)

instance HasConnectionDrainingTimeout ElbResource Text where
    connectionDrainingTimeout =
        lens (_connection_draining_timeout :: ElbResource -> TF.Argument "connection_draining_timeout" Text)
             (\s a -> s { _connection_draining_timeout = a } :: ElbResource)

instance HasCrossZoneLoadBalancing ElbResource Text where
    crossZoneLoadBalancing =
        lens (_cross_zone_load_balancing :: ElbResource -> TF.Argument "cross_zone_load_balancing" Text)
             (\s a -> s { _cross_zone_load_balancing = a } :: ElbResource)

instance HasHealthCheck ElbResource Text where
    healthCheck =
        lens (_health_check :: ElbResource -> TF.Argument "health_check" Text)
             (\s a -> s { _health_check = a } :: ElbResource)

instance HasIdleTimeout ElbResource Text where
    idleTimeout =
        lens (_idle_timeout :: ElbResource -> TF.Argument "idle_timeout" Text)
             (\s a -> s { _idle_timeout = a } :: ElbResource)

instance HasInstances ElbResource Text where
    instances =
        lens (_instances :: ElbResource -> TF.Argument "instances" Text)
             (\s a -> s { _instances = a } :: ElbResource)

instance HasInternal ElbResource Text where
    internal =
        lens (_internal :: ElbResource -> TF.Argument "internal" Text)
             (\s a -> s { _internal = a } :: ElbResource)

instance HasListener ElbResource Text where
    listener =
        lens (_listener :: ElbResource -> TF.Argument "listener" Text)
             (\s a -> s { _listener = a } :: ElbResource)

instance HasName ElbResource Text where
    name =
        lens (_name :: ElbResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: ElbResource)

instance HasNamePrefix ElbResource Text where
    namePrefix =
        lens (_name_prefix :: ElbResource -> TF.Argument "name_prefix" Text)
             (\s a -> s { _name_prefix = a } :: ElbResource)

instance HasSecurityGroups ElbResource Text where
    securityGroups =
        lens (_security_groups :: ElbResource -> TF.Argument "security_groups" Text)
             (\s a -> s { _security_groups = a } :: ElbResource)

instance HasSubnets ElbResource Text where
    subnets =
        lens (_subnets :: ElbResource -> TF.Argument "subnets" Text)
             (\s a -> s { _subnets = a } :: ElbResource)

instance HasTags ElbResource TF.Tags where
    tags =
        lens (_tags :: ElbResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: ElbResource)

elbResource :: TF.Resource TF.AWS ElbResource
elbResource =
    TF.newResource "aws_elb" $
        ElbResource {
            _access_logs = TF.Nil
            , _availability_zones = TF.Nil
            , _connection_draining = TF.Nil
            , _connection_draining_timeout = TF.Nil
            , _cross_zone_load_balancing = TF.Nil
            , _health_check = TF.Nil
            , _idle_timeout = TF.Nil
            , _instances = TF.Nil
            , _internal = TF.Nil
            , _listener = TF.Nil
            , _name = TF.Nil
            , _name_prefix = TF.Nil
            , _security_groups = TF.Nil
            , _subnets = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_emr_cluster@ AWS resource.

Provides an Elastic MapReduce Cluster, a web service that makes it easy to
process large amounts of data efficiently. See
<https://aws.amazon.com/documentation/elastic-mapreduce/> for more
information.
-}
data EmrClusterResource = EmrClusterResource {
      _applications :: !(TF.Argument "applications" Text)
    {- ^ (Optional) A list of applications for the cluster. Valid values are: @Flink@ , @Hadoop@ , @Hive@ , @Mahout@ , @Pig@ , and @Spark@ . Case insensitive -}
    , _autoscaling_role :: !(TF.Argument "autoscaling_role" Text)
    {- ^ (Optional) An IAM role for automatic scaling policies. The IAM role provides permissions that the automatic scaling feature requires to launch and terminate EC2 instances in an instance group. -}
    , _bootstrap_action :: !(TF.Argument "bootstrap_action" Text)
    {- ^ (Optional) List of bootstrap actions that will be run before Hadoop is started on the cluster nodes. Defined below -}
    , _configurations :: !(TF.Argument "configurations" Text)
    {- ^ (Optional) List of configurations supplied for the EMR cluster you are creating -}
    , _core_instance_count :: !(TF.Argument "core_instance_count" Text)
    {- ^ (Optional) Number of Amazon EC2 instances used to execute the job flow. EMR will use one node as the cluster's master node and use the remainder of the nodes ( @core_instance_count@ -1) as core nodes. Cannot be specified if @instance_groups@ is set. Default @1@ -}
    , _core_instance_type :: !(TF.Argument "core_instance_type" Text)
    {- ^ (Optional) The EC2 instance type of the slave nodes. Cannot be specified if @instance_groups@ is set -}
    , _ebs_root_volume_size :: !(TF.Argument "ebs_root_volume_size" Text)
    {- ^ (Optional) Size in GiB of the EBS root device volume of the Linux AMI that is used for each EC2 instance. Available in Amazon EMR version 4.x and later. -}
    , _ec2_attributes :: !(TF.Argument "ec2_attributes" Text)
    {- ^ (Optional) Attributes for the EC2 instances running the job flow. Defined below -}
    , _instance_group :: !(TF.Argument "instance_group" Text)
    {- ^ (Optional) A list of @instance_group@ objects for each instance group in the cluster. Exactly one of @master_instance_type@ and @instance_group@ must be specified. If @instance_group@ is set, then it must contain a configuration block for at least the @MASTER@ instance group type (as well as any additional instance groups). Defined below -}
    , _keep_job_flow_alive_when_no_steps :: !(TF.Argument "keep_job_flow_alive_when_no_steps" Text)
    {- ^ (Optional) Switch on/off run cluster with no steps or when all steps are complete (default is on) -}
    , _log_uri :: !(TF.Argument "log_uri" Text)
    {- ^ (Optional) S3 bucket to write the log files of the job flow. If a value is not provided, logs are not created -}
    , _master_instance_type :: !(TF.Argument "master_instance_type" Text)
    {- ^ (Optional) The EC2 instance type of the master node. Exactly one of @master_instance_type@ and @instance_group@ must be specified. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the job flow -}
    , _release_label :: !(TF.Argument "release_label" Text)
    {- ^ (Required) The release label for the Amazon EMR release -}
    , _security_configuration :: !(TF.Argument "security_configuration" Text)
    {- ^ (Optional) The security configuration name to attach to the EMR cluster. Only valid for EMR clusters with @release_label@ 4.8.0 or greater -}
    , _service_role :: !(TF.Argument "service_role" Text)
    {- ^ (Required) IAM role that will be assumed by the Amazon EMR service to access AWS resources -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) list of tags to apply to the EMR Cluster -}
    , _termination_protection :: !(TF.Argument "termination_protection" Text)
    {- ^ (Optional) Switch on/off termination protection (default is off) -}
    , _visible_to_all_users :: !(TF.Argument "visible_to_all_users" Text)
    {- ^ (Optional) Whether the job flow is visible to all IAM users of the AWS account associated with the job flow. Default @true@ -}
    } deriving (Show, Eq)

instance TF.ToHCL EmrClusterResource where
    toHCL EmrClusterResource{..} = TF.block $ catMaybes
        [ TF.argument _applications
        , TF.argument _autoscaling_role
        , TF.argument _bootstrap_action
        , TF.argument _configurations
        , TF.argument _core_instance_count
        , TF.argument _core_instance_type
        , TF.argument _ebs_root_volume_size
        , TF.argument _ec2_attributes
        , TF.argument _instance_group
        , TF.argument _keep_job_flow_alive_when_no_steps
        , TF.argument _log_uri
        , TF.argument _master_instance_type
        , TF.argument _name
        , TF.argument _release_label
        , TF.argument _security_configuration
        , TF.argument _service_role
        , TF.argument _tags
        , TF.argument _termination_protection
        , TF.argument _visible_to_all_users
        ]

instance HasApplications EmrClusterResource Text where
    applications =
        lens (_applications :: EmrClusterResource -> TF.Argument "applications" Text)
             (\s a -> s { _applications = a } :: EmrClusterResource)

instance HasAutoscalingRole EmrClusterResource Text where
    autoscalingRole =
        lens (_autoscaling_role :: EmrClusterResource -> TF.Argument "autoscaling_role" Text)
             (\s a -> s { _autoscaling_role = a } :: EmrClusterResource)

instance HasBootstrapAction EmrClusterResource Text where
    bootstrapAction =
        lens (_bootstrap_action :: EmrClusterResource -> TF.Argument "bootstrap_action" Text)
             (\s a -> s { _bootstrap_action = a } :: EmrClusterResource)

instance HasConfigurations EmrClusterResource Text where
    configurations =
        lens (_configurations :: EmrClusterResource -> TF.Argument "configurations" Text)
             (\s a -> s { _configurations = a } :: EmrClusterResource)

instance HasCoreInstanceCount EmrClusterResource Text where
    coreInstanceCount =
        lens (_core_instance_count :: EmrClusterResource -> TF.Argument "core_instance_count" Text)
             (\s a -> s { _core_instance_count = a } :: EmrClusterResource)

instance HasCoreInstanceType EmrClusterResource Text where
    coreInstanceType =
        lens (_core_instance_type :: EmrClusterResource -> TF.Argument "core_instance_type" Text)
             (\s a -> s { _core_instance_type = a } :: EmrClusterResource)

instance HasEbsRootVolumeSize EmrClusterResource Text where
    ebsRootVolumeSize =
        lens (_ebs_root_volume_size :: EmrClusterResource -> TF.Argument "ebs_root_volume_size" Text)
             (\s a -> s { _ebs_root_volume_size = a } :: EmrClusterResource)

instance HasEc2Attributes EmrClusterResource Text where
    ec2Attributes =
        lens (_ec2_attributes :: EmrClusterResource -> TF.Argument "ec2_attributes" Text)
             (\s a -> s { _ec2_attributes = a } :: EmrClusterResource)

instance HasInstanceGroup EmrClusterResource Text where
    instanceGroup =
        lens (_instance_group :: EmrClusterResource -> TF.Argument "instance_group" Text)
             (\s a -> s { _instance_group = a } :: EmrClusterResource)

instance HasKeepJobFlowAliveWhenNoSteps EmrClusterResource Text where
    keepJobFlowAliveWhenNoSteps =
        lens (_keep_job_flow_alive_when_no_steps :: EmrClusterResource -> TF.Argument "keep_job_flow_alive_when_no_steps" Text)
             (\s a -> s { _keep_job_flow_alive_when_no_steps = a } :: EmrClusterResource)

instance HasLogUri EmrClusterResource Text where
    logUri =
        lens (_log_uri :: EmrClusterResource -> TF.Argument "log_uri" Text)
             (\s a -> s { _log_uri = a } :: EmrClusterResource)

instance HasMasterInstanceType EmrClusterResource Text where
    masterInstanceType =
        lens (_master_instance_type :: EmrClusterResource -> TF.Argument "master_instance_type" Text)
             (\s a -> s { _master_instance_type = a } :: EmrClusterResource)

instance HasName EmrClusterResource Text where
    name =
        lens (_name :: EmrClusterResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: EmrClusterResource)

instance HasReleaseLabel EmrClusterResource Text where
    releaseLabel =
        lens (_release_label :: EmrClusterResource -> TF.Argument "release_label" Text)
             (\s a -> s { _release_label = a } :: EmrClusterResource)

instance HasSecurityConfiguration EmrClusterResource Text where
    securityConfiguration =
        lens (_security_configuration :: EmrClusterResource -> TF.Argument "security_configuration" Text)
             (\s a -> s { _security_configuration = a } :: EmrClusterResource)

instance HasServiceRole EmrClusterResource Text where
    serviceRole =
        lens (_service_role :: EmrClusterResource -> TF.Argument "service_role" Text)
             (\s a -> s { _service_role = a } :: EmrClusterResource)

instance HasTags EmrClusterResource TF.Tags where
    tags =
        lens (_tags :: EmrClusterResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: EmrClusterResource)

instance HasTerminationProtection EmrClusterResource Text where
    terminationProtection =
        lens (_termination_protection :: EmrClusterResource -> TF.Argument "termination_protection" Text)
             (\s a -> s { _termination_protection = a } :: EmrClusterResource)

instance HasVisibleToAllUsers EmrClusterResource Text where
    visibleToAllUsers =
        lens (_visible_to_all_users :: EmrClusterResource -> TF.Argument "visible_to_all_users" Text)
             (\s a -> s { _visible_to_all_users = a } :: EmrClusterResource)

emrClusterResource :: TF.Resource TF.AWS EmrClusterResource
emrClusterResource =
    TF.newResource "aws_emr_cluster" $
        EmrClusterResource {
            _applications = TF.Nil
            , _autoscaling_role = TF.Nil
            , _bootstrap_action = TF.Nil
            , _configurations = TF.Nil
            , _core_instance_count = TF.Nil
            , _core_instance_type = TF.Nil
            , _ebs_root_volume_size = TF.Nil
            , _ec2_attributes = TF.Nil
            , _instance_group = TF.Nil
            , _keep_job_flow_alive_when_no_steps = TF.Nil
            , _log_uri = TF.Nil
            , _master_instance_type = TF.Nil
            , _name = TF.Nil
            , _release_label = TF.Nil
            , _security_configuration = TF.Nil
            , _service_role = TF.Nil
            , _tags = TF.Nil
            , _termination_protection = TF.Nil
            , _visible_to_all_users = TF.Nil
            }

{- | The @aws_emr_instance_group@ AWS resource.

Provides an Elastic MapReduce Cluster Instance Group configuration. See
<https://aws.amazon.com/documentation/emr/> for more information. ~> NOTE:
At this time, Instance Groups cannot be destroyed through the API nor web
interface. Instance Groups are destroyed when the EMR Cluster is destroyed.
Terraform will resize any Instance Group to zero when destroying the
resource.
-}
data EmrInstanceGroupResource = EmrInstanceGroupResource {
      _cluster_id :: !(TF.Argument "cluster_id" Text)
    {- ^ (Required) ID of the EMR Cluster to attach to. Changing this forces a new resource to be created. -}
    , _ebs_config :: !(TF.Argument "ebs_config" Text)
    {- ^ (Optional) One or more @ebs_config@ blocks as defined below. Changing this forces a new resource to be created. -}
    , _ebs_optimized :: !(TF.Argument "ebs_optimized" Text)
    {- ^ (Optional) Indicates whether an Amazon EBS volume is EBS-optimized. Changing this forces a new resource to be created. -}
    , _instance_count :: !(TF.Argument "instance_count" Text)
    {- ^ (Optional) Target number of instances for the instance group. Defaults to 0. -}
    , _instance_type :: !(TF.Argument "instance_type" Text)
    {- ^ (Required) The EC2 instance type for all instances in the instance group. Changing this forces a new resource to be created. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) Human friendly name given to the instance group. Changing this forces a new resource to be created. -}
    } deriving (Show, Eq)

instance TF.ToHCL EmrInstanceGroupResource where
    toHCL EmrInstanceGroupResource{..} = TF.block $ catMaybes
        [ TF.argument _cluster_id
        , TF.argument _ebs_config
        , TF.argument _ebs_optimized
        , TF.argument _instance_count
        , TF.argument _instance_type
        , TF.argument _name
        ]

instance HasClusterId EmrInstanceGroupResource Text where
    clusterId =
        lens (_cluster_id :: EmrInstanceGroupResource -> TF.Argument "cluster_id" Text)
             (\s a -> s { _cluster_id = a } :: EmrInstanceGroupResource)

instance HasEbsConfig EmrInstanceGroupResource Text where
    ebsConfig =
        lens (_ebs_config :: EmrInstanceGroupResource -> TF.Argument "ebs_config" Text)
             (\s a -> s { _ebs_config = a } :: EmrInstanceGroupResource)

instance HasEbsOptimized EmrInstanceGroupResource Text where
    ebsOptimized =
        lens (_ebs_optimized :: EmrInstanceGroupResource -> TF.Argument "ebs_optimized" Text)
             (\s a -> s { _ebs_optimized = a } :: EmrInstanceGroupResource)

instance HasInstanceCount EmrInstanceGroupResource Text where
    instanceCount =
        lens (_instance_count :: EmrInstanceGroupResource -> TF.Argument "instance_count" Text)
             (\s a -> s { _instance_count = a } :: EmrInstanceGroupResource)

instance HasInstanceType EmrInstanceGroupResource Text where
    instanceType =
        lens (_instance_type :: EmrInstanceGroupResource -> TF.Argument "instance_type" Text)
             (\s a -> s { _instance_type = a } :: EmrInstanceGroupResource)

instance HasName EmrInstanceGroupResource Text where
    name =
        lens (_name :: EmrInstanceGroupResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: EmrInstanceGroupResource)

instance HasComputedId EmrInstanceGroupResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedRunningInstanceCount EmrInstanceGroupResource Text where
    computedRunningInstanceCount =
        to (\_  -> TF.Compute "running_instance_count")

instance HasComputedStatus EmrInstanceGroupResource Text where
    computedStatus =
        to (\_  -> TF.Compute "status")

emrInstanceGroupResource :: TF.Resource TF.AWS EmrInstanceGroupResource
emrInstanceGroupResource =
    TF.newResource "aws_emr_instance_group" $
        EmrInstanceGroupResource {
            _cluster_id = TF.Nil
            , _ebs_config = TF.Nil
            , _ebs_optimized = TF.Nil
            , _instance_count = TF.Nil
            , _instance_type = TF.Nil
            , _name = TF.Nil
            }

{- | The @aws_emr_security_configuration@ AWS resource.

Provides a resource to manage AWS EMR Security Configurations
-}
data EmrSecurityConfigurationResource = EmrSecurityConfigurationResource {
      _configuration :: !(TF.Argument "configuration" Text)
    {- ^ (Required) A JSON formatted Security Configuration -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Optional) The name of the EMR Security Configuration. By default generated by Terraform. -}
    , _name_prefix :: !(TF.Argument "name_prefix" Text)
    {- ^ (Optional) Creates a unique name beginning with the specified prefix. Conflicts with @name@ . -}
    } deriving (Show, Eq)

instance TF.ToHCL EmrSecurityConfigurationResource where
    toHCL EmrSecurityConfigurationResource{..} = TF.block $ catMaybes
        [ TF.argument _configuration
        , TF.argument _name
        , TF.argument _name_prefix
        ]

instance HasConfiguration EmrSecurityConfigurationResource Text where
    configuration =
        lens (_configuration :: EmrSecurityConfigurationResource -> TF.Argument "configuration" Text)
             (\s a -> s { _configuration = a } :: EmrSecurityConfigurationResource)

instance HasName EmrSecurityConfigurationResource Text where
    name =
        lens (_name :: EmrSecurityConfigurationResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: EmrSecurityConfigurationResource)

instance HasNamePrefix EmrSecurityConfigurationResource Text where
    namePrefix =
        lens (_name_prefix :: EmrSecurityConfigurationResource -> TF.Argument "name_prefix" Text)
             (\s a -> s { _name_prefix = a } :: EmrSecurityConfigurationResource)

instance HasComputedConfiguration EmrSecurityConfigurationResource Text where
    computedConfiguration =
        to (\_  -> TF.Compute "configuration")

instance HasComputedCreationDate EmrSecurityConfigurationResource Text where
    computedCreationDate =
        to (\_  -> TF.Compute "creation_date")

instance HasComputedId EmrSecurityConfigurationResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedName EmrSecurityConfigurationResource Text where
    computedName =
        to (\_  -> TF.Compute "name")

emrSecurityConfigurationResource :: TF.Resource TF.AWS EmrSecurityConfigurationResource
emrSecurityConfigurationResource =
    TF.newResource "aws_emr_security_configuration" $
        EmrSecurityConfigurationResource {
            _configuration = TF.Nil
            , _name = TF.Nil
            , _name_prefix = TF.Nil
            }

{- | The @aws_flow_log@ AWS resource.

Provides a VPC/Subnet/ENI Flow Log to capture IP traffic for a specific
network interface, subnet, or VPC. Logs are sent to a CloudWatch Log Group.
-}
data FlowLogResource = FlowLogResource {
      _eni_id :: !(TF.Argument "eni_id" Text)
    {- ^ (Optional) Elastic Network Interface ID to attach to -}
    , _iam_role_arn :: !(TF.Argument "iam_role_arn" Text)
    {- ^ (Required) The ARN for the IAM role that's used to post flow logs to a CloudWatch Logs log group -}
    , _log_group_name :: !(TF.Argument "log_group_name" Text)
    {- ^ (Required) The name of the CloudWatch log group -}
    , _subnet_id :: !(TF.Argument "subnet_id" Text)
    {- ^ (Optional) Subnet ID to attach to -}
    , _traffic_type :: !(TF.Argument "traffic_type" Text)
    {- ^ (Required) The type of traffic to capture. Valid values: @ACCEPT@ , @REJECT@ , @ALL@ -}
    , _vpc_id :: !(TF.Argument "vpc_id" Text)
    {- ^ (Optional) VPC ID to attach to -}
    } deriving (Show, Eq)

instance TF.ToHCL FlowLogResource where
    toHCL FlowLogResource{..} = TF.block $ catMaybes
        [ TF.argument _eni_id
        , TF.argument _iam_role_arn
        , TF.argument _log_group_name
        , TF.argument _subnet_id
        , TF.argument _traffic_type
        , TF.argument _vpc_id
        ]

instance HasEniId FlowLogResource Text where
    eniId =
        lens (_eni_id :: FlowLogResource -> TF.Argument "eni_id" Text)
             (\s a -> s { _eni_id = a } :: FlowLogResource)

instance HasIamRoleArn FlowLogResource Text where
    iamRoleArn =
        lens (_iam_role_arn :: FlowLogResource -> TF.Argument "iam_role_arn" Text)
             (\s a -> s { _iam_role_arn = a } :: FlowLogResource)

instance HasLogGroupName FlowLogResource Text where
    logGroupName =
        lens (_log_group_name :: FlowLogResource -> TF.Argument "log_group_name" Text)
             (\s a -> s { _log_group_name = a } :: FlowLogResource)

instance HasSubnetId FlowLogResource Text where
    subnetId =
        lens (_subnet_id :: FlowLogResource -> TF.Argument "subnet_id" Text)
             (\s a -> s { _subnet_id = a } :: FlowLogResource)

instance HasTrafficType FlowLogResource Text where
    trafficType =
        lens (_traffic_type :: FlowLogResource -> TF.Argument "traffic_type" Text)
             (\s a -> s { _traffic_type = a } :: FlowLogResource)

instance HasVpcId FlowLogResource Text where
    vpcId =
        lens (_vpc_id :: FlowLogResource -> TF.Argument "vpc_id" Text)
             (\s a -> s { _vpc_id = a } :: FlowLogResource)

instance HasComputedId FlowLogResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

flowLogResource :: TF.Resource TF.AWS FlowLogResource
flowLogResource =
    TF.newResource "aws_flow_log" $
        FlowLogResource {
            _eni_id = TF.Nil
            , _iam_role_arn = TF.Nil
            , _log_group_name = TF.Nil
            , _subnet_id = TF.Nil
            , _traffic_type = TF.Nil
            , _vpc_id = TF.Nil
            }

{- | The @aws_glacier_vault@ AWS resource.

Provides a Glacier Vault Resource. You can refer to the
<https://docs.aws.amazon.com/amazonglacier/latest/dev/working-with-vaults.html>
for a full explanation of the Glacier Vault functionality ~> NOTE: When
removing a Glacier Vault, the Vault must be empty.
-}
data GlacierVaultResource = GlacierVaultResource {
      _access_policy :: !(TF.Argument "access_policy" Text)
    {- ^ (Optional) The policy document. This is a JSON formatted string. The heredoc syntax or @file@ function is helpful here. Use the <https://docs.aws.amazon.com/amazonglacier/latest/dev/vault-access-policy.html> for more information on Glacier Vault Policy -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the Vault. Names can be between 1 and 255 characters long and the valid characters are a-z, A-Z, 0-9, '_' (underscore), '-' (hyphen), and '.' (period). -}
    , _notification :: !(TF.Argument "notification" Text)
    {- ^ (Optional) The notifications for the Vault. Fields documented below. -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    } deriving (Show, Eq)

instance TF.ToHCL GlacierVaultResource where
    toHCL GlacierVaultResource{..} = TF.block $ catMaybes
        [ TF.argument _access_policy
        , TF.argument _name
        , TF.argument _notification
        , TF.argument _tags
        ]

instance HasAccessPolicy GlacierVaultResource Text where
    accessPolicy =
        lens (_access_policy :: GlacierVaultResource -> TF.Argument "access_policy" Text)
             (\s a -> s { _access_policy = a } :: GlacierVaultResource)

instance HasName GlacierVaultResource Text where
    name =
        lens (_name :: GlacierVaultResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: GlacierVaultResource)

instance HasNotification GlacierVaultResource Text where
    notification =
        lens (_notification :: GlacierVaultResource -> TF.Argument "notification" Text)
             (\s a -> s { _notification = a } :: GlacierVaultResource)

instance HasTags GlacierVaultResource TF.Tags where
    tags =
        lens (_tags :: GlacierVaultResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: GlacierVaultResource)

instance HasComputedArn GlacierVaultResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

instance HasComputedLocation GlacierVaultResource Text where
    computedLocation =
        to (\_  -> TF.Compute "location")

glacierVaultResource :: TF.Resource TF.AWS GlacierVaultResource
glacierVaultResource =
    TF.newResource "aws_glacier_vault" $
        GlacierVaultResource {
            _access_policy = TF.Nil
            , _name = TF.Nil
            , _notification = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_glue_catalog_database@ AWS resource.

Provides a Glue Catalog Database Resource. You can refer to the
<http://docs.aws.amazon.com/glue/latest/dg/populate-data-catalog.html> for a
full explanation of the Glue Data Catalog functionality
-}
data GlueCatalogDatabaseResource = GlueCatalogDatabaseResource {
      _catalog_id :: !(TF.Argument "catalog_id" Text)
    {- ^ (Optional) ID of the Glue Catalog to create the database in. If omitted, this defaults to the AWS Account ID. -}
    , _description :: !(TF.Argument "description" Text)
    {- ^ (Optional) Description of the database. -}
    , _location_uri :: !(TF.Argument "location_uri" Text)
    {- ^ (Optional) The location of the database (for example, an HDFS path). -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the database. -}
    , _parameters :: !(TF.Argument "parameters" Text)
    {- ^ (Optional) A list of key-value pairs that define parameters and properties of the database. -}
    } deriving (Show, Eq)

instance TF.ToHCL GlueCatalogDatabaseResource where
    toHCL GlueCatalogDatabaseResource{..} = TF.block $ catMaybes
        [ TF.argument _catalog_id
        , TF.argument _description
        , TF.argument _location_uri
        , TF.argument _name
        , TF.argument _parameters
        ]

instance HasCatalogId GlueCatalogDatabaseResource Text where
    catalogId =
        lens (_catalog_id :: GlueCatalogDatabaseResource -> TF.Argument "catalog_id" Text)
             (\s a -> s { _catalog_id = a } :: GlueCatalogDatabaseResource)

instance HasDescription GlueCatalogDatabaseResource Text where
    description =
        lens (_description :: GlueCatalogDatabaseResource -> TF.Argument "description" Text)
             (\s a -> s { _description = a } :: GlueCatalogDatabaseResource)

instance HasLocationUri GlueCatalogDatabaseResource Text where
    locationUri =
        lens (_location_uri :: GlueCatalogDatabaseResource -> TF.Argument "location_uri" Text)
             (\s a -> s { _location_uri = a } :: GlueCatalogDatabaseResource)

instance HasName GlueCatalogDatabaseResource Text where
    name =
        lens (_name :: GlueCatalogDatabaseResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: GlueCatalogDatabaseResource)

instance HasParameters GlueCatalogDatabaseResource Text where
    parameters =
        lens (_parameters :: GlueCatalogDatabaseResource -> TF.Argument "parameters" Text)
             (\s a -> s { _parameters = a } :: GlueCatalogDatabaseResource)

glueCatalogDatabaseResource :: TF.Resource TF.AWS GlueCatalogDatabaseResource
glueCatalogDatabaseResource =
    TF.newResource "aws_glue_catalog_database" $
        GlueCatalogDatabaseResource {
            _catalog_id = TF.Nil
            , _description = TF.Nil
            , _location_uri = TF.Nil
            , _name = TF.Nil
            , _parameters = TF.Nil
            }

{- | The @aws_guardduty_detector@ AWS resource.

Provides a resource to manage a GuardDuty detector. ~> NOTE: Deleting this
resource is equivalent to "disabling" GuardDuty for an AWS region, which
removes all existing findings. You can set the @enable@ attribute to @false@
to instead "suspend" monitoring and feedback reporting while keeping
existing data. See the
<https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_suspend-disable.html>
for more information.
-}
data GuarddutyDetectorResource = GuarddutyDetectorResource {
      _enable :: !(TF.Argument "enable" TF.Bool)
    {- ^ (Optional) Enable monitoring and feedback reporting. Setting to @false@ is equivalent to "suspending" GuardDuty. Defaults to @true@ . -}
    } deriving (Show, Eq)

instance TF.ToHCL GuarddutyDetectorResource where
    toHCL GuarddutyDetectorResource{..} = TF.block $ catMaybes
        [ TF.argument _enable
        ]

instance HasEnable GuarddutyDetectorResource TF.Bool where
    enable =
        lens (_enable :: GuarddutyDetectorResource -> TF.Argument "enable" TF.Bool)
             (\s a -> s { _enable = a } :: GuarddutyDetectorResource)

instance HasComputedAccountId GuarddutyDetectorResource Text where
    computedAccountId =
        to (\_  -> TF.Compute "account_id")

instance HasComputedId GuarddutyDetectorResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

guarddutyDetectorResource :: TF.Resource TF.AWS GuarddutyDetectorResource
guarddutyDetectorResource =
    TF.newResource "aws_guardduty_detector" $
        GuarddutyDetectorResource {
            _enable = TF.Nil
            }

{- | The @aws_guardduty_member@ AWS resource.

Provides a resource to manage a GuardDuty member. ~> NOTE: Currently after
using this resource, you must manually invite and accept member account
invitations before GuardDuty will begin sending cross-account events. More
information for how to accomplish this via the AWS Console or API can be
found in the
<https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_accounts.html> .
Terraform implementation of member invitation and acceptance resources can
be tracked in
<https://github.com/terraform-providers/terraform-provider-aws/issues/2489>
.
-}
data GuarddutyMemberResource = GuarddutyMemberResource {
      _account_id :: !(TF.Argument "account_id" Text)
    {- ^ (Required) AWS account ID for member account. -}
    , _detector_id :: !(TF.Argument "detector_id" Text)
    {- ^ (Required) The detector ID of the GuardDuty account where you want to create member accounts. -}
    , _email :: !(TF.Argument "email" Text)
    {- ^ (Required) Email address for member account. -}
    } deriving (Show, Eq)

instance TF.ToHCL GuarddutyMemberResource where
    toHCL GuarddutyMemberResource{..} = TF.block $ catMaybes
        [ TF.argument _account_id
        , TF.argument _detector_id
        , TF.argument _email
        ]

instance HasAccountId GuarddutyMemberResource Text where
    accountId =
        lens (_account_id :: GuarddutyMemberResource -> TF.Argument "account_id" Text)
             (\s a -> s { _account_id = a } :: GuarddutyMemberResource)

instance HasDetectorId GuarddutyMemberResource Text where
    detectorId =
        lens (_detector_id :: GuarddutyMemberResource -> TF.Argument "detector_id" Text)
             (\s a -> s { _detector_id = a } :: GuarddutyMemberResource)

instance HasEmail GuarddutyMemberResource Text where
    email =
        lens (_email :: GuarddutyMemberResource -> TF.Argument "email" Text)
             (\s a -> s { _email = a } :: GuarddutyMemberResource)

instance HasComputedId GuarddutyMemberResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

guarddutyMemberResource :: TF.Resource TF.AWS GuarddutyMemberResource
guarddutyMemberResource =
    TF.newResource "aws_guardduty_member" $
        GuarddutyMemberResource {
            _account_id = TF.Nil
            , _detector_id = TF.Nil
            , _email = TF.Nil
            }

{- | The @aws_iam_access_key@ AWS resource.

Provides an IAM access key. This is a set of credentials that allow API
requests to be made as an IAM user.
-}
data IamAccessKeyResource = IamAccessKeyResource {
      _pgp_key :: !(TF.Argument "pgp_key" Text)
    {- ^ (Optional) Either a base-64 encoded PGP public key, or a keybase username in the form @keybase:some_person_that_exists@ . -}
    , _user :: !(TF.Argument "user" Text)
    {- ^ (Required) The IAM user to associate with this access key. -}
    } deriving (Show, Eq)

instance TF.ToHCL IamAccessKeyResource where
    toHCL IamAccessKeyResource{..} = TF.block $ catMaybes
        [ TF.argument _pgp_key
        , TF.argument _user
        ]

instance HasPgpKey IamAccessKeyResource Text where
    pgpKey =
        lens (_pgp_key :: IamAccessKeyResource -> TF.Argument "pgp_key" Text)
             (\s a -> s { _pgp_key = a } :: IamAccessKeyResource)

instance HasUser IamAccessKeyResource Text where
    user =
        lens (_user :: IamAccessKeyResource -> TF.Argument "user" Text)
             (\s a -> s { _user = a } :: IamAccessKeyResource)

instance HasComputedEncryptedSecret IamAccessKeyResource Text where
    computedEncryptedSecret =
        to (\_  -> TF.Compute "encrypted_secret")

instance HasComputedId IamAccessKeyResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedKeyFingerprint IamAccessKeyResource Text where
    computedKeyFingerprint =
        to (\_  -> TF.Compute "key_fingerprint")

instance HasComputedSecret IamAccessKeyResource Text where
    computedSecret =
        to (\_  -> TF.Compute "secret")

instance HasComputedSesSmtpPassword IamAccessKeyResource Text where
    computedSesSmtpPassword =
        to (\_  -> TF.Compute "ses_smtp_password")

instance HasComputedStatus IamAccessKeyResource Text where
    computedStatus =
        to (\_  -> TF.Compute "status")

instance HasComputedUser IamAccessKeyResource Text where
    computedUser =
        to (\_  -> TF.Compute "user")

iamAccessKeyResource :: TF.Resource TF.AWS IamAccessKeyResource
iamAccessKeyResource =
    TF.newResource "aws_iam_access_key" $
        IamAccessKeyResource {
            _pgp_key = TF.Nil
            , _user = TF.Nil
            }

{- | The @aws_iam_account_alias@ AWS resource.

-> Note: There is only a single account alias per AWS account. Manages the
account alias for the AWS Account.
-}
data IamAccountAliasResource = IamAccountAliasResource {
      _account_alias :: !(TF.Argument "account_alias" Text)
    {- ^ (Required) The account alias -}
    } deriving (Show, Eq)

instance TF.ToHCL IamAccountAliasResource where
    toHCL IamAccountAliasResource{..} = TF.block $ catMaybes
        [ TF.argument _account_alias
        ]

instance HasAccountAlias IamAccountAliasResource Text where
    accountAlias =
        lens (_account_alias :: IamAccountAliasResource -> TF.Argument "account_alias" Text)
             (\s a -> s { _account_alias = a } :: IamAccountAliasResource)

iamAccountAliasResource :: TF.Resource TF.AWS IamAccountAliasResource
iamAccountAliasResource =
    TF.newResource "aws_iam_account_alias" $
        IamAccountAliasResource {
            _account_alias = TF.Nil
            }

{- | The @aws_iam_account_password_policy@ AWS resource.

-> Note: There is only a single policy allowed per AWS account. An existing
policy will be lost when using this resource as an effect of this
limitation. Manages Password Policy for the AWS Account. See more about
<http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_passwords_account-policy.html>
in the official AWS docs.
-}
data IamAccountPasswordPolicyResource = IamAccountPasswordPolicyResource {
      _allow_users_to_change_password :: !(TF.Argument "allow_users_to_change_password" Text)
    {- ^ (Optional) Whether to allow users to change their own password -}
    , _hard_expiry :: !(TF.Argument "hard_expiry" Text)
    {- ^ (Optional) Whether users are prevented from setting a new password after their password has expired (i.e. require administrator reset) -}
    , _max_password_age :: !(TF.Argument "max_password_age" Text)
    {- ^ (Optional) The number of days that an user password is valid. -}
    , _minimum_password_length :: !(TF.Argument "minimum_password_length" Text)
    {- ^ (Optional) Minimum length to require for user passwords. -}
    , _password_reuse_prevention :: !(TF.Argument "password_reuse_prevention" Text)
    {- ^ (Optional) The number of previous passwords that users are prevented from reusing. -}
    , _require_lowercase_characters :: !(TF.Argument "require_lowercase_characters" Text)
    {- ^ (Optional) Whether to require lowercase characters for user passwords. -}
    , _require_numbers :: !(TF.Argument "require_numbers" Text)
    {- ^ (Optional) Whether to require numbers for user passwords. -}
    , _require_symbols :: !(TF.Argument "require_symbols" Text)
    {- ^ (Optional) Whether to require symbols for user passwords. -}
    , _require_uppercase_characters :: !(TF.Argument "require_uppercase_characters" Text)
    {- ^ (Optional) Whether to require uppercase characters for user passwords. -}
    } deriving (Show, Eq)

instance TF.ToHCL IamAccountPasswordPolicyResource where
    toHCL IamAccountPasswordPolicyResource{..} = TF.block $ catMaybes
        [ TF.argument _allow_users_to_change_password
        , TF.argument _hard_expiry
        , TF.argument _max_password_age
        , TF.argument _minimum_password_length
        , TF.argument _password_reuse_prevention
        , TF.argument _require_lowercase_characters
        , TF.argument _require_numbers
        , TF.argument _require_symbols
        , TF.argument _require_uppercase_characters
        ]

instance HasAllowUsersToChangePassword IamAccountPasswordPolicyResource Text where
    allowUsersToChangePassword =
        lens (_allow_users_to_change_password :: IamAccountPasswordPolicyResource -> TF.Argument "allow_users_to_change_password" Text)
             (\s a -> s { _allow_users_to_change_password = a } :: IamAccountPasswordPolicyResource)

instance HasHardExpiry IamAccountPasswordPolicyResource Text where
    hardExpiry =
        lens (_hard_expiry :: IamAccountPasswordPolicyResource -> TF.Argument "hard_expiry" Text)
             (\s a -> s { _hard_expiry = a } :: IamAccountPasswordPolicyResource)

instance HasMaxPasswordAge IamAccountPasswordPolicyResource Text where
    maxPasswordAge =
        lens (_max_password_age :: IamAccountPasswordPolicyResource -> TF.Argument "max_password_age" Text)
             (\s a -> s { _max_password_age = a } :: IamAccountPasswordPolicyResource)

instance HasMinimumPasswordLength IamAccountPasswordPolicyResource Text where
    minimumPasswordLength =
        lens (_minimum_password_length :: IamAccountPasswordPolicyResource -> TF.Argument "minimum_password_length" Text)
             (\s a -> s { _minimum_password_length = a } :: IamAccountPasswordPolicyResource)

instance HasPasswordReusePrevention IamAccountPasswordPolicyResource Text where
    passwordReusePrevention =
        lens (_password_reuse_prevention :: IamAccountPasswordPolicyResource -> TF.Argument "password_reuse_prevention" Text)
             (\s a -> s { _password_reuse_prevention = a } :: IamAccountPasswordPolicyResource)

instance HasRequireLowercaseCharacters IamAccountPasswordPolicyResource Text where
    requireLowercaseCharacters =
        lens (_require_lowercase_characters :: IamAccountPasswordPolicyResource -> TF.Argument "require_lowercase_characters" Text)
             (\s a -> s { _require_lowercase_characters = a } :: IamAccountPasswordPolicyResource)

instance HasRequireNumbers IamAccountPasswordPolicyResource Text where
    requireNumbers =
        lens (_require_numbers :: IamAccountPasswordPolicyResource -> TF.Argument "require_numbers" Text)
             (\s a -> s { _require_numbers = a } :: IamAccountPasswordPolicyResource)

instance HasRequireSymbols IamAccountPasswordPolicyResource Text where
    requireSymbols =
        lens (_require_symbols :: IamAccountPasswordPolicyResource -> TF.Argument "require_symbols" Text)
             (\s a -> s { _require_symbols = a } :: IamAccountPasswordPolicyResource)

instance HasRequireUppercaseCharacters IamAccountPasswordPolicyResource Text where
    requireUppercaseCharacters =
        lens (_require_uppercase_characters :: IamAccountPasswordPolicyResource -> TF.Argument "require_uppercase_characters" Text)
             (\s a -> s { _require_uppercase_characters = a } :: IamAccountPasswordPolicyResource)

instance HasComputedExpirePasswords IamAccountPasswordPolicyResource Text where
    computedExpirePasswords =
        to (\_  -> TF.Compute "expire_passwords")

iamAccountPasswordPolicyResource :: TF.Resource TF.AWS IamAccountPasswordPolicyResource
iamAccountPasswordPolicyResource =
    TF.newResource "aws_iam_account_password_policy" $
        IamAccountPasswordPolicyResource {
            _allow_users_to_change_password = TF.Nil
            , _hard_expiry = TF.Nil
            , _max_password_age = TF.Nil
            , _minimum_password_length = TF.Nil
            , _password_reuse_prevention = TF.Nil
            , _require_lowercase_characters = TF.Nil
            , _require_numbers = TF.Nil
            , _require_symbols = TF.Nil
            , _require_uppercase_characters = TF.Nil
            }

{- | The @aws_iam_group_membership@ AWS resource.

Provides a top level resource to manage IAM Group membership for IAM Users.
For more information on managing IAM Groups or IAM Users, see
</docs/providers/aws/r/iam_group.html> or
</docs/providers/aws/r/iam_user.html>
-}
data IamGroupMembershipResource = IamGroupMembershipResource {
      _group :: !(TF.Argument "group" Text)
    {- ^  (Required) The IAM Group name to attach the list of @users@ to -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name to identify the Group Membership -}
    , _users :: !(TF.Argument "users" Text)
    {- ^ (Required) A list of IAM User names to associate with the Group -}
    } deriving (Show, Eq)

instance TF.ToHCL IamGroupMembershipResource where
    toHCL IamGroupMembershipResource{..} = TF.block $ catMaybes
        [ TF.argument _group
        , TF.argument _name
        , TF.argument _users
        ]

instance HasGroup IamGroupMembershipResource Text where
    group =
        lens (_group :: IamGroupMembershipResource -> TF.Argument "group" Text)
             (\s a -> s { _group = a } :: IamGroupMembershipResource)

instance HasName IamGroupMembershipResource Text where
    name =
        lens (_name :: IamGroupMembershipResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: IamGroupMembershipResource)

instance HasUsers IamGroupMembershipResource Text where
    users =
        lens (_users :: IamGroupMembershipResource -> TF.Argument "users" Text)
             (\s a -> s { _users = a } :: IamGroupMembershipResource)

instance HasComputedGroup IamGroupMembershipResource Text where
    computedGroup =
        to (\_  -> TF.Compute "group")

instance HasComputedName IamGroupMembershipResource Text where
    computedName =
        to (\_  -> TF.Compute "name")

instance HasComputedUsers IamGroupMembershipResource Text where
    computedUsers =
        to (\_  -> TF.Compute "users")

iamGroupMembershipResource :: TF.Resource TF.AWS IamGroupMembershipResource
iamGroupMembershipResource =
    TF.newResource "aws_iam_group_membership" $
        IamGroupMembershipResource {
            _group = TF.Nil
            , _name = TF.Nil
            , _users = TF.Nil
            }

{- | The @aws_iam_group_policy_attachment@ AWS resource.

Attaches a Managed IAM Policy to an IAM group
-}
data IamGroupPolicyAttachmentResource = IamGroupPolicyAttachmentResource {
      _group :: !(TF.Argument "group" Text)
    {- ^ (Required) - The group the policy should be applied to -}
    , _policy_arn :: !(TF.Argument "policy_arn" Text)
    {- ^ (Required) - The ARN of the policy you want to apply -}
    } deriving (Show, Eq)

instance TF.ToHCL IamGroupPolicyAttachmentResource where
    toHCL IamGroupPolicyAttachmentResource{..} = TF.block $ catMaybes
        [ TF.argument _group
        , TF.argument _policy_arn
        ]

instance HasGroup IamGroupPolicyAttachmentResource Text where
    group =
        lens (_group :: IamGroupPolicyAttachmentResource -> TF.Argument "group" Text)
             (\s a -> s { _group = a } :: IamGroupPolicyAttachmentResource)

instance HasPolicyArn IamGroupPolicyAttachmentResource Text where
    policyArn =
        lens (_policy_arn :: IamGroupPolicyAttachmentResource -> TF.Argument "policy_arn" Text)
             (\s a -> s { _policy_arn = a } :: IamGroupPolicyAttachmentResource)

iamGroupPolicyAttachmentResource :: TF.Resource TF.AWS IamGroupPolicyAttachmentResource
iamGroupPolicyAttachmentResource =
    TF.newResource "aws_iam_group_policy_attachment" $
        IamGroupPolicyAttachmentResource {
            _group = TF.Nil
            , _policy_arn = TF.Nil
            }

{- | The @aws_iam_group_policy@ AWS resource.

Provides an IAM policy attached to a group.
-}
data IamGroupPolicyResource = IamGroupPolicyResource {
      _group :: !(TF.Argument "group" Text)
    {- ^ (Required) The IAM group to attach to the policy. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Optional) The name of the policy. If omitted, Terraform will assign a random, unique name. -}
    , _name_prefix :: !(TF.Argument "name_prefix" Text)
    {- ^ (Optional) Creates a unique name beginning with the specified prefix. Conflicts with @name@ . -}
    , _policy :: !(TF.Argument "policy" Text)
    {- ^ (Required) The policy document. This is a JSON formatted string. The heredoc syntax or @file@ function is helpful here. -}
    } deriving (Show, Eq)

instance TF.ToHCL IamGroupPolicyResource where
    toHCL IamGroupPolicyResource{..} = TF.block $ catMaybes
        [ TF.argument _group
        , TF.argument _name
        , TF.argument _name_prefix
        , TF.argument _policy
        ]

instance HasGroup IamGroupPolicyResource Text where
    group =
        lens (_group :: IamGroupPolicyResource -> TF.Argument "group" Text)
             (\s a -> s { _group = a } :: IamGroupPolicyResource)

instance HasName IamGroupPolicyResource Text where
    name =
        lens (_name :: IamGroupPolicyResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: IamGroupPolicyResource)

instance HasNamePrefix IamGroupPolicyResource Text where
    namePrefix =
        lens (_name_prefix :: IamGroupPolicyResource -> TF.Argument "name_prefix" Text)
             (\s a -> s { _name_prefix = a } :: IamGroupPolicyResource)

instance HasPolicy IamGroupPolicyResource Text where
    policy =
        lens (_policy :: IamGroupPolicyResource -> TF.Argument "policy" Text)
             (\s a -> s { _policy = a } :: IamGroupPolicyResource)

instance HasComputedGroup IamGroupPolicyResource Text where
    computedGroup =
        to (\_  -> TF.Compute "group")

instance HasComputedId IamGroupPolicyResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedName IamGroupPolicyResource Text where
    computedName =
        to (\_  -> TF.Compute "name")

instance HasComputedPolicy IamGroupPolicyResource Text where
    computedPolicy =
        to (\_  -> TF.Compute "policy")

iamGroupPolicyResource :: TF.Resource TF.AWS IamGroupPolicyResource
iamGroupPolicyResource =
    TF.newResource "aws_iam_group_policy" $
        IamGroupPolicyResource {
            _group = TF.Nil
            , _name = TF.Nil
            , _name_prefix = TF.Nil
            , _policy = TF.Nil
            }

{- | The @aws_iam_group@ AWS resource.

Provides an IAM group.
-}
data IamGroupResource = IamGroupResource {
      _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The group's name. The name must consist of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: @=,.@-_.@ . Group names are not distinguished by case. For example, you cannot create groups named both "ADMINS" and "admins". -}
    , _path :: !(TF.Argument "path" Text)
    {- ^ (Optional, default "/") Path in which to create the group. -}
    } deriving (Show, Eq)

instance TF.ToHCL IamGroupResource where
    toHCL IamGroupResource{..} = TF.block $ catMaybes
        [ TF.argument _name
        , TF.argument _path
        ]

instance HasName IamGroupResource Text where
    name =
        lens (_name :: IamGroupResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: IamGroupResource)

instance HasPath IamGroupResource Text where
    path =
        lens (_path :: IamGroupResource -> TF.Argument "path" Text)
             (\s a -> s { _path = a } :: IamGroupResource)

instance HasComputedArn IamGroupResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

instance HasComputedId IamGroupResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedName IamGroupResource Text where
    computedName =
        to (\_  -> TF.Compute "name")

instance HasComputedPath IamGroupResource Text where
    computedPath =
        to (\_  -> TF.Compute "path")

instance HasComputedUniqueId IamGroupResource Text where
    computedUniqueId =
        to (\_  -> TF.Compute "unique_id")

iamGroupResource :: TF.Resource TF.AWS IamGroupResource
iamGroupResource =
    TF.newResource "aws_iam_group" $
        IamGroupResource {
            _name = TF.Nil
            , _path = TF.Nil
            }

{- | The @aws_iam_instance_profile@ AWS resource.

Provides an IAM instance profile. ~> NOTE: Either @role@ or @roles@ (
deprecated ) must be specified.
-}
data IamInstanceProfileResource = IamInstanceProfileResource {
      _name :: !(TF.Argument "name" Text)
    {- ^ (Optional, Forces new resource) The profile's name. If omitted, Terraform will assign a random, unique name. -}
    , _name_prefix :: !(TF.Argument "name_prefix" Text)
    {- ^ (Optional, Forces new resource) Creates a unique name beginning with the specified prefix. Conflicts with @name@ . -}
    , _path :: !(TF.Argument "path" Text)
    {- ^ (Optional, default "/") Path in which to create the profile. -}
    , _role :: !(TF.Argument "role" Text)
    {- ^ (Optional) The role name to include in the profile. -}
    , _roles :: !(TF.Argument "roles" Text)
    {- ^ - ( Deprecated ) A list of role names to include in the profile.  The current default is 1.  If you see an error message similar to @Cannot exceed quota for InstanceSessionsPerInstanceProfile: 1@ , then you must contact AWS support and ask for a limit increase. WARNING: This is deprecated since <https://github.com/hashicorp/terraform/blob/master/CHANGELOG.md#093-april-12-2017> , as >= 2 roles are not possible. See <https://github.com/hashicorp/terraform/issues/11575> . -}
    } deriving (Show, Eq)

instance TF.ToHCL IamInstanceProfileResource where
    toHCL IamInstanceProfileResource{..} = TF.block $ catMaybes
        [ TF.argument _name
        , TF.argument _name_prefix
        , TF.argument _path
        , TF.argument _role
        , TF.argument _roles
        ]

instance HasName IamInstanceProfileResource Text where
    name =
        lens (_name :: IamInstanceProfileResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: IamInstanceProfileResource)

instance HasNamePrefix IamInstanceProfileResource Text where
    namePrefix =
        lens (_name_prefix :: IamInstanceProfileResource -> TF.Argument "name_prefix" Text)
             (\s a -> s { _name_prefix = a } :: IamInstanceProfileResource)

instance HasPath IamInstanceProfileResource Text where
    path =
        lens (_path :: IamInstanceProfileResource -> TF.Argument "path" Text)
             (\s a -> s { _path = a } :: IamInstanceProfileResource)

instance HasRole IamInstanceProfileResource Text where
    role =
        lens (_role :: IamInstanceProfileResource -> TF.Argument "role" Text)
             (\s a -> s { _role = a } :: IamInstanceProfileResource)

instance HasRoles IamInstanceProfileResource Text where
    roles =
        lens (_roles :: IamInstanceProfileResource -> TF.Argument "roles" Text)
             (\s a -> s { _roles = a } :: IamInstanceProfileResource)

instance HasComputedArn IamInstanceProfileResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

instance HasComputedCreateDate IamInstanceProfileResource Text where
    computedCreateDate =
        to (\_  -> TF.Compute "create_date")

instance HasComputedId IamInstanceProfileResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedName IamInstanceProfileResource Text where
    computedName =
        to (\_  -> TF.Compute "name")

instance HasComputedPath IamInstanceProfileResource Text where
    computedPath =
        to (\_  -> TF.Compute "path")

instance HasComputedRole IamInstanceProfileResource Text where
    computedRole =
        to (\_  -> TF.Compute "role")

instance HasComputedRoles IamInstanceProfileResource Text where
    computedRoles =
        to (\_  -> TF.Compute "roles")

instance HasComputedUniqueId IamInstanceProfileResource Text where
    computedUniqueId =
        to (\_  -> TF.Compute "unique_id")

iamInstanceProfileResource :: TF.Resource TF.AWS IamInstanceProfileResource
iamInstanceProfileResource =
    TF.newResource "aws_iam_instance_profile" $
        IamInstanceProfileResource {
            _name = TF.Nil
            , _name_prefix = TF.Nil
            , _path = TF.Nil
            , _role = TF.Nil
            , _roles = TF.Nil
            }

{- | The @aws_iam_openid_connect_provider@ AWS resource.

Provides an IAM OpenID Connect provider.
-}
data IamOpenidConnectProviderResource = IamOpenidConnectProviderResource {
      _client_id_list :: !(TF.Argument "client_id_list" Text)
    {- ^ (Required) A list of client IDs (also known as audiences). When a mobile or web app registers with an OpenID Connect provider, they establish a value that identifies the application. (This is the value that's sent as the client_id parameter on OAuth requests.) -}
    , _thumbprint_list :: !(TF.Argument "thumbprint_list" Text)
    {- ^ (Required) A list of server certificate thumbprints for the OpenID Connect (OIDC) identity provider's server certificate(s). -}
    , _url :: !(TF.Argument "url" Text)
    {- ^ (Required) The URL of the identity provider. Corresponds to the iss claim. -}
    } deriving (Show, Eq)

instance TF.ToHCL IamOpenidConnectProviderResource where
    toHCL IamOpenidConnectProviderResource{..} = TF.block $ catMaybes
        [ TF.argument _client_id_list
        , TF.argument _thumbprint_list
        , TF.argument _url
        ]

instance HasClientIdList IamOpenidConnectProviderResource Text where
    clientIdList =
        lens (_client_id_list :: IamOpenidConnectProviderResource -> TF.Argument "client_id_list" Text)
             (\s a -> s { _client_id_list = a } :: IamOpenidConnectProviderResource)

instance HasThumbprintList IamOpenidConnectProviderResource Text where
    thumbprintList =
        lens (_thumbprint_list :: IamOpenidConnectProviderResource -> TF.Argument "thumbprint_list" Text)
             (\s a -> s { _thumbprint_list = a } :: IamOpenidConnectProviderResource)

instance HasUrl IamOpenidConnectProviderResource Text where
    url =
        lens (_url :: IamOpenidConnectProviderResource -> TF.Argument "url" Text)
             (\s a -> s { _url = a } :: IamOpenidConnectProviderResource)

instance HasComputedArn IamOpenidConnectProviderResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

iamOpenidConnectProviderResource :: TF.Resource TF.AWS IamOpenidConnectProviderResource
iamOpenidConnectProviderResource =
    TF.newResource "aws_iam_openid_connect_provider" $
        IamOpenidConnectProviderResource {
            _client_id_list = TF.Nil
            , _thumbprint_list = TF.Nil
            , _url = TF.Nil
            }

{- | The @aws_iam_policy_attachment@ AWS resource.

Attaches a Managed IAM Policy to user(s), role(s), and/or group(s) !>
WARNING: The aws_iam_policy_attachment resource creates exclusive
attachments of IAM policies. Across the entire AWS account, all of the
users/roles/groups to which a single policy is attached must be declared by
a single aws_iam_policy_attachment resource. This means that even any
users/roles/groups that have the attached policy via some mechanism other
than Terraform will have that attached policy revoked by Terraform. Consider
@aws_iam_role_policy_attachment@ , @iam_user_policy_attachment@ , or
@iam_group_policy_attachment@ instead. These resources do not enforce
exclusive attachment of an IAM policy.
-}
data IamPolicyAttachmentResource = IamPolicyAttachmentResource {
      _groups :: !(TF.Argument "groups" Text)
    {- ^ (Optional) - The group(s) the policy should be applied to -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) - The name of the policy. This cannot be an empty string. -}
    , _policy_arn :: !(TF.Argument "policy_arn" Text)
    {- ^ (Required) - The ARN of the policy you want to apply -}
    , _roles :: !(TF.Argument "roles" Text)
    {- ^ (Optional) - The role(s) the policy should be applied to -}
    , _users :: !(TF.Argument "users" Text)
    {- ^ (Optional) - The user(s) the policy should be applied to -}
    } deriving (Show, Eq)

instance TF.ToHCL IamPolicyAttachmentResource where
    toHCL IamPolicyAttachmentResource{..} = TF.block $ catMaybes
        [ TF.argument _groups
        , TF.argument _name
        , TF.argument _policy_arn
        , TF.argument _roles
        , TF.argument _users
        ]

instance HasGroups IamPolicyAttachmentResource Text where
    groups =
        lens (_groups :: IamPolicyAttachmentResource -> TF.Argument "groups" Text)
             (\s a -> s { _groups = a } :: IamPolicyAttachmentResource)

instance HasName IamPolicyAttachmentResource Text where
    name =
        lens (_name :: IamPolicyAttachmentResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: IamPolicyAttachmentResource)

instance HasPolicyArn IamPolicyAttachmentResource Text where
    policyArn =
        lens (_policy_arn :: IamPolicyAttachmentResource -> TF.Argument "policy_arn" Text)
             (\s a -> s { _policy_arn = a } :: IamPolicyAttachmentResource)

instance HasRoles IamPolicyAttachmentResource Text where
    roles =
        lens (_roles :: IamPolicyAttachmentResource -> TF.Argument "roles" Text)
             (\s a -> s { _roles = a } :: IamPolicyAttachmentResource)

instance HasUsers IamPolicyAttachmentResource Text where
    users =
        lens (_users :: IamPolicyAttachmentResource -> TF.Argument "users" Text)
             (\s a -> s { _users = a } :: IamPolicyAttachmentResource)

instance HasComputedId IamPolicyAttachmentResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedName IamPolicyAttachmentResource Text where
    computedName =
        to (\_  -> TF.Compute "name")

iamPolicyAttachmentResource :: TF.Resource TF.AWS IamPolicyAttachmentResource
iamPolicyAttachmentResource =
    TF.newResource "aws_iam_policy_attachment" $
        IamPolicyAttachmentResource {
            _groups = TF.Nil
            , _name = TF.Nil
            , _policy_arn = TF.Nil
            , _roles = TF.Nil
            , _users = TF.Nil
            }

{- | The @aws_iam_policy@ AWS resource.

Provides an IAM policy.
-}
data IamPolicyResource = IamPolicyResource {
      _description :: !(TF.Argument "description" Text)
    {- ^ (Optional) Description of the IAM policy. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Optional, Forces new resource) The name of the policy. If omitted, Terraform will assign a random, unique name. -}
    , _name_prefix :: !(TF.Argument "name_prefix" Text)
    {- ^ (Optional, Forces new resource) Creates a unique name beginning with the specified prefix. Conflicts with @name@ . -}
    , _path :: !(TF.Argument "path" Text)
    {- ^ (Optional, default "/") Path in which to create the policy. See <https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html> for more information. -}
    , _policy :: !(TF.Argument "policy" Text)
    {- ^ (Required) The policy document. This is a JSON formatted string. The heredoc syntax, @file@ function, or the </docs/providers/aws/d/iam_policy_document.html> are all helpful here. -}
    } deriving (Show, Eq)

instance TF.ToHCL IamPolicyResource where
    toHCL IamPolicyResource{..} = TF.block $ catMaybes
        [ TF.argument _description
        , TF.argument _name
        , TF.argument _name_prefix
        , TF.argument _path
        , TF.argument _policy
        ]

instance HasDescription IamPolicyResource Text where
    description =
        lens (_description :: IamPolicyResource -> TF.Argument "description" Text)
             (\s a -> s { _description = a } :: IamPolicyResource)

instance HasName IamPolicyResource Text where
    name =
        lens (_name :: IamPolicyResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: IamPolicyResource)

instance HasNamePrefix IamPolicyResource Text where
    namePrefix =
        lens (_name_prefix :: IamPolicyResource -> TF.Argument "name_prefix" Text)
             (\s a -> s { _name_prefix = a } :: IamPolicyResource)

instance HasPath IamPolicyResource Text where
    path =
        lens (_path :: IamPolicyResource -> TF.Argument "path" Text)
             (\s a -> s { _path = a } :: IamPolicyResource)

instance HasPolicy IamPolicyResource Text where
    policy =
        lens (_policy :: IamPolicyResource -> TF.Argument "policy" Text)
             (\s a -> s { _policy = a } :: IamPolicyResource)

instance HasComputedArn IamPolicyResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

instance HasComputedDescription IamPolicyResource Text where
    computedDescription =
        to (\_  -> TF.Compute "description")

instance HasComputedId IamPolicyResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedName IamPolicyResource Text where
    computedName =
        to (\_  -> TF.Compute "name")

instance HasComputedPath IamPolicyResource Text where
    computedPath =
        to (\_  -> TF.Compute "path")

instance HasComputedPolicy IamPolicyResource Text where
    computedPolicy =
        to (\_  -> TF.Compute "policy")

iamPolicyResource :: TF.Resource TF.AWS IamPolicyResource
iamPolicyResource =
    TF.newResource "aws_iam_policy" $
        IamPolicyResource {
            _description = TF.Nil
            , _name = TF.Nil
            , _name_prefix = TF.Nil
            , _path = TF.Nil
            , _policy = TF.Nil
            }

{- | The @aws_iam_role_policy_attachment@ AWS resource.

Attaches a Managed IAM Policy to an IAM role
-}
data IamRolePolicyAttachmentResource = IamRolePolicyAttachmentResource {
      _policy_arn :: !(TF.Argument "policy_arn" Text)
    {- ^ (Required) - The ARN of the policy you want to apply -}
    , _role :: !(TF.Argument "role" Text)
    {- ^ (Required) - The role the policy should be applied to -}
    } deriving (Show, Eq)

instance TF.ToHCL IamRolePolicyAttachmentResource where
    toHCL IamRolePolicyAttachmentResource{..} = TF.block $ catMaybes
        [ TF.argument _policy_arn
        , TF.argument _role
        ]

instance HasPolicyArn IamRolePolicyAttachmentResource Text where
    policyArn =
        lens (_policy_arn :: IamRolePolicyAttachmentResource -> TF.Argument "policy_arn" Text)
             (\s a -> s { _policy_arn = a } :: IamRolePolicyAttachmentResource)

instance HasRole IamRolePolicyAttachmentResource Text where
    role =
        lens (_role :: IamRolePolicyAttachmentResource -> TF.Argument "role" Text)
             (\s a -> s { _role = a } :: IamRolePolicyAttachmentResource)

iamRolePolicyAttachmentResource :: TF.Resource TF.AWS IamRolePolicyAttachmentResource
iamRolePolicyAttachmentResource =
    TF.newResource "aws_iam_role_policy_attachment" $
        IamRolePolicyAttachmentResource {
            _policy_arn = TF.Nil
            , _role = TF.Nil
            }

{- | The @aws_iam_role_policy@ AWS resource.

Provides an IAM role policy.
-}
data IamRolePolicyResource = IamRolePolicyResource {
      _name :: !(TF.Argument "name" Text)
    {- ^ (Optional) The name of the role policy. If omitted, Terraform will assign a random, unique name. -}
    , _name_prefix :: !(TF.Argument "name_prefix" Text)
    {- ^ (Optional) Creates a unique name beginning with the specified prefix. Conflicts with @name@ . -}
    , _policy :: !(TF.Argument "policy" Text)
    {- ^ (Required) The policy document. This is a JSON formatted string. The heredoc syntax or @file@ function is helpful here. -}
    , _role :: !(TF.Argument "role" Text)
    {- ^ (Required) The IAM role to attach to the policy. -}
    } deriving (Show, Eq)

instance TF.ToHCL IamRolePolicyResource where
    toHCL IamRolePolicyResource{..} = TF.block $ catMaybes
        [ TF.argument _name
        , TF.argument _name_prefix
        , TF.argument _policy
        , TF.argument _role
        ]

instance HasName IamRolePolicyResource Text where
    name =
        lens (_name :: IamRolePolicyResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: IamRolePolicyResource)

instance HasNamePrefix IamRolePolicyResource Text where
    namePrefix =
        lens (_name_prefix :: IamRolePolicyResource -> TF.Argument "name_prefix" Text)
             (\s a -> s { _name_prefix = a } :: IamRolePolicyResource)

instance HasPolicy IamRolePolicyResource Text where
    policy =
        lens (_policy :: IamRolePolicyResource -> TF.Argument "policy" Text)
             (\s a -> s { _policy = a } :: IamRolePolicyResource)

instance HasRole IamRolePolicyResource Text where
    role =
        lens (_role :: IamRolePolicyResource -> TF.Argument "role" Text)
             (\s a -> s { _role = a } :: IamRolePolicyResource)

instance HasComputedId IamRolePolicyResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedName IamRolePolicyResource Text where
    computedName =
        to (\_  -> TF.Compute "name")

instance HasComputedPolicy IamRolePolicyResource Text where
    computedPolicy =
        to (\_  -> TF.Compute "policy")

instance HasComputedRole IamRolePolicyResource Text where
    computedRole =
        to (\_  -> TF.Compute "role")

iamRolePolicyResource :: TF.Resource TF.AWS IamRolePolicyResource
iamRolePolicyResource =
    TF.newResource "aws_iam_role_policy" $
        IamRolePolicyResource {
            _name = TF.Nil
            , _name_prefix = TF.Nil
            , _policy = TF.Nil
            , _role = TF.Nil
            }

{- | The @aws_iam_role@ AWS resource.

Provides an IAM role.
-}
data IamRoleResource = IamRoleResource {
      _assume_role_policy :: !(TF.Argument "assume_role_policy" Text)
    {- ^ (Required) The policy that grants an entity permission to assume the role. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Optional, Forces new resource) The name of the role. If omitted, Terraform will assign a random, unique name. -}
    , _name_prefix :: !(TF.Argument "name_prefix" Text)
    {- ^ (Optional, Forces new resource) Creates a unique name beginning with the specified prefix. Conflicts with @name@ . -}
    } deriving (Show, Eq)

instance TF.ToHCL IamRoleResource where
    toHCL IamRoleResource{..} = TF.block $ catMaybes
        [ TF.argument _assume_role_policy
        , TF.argument _name
        , TF.argument _name_prefix
        ]

instance HasAssumeRolePolicy IamRoleResource Text where
    assumeRolePolicy =
        lens (_assume_role_policy :: IamRoleResource -> TF.Argument "assume_role_policy" Text)
             (\s a -> s { _assume_role_policy = a } :: IamRoleResource)

instance HasName IamRoleResource Text where
    name =
        lens (_name :: IamRoleResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: IamRoleResource)

instance HasNamePrefix IamRoleResource Text where
    namePrefix =
        lens (_name_prefix :: IamRoleResource -> TF.Argument "name_prefix" Text)
             (\s a -> s { _name_prefix = a } :: IamRoleResource)

instance HasComputedArn IamRoleResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

instance HasComputedCreateDate IamRoleResource Text where
    computedCreateDate =
        to (\_  -> TF.Compute "create_date")

instance HasComputedDescription IamRoleResource Text where
    computedDescription =
        to (\_  -> TF.Compute "description")

instance HasComputedName IamRoleResource Text where
    computedName =
        to (\_  -> TF.Compute "name")

instance HasComputedUniqueId IamRoleResource Text where
    computedUniqueId =
        to (\_  -> TF.Compute "unique_id")

iamRoleResource :: TF.Resource TF.AWS IamRoleResource
iamRoleResource =
    TF.newResource "aws_iam_role" $
        IamRoleResource {
            _assume_role_policy = TF.Nil
            , _name = TF.Nil
            , _name_prefix = TF.Nil
            }

{- | The @aws_iam_saml_provider@ AWS resource.

Provides an IAM SAML provider.
-}
data IamSamlProviderResource = IamSamlProviderResource {
      _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the provider to create. -}
    , _saml_metadata_document :: !(TF.Argument "saml_metadata_document" Text)
    {- ^ (Required) An XML document generated by an identity provider that supports SAML 2.0. -}
    } deriving (Show, Eq)

instance TF.ToHCL IamSamlProviderResource where
    toHCL IamSamlProviderResource{..} = TF.block $ catMaybes
        [ TF.argument _name
        , TF.argument _saml_metadata_document
        ]

instance HasName IamSamlProviderResource Text where
    name =
        lens (_name :: IamSamlProviderResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: IamSamlProviderResource)

instance HasSamlMetadataDocument IamSamlProviderResource Text where
    samlMetadataDocument =
        lens (_saml_metadata_document :: IamSamlProviderResource -> TF.Argument "saml_metadata_document" Text)
             (\s a -> s { _saml_metadata_document = a } :: IamSamlProviderResource)

instance HasComputedArn IamSamlProviderResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

instance HasComputedValidUntil IamSamlProviderResource Text where
    computedValidUntil =
        to (\_  -> TF.Compute "valid_until")

iamSamlProviderResource :: TF.Resource TF.AWS IamSamlProviderResource
iamSamlProviderResource =
    TF.newResource "aws_iam_saml_provider" $
        IamSamlProviderResource {
            _name = TF.Nil
            , _saml_metadata_document = TF.Nil
            }

{- | The @aws_iam_server_certificate@ AWS resource.

Provides an IAM Server Certificate resource to upload Server Certificates.
Certs uploaded to IAM can easily work with other AWS services such as:
-}
data IamServerCertificateResource = IamServerCertificateResource {
      _certificate_body :: !(TF.Argument "certificate_body" Text)
    {- ^ (Required) The contents of the public key certificate in PEM-encoded format. -}
    , _certificate_chain :: !(TF.Argument "certificate_chain" Text)
    {- ^ (Optional) The contents of the certificate chain. This is typically a concatenation of the PEM-encoded public key certificates of the chain. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Optional) The name of the Server Certificate. Do not include the path in this value. If omitted, Terraform will assign a random, unique name. -}
    , _name_prefix :: !(TF.Argument "name_prefix" Text)
    {- ^ (Optional) Creates a unique name beginning with the specified prefix. Conflicts with @name@ . -}
    , _path :: !(TF.Argument "path" Text)
    {- ^ (Optional) The IAM path for the server certificate.  If it is not included, it defaults to a slash (/). If this certificate is for use with AWS CloudFront, the path must be in format @/cloudfront/your_path_here@ . See <https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html> for more details on IAM Paths. -}
    , _private_key :: !(TF.Argument "private_key" Text)
    {- ^ (Required) The contents of the private key in PEM-encoded format. -}
    } deriving (Show, Eq)

instance TF.ToHCL IamServerCertificateResource where
    toHCL IamServerCertificateResource{..} = TF.block $ catMaybes
        [ TF.argument _certificate_body
        , TF.argument _certificate_chain
        , TF.argument _name
        , TF.argument _name_prefix
        , TF.argument _path
        , TF.argument _private_key
        ]

instance HasCertificateBody IamServerCertificateResource Text where
    certificateBody =
        lens (_certificate_body :: IamServerCertificateResource -> TF.Argument "certificate_body" Text)
             (\s a -> s { _certificate_body = a } :: IamServerCertificateResource)

instance HasCertificateChain IamServerCertificateResource Text where
    certificateChain =
        lens (_certificate_chain :: IamServerCertificateResource -> TF.Argument "certificate_chain" Text)
             (\s a -> s { _certificate_chain = a } :: IamServerCertificateResource)

instance HasName IamServerCertificateResource Text where
    name =
        lens (_name :: IamServerCertificateResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: IamServerCertificateResource)

instance HasNamePrefix IamServerCertificateResource Text where
    namePrefix =
        lens (_name_prefix :: IamServerCertificateResource -> TF.Argument "name_prefix" Text)
             (\s a -> s { _name_prefix = a } :: IamServerCertificateResource)

instance HasPath IamServerCertificateResource Text where
    path =
        lens (_path :: IamServerCertificateResource -> TF.Argument "path" Text)
             (\s a -> s { _path = a } :: IamServerCertificateResource)

instance HasPrivateKey IamServerCertificateResource Text where
    privateKey =
        lens (_private_key :: IamServerCertificateResource -> TF.Argument "private_key" Text)
             (\s a -> s { _private_key = a } :: IamServerCertificateResource)

instance HasComputedArn IamServerCertificateResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

instance HasComputedId IamServerCertificateResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedName IamServerCertificateResource Text where
    computedName =
        to (\_  -> TF.Compute "name")

iamServerCertificateResource :: TF.Resource TF.AWS IamServerCertificateResource
iamServerCertificateResource =
    TF.newResource "aws_iam_server_certificate" $
        IamServerCertificateResource {
            _certificate_body = TF.Nil
            , _certificate_chain = TF.Nil
            , _name = TF.Nil
            , _name_prefix = TF.Nil
            , _path = TF.Nil
            , _private_key = TF.Nil
            }

{- | The @aws_iam_user_login_profile@ AWS resource.

Provides one-time creation of a IAM user login profile, and uses PGP to
encrypt the password for safe transport to the user. PGP keys can be
obtained from Keybase.
-}
data IamUserLoginProfileResource = IamUserLoginProfileResource {
      _password_length :: !(TF.Argument "password_length" Text)
    {- ^ (Optional, default 20) The length of the generated password. -}
    , _password_reset_required :: !(TF.Argument "password_reset_required" Text)
    {- ^ (Optional, default "true") Whether the user should be forced to reset the generated password on first login. -}
    , _pgp_key :: !(TF.Argument "pgp_key" Text)
    {- ^ (Required) Either a base-64 encoded PGP public key, or a keybase username in the form @keybase:username@ . -}
    , _user :: !(TF.Argument "user" Text)
    {- ^ (Required) The IAM user's name. -}
    } deriving (Show, Eq)

instance TF.ToHCL IamUserLoginProfileResource where
    toHCL IamUserLoginProfileResource{..} = TF.block $ catMaybes
        [ TF.argument _password_length
        , TF.argument _password_reset_required
        , TF.argument _pgp_key
        , TF.argument _user
        ]

instance HasPasswordLength IamUserLoginProfileResource Text where
    passwordLength =
        lens (_password_length :: IamUserLoginProfileResource -> TF.Argument "password_length" Text)
             (\s a -> s { _password_length = a } :: IamUserLoginProfileResource)

instance HasPasswordResetRequired IamUserLoginProfileResource Text where
    passwordResetRequired =
        lens (_password_reset_required :: IamUserLoginProfileResource -> TF.Argument "password_reset_required" Text)
             (\s a -> s { _password_reset_required = a } :: IamUserLoginProfileResource)

instance HasPgpKey IamUserLoginProfileResource Text where
    pgpKey =
        lens (_pgp_key :: IamUserLoginProfileResource -> TF.Argument "pgp_key" Text)
             (\s a -> s { _pgp_key = a } :: IamUserLoginProfileResource)

instance HasUser IamUserLoginProfileResource Text where
    user =
        lens (_user :: IamUserLoginProfileResource -> TF.Argument "user" Text)
             (\s a -> s { _user = a } :: IamUserLoginProfileResource)

instance HasComputedEncryptedPassword IamUserLoginProfileResource Text where
    computedEncryptedPassword =
        to (\_  -> TF.Compute "encrypted_password")

instance HasComputedKeyFingerprint IamUserLoginProfileResource Text where
    computedKeyFingerprint =
        to (\_  -> TF.Compute "key_fingerprint")

iamUserLoginProfileResource :: TF.Resource TF.AWS IamUserLoginProfileResource
iamUserLoginProfileResource =
    TF.newResource "aws_iam_user_login_profile" $
        IamUserLoginProfileResource {
            _password_length = TF.Nil
            , _password_reset_required = TF.Nil
            , _pgp_key = TF.Nil
            , _user = TF.Nil
            }

{- | The @aws_iam_user_policy_attachment@ AWS resource.

Attaches a Managed IAM Policy to an IAM user
-}
data IamUserPolicyAttachmentResource = IamUserPolicyAttachmentResource {
      _policy_arn :: !(TF.Argument "policy_arn" Text)
    {- ^ (Required) - The ARN of the policy you want to apply -}
    , _user :: !(TF.Argument "user" Text)
    {- ^ (Required) - The user the policy should be applied to -}
    } deriving (Show, Eq)

instance TF.ToHCL IamUserPolicyAttachmentResource where
    toHCL IamUserPolicyAttachmentResource{..} = TF.block $ catMaybes
        [ TF.argument _policy_arn
        , TF.argument _user
        ]

instance HasPolicyArn IamUserPolicyAttachmentResource Text where
    policyArn =
        lens (_policy_arn :: IamUserPolicyAttachmentResource -> TF.Argument "policy_arn" Text)
             (\s a -> s { _policy_arn = a } :: IamUserPolicyAttachmentResource)

instance HasUser IamUserPolicyAttachmentResource Text where
    user =
        lens (_user :: IamUserPolicyAttachmentResource -> TF.Argument "user" Text)
             (\s a -> s { _user = a } :: IamUserPolicyAttachmentResource)

iamUserPolicyAttachmentResource :: TF.Resource TF.AWS IamUserPolicyAttachmentResource
iamUserPolicyAttachmentResource =
    TF.newResource "aws_iam_user_policy_attachment" $
        IamUserPolicyAttachmentResource {
            _policy_arn = TF.Nil
            , _user = TF.Nil
            }

{- | The @aws_iam_user_policy@ AWS resource.

Provides an IAM policy attached to a user.
-}
data IamUserPolicyResource = IamUserPolicyResource {
      _name :: !(TF.Argument "name" Text)
    {- ^ (Optional) The name of the policy. If omitted, Terraform will assign a random, unique name. -}
    , _name_prefix :: !(TF.Argument "name_prefix" Text)
    {- ^ (Optional, Forces new resource) Creates a unique name beginning with the specified prefix. Conflicts with @name@ . -}
    , _policy :: !(TF.Argument "policy" Text)
    {- ^ (Required) The policy document. This is a JSON formatted string. The heredoc syntax or @file@ function is helpful here. -}
    , _user :: !(TF.Argument "user" Text)
    {- ^ (Required) IAM user to which to attach this policy. -}
    } deriving (Show, Eq)

instance TF.ToHCL IamUserPolicyResource where
    toHCL IamUserPolicyResource{..} = TF.block $ catMaybes
        [ TF.argument _name
        , TF.argument _name_prefix
        , TF.argument _policy
        , TF.argument _user
        ]

instance HasName IamUserPolicyResource Text where
    name =
        lens (_name :: IamUserPolicyResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: IamUserPolicyResource)

instance HasNamePrefix IamUserPolicyResource Text where
    namePrefix =
        lens (_name_prefix :: IamUserPolicyResource -> TF.Argument "name_prefix" Text)
             (\s a -> s { _name_prefix = a } :: IamUserPolicyResource)

instance HasPolicy IamUserPolicyResource Text where
    policy =
        lens (_policy :: IamUserPolicyResource -> TF.Argument "policy" Text)
             (\s a -> s { _policy = a } :: IamUserPolicyResource)

instance HasUser IamUserPolicyResource Text where
    user =
        lens (_user :: IamUserPolicyResource -> TF.Argument "user" Text)
             (\s a -> s { _user = a } :: IamUserPolicyResource)

iamUserPolicyResource :: TF.Resource TF.AWS IamUserPolicyResource
iamUserPolicyResource =
    TF.newResource "aws_iam_user_policy" $
        IamUserPolicyResource {
            _name = TF.Nil
            , _name_prefix = TF.Nil
            , _policy = TF.Nil
            , _user = TF.Nil
            }

{- | The @aws_iam_user@ AWS resource.

Provides an IAM user.
-}
data IamUserResource = IamUserResource {
      _force_destroy :: !(TF.Argument "force_destroy" Text)
    {- ^ (Optional, default false) When destroying this user, destroy even if it has non-Terraform-managed IAM access keys, login profile or MFA devices. Without @force_destroy@ a user with non-Terraform-managed access keys and login profile will fail to be destroyed. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The user's name. The name must consist of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: @=,.@-_.@ . User names are not distinguished by case. For example, you cannot create users named both "TESTUSER" and "testuser". -}
    , _path :: !(TF.Argument "path" Text)
    {- ^ (Optional, default "/") Path in which to create the user. -}
    } deriving (Show, Eq)

instance TF.ToHCL IamUserResource where
    toHCL IamUserResource{..} = TF.block $ catMaybes
        [ TF.argument _force_destroy
        , TF.argument _name
        , TF.argument _path
        ]

instance HasForceDestroy IamUserResource Text where
    forceDestroy =
        lens (_force_destroy :: IamUserResource -> TF.Argument "force_destroy" Text)
             (\s a -> s { _force_destroy = a } :: IamUserResource)

instance HasName IamUserResource Text where
    name =
        lens (_name :: IamUserResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: IamUserResource)

instance HasPath IamUserResource Text where
    path =
        lens (_path :: IamUserResource -> TF.Argument "path" Text)
             (\s a -> s { _path = a } :: IamUserResource)

instance HasComputedArn IamUserResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

instance HasComputedName IamUserResource Text where
    computedName =
        to (\_  -> TF.Compute "name")

instance HasComputedUniqueId IamUserResource Text where
    computedUniqueId =
        to (\_  -> TF.Compute "unique_id")

iamUserResource :: TF.Resource TF.AWS IamUserResource
iamUserResource =
    TF.newResource "aws_iam_user" $
        IamUserResource {
            _force_destroy = TF.Nil
            , _name = TF.Nil
            , _path = TF.Nil
            }

{- | The @aws_iam_user_ssh_key@ AWS resource.

Uploads an SSH public key and associates it with the specified IAM user.
-}
data IamUserSshKeyResource = IamUserSshKeyResource {
      _encoding :: !(TF.Argument "encoding" Text)
    {- ^ (Required) Specifies the public key encoding format to use in the response. To retrieve the public key in ssh-rsa format, use @SSH@ . To retrieve the public key in PEM format, use @PEM@ . -}
    , _public_key :: !(TF.Argument "public_key" Text)
    {- ^ (Required) The SSH public key. The public key must be encoded in ssh-rsa format or PEM format. -}
    , _status :: !(TF.Argument "status" Text)
    {- ^ (Optional) The status to assign to the SSH public key. Active means the key can be used for authentication with an AWS CodeCommit repository. Inactive means the key cannot be used. Default is @active@ . -}
    , _username :: !(TF.Argument "username" Text)
    {- ^ (Required) The name of the IAM user to associate the SSH public key with. -}
    } deriving (Show, Eq)

instance TF.ToHCL IamUserSshKeyResource where
    toHCL IamUserSshKeyResource{..} = TF.block $ catMaybes
        [ TF.argument _encoding
        , TF.argument _public_key
        , TF.argument _status
        , TF.argument _username
        ]

instance HasEncoding IamUserSshKeyResource Text where
    encoding =
        lens (_encoding :: IamUserSshKeyResource -> TF.Argument "encoding" Text)
             (\s a -> s { _encoding = a } :: IamUserSshKeyResource)

instance HasPublicKey IamUserSshKeyResource Text where
    publicKey =
        lens (_public_key :: IamUserSshKeyResource -> TF.Argument "public_key" Text)
             (\s a -> s { _public_key = a } :: IamUserSshKeyResource)

instance HasStatus IamUserSshKeyResource Text where
    status =
        lens (_status :: IamUserSshKeyResource -> TF.Argument "status" Text)
             (\s a -> s { _status = a } :: IamUserSshKeyResource)

instance HasUsername IamUserSshKeyResource Text where
    username =
        lens (_username :: IamUserSshKeyResource -> TF.Argument "username" Text)
             (\s a -> s { _username = a } :: IamUserSshKeyResource)

instance HasComputedFingerprint IamUserSshKeyResource Text where
    computedFingerprint =
        to (\_  -> TF.Compute "fingerprint")

instance HasComputedSshPublicKeyId IamUserSshKeyResource Text where
    computedSshPublicKeyId =
        to (\_  -> TF.Compute "ssh_public_key_id")

iamUserSshKeyResource :: TF.Resource TF.AWS IamUserSshKeyResource
iamUserSshKeyResource =
    TF.newResource "aws_iam_user_ssh_key" $
        IamUserSshKeyResource {
            _encoding = TF.Nil
            , _public_key = TF.Nil
            , _status = TF.Nil
            , _username = TF.Nil
            }

{- | The @aws_inspector_assessment_target@ AWS resource.

Provides a Inspector assessment target
-}
data InspectorAssessmentTargetResource = InspectorAssessmentTargetResource {
      _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the assessment target. -}
    , _resource_group_arn :: !(TF.Argument "resource_group_arn" Text)
    {- ^ (Required )- The resource group ARN stating tags for instance matching. -}
    } deriving (Show, Eq)

instance TF.ToHCL InspectorAssessmentTargetResource where
    toHCL InspectorAssessmentTargetResource{..} = TF.block $ catMaybes
        [ TF.argument _name
        , TF.argument _resource_group_arn
        ]

instance HasName InspectorAssessmentTargetResource Text where
    name =
        lens (_name :: InspectorAssessmentTargetResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: InspectorAssessmentTargetResource)

instance HasResourceGroupArn InspectorAssessmentTargetResource Text where
    resourceGroupArn =
        lens (_resource_group_arn :: InspectorAssessmentTargetResource -> TF.Argument "resource_group_arn" Text)
             (\s a -> s { _resource_group_arn = a } :: InspectorAssessmentTargetResource)

instance HasComputedArn InspectorAssessmentTargetResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

inspectorAssessmentTargetResource :: TF.Resource TF.AWS InspectorAssessmentTargetResource
inspectorAssessmentTargetResource =
    TF.newResource "aws_inspector_assessment_target" $
        InspectorAssessmentTargetResource {
            _name = TF.Nil
            , _resource_group_arn = TF.Nil
            }

{- | The @aws_inspector_assessment_template@ AWS resource.

Provides a Inspector assessment template
-}
data InspectorAssessmentTemplateResource = InspectorAssessmentTemplateResource {
      _duration :: !(TF.Argument "duration" Text)
    {- ^ (Required) The duration of the inspector run. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the assessment template. -}
    , _rules_package_arns :: !(TF.Argument "rules_package_arns" Text)
    {- ^ (Required) The rules to be used during the run. -}
    , _target_arn :: !(TF.Argument "target_arn" Text)
    {- ^ (Required) The assessment target ARN to attach the template to. -}
    } deriving (Show, Eq)

instance TF.ToHCL InspectorAssessmentTemplateResource where
    toHCL InspectorAssessmentTemplateResource{..} = TF.block $ catMaybes
        [ TF.argument _duration
        , TF.argument _name
        , TF.argument _rules_package_arns
        , TF.argument _target_arn
        ]

instance HasDuration InspectorAssessmentTemplateResource Text where
    duration =
        lens (_duration :: InspectorAssessmentTemplateResource -> TF.Argument "duration" Text)
             (\s a -> s { _duration = a } :: InspectorAssessmentTemplateResource)

instance HasName InspectorAssessmentTemplateResource Text where
    name =
        lens (_name :: InspectorAssessmentTemplateResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: InspectorAssessmentTemplateResource)

instance HasRulesPackageArns InspectorAssessmentTemplateResource Text where
    rulesPackageArns =
        lens (_rules_package_arns :: InspectorAssessmentTemplateResource -> TF.Argument "rules_package_arns" Text)
             (\s a -> s { _rules_package_arns = a } :: InspectorAssessmentTemplateResource)

instance HasTargetArn InspectorAssessmentTemplateResource Text where
    targetArn =
        lens (_target_arn :: InspectorAssessmentTemplateResource -> TF.Argument "target_arn" Text)
             (\s a -> s { _target_arn = a } :: InspectorAssessmentTemplateResource)

instance HasComputedArn InspectorAssessmentTemplateResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

inspectorAssessmentTemplateResource :: TF.Resource TF.AWS InspectorAssessmentTemplateResource
inspectorAssessmentTemplateResource =
    TF.newResource "aws_inspector_assessment_template" $
        InspectorAssessmentTemplateResource {
            _duration = TF.Nil
            , _name = TF.Nil
            , _rules_package_arns = TF.Nil
            , _target_arn = TF.Nil
            }

{- | The @aws_inspector_resource_group@ AWS resource.

Provides a Inspector resource group
-}
data InspectorResourceGroupResource = InspectorResourceGroupResource {
      _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Required) The tags on your EC2 Instance. -}
    } deriving (Show, Eq)

instance TF.ToHCL InspectorResourceGroupResource where
    toHCL InspectorResourceGroupResource{..} = TF.block $ catMaybes
        [ TF.argument _tags
        ]

instance HasTags InspectorResourceGroupResource TF.Tags where
    tags =
        lens (_tags :: InspectorResourceGroupResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: InspectorResourceGroupResource)

instance HasComputedArn InspectorResourceGroupResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

inspectorResourceGroupResource :: TF.Resource TF.AWS InspectorResourceGroupResource
inspectorResourceGroupResource =
    TF.newResource "aws_inspector_resource_group" $
        InspectorResourceGroupResource {
            _tags = TF.Nil
            }

{- | The @aws_instance@ AWS resource.

Provides an EC2 instance resource. This allows instances to be created,
updated, and deleted. Instances also support </docs/provisioners/index.html>
.
-}
data InstanceResource = InstanceResource {
      _ami :: !(TF.Argument "ami" Text)
    {- ^ (Required) The AMI to use for the instance. -}
    , _associate_public_ip_address :: !(TF.Argument "associate_public_ip_address" Text)
    {- ^ (Optional) Associate a public ip address with an instance in a VPC.  Boolean value. -}
    , _availability_zone :: !(TF.Argument "availability_zone" TF.Zone)
    {- ^ (Optional) The AZ to start the instance in. -}
    , _disable_api_termination :: !(TF.Argument "disable_api_termination" Text)
    {- ^ (Optional) If true, enables <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/terminating-instances.html#Using_ChangingDisableAPITermination> -}
    , _ebs_block_device :: !(TF.Argument "ebs_block_device" Text)
    {- ^ (Optional) Additional EBS block devices to attach to the instance.  See <#block-devices> below for details. -}
    , _ebs_optimized :: !(TF.Argument "ebs_optimized" Text)
    {- ^ (Optional) If true, the launched EC2 instance will be EBS-optimized. -}
    , _ephemeral_block_device :: !(TF.Argument "ephemeral_block_device" Text)
    {- ^ (Optional) Customize Ephemeral (also known as "Instance Store") volumes on the instance. See <#block-devices> below for details. -}
    , _iam_instance_profile :: !(TF.Argument "iam_instance_profile" Text)
    {- ^ (Optional) The IAM Instance Profile to launch the instance with. Specified as the name of the Instance Profile. Ensure your credentials have the correct permission to assign the instance profile according to the <http://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_switch-role-ec2.html#roles-usingrole-ec2instance-permissions> , notably @iam:PassRole@ . -}
    , _instance_initiated_shutdown_behavior :: !(TF.Argument "instance_initiated_shutdown_behavior" Text)
    {- ^ (Optional) Shutdown behavior for the instance. Amazon defaults this to @stop@ for EBS-backed instances and @terminate@ for instance-store instances. Cannot be set on instance-store instances. See <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/terminating-instances.html#Using_ChangingInstanceInitiatedShutdownBehavior> for more information. -}
    , _instance_type :: !(TF.Argument "instance_type" Text)
    {- ^ (Required) The type of instance to start. Updates to this field will trigger a stop/start of the EC2 instance. -}
    , _ipv6_address_count :: !(TF.Argument "ipv6_address_count" Text)
    {- ^ (Optional) A number of IPv6 addresses to associate with the primary network interface. Amazon EC2 chooses the IPv6 addresses from the range of your subnet. -}
    , _ipv6_addresses :: !(TF.Argument "ipv6_addresses" Text)
    {- ^ (Optional) Specify one or more IPv6 addresses from the range of the subnet to associate with the primary network interface -}
    , _key_name :: !(TF.Argument "key_name" Text)
    {- ^ (Optional) The key name to use for the instance. -}
    , _monitoring :: !(TF.Argument "monitoring" Text)
    {- ^ (Optional) If true, the launched EC2 instance will have detailed monitoring enabled. (Available since v0.6.0) -}
    , _network_interface :: !(TF.Argument "network_interface" Text)
    {- ^ (Optional) Customize network interfaces to be attached at instance boot time. See <#network-interfaces> below for more details. -}
    , _placement_group :: !(TF.Argument "placement_group" Text)
    {- ^ (Optional) The Placement Group to start the instance in. -}
    , _private_ip :: !(TF.Argument "private_ip" Text)
    {- ^ (Optional) Private IP address to associate with the instance in a VPC. -}
    , _root_block_device :: !(TF.Argument "root_block_device" Text)
    {- ^ (Optional) Customize details about the root block device of the instance. See <#block-devices> below for details. -}
    , _security_groups :: !(TF.Argument "security_groups" Text)
    {- ^ (Optional) A list of security group names to associate with. If you are creating Instances in a VPC, use @vpc_security_group_ids@ instead. -}
    , _source_dest_check :: !(TF.Argument "source_dest_check" Text)
    {- ^ (Optional) Controls if traffic is routed to the instance when the destination address does not match the instance. Used for NAT or VPNs. Defaults true. -}
    , _subnet_id :: !(TF.Argument "subnet_id" Text)
    {- ^ (Optional) The VPC Subnet ID to launch in. -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    , _tenancy :: !(TF.Argument "tenancy" Text)
    {- ^ (Optional) The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of dedicated runs on single-tenant hardware. The host tenancy is not supported for the import-instance command. -}
    , _user_data :: !(TF.Argument "user_data" Text)
    {- ^ (Optional) The user data to provide when launching the instance. Do not pass gzip-compressed data via this argument; see @user_data_base64@ instead. -}
    , _user_data_base64 :: !(TF.Argument "user_data_base64" Text)
    {- ^ (Optional) Can be used instead of @user_data@ to pass base64-encoded binary data directly. Use this instead of @user_data@ whenever the value is not a valid UTF-8 string. For example, gzip-encoded user data must be base64-encoded and passed via this argument to avoid corruption. -}
    , _volume_tags :: !(TF.Argument "volume_tags" Text)
    {- ^ (Optional) A mapping of tags to assign to the devices created by the instance at launch time. -}
    , _vpc_security_group_ids :: !(TF.Argument "vpc_security_group_ids" Text)
    {- ^ (Optional) A list of security group IDs to associate with. -}
    } deriving (Show, Eq)

instance TF.ToHCL InstanceResource where
    toHCL InstanceResource{..} = TF.block $ catMaybes
        [ TF.argument _ami
        , TF.argument _associate_public_ip_address
        , TF.argument _availability_zone
        , TF.argument _disable_api_termination
        , TF.argument _ebs_block_device
        , TF.argument _ebs_optimized
        , TF.argument _ephemeral_block_device
        , TF.argument _iam_instance_profile
        , TF.argument _instance_initiated_shutdown_behavior
        , TF.argument _instance_type
        , TF.argument _ipv6_address_count
        , TF.argument _ipv6_addresses
        , TF.argument _key_name
        , TF.argument _monitoring
        , TF.argument _network_interface
        , TF.argument _placement_group
        , TF.argument _private_ip
        , TF.argument _root_block_device
        , TF.argument _security_groups
        , TF.argument _source_dest_check
        , TF.argument _subnet_id
        , TF.argument _tags
        , TF.argument _tenancy
        , TF.argument _user_data
        , TF.argument _user_data_base64
        , TF.argument _volume_tags
        , TF.argument _vpc_security_group_ids
        ]

instance HasAmi InstanceResource Text where
    ami =
        lens (_ami :: InstanceResource -> TF.Argument "ami" Text)
             (\s a -> s { _ami = a } :: InstanceResource)

instance HasAssociatePublicIpAddress InstanceResource Text where
    associatePublicIpAddress =
        lens (_associate_public_ip_address :: InstanceResource -> TF.Argument "associate_public_ip_address" Text)
             (\s a -> s { _associate_public_ip_address = a } :: InstanceResource)

instance HasAvailabilityZone InstanceResource TF.Zone where
    availabilityZone =
        lens (_availability_zone :: InstanceResource -> TF.Argument "availability_zone" TF.Zone)
             (\s a -> s { _availability_zone = a } :: InstanceResource)

instance HasDisableApiTermination InstanceResource Text where
    disableApiTermination =
        lens (_disable_api_termination :: InstanceResource -> TF.Argument "disable_api_termination" Text)
             (\s a -> s { _disable_api_termination = a } :: InstanceResource)

instance HasEbsBlockDevice InstanceResource Text where
    ebsBlockDevice =
        lens (_ebs_block_device :: InstanceResource -> TF.Argument "ebs_block_device" Text)
             (\s a -> s { _ebs_block_device = a } :: InstanceResource)

instance HasEbsOptimized InstanceResource Text where
    ebsOptimized =
        lens (_ebs_optimized :: InstanceResource -> TF.Argument "ebs_optimized" Text)
             (\s a -> s { _ebs_optimized = a } :: InstanceResource)

instance HasEphemeralBlockDevice InstanceResource Text where
    ephemeralBlockDevice =
        lens (_ephemeral_block_device :: InstanceResource -> TF.Argument "ephemeral_block_device" Text)
             (\s a -> s { _ephemeral_block_device = a } :: InstanceResource)

instance HasIamInstanceProfile InstanceResource Text where
    iamInstanceProfile =
        lens (_iam_instance_profile :: InstanceResource -> TF.Argument "iam_instance_profile" Text)
             (\s a -> s { _iam_instance_profile = a } :: InstanceResource)

instance HasInstanceInitiatedShutdownBehavior InstanceResource Text where
    instanceInitiatedShutdownBehavior =
        lens (_instance_initiated_shutdown_behavior :: InstanceResource -> TF.Argument "instance_initiated_shutdown_behavior" Text)
             (\s a -> s { _instance_initiated_shutdown_behavior = a } :: InstanceResource)

instance HasInstanceType InstanceResource Text where
    instanceType =
        lens (_instance_type :: InstanceResource -> TF.Argument "instance_type" Text)
             (\s a -> s { _instance_type = a } :: InstanceResource)

instance HasIpv6AddressCount InstanceResource Text where
    ipv6AddressCount =
        lens (_ipv6_address_count :: InstanceResource -> TF.Argument "ipv6_address_count" Text)
             (\s a -> s { _ipv6_address_count = a } :: InstanceResource)

instance HasIpv6Addresses InstanceResource Text where
    ipv6Addresses =
        lens (_ipv6_addresses :: InstanceResource -> TF.Argument "ipv6_addresses" Text)
             (\s a -> s { _ipv6_addresses = a } :: InstanceResource)

instance HasKeyName InstanceResource Text where
    keyName =
        lens (_key_name :: InstanceResource -> TF.Argument "key_name" Text)
             (\s a -> s { _key_name = a } :: InstanceResource)

instance HasMonitoring InstanceResource Text where
    monitoring =
        lens (_monitoring :: InstanceResource -> TF.Argument "monitoring" Text)
             (\s a -> s { _monitoring = a } :: InstanceResource)

instance HasNetworkInterface InstanceResource Text where
    networkInterface =
        lens (_network_interface :: InstanceResource -> TF.Argument "network_interface" Text)
             (\s a -> s { _network_interface = a } :: InstanceResource)

instance HasPlacementGroup InstanceResource Text where
    placementGroup =
        lens (_placement_group :: InstanceResource -> TF.Argument "placement_group" Text)
             (\s a -> s { _placement_group = a } :: InstanceResource)

instance HasPrivateIp InstanceResource Text where
    privateIp =
        lens (_private_ip :: InstanceResource -> TF.Argument "private_ip" Text)
             (\s a -> s { _private_ip = a } :: InstanceResource)

instance HasRootBlockDevice InstanceResource Text where
    rootBlockDevice =
        lens (_root_block_device :: InstanceResource -> TF.Argument "root_block_device" Text)
             (\s a -> s { _root_block_device = a } :: InstanceResource)

instance HasSecurityGroups InstanceResource Text where
    securityGroups =
        lens (_security_groups :: InstanceResource -> TF.Argument "security_groups" Text)
             (\s a -> s { _security_groups = a } :: InstanceResource)

instance HasSourceDestCheck InstanceResource Text where
    sourceDestCheck =
        lens (_source_dest_check :: InstanceResource -> TF.Argument "source_dest_check" Text)
             (\s a -> s { _source_dest_check = a } :: InstanceResource)

instance HasSubnetId InstanceResource Text where
    subnetId =
        lens (_subnet_id :: InstanceResource -> TF.Argument "subnet_id" Text)
             (\s a -> s { _subnet_id = a } :: InstanceResource)

instance HasTags InstanceResource TF.Tags where
    tags =
        lens (_tags :: InstanceResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: InstanceResource)

instance HasTenancy InstanceResource Text where
    tenancy =
        lens (_tenancy :: InstanceResource -> TF.Argument "tenancy" Text)
             (\s a -> s { _tenancy = a } :: InstanceResource)

instance HasUserData InstanceResource Text where
    userData =
        lens (_user_data :: InstanceResource -> TF.Argument "user_data" Text)
             (\s a -> s { _user_data = a } :: InstanceResource)

instance HasUserDataBase64 InstanceResource Text where
    userDataBase64 =
        lens (_user_data_base64 :: InstanceResource -> TF.Argument "user_data_base64" Text)
             (\s a -> s { _user_data_base64 = a } :: InstanceResource)

instance HasVolumeTags InstanceResource Text where
    volumeTags =
        lens (_volume_tags :: InstanceResource -> TF.Argument "volume_tags" Text)
             (\s a -> s { _volume_tags = a } :: InstanceResource)

instance HasVpcSecurityGroupIds InstanceResource Text where
    vpcSecurityGroupIds =
        lens (_vpc_security_group_ids :: InstanceResource -> TF.Argument "vpc_security_group_ids" Text)
             (\s a -> s { _vpc_security_group_ids = a } :: InstanceResource)

instanceResource :: TF.Resource TF.AWS InstanceResource
instanceResource =
    TF.newResource "aws_instance" $
        InstanceResource {
            _ami = TF.Nil
            , _associate_public_ip_address = TF.Nil
            , _availability_zone = TF.Nil
            , _disable_api_termination = TF.Nil
            , _ebs_block_device = TF.Nil
            , _ebs_optimized = TF.Nil
            , _ephemeral_block_device = TF.Nil
            , _iam_instance_profile = TF.Nil
            , _instance_initiated_shutdown_behavior = TF.Nil
            , _instance_type = TF.Nil
            , _ipv6_address_count = TF.Nil
            , _ipv6_addresses = TF.Nil
            , _key_name = TF.Nil
            , _monitoring = TF.Nil
            , _network_interface = TF.Nil
            , _placement_group = TF.Nil
            , _private_ip = TF.Nil
            , _root_block_device = TF.Nil
            , _security_groups = TF.Nil
            , _source_dest_check = TF.Nil
            , _subnet_id = TF.Nil
            , _tags = TF.Nil
            , _tenancy = TF.Nil
            , _user_data = TF.Nil
            , _user_data_base64 = TF.Nil
            , _volume_tags = TF.Nil
            , _vpc_security_group_ids = TF.Nil
            }

{- | The @aws_internet_gateway@ AWS resource.

Provides a resource to create a VPC Internet Gateway.
-}
data InternetGatewayResource = InternetGatewayResource {
      _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    , _vpc_id :: !(TF.Argument "vpc_id" Text)
    {- ^ (Required) The VPC ID to create in. -}
    } deriving (Show, Eq)

instance TF.ToHCL InternetGatewayResource where
    toHCL InternetGatewayResource{..} = TF.block $ catMaybes
        [ TF.argument _tags
        , TF.argument _vpc_id
        ]

instance HasTags InternetGatewayResource TF.Tags where
    tags =
        lens (_tags :: InternetGatewayResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: InternetGatewayResource)

instance HasVpcId InternetGatewayResource Text where
    vpcId =
        lens (_vpc_id :: InternetGatewayResource -> TF.Argument "vpc_id" Text)
             (\s a -> s { _vpc_id = a } :: InternetGatewayResource)

instance HasComputedId InternetGatewayResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

internetGatewayResource :: TF.Resource TF.AWS InternetGatewayResource
internetGatewayResource =
    TF.newResource "aws_internet_gateway" $
        InternetGatewayResource {
            _tags = TF.Nil
            , _vpc_id = TF.Nil
            }

{- | The @aws_iot_certificate@ AWS resource.

Creates and manages an AWS IoT certificate.
-}
data IotCertificateResource = IotCertificateResource {
      _active :: !(TF.Argument "active" Text)
    {- ^ (Required)  Boolean flag to indicate if the certificate should be active -}
    , _csr :: !(TF.Argument "csr" Text)
    {- ^ (Required) The certificate signing request. Review the [IoT API Reference Guide] (http://docs.aws.amazon.com/iot/latest/apireference/API_CreateCertificateFromCsr.html) for more information on creating a certificate from a certificate signing request (CSR). -}
    } deriving (Show, Eq)

instance TF.ToHCL IotCertificateResource where
    toHCL IotCertificateResource{..} = TF.block $ catMaybes
        [ TF.argument _active
        , TF.argument _csr
        ]

instance HasActive IotCertificateResource Text where
    active =
        lens (_active :: IotCertificateResource -> TF.Argument "active" Text)
             (\s a -> s { _active = a } :: IotCertificateResource)

instance HasCsr IotCertificateResource Text where
    csr =
        lens (_csr :: IotCertificateResource -> TF.Argument "csr" Text)
             (\s a -> s { _csr = a } :: IotCertificateResource)

instance HasComputedArn IotCertificateResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

iotCertificateResource :: TF.Resource TF.AWS IotCertificateResource
iotCertificateResource =
    TF.newResource "aws_iot_certificate" $
        IotCertificateResource {
            _active = TF.Nil
            , _csr = TF.Nil
            }

{- | The @aws_iot_policy@ AWS resource.

Provides an IoT policy.
-}
data IotPolicyResource = IotPolicyResource {
      _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the policy. -}
    , _policy :: !(TF.Argument "policy" Text)
    {- ^ (Required) The policy document. This is a JSON formatted string. The heredoc syntax or @file@ function is helpful here. Use the [IoT Developer Guide] (http://docs.aws.amazon.com/iot/latest/developerguide/iot-policies.html) for more information on IoT Policies -}
    } deriving (Show, Eq)

instance TF.ToHCL IotPolicyResource where
    toHCL IotPolicyResource{..} = TF.block $ catMaybes
        [ TF.argument _name
        , TF.argument _policy
        ]

instance HasName IotPolicyResource Text where
    name =
        lens (_name :: IotPolicyResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: IotPolicyResource)

instance HasPolicy IotPolicyResource Text where
    policy =
        lens (_policy :: IotPolicyResource -> TF.Argument "policy" Text)
             (\s a -> s { _policy = a } :: IotPolicyResource)

instance HasComputedArn IotPolicyResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

instance HasComputedDefaultVersionId IotPolicyResource Text where
    computedDefaultVersionId =
        to (\_  -> TF.Compute "default_version_id")

instance HasComputedName IotPolicyResource Text where
    computedName =
        to (\_  -> TF.Compute "name")

instance HasComputedPolicy IotPolicyResource Text where
    computedPolicy =
        to (\_  -> TF.Compute "policy")

iotPolicyResource :: TF.Resource TF.AWS IotPolicyResource
iotPolicyResource =
    TF.newResource "aws_iot_policy" $
        IotPolicyResource {
            _name = TF.Nil
            , _policy = TF.Nil
            }

{- | The @aws_key_pair@ AWS resource.

Provides an
<https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html>
resource. A key pair is used to control login access to EC2 instances.
Currently this resource requires an existing user-supplied key pair. This
key pair's public key will be registered with AWS to allow logging-in to EC2
instances. When importing an existing key pair the public key material may
be in any format supported by AWS. Supported formats (per the
<https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html#how-to-generate-your-own-key-and-import-it-to-aws>
) are:
-}
data KeyPairResource = KeyPairResource {
      _key_name :: !(TF.Argument "key_name" Text)
    {- ^ (Optional) The name for the key pair. -}
    , _key_name_prefix :: !(TF.Argument "key_name_prefix" Text)
    {- ^ (Optional) Creates a unique name beginning with the specified prefix. Conflicts with @key_name@ . -}
    , _public_key :: !(TF.Argument "public_key" Text)
    {- ^ (Required) The public key material. -}
    } deriving (Show, Eq)

instance TF.ToHCL KeyPairResource where
    toHCL KeyPairResource{..} = TF.block $ catMaybes
        [ TF.argument _key_name
        , TF.argument _key_name_prefix
        , TF.argument _public_key
        ]

instance HasKeyName KeyPairResource Text where
    keyName =
        lens (_key_name :: KeyPairResource -> TF.Argument "key_name" Text)
             (\s a -> s { _key_name = a } :: KeyPairResource)

instance HasKeyNamePrefix KeyPairResource Text where
    keyNamePrefix =
        lens (_key_name_prefix :: KeyPairResource -> TF.Argument "key_name_prefix" Text)
             (\s a -> s { _key_name_prefix = a } :: KeyPairResource)

instance HasPublicKey KeyPairResource Text where
    publicKey =
        lens (_public_key :: KeyPairResource -> TF.Argument "public_key" Text)
             (\s a -> s { _public_key = a } :: KeyPairResource)

instance HasComputedFingerprint KeyPairResource Text where
    computedFingerprint =
        to (\_  -> TF.Compute "fingerprint")

instance HasComputedKeyName KeyPairResource Text where
    computedKeyName =
        to (\_  -> TF.Compute "key_name")

keyPairResource :: TF.Resource TF.AWS KeyPairResource
keyPairResource =
    TF.newResource "aws_key_pair" $
        KeyPairResource {
            _key_name = TF.Nil
            , _key_name_prefix = TF.Nil
            , _public_key = TF.Nil
            }

{- | The @aws_kinesis_firehose_delivery_stream@ AWS resource.

Provides a Kinesis Firehose Delivery Stream resource. Amazon Kinesis
Firehose is a fully managed, elastic service to easily deliver real-time
data streams to destinations such as Amazon S3 and Amazon Redshift. For more
details, see the <https://aws.amazon.com/documentation/firehose/> .
-}
data KinesisFirehoseDeliveryStreamResource = KinesisFirehoseDeliveryStreamResource {
      _destination :: !(TF.Argument "destination" Text)
    {- ^  (Required) This is the destination to where the data is delivered. The only options are @s3@ (Deprecated, use @extended_s3@ instead), @extended_s3@ , @redshift@ , and @elasticsearch@ . -}
    , _extended_s3_configuration :: !(TF.Argument "extended_s3_configuration" Text)
    {- ^ (Optional, only Required when @destination@ is @extended_s3@ ) Enhanced configuration options for the s3 destination. More details are given below. -}
    , _kinesis_source_configuration :: !(TF.Argument "kinesis_source_configuration" Text)
    {- ^ (Optional) Allows the ability to specify the kinesis stream that is used as the source of the firehose delivery stream. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) A name to identify the stream. This is unique to the AWS account and region the Stream is created in. -}
    , _redshift_configuration :: !(TF.Argument "redshift_configuration" Text)
    {- ^ (Optional) Configuration options if redshift is the destination. Using @redshift_configuration@ requires the user to also specify a @s3_configuration@ block. More details are given below. -}
    , _s3_configuration :: !(TF.Argument "s3_configuration" Text)
    {- ^ (Optional, Deprecated, see/use @extended_s3_configuration@ unless @destination@ is @redshift@ ) Configuration options for the s3 destination (or the intermediate bucket if the destination is redshift). More details are given below. -}
    } deriving (Show, Eq)

instance TF.ToHCL KinesisFirehoseDeliveryStreamResource where
    toHCL KinesisFirehoseDeliveryStreamResource{..} = TF.block $ catMaybes
        [ TF.argument _destination
        , TF.argument _extended_s3_configuration
        , TF.argument _kinesis_source_configuration
        , TF.argument _name
        , TF.argument _redshift_configuration
        , TF.argument _s3_configuration
        ]

instance HasDestination KinesisFirehoseDeliveryStreamResource Text where
    destination =
        lens (_destination :: KinesisFirehoseDeliveryStreamResource -> TF.Argument "destination" Text)
             (\s a -> s { _destination = a } :: KinesisFirehoseDeliveryStreamResource)

instance HasExtendedS3Configuration KinesisFirehoseDeliveryStreamResource Text where
    extendedS3Configuration =
        lens (_extended_s3_configuration :: KinesisFirehoseDeliveryStreamResource -> TF.Argument "extended_s3_configuration" Text)
             (\s a -> s { _extended_s3_configuration = a } :: KinesisFirehoseDeliveryStreamResource)

instance HasKinesisSourceConfiguration KinesisFirehoseDeliveryStreamResource Text where
    kinesisSourceConfiguration =
        lens (_kinesis_source_configuration :: KinesisFirehoseDeliveryStreamResource -> TF.Argument "kinesis_source_configuration" Text)
             (\s a -> s { _kinesis_source_configuration = a } :: KinesisFirehoseDeliveryStreamResource)

instance HasName KinesisFirehoseDeliveryStreamResource Text where
    name =
        lens (_name :: KinesisFirehoseDeliveryStreamResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: KinesisFirehoseDeliveryStreamResource)

instance HasRedshiftConfiguration KinesisFirehoseDeliveryStreamResource Text where
    redshiftConfiguration =
        lens (_redshift_configuration :: KinesisFirehoseDeliveryStreamResource -> TF.Argument "redshift_configuration" Text)
             (\s a -> s { _redshift_configuration = a } :: KinesisFirehoseDeliveryStreamResource)

instance HasS3Configuration KinesisFirehoseDeliveryStreamResource Text where
    s3Configuration =
        lens (_s3_configuration :: KinesisFirehoseDeliveryStreamResource -> TF.Argument "s3_configuration" Text)
             (\s a -> s { _s3_configuration = a } :: KinesisFirehoseDeliveryStreamResource)

instance HasComputedArn KinesisFirehoseDeliveryStreamResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

kinesisFirehoseDeliveryStreamResource :: TF.Resource TF.AWS KinesisFirehoseDeliveryStreamResource
kinesisFirehoseDeliveryStreamResource =
    TF.newResource "aws_kinesis_firehose_delivery_stream" $
        KinesisFirehoseDeliveryStreamResource {
            _destination = TF.Nil
            , _extended_s3_configuration = TF.Nil
            , _kinesis_source_configuration = TF.Nil
            , _name = TF.Nil
            , _redshift_configuration = TF.Nil
            , _s3_configuration = TF.Nil
            }

{- | The @aws_kinesis_stream@ AWS resource.

Provides a Kinesis Stream resource. Amazon Kinesis is a managed service that
scales elastically for real-time processing of streaming big data. For more
details, see the <https://aws.amazon.com/documentation/kinesis/> .
-}
data KinesisStreamResource = KinesisStreamResource {
      _encryption_type :: !(TF.Argument "encryption_type" Text)
    {- ^ (Optional) The encryption type to use. The only acceptable values are @NONE@ or @KMS@ . The default value is @NONE@ . -}
    , _kms_key_id :: !(TF.Argument "kms_key_id" Text)
    {- ^ (Optional) The GUID for the customer-managed KMS key to use for encryption. You can also use a Kinesis-owned master key by specifying the alias aws/kinesis. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) A name to identify the stream. This is unique to the AWS account and region the Stream is created in. -}
    , _retention_period :: !(TF.Argument "retention_period" Text)
    {- ^ (Optional) Length of time data records are accessible after they are added to the stream. The maximum value of a stream's retention period is 168 hours. Minimum value is 24. Default is 24. -}
    , _shard_count :: !(TF.Argument "shard_count" Text)
    {- ^ (Required) The number of shards that the stream will use. Amazon has guidlines for specifying the Stream size that should be referenced when creating a Kinesis stream. See <https://docs.aws.amazon.com/kinesis/latest/dev/amazon-kinesis-streams.html> for more. -}
    , _shard_level_metrics :: !(TF.Argument "shard_level_metrics" Text)
    {- ^ (Optional) A list of shard-level CloudWatch metrics which can be enabled for the stream. See <https://docs.aws.amazon.com/streams/latest/dev/monitoring-with-cloudwatch.html> for more. Note that the value ALL should not be used; instead you should provide an explicit list of metrics you wish to enable. -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    } deriving (Show, Eq)

instance TF.ToHCL KinesisStreamResource where
    toHCL KinesisStreamResource{..} = TF.block $ catMaybes
        [ TF.argument _encryption_type
        , TF.argument _kms_key_id
        , TF.argument _name
        , TF.argument _retention_period
        , TF.argument _shard_count
        , TF.argument _shard_level_metrics
        , TF.argument _tags
        ]

instance HasEncryptionType KinesisStreamResource Text where
    encryptionType =
        lens (_encryption_type :: KinesisStreamResource -> TF.Argument "encryption_type" Text)
             (\s a -> s { _encryption_type = a } :: KinesisStreamResource)

instance HasKmsKeyId KinesisStreamResource Text where
    kmsKeyId =
        lens (_kms_key_id :: KinesisStreamResource -> TF.Argument "kms_key_id" Text)
             (\s a -> s { _kms_key_id = a } :: KinesisStreamResource)

instance HasName KinesisStreamResource Text where
    name =
        lens (_name :: KinesisStreamResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: KinesisStreamResource)

instance HasRetentionPeriod KinesisStreamResource Text where
    retentionPeriod =
        lens (_retention_period :: KinesisStreamResource -> TF.Argument "retention_period" Text)
             (\s a -> s { _retention_period = a } :: KinesisStreamResource)

instance HasShardCount KinesisStreamResource Text where
    shardCount =
        lens (_shard_count :: KinesisStreamResource -> TF.Argument "shard_count" Text)
             (\s a -> s { _shard_count = a } :: KinesisStreamResource)

instance HasShardLevelMetrics KinesisStreamResource Text where
    shardLevelMetrics =
        lens (_shard_level_metrics :: KinesisStreamResource -> TF.Argument "shard_level_metrics" Text)
             (\s a -> s { _shard_level_metrics = a } :: KinesisStreamResource)

instance HasTags KinesisStreamResource TF.Tags where
    tags =
        lens (_tags :: KinesisStreamResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: KinesisStreamResource)

instance HasComputedArn KinesisStreamResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

instance HasComputedId KinesisStreamResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedName KinesisStreamResource Text where
    computedName =
        to (\_  -> TF.Compute "name")

instance HasComputedShardCount KinesisStreamResource Text where
    computedShardCount =
        to (\_  -> TF.Compute "shard_count")

kinesisStreamResource :: TF.Resource TF.AWS KinesisStreamResource
kinesisStreamResource =
    TF.newResource "aws_kinesis_stream" $
        KinesisStreamResource {
            _encryption_type = TF.Nil
            , _kms_key_id = TF.Nil
            , _name = TF.Nil
            , _retention_period = TF.Nil
            , _shard_count = TF.Nil
            , _shard_level_metrics = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_kms_alias@ AWS resource.

Provides an alias for a KMS customer master key. AWS Console enforces 1-to-1
mapping between aliases & keys, but API (hence Terraform too) allows you to
create as many aliases as the
<http://docs.aws.amazon.com/kms/latest/developerguide/limits.html> allow
you.
-}
data KmsAliasResource = KmsAliasResource {
      _name :: !(TF.Argument "name" Text)
    {- ^ (Optional) The display name of the alias. The name must start with the word "alias" followed by a forward slash (alias/) -}
    , _name_prefix :: !(TF.Argument "name_prefix" Text)
    {- ^ (Optional) Creates an unique alias beginning with the specified prefix. The name must start with the word "alias" followed by a forward slash (alias/).  Conflicts with @name@ . -}
    , _target_key_id :: !(TF.Argument "target_key_id" Text)
    {- ^ (Required) Identifier for the key for which the alias is for, can be either an ARN or key_id. -}
    } deriving (Show, Eq)

instance TF.ToHCL KmsAliasResource where
    toHCL KmsAliasResource{..} = TF.block $ catMaybes
        [ TF.argument _name
        , TF.argument _name_prefix
        , TF.argument _target_key_id
        ]

instance HasName KmsAliasResource Text where
    name =
        lens (_name :: KmsAliasResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: KmsAliasResource)

instance HasNamePrefix KmsAliasResource Text where
    namePrefix =
        lens (_name_prefix :: KmsAliasResource -> TF.Argument "name_prefix" Text)
             (\s a -> s { _name_prefix = a } :: KmsAliasResource)

instance HasTargetKeyId KmsAliasResource Text where
    targetKeyId =
        lens (_target_key_id :: KmsAliasResource -> TF.Argument "target_key_id" Text)
             (\s a -> s { _target_key_id = a } :: KmsAliasResource)

instance HasComputedArn KmsAliasResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

kmsAliasResource :: TF.Resource TF.AWS KmsAliasResource
kmsAliasResource =
    TF.newResource "aws_kms_alias" $
        KmsAliasResource {
            _name = TF.Nil
            , _name_prefix = TF.Nil
            , _target_key_id = TF.Nil
            }

{- | The @aws_kms_key@ AWS resource.

Provides a KMS customer master key.
-}
data KmsKeyResource = KmsKeyResource {
      _deletion_window_in_days :: !(TF.Argument "deletion_window_in_days" Text)
    {- ^ (Optional) Duration in days after which the key is deleted after destruction of the resource, must be between 7 and 30 days. Defaults to 30 days. -}
    , _description :: !(TF.Argument "description" Text)
    {- ^ (Optional) The description of the key as viewed in AWS console. -}
    , _enable_key_rotation :: !(TF.Argument "enable_key_rotation" TF.Bool)
    {- ^ (Optional) Specifies whether <http://docs.aws.amazon.com/kms/latest/developerguide/rotate-keys.html> is enabled. Defaults to false. -}
    , _is_enabled :: !(TF.Argument "is_enabled" TF.Bool)
    {- ^ (Optional) Specifies whether the key is enabled. Defaults to true. -}
    , _key_usage :: !(TF.Argument "key_usage" Text)
    {- ^ (Optional) Specifies the intended use of the key. Defaults to ENCRYPT_DECRYPT, and only symmetric encryption and decryption are supported. -}
    , _policy :: !(TF.Argument "policy" Text)
    {- ^ (Optional) A valid policy JSON document. -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the object. -}
    } deriving (Show, Eq)

instance TF.ToHCL KmsKeyResource where
    toHCL KmsKeyResource{..} = TF.block $ catMaybes
        [ TF.argument _deletion_window_in_days
        , TF.argument _description
        , TF.argument _enable_key_rotation
        , TF.argument _is_enabled
        , TF.argument _key_usage
        , TF.argument _policy
        , TF.argument _tags
        ]

instance HasDeletionWindowInDays KmsKeyResource Text where
    deletionWindowInDays =
        lens (_deletion_window_in_days :: KmsKeyResource -> TF.Argument "deletion_window_in_days" Text)
             (\s a -> s { _deletion_window_in_days = a } :: KmsKeyResource)

instance HasDescription KmsKeyResource Text where
    description =
        lens (_description :: KmsKeyResource -> TF.Argument "description" Text)
             (\s a -> s { _description = a } :: KmsKeyResource)

instance HasEnableKeyRotation KmsKeyResource TF.Bool where
    enableKeyRotation =
        lens (_enable_key_rotation :: KmsKeyResource -> TF.Argument "enable_key_rotation" TF.Bool)
             (\s a -> s { _enable_key_rotation = a } :: KmsKeyResource)

instance HasIsEnabled KmsKeyResource TF.Bool where
    isEnabled =
        lens (_is_enabled :: KmsKeyResource -> TF.Argument "is_enabled" TF.Bool)
             (\s a -> s { _is_enabled = a } :: KmsKeyResource)

instance HasKeyUsage KmsKeyResource Text where
    keyUsage =
        lens (_key_usage :: KmsKeyResource -> TF.Argument "key_usage" Text)
             (\s a -> s { _key_usage = a } :: KmsKeyResource)

instance HasPolicy KmsKeyResource Text where
    policy =
        lens (_policy :: KmsKeyResource -> TF.Argument "policy" Text)
             (\s a -> s { _policy = a } :: KmsKeyResource)

instance HasTags KmsKeyResource TF.Tags where
    tags =
        lens (_tags :: KmsKeyResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: KmsKeyResource)

instance HasComputedArn KmsKeyResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

instance HasComputedKeyId KmsKeyResource Text where
    computedKeyId =
        to (\_  -> TF.Compute "key_id")

kmsKeyResource :: TF.Resource TF.AWS KmsKeyResource
kmsKeyResource =
    TF.newResource "aws_kms_key" $
        KmsKeyResource {
            _deletion_window_in_days = TF.Nil
            , _description = TF.Nil
            , _enable_key_rotation = TF.Nil
            , _is_enabled = TF.Nil
            , _key_usage = TF.Nil
            , _policy = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_lambda_alias@ AWS resource.

Creates a Lambda function alias. Creates an alias that points to the
specified Lambda function version. For information about Lambda and how to
use it, see <http://docs.aws.amazon.com/lambda/latest/dg/welcome.html> For
information about function aliases, see
<http://docs.aws.amazon.com/lambda/latest/dg/API_CreateAlias.html> in the
API docs.
-}
data LambdaAliasResource = LambdaAliasResource {
      _description :: !(TF.Argument "description" Text)
    {- ^ (Optional) Description of the alias. -}
    , _function_name :: !(TF.Argument "function_name" Text)
    {- ^ (Required) The function ARN of the Lambda function for which you want to create an alias. -}
    , _function_version :: !(TF.Argument "function_version" Text)
    {- ^ (Required) Lambda function version for which you are creating the alias. Pattern: @(\$LATEST|[0-9]+)@ . -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) Name for the alias you are creating. Pattern: @(?!^[0-9]+$)([a-zA-Z0-9-_]+)@ -}
    } deriving (Show, Eq)

instance TF.ToHCL LambdaAliasResource where
    toHCL LambdaAliasResource{..} = TF.block $ catMaybes
        [ TF.argument _description
        , TF.argument _function_name
        , TF.argument _function_version
        , TF.argument _name
        ]

instance HasDescription LambdaAliasResource Text where
    description =
        lens (_description :: LambdaAliasResource -> TF.Argument "description" Text)
             (\s a -> s { _description = a } :: LambdaAliasResource)

instance HasFunctionName LambdaAliasResource Text where
    functionName =
        lens (_function_name :: LambdaAliasResource -> TF.Argument "function_name" Text)
             (\s a -> s { _function_name = a } :: LambdaAliasResource)

instance HasFunctionVersion LambdaAliasResource Text where
    functionVersion =
        lens (_function_version :: LambdaAliasResource -> TF.Argument "function_version" Text)
             (\s a -> s { _function_version = a } :: LambdaAliasResource)

instance HasName LambdaAliasResource Text where
    name =
        lens (_name :: LambdaAliasResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: LambdaAliasResource)

instance HasComputedArn LambdaAliasResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

lambdaAliasResource :: TF.Resource TF.AWS LambdaAliasResource
lambdaAliasResource =
    TF.newResource "aws_lambda_alias" $
        LambdaAliasResource {
            _description = TF.Nil
            , _function_name = TF.Nil
            , _function_version = TF.Nil
            , _name = TF.Nil
            }

{- | The @aws_lambda_event_source_mapping@ AWS resource.

Provides a Lambda event source mapping. This allows Lambda functions to get
events from Kinesis and DynamoDB. For information about Lambda and how to
use it, see <http://docs.aws.amazon.com/lambda/latest/dg/welcome.html> For
information about event source mappings, see
<http://docs.aws.amazon.com/lambda/latest/dg/API_CreateEventSourceMapping.html>
in the API docs.
-}
data LambdaEventSourceMappingResource = LambdaEventSourceMappingResource {
      _batch_size :: !(TF.Argument "batch_size" Text)
    {- ^ (Optional) The largest number of records that Lambda will retrieve from your event source at the time of invocation. Defaults to @100@ . -}
    , _enabled :: !(TF.Argument "enabled" TF.Bool)
    {- ^ (Optional) Determines if the mapping will be enabled on creation. Defaults to @true@ . -}
    , _event_source_arn :: !(TF.Argument "event_source_arn" Text)
    {- ^ (Required) The event source ARN - can either be a Kinesis or DynamoDB stream. -}
    , _function_name :: !(TF.Argument "function_name" Text)
    {- ^ (Required) The name or the ARN of the Lambda function that will be subscribing to events. -}
    , _starting_position :: !(TF.Argument "starting_position" Text)
    {- ^ (Required) The position in the stream where AWS Lambda should start reading. Can be one of either @TRIM_HORIZON@ or @LATEST@ . -}
    } deriving (Show, Eq)

instance TF.ToHCL LambdaEventSourceMappingResource where
    toHCL LambdaEventSourceMappingResource{..} = TF.block $ catMaybes
        [ TF.argument _batch_size
        , TF.argument _enabled
        , TF.argument _event_source_arn
        , TF.argument _function_name
        , TF.argument _starting_position
        ]

instance HasBatchSize LambdaEventSourceMappingResource Text where
    batchSize =
        lens (_batch_size :: LambdaEventSourceMappingResource -> TF.Argument "batch_size" Text)
             (\s a -> s { _batch_size = a } :: LambdaEventSourceMappingResource)

instance HasEnabled LambdaEventSourceMappingResource TF.Bool where
    enabled =
        lens (_enabled :: LambdaEventSourceMappingResource -> TF.Argument "enabled" TF.Bool)
             (\s a -> s { _enabled = a } :: LambdaEventSourceMappingResource)

instance HasEventSourceArn LambdaEventSourceMappingResource Text where
    eventSourceArn =
        lens (_event_source_arn :: LambdaEventSourceMappingResource -> TF.Argument "event_source_arn" Text)
             (\s a -> s { _event_source_arn = a } :: LambdaEventSourceMappingResource)

instance HasFunctionName LambdaEventSourceMappingResource Text where
    functionName =
        lens (_function_name :: LambdaEventSourceMappingResource -> TF.Argument "function_name" Text)
             (\s a -> s { _function_name = a } :: LambdaEventSourceMappingResource)

instance HasStartingPosition LambdaEventSourceMappingResource Text where
    startingPosition =
        lens (_starting_position :: LambdaEventSourceMappingResource -> TF.Argument "starting_position" Text)
             (\s a -> s { _starting_position = a } :: LambdaEventSourceMappingResource)

instance HasComputedFunctionArn LambdaEventSourceMappingResource Text where
    computedFunctionArn =
        to (\_  -> TF.Compute "function_arn")

instance HasComputedLastModified LambdaEventSourceMappingResource Text where
    computedLastModified =
        to (\_  -> TF.Compute "last_modified")

instance HasComputedLastProcessingResult LambdaEventSourceMappingResource Text where
    computedLastProcessingResult =
        to (\_  -> TF.Compute "last_processing_result")

instance HasComputedState LambdaEventSourceMappingResource Text where
    computedState =
        to (\_  -> TF.Compute "state")

instance HasComputedStateTransitionReason LambdaEventSourceMappingResource Text where
    computedStateTransitionReason =
        to (\_  -> TF.Compute "state_transition_reason")

instance HasComputedUuid LambdaEventSourceMappingResource Text where
    computedUuid =
        to (\_  -> TF.Compute "uuid")

lambdaEventSourceMappingResource :: TF.Resource TF.AWS LambdaEventSourceMappingResource
lambdaEventSourceMappingResource =
    TF.newResource "aws_lambda_event_source_mapping" $
        LambdaEventSourceMappingResource {
            _batch_size = TF.Nil
            , _enabled = TF.Nil
            , _event_source_arn = TF.Nil
            , _function_name = TF.Nil
            , _starting_position = TF.Nil
            }

{- | The @aws_lambda_function@ AWS resource.

Provides a Lambda Function resource. Lambda allows you to trigger execution
of code in response to events in AWS. The Lambda Function itself includes
source code and runtime configuration. For information about Lambda and how
to use it, see <https://docs.aws.amazon.com/lambda/latest/dg/welcome.html>
-}
data LambdaFunctionResource = LambdaFunctionResource {
      _dead_letter_config :: !(TF.Argument "dead_letter_config" Text)
    {- ^ (Optional) Nested block to configure the function's dead letter queue . See details below. -}
    , _description :: !(TF.Argument "description" Text)
    {- ^ (Optional) Description of what your Lambda Function does. -}
    , _environment :: !(TF.Argument "environment" Text)
    {- ^ (Optional) The Lambda environment's configuration settings. Fields documented below. -}
    , _filename :: !(TF.Argument "filename" Text)
    {- ^ (Optional) The path to the function's deployment package within the local filesystem. If defined, The @s3_@ -prefixed options cannot be used. -}
    , _function_name :: !(TF.Argument "function_name" Text)
    {- ^ (Required) A unique name for your Lambda Function. -}
    , _handler :: !(TF.Argument "handler" Text)
    {- ^ (Required) The function <https://docs.aws.amazon.com/lambda/latest/dg/walkthrough-custom-events-create-test-function.html> in your code. -}
    , _kms_key_arn :: !(TF.Argument "kms_key_arn" Text)
    {- ^ (Optional) The ARN for the KMS encryption key. -}
    , _memory_size :: !(TF.Argument "memory_size" Text)
    {- ^ (Optional) Amount of memory in MB your Lambda Function can use at runtime. Defaults to @128@ . See <https://docs.aws.amazon.com/lambda/latest/dg/limits.html> -}
    , _publish :: !(TF.Argument "publish" Text)
    {- ^ (Optional) Whether to publish creation/change as new Lambda Function Version. Defaults to @false@ . -}
    , _reserved_concurrent_executions :: !(TF.Argument "reserved_concurrent_executions" Text)
    {- ^ (Optional) The amount of reserved concurrent executions for this lambda function. Defaults to Unreserved Concurrency Limits. See <https://docs.aws.amazon.com/lambda/latest/dg/concurrent-executions.html> -}
    , _role :: !(TF.Argument "role" Text)
    {- ^ (Required) IAM role attached to the Lambda Function. This governs both who / what can invoke your Lambda Function, as well as what resources our Lambda Function has access to. See <https://docs.aws.amazon.com/lambda/latest/dg/intro-permission-model.html> for more details. -}
    , _runtime :: !(TF.Argument "runtime" Text)
    {- ^ (Required) See <https://docs.aws.amazon.com/lambda/latest/dg/API_CreateFunction.html#SSS-CreateFunction-request-Runtime> for valid values. -}
    , _s3_bucket :: !(TF.Argument "s3_bucket" Text)
    {- ^ (Optional) The S3 bucket location containing the function's deployment package. Conflicts with @filename@ . -}
    , _s3_key :: !(TF.Argument "s3_key" Text)
    {- ^ (Optional) The S3 key of an object containing the function's deployment package. Conflicts with @filename@ . -}
    , _s3_object_version :: !(TF.Argument "s3_object_version" Text)
    {- ^ (Optional) The object version containing the function's deployment package. Conflicts with @filename@ . -}
    , _source_code_hash :: !(TF.Argument "source_code_hash" Text)
    {- ^ (Optional) Used to trigger updates. Must be set to a base64-encoded SHA256 hash of the package file specified with either @filename@ or @s3_key@ . The usual way to set this is @${base64sha256(file("file.zip"))}@ , where "file.zip" is the local filename of the lambda function source archive. -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the object. -}
    , _timeout :: !(TF.Argument "timeout" Text)
    {- ^ (Optional) The amount of time your Lambda Function has to run in seconds. Defaults to @3@ . See <https://docs.aws.amazon.com/lambda/latest/dg/limits.html> -}
    , _vpc_config :: !(TF.Argument "vpc_config" Text)
    {- ^ (Optional) Provide this to allow your function to access your VPC. Fields documented below. See <http://docs.aws.amazon.com/lambda/latest/dg/vpc.html> -}
    } deriving (Show, Eq)

instance TF.ToHCL LambdaFunctionResource where
    toHCL LambdaFunctionResource{..} = TF.block $ catMaybes
        [ TF.argument _dead_letter_config
        , TF.argument _description
        , TF.argument _environment
        , TF.argument _filename
        , TF.argument _function_name
        , TF.argument _handler
        , TF.argument _kms_key_arn
        , TF.argument _memory_size
        , TF.argument _publish
        , TF.argument _reserved_concurrent_executions
        , TF.argument _role
        , TF.argument _runtime
        , TF.argument _s3_bucket
        , TF.argument _s3_key
        , TF.argument _s3_object_version
        , TF.argument _source_code_hash
        , TF.argument _tags
        , TF.argument _timeout
        , TF.argument _vpc_config
        ]

instance HasDeadLetterConfig LambdaFunctionResource Text where
    deadLetterConfig =
        lens (_dead_letter_config :: LambdaFunctionResource -> TF.Argument "dead_letter_config" Text)
             (\s a -> s { _dead_letter_config = a } :: LambdaFunctionResource)

instance HasDescription LambdaFunctionResource Text where
    description =
        lens (_description :: LambdaFunctionResource -> TF.Argument "description" Text)
             (\s a -> s { _description = a } :: LambdaFunctionResource)

instance HasEnvironment LambdaFunctionResource Text where
    environment =
        lens (_environment :: LambdaFunctionResource -> TF.Argument "environment" Text)
             (\s a -> s { _environment = a } :: LambdaFunctionResource)

instance HasFilename LambdaFunctionResource Text where
    filename =
        lens (_filename :: LambdaFunctionResource -> TF.Argument "filename" Text)
             (\s a -> s { _filename = a } :: LambdaFunctionResource)

instance HasFunctionName LambdaFunctionResource Text where
    functionName =
        lens (_function_name :: LambdaFunctionResource -> TF.Argument "function_name" Text)
             (\s a -> s { _function_name = a } :: LambdaFunctionResource)

instance HasHandler LambdaFunctionResource Text where
    handler =
        lens (_handler :: LambdaFunctionResource -> TF.Argument "handler" Text)
             (\s a -> s { _handler = a } :: LambdaFunctionResource)

instance HasKmsKeyArn LambdaFunctionResource Text where
    kmsKeyArn =
        lens (_kms_key_arn :: LambdaFunctionResource -> TF.Argument "kms_key_arn" Text)
             (\s a -> s { _kms_key_arn = a } :: LambdaFunctionResource)

instance HasMemorySize LambdaFunctionResource Text where
    memorySize =
        lens (_memory_size :: LambdaFunctionResource -> TF.Argument "memory_size" Text)
             (\s a -> s { _memory_size = a } :: LambdaFunctionResource)

instance HasPublish LambdaFunctionResource Text where
    publish =
        lens (_publish :: LambdaFunctionResource -> TF.Argument "publish" Text)
             (\s a -> s { _publish = a } :: LambdaFunctionResource)

instance HasReservedConcurrentExecutions LambdaFunctionResource Text where
    reservedConcurrentExecutions =
        lens (_reserved_concurrent_executions :: LambdaFunctionResource -> TF.Argument "reserved_concurrent_executions" Text)
             (\s a -> s { _reserved_concurrent_executions = a } :: LambdaFunctionResource)

instance HasRole LambdaFunctionResource Text where
    role =
        lens (_role :: LambdaFunctionResource -> TF.Argument "role" Text)
             (\s a -> s { _role = a } :: LambdaFunctionResource)

instance HasRuntime LambdaFunctionResource Text where
    runtime =
        lens (_runtime :: LambdaFunctionResource -> TF.Argument "runtime" Text)
             (\s a -> s { _runtime = a } :: LambdaFunctionResource)

instance HasS3Bucket LambdaFunctionResource Text where
    s3Bucket =
        lens (_s3_bucket :: LambdaFunctionResource -> TF.Argument "s3_bucket" Text)
             (\s a -> s { _s3_bucket = a } :: LambdaFunctionResource)

instance HasS3Key LambdaFunctionResource Text where
    s3Key =
        lens (_s3_key :: LambdaFunctionResource -> TF.Argument "s3_key" Text)
             (\s a -> s { _s3_key = a } :: LambdaFunctionResource)

instance HasS3ObjectVersion LambdaFunctionResource Text where
    s3ObjectVersion =
        lens (_s3_object_version :: LambdaFunctionResource -> TF.Argument "s3_object_version" Text)
             (\s a -> s { _s3_object_version = a } :: LambdaFunctionResource)

instance HasSourceCodeHash LambdaFunctionResource Text where
    sourceCodeHash =
        lens (_source_code_hash :: LambdaFunctionResource -> TF.Argument "source_code_hash" Text)
             (\s a -> s { _source_code_hash = a } :: LambdaFunctionResource)

instance HasTags LambdaFunctionResource TF.Tags where
    tags =
        lens (_tags :: LambdaFunctionResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: LambdaFunctionResource)

instance HasTimeout LambdaFunctionResource Text where
    timeout =
        lens (_timeout :: LambdaFunctionResource -> TF.Argument "timeout" Text)
             (\s a -> s { _timeout = a } :: LambdaFunctionResource)

instance HasVpcConfig LambdaFunctionResource Text where
    vpcConfig =
        lens (_vpc_config :: LambdaFunctionResource -> TF.Argument "vpc_config" Text)
             (\s a -> s { _vpc_config = a } :: LambdaFunctionResource)

instance HasComputedArn LambdaFunctionResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

instance HasComputedInvokeArn LambdaFunctionResource Text where
    computedInvokeArn =
        to (\_  -> TF.Compute "invoke_arn")

instance HasComputedKmsKeyArn LambdaFunctionResource Text where
    computedKmsKeyArn =
        to (\_  -> TF.Compute "kms_key_arn")

instance HasComputedLastModified LambdaFunctionResource Text where
    computedLastModified =
        to (\_  -> TF.Compute "last_modified")

instance HasComputedQualifiedArn LambdaFunctionResource Text where
    computedQualifiedArn =
        to (\_  -> TF.Compute "qualified_arn")

instance HasComputedSourceCodeHash LambdaFunctionResource Text where
    computedSourceCodeHash =
        to (\_  -> TF.Compute "source_code_hash")

instance HasComputedVersion LambdaFunctionResource Text where
    computedVersion =
        to (\_  -> TF.Compute "version")

lambdaFunctionResource :: TF.Resource TF.AWS LambdaFunctionResource
lambdaFunctionResource =
    TF.newResource "aws_lambda_function" $
        LambdaFunctionResource {
            _dead_letter_config = TF.Nil
            , _description = TF.Nil
            , _environment = TF.Nil
            , _filename = TF.Nil
            , _function_name = TF.Nil
            , _handler = TF.Nil
            , _kms_key_arn = TF.Nil
            , _memory_size = TF.Nil
            , _publish = TF.Nil
            , _reserved_concurrent_executions = TF.Nil
            , _role = TF.Nil
            , _runtime = TF.Nil
            , _s3_bucket = TF.Nil
            , _s3_key = TF.Nil
            , _s3_object_version = TF.Nil
            , _source_code_hash = TF.Nil
            , _tags = TF.Nil
            , _timeout = TF.Nil
            , _vpc_config = TF.Nil
            }

{- | The @aws_lambda_permission@ AWS resource.

Creates a Lambda permission to allow external sources invoking the Lambda
function (e.g. CloudWatch Event Rule, SNS or S3).
-}
data LambdaPermissionResource = LambdaPermissionResource {
      _action :: !(TF.Argument "action" Text)
    {- ^ (Required) The AWS Lambda action you want to allow in this statement. (e.g. @lambda:InvokeFunction@ ) -}
    , _function_name :: !(TF.Argument "function_name" Text)
    {- ^ (Required) Name of the Lambda function whose resource policy you are updating -}
    , _principal :: !(TF.Argument "principal" Text)
    {- ^ (Required) The principal who is getting this permission. e.g. @s3.amazonaws.com@ , an AWS account ID, or any valid AWS service principal such as @events.amazonaws.com@ or @sns.amazonaws.com@ . -}
    , _qualifier :: !(TF.Argument "qualifier" Text)
    {- ^ (Optional) Query parameter to specify function version or alias name. The permission will then apply to the specific qualified ARN. e.g. @arn:aws:lambda:aws-region:acct-id:function:function-name:2@ -}
    , _source_account :: !(TF.Argument "source_account" Text)
    {- ^ (Optional) The AWS account ID (without a hyphen) of the source owner. -}
    , _source_arn :: !(TF.Argument "source_arn" Text)
    {- ^ (Optional) When granting Amazon S3 or CloudWatch Events permission to invoke your function, you should specify this field with the Amazon Resource Name (ARN) for the S3 Bucket or CloudWatch Events Rule as its value.  This ensures that only events generated from the specified bucket or rule can invoke the function. API Gateway ARNs have a unique structure described <http://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-control-access-using-iam-policies-to-invoke-api.html> . -}
    , _statement_id :: !(TF.Argument "statement_id" Text)
    {- ^ (Required) A unique statement identifier. -}
    } deriving (Show, Eq)

instance TF.ToHCL LambdaPermissionResource where
    toHCL LambdaPermissionResource{..} = TF.block $ catMaybes
        [ TF.argument _action
        , TF.argument _function_name
        , TF.argument _principal
        , TF.argument _qualifier
        , TF.argument _source_account
        , TF.argument _source_arn
        , TF.argument _statement_id
        ]

instance HasAction LambdaPermissionResource Text where
    action =
        lens (_action :: LambdaPermissionResource -> TF.Argument "action" Text)
             (\s a -> s { _action = a } :: LambdaPermissionResource)

instance HasFunctionName LambdaPermissionResource Text where
    functionName =
        lens (_function_name :: LambdaPermissionResource -> TF.Argument "function_name" Text)
             (\s a -> s { _function_name = a } :: LambdaPermissionResource)

instance HasPrincipal LambdaPermissionResource Text where
    principal =
        lens (_principal :: LambdaPermissionResource -> TF.Argument "principal" Text)
             (\s a -> s { _principal = a } :: LambdaPermissionResource)

instance HasQualifier LambdaPermissionResource Text where
    qualifier =
        lens (_qualifier :: LambdaPermissionResource -> TF.Argument "qualifier" Text)
             (\s a -> s { _qualifier = a } :: LambdaPermissionResource)

instance HasSourceAccount LambdaPermissionResource Text where
    sourceAccount =
        lens (_source_account :: LambdaPermissionResource -> TF.Argument "source_account" Text)
             (\s a -> s { _source_account = a } :: LambdaPermissionResource)

instance HasSourceArn LambdaPermissionResource Text where
    sourceArn =
        lens (_source_arn :: LambdaPermissionResource -> TF.Argument "source_arn" Text)
             (\s a -> s { _source_arn = a } :: LambdaPermissionResource)

instance HasStatementId LambdaPermissionResource Text where
    statementId =
        lens (_statement_id :: LambdaPermissionResource -> TF.Argument "statement_id" Text)
             (\s a -> s { _statement_id = a } :: LambdaPermissionResource)

lambdaPermissionResource :: TF.Resource TF.AWS LambdaPermissionResource
lambdaPermissionResource =
    TF.newResource "aws_lambda_permission" $
        LambdaPermissionResource {
            _action = TF.Nil
            , _function_name = TF.Nil
            , _principal = TF.Nil
            , _qualifier = TF.Nil
            , _source_account = TF.Nil
            , _source_arn = TF.Nil
            , _statement_id = TF.Nil
            }

{- | The @aws_launch_configuration@ AWS resource.

Provides a resource to create a new launch configuration, used for
autoscaling groups.
-}
data LaunchConfigurationResource = LaunchConfigurationResource {
      _associate_public_ip_address :: !(TF.Argument "associate_public_ip_address" Text)
    {- ^ (Optional) Associate a public ip address with an instance in a VPC. -}
    , _ebs_block_device :: !(TF.Argument "ebs_block_device" Text)
    {- ^ (Optional) Additional EBS block devices to attach to the instance.  See <#block-devices> below for details. -}
    , _ebs_optimized :: !(TF.Argument "ebs_optimized" Text)
    {- ^ (Optional) If true, the launched EC2 instance will be EBS-optimized. -}
    , _enable_monitoring :: !(TF.Argument "enable_monitoring" TF.Bool)
    {- ^ (Optional) Enables/disables detailed monitoring. This is enabled by default. -}
    , _ephemeral_block_device :: !(TF.Argument "ephemeral_block_device" Text)
    {- ^ (Optional) Customize Ephemeral (also known as "Instance Store") volumes on the instance. See <#block-devices> below for details. -}
    , _iam_instance_profile :: !(TF.Argument "iam_instance_profile" Text)
    {- ^ (Optional) The IAM instance profile to associate with launched instances. -}
    , _image_id :: !(TF.Argument "image_id" Text)
    {- ^ (Required) The EC2 image ID to launch. -}
    , _instance_type :: !(TF.Argument "instance_type" Text)
    {- ^ (Required) The size of instance to launch. -}
    , _key_name :: !(TF.Argument "key_name" Text)
    {- ^ (Optional) The key name that should be used for the instance. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Optional) The name of the launch configuration. If you leave this blank, Terraform will auto-generate a unique name. -}
    , _name_prefix :: !(TF.Argument "name_prefix" Text)
    {- ^ (Optional) Creates a unique name beginning with the specified prefix. Conflicts with @name@ . -}
    , _placement_tenancy :: !(TF.Argument "placement_tenancy" Text)
    {- ^ (Optional) The tenancy of the instance. Valid values are @"default"@ or @"dedicated"@ , see <http://docs.aws.amazon.com/AutoScaling/latest/APIReference/API_CreateLaunchConfiguration.html> for more details -}
    , _root_block_device :: !(TF.Argument "root_block_device" Text)
    {- ^ (Optional) Customize details about the root block device of the instance. See <#block-devices> below for details. -}
    , _security_groups :: !(TF.Argument "security_groups" Text)
    {- ^ (Optional) A list of associated security group IDS. -}
    , _spot_price :: !(TF.Argument "spot_price" Text)
    {- ^ (Optional) The price to use for reserving spot instances. -}
    , _user_data :: !(TF.Argument "user_data" Text)
    {- ^ (Optional) The user data to provide when launching the instance. -}
    , _vpc_classic_link_id :: !(TF.Argument "vpc_classic_link_id" Text)
    {- ^ (Optional) The ID of a ClassicLink-enabled VPC. Only applies to EC2-Classic instances. (eg. @vpc-2730681a@ ) -}
    , _vpc_classic_link_security_groups :: !(TF.Argument "vpc_classic_link_security_groups" Text)
    {- ^ (Optional) The IDs of one or more security groups for the specified ClassicLink-enabled VPC (eg. @sg-46ae3d11@ ). -}
    } deriving (Show, Eq)

instance TF.ToHCL LaunchConfigurationResource where
    toHCL LaunchConfigurationResource{..} = TF.block $ catMaybes
        [ TF.argument _associate_public_ip_address
        , TF.argument _ebs_block_device
        , TF.argument _ebs_optimized
        , TF.argument _enable_monitoring
        , TF.argument _ephemeral_block_device
        , TF.argument _iam_instance_profile
        , TF.argument _image_id
        , TF.argument _instance_type
        , TF.argument _key_name
        , TF.argument _name
        , TF.argument _name_prefix
        , TF.argument _placement_tenancy
        , TF.argument _root_block_device
        , TF.argument _security_groups
        , TF.argument _spot_price
        , TF.argument _user_data
        , TF.argument _vpc_classic_link_id
        , TF.argument _vpc_classic_link_security_groups
        ]

instance HasAssociatePublicIpAddress LaunchConfigurationResource Text where
    associatePublicIpAddress =
        lens (_associate_public_ip_address :: LaunchConfigurationResource -> TF.Argument "associate_public_ip_address" Text)
             (\s a -> s { _associate_public_ip_address = a } :: LaunchConfigurationResource)

instance HasEbsBlockDevice LaunchConfigurationResource Text where
    ebsBlockDevice =
        lens (_ebs_block_device :: LaunchConfigurationResource -> TF.Argument "ebs_block_device" Text)
             (\s a -> s { _ebs_block_device = a } :: LaunchConfigurationResource)

instance HasEbsOptimized LaunchConfigurationResource Text where
    ebsOptimized =
        lens (_ebs_optimized :: LaunchConfigurationResource -> TF.Argument "ebs_optimized" Text)
             (\s a -> s { _ebs_optimized = a } :: LaunchConfigurationResource)

instance HasEnableMonitoring LaunchConfigurationResource TF.Bool where
    enableMonitoring =
        lens (_enable_monitoring :: LaunchConfigurationResource -> TF.Argument "enable_monitoring" TF.Bool)
             (\s a -> s { _enable_monitoring = a } :: LaunchConfigurationResource)

instance HasEphemeralBlockDevice LaunchConfigurationResource Text where
    ephemeralBlockDevice =
        lens (_ephemeral_block_device :: LaunchConfigurationResource -> TF.Argument "ephemeral_block_device" Text)
             (\s a -> s { _ephemeral_block_device = a } :: LaunchConfigurationResource)

instance HasIamInstanceProfile LaunchConfigurationResource Text where
    iamInstanceProfile =
        lens (_iam_instance_profile :: LaunchConfigurationResource -> TF.Argument "iam_instance_profile" Text)
             (\s a -> s { _iam_instance_profile = a } :: LaunchConfigurationResource)

instance HasImageId LaunchConfigurationResource Text where
    imageId =
        lens (_image_id :: LaunchConfigurationResource -> TF.Argument "image_id" Text)
             (\s a -> s { _image_id = a } :: LaunchConfigurationResource)

instance HasInstanceType LaunchConfigurationResource Text where
    instanceType =
        lens (_instance_type :: LaunchConfigurationResource -> TF.Argument "instance_type" Text)
             (\s a -> s { _instance_type = a } :: LaunchConfigurationResource)

instance HasKeyName LaunchConfigurationResource Text where
    keyName =
        lens (_key_name :: LaunchConfigurationResource -> TF.Argument "key_name" Text)
             (\s a -> s { _key_name = a } :: LaunchConfigurationResource)

instance HasName LaunchConfigurationResource Text where
    name =
        lens (_name :: LaunchConfigurationResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: LaunchConfigurationResource)

instance HasNamePrefix LaunchConfigurationResource Text where
    namePrefix =
        lens (_name_prefix :: LaunchConfigurationResource -> TF.Argument "name_prefix" Text)
             (\s a -> s { _name_prefix = a } :: LaunchConfigurationResource)

instance HasPlacementTenancy LaunchConfigurationResource Text where
    placementTenancy =
        lens (_placement_tenancy :: LaunchConfigurationResource -> TF.Argument "placement_tenancy" Text)
             (\s a -> s { _placement_tenancy = a } :: LaunchConfigurationResource)

instance HasRootBlockDevice LaunchConfigurationResource Text where
    rootBlockDevice =
        lens (_root_block_device :: LaunchConfigurationResource -> TF.Argument "root_block_device" Text)
             (\s a -> s { _root_block_device = a } :: LaunchConfigurationResource)

instance HasSecurityGroups LaunchConfigurationResource Text where
    securityGroups =
        lens (_security_groups :: LaunchConfigurationResource -> TF.Argument "security_groups" Text)
             (\s a -> s { _security_groups = a } :: LaunchConfigurationResource)

instance HasSpotPrice LaunchConfigurationResource Text where
    spotPrice =
        lens (_spot_price :: LaunchConfigurationResource -> TF.Argument "spot_price" Text)
             (\s a -> s { _spot_price = a } :: LaunchConfigurationResource)

instance HasUserData LaunchConfigurationResource Text where
    userData =
        lens (_user_data :: LaunchConfigurationResource -> TF.Argument "user_data" Text)
             (\s a -> s { _user_data = a } :: LaunchConfigurationResource)

instance HasVpcClassicLinkId LaunchConfigurationResource Text where
    vpcClassicLinkId =
        lens (_vpc_classic_link_id :: LaunchConfigurationResource -> TF.Argument "vpc_classic_link_id" Text)
             (\s a -> s { _vpc_classic_link_id = a } :: LaunchConfigurationResource)

instance HasVpcClassicLinkSecurityGroups LaunchConfigurationResource Text where
    vpcClassicLinkSecurityGroups =
        lens (_vpc_classic_link_security_groups :: LaunchConfigurationResource -> TF.Argument "vpc_classic_link_security_groups" Text)
             (\s a -> s { _vpc_classic_link_security_groups = a } :: LaunchConfigurationResource)

launchConfigurationResource :: TF.Resource TF.AWS LaunchConfigurationResource
launchConfigurationResource =
    TF.newResource "aws_launch_configuration" $
        LaunchConfigurationResource {
            _associate_public_ip_address = TF.Nil
            , _ebs_block_device = TF.Nil
            , _ebs_optimized = TF.Nil
            , _enable_monitoring = TF.Nil
            , _ephemeral_block_device = TF.Nil
            , _iam_instance_profile = TF.Nil
            , _image_id = TF.Nil
            , _instance_type = TF.Nil
            , _key_name = TF.Nil
            , _name = TF.Nil
            , _name_prefix = TF.Nil
            , _placement_tenancy = TF.Nil
            , _root_block_device = TF.Nil
            , _security_groups = TF.Nil
            , _spot_price = TF.Nil
            , _user_data = TF.Nil
            , _vpc_classic_link_id = TF.Nil
            , _vpc_classic_link_security_groups = TF.Nil
            }

{- | The @aws_lb_cookie_stickiness_policy@ AWS resource.

Provides a load balancer cookie stickiness policy, which allows an ELB to
control the sticky session lifetime of the browser.
-}
data LbCookieStickinessPolicyResource = LbCookieStickinessPolicyResource {
      _cookie_expiration_period :: !(TF.Argument "cookie_expiration_period" Text)
    {- ^ (Optional) The time period after which the session cookie should be considered stale, expressed in seconds. -}
    , _lb_port :: !(TF.Argument "lb_port" TF.Word16)
    {- ^ (Required) The load balancer port to which the policy should be applied. This must be an active listener on the load balancer. -}
    , _load_balancer :: !(TF.Argument "load_balancer" Text)
    {- ^ (Required) The load balancer to which the policy should be attached. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the stickiness policy. -}
    } deriving (Show, Eq)

instance TF.ToHCL LbCookieStickinessPolicyResource where
    toHCL LbCookieStickinessPolicyResource{..} = TF.block $ catMaybes
        [ TF.argument _cookie_expiration_period
        , TF.argument _lb_port
        , TF.argument _load_balancer
        , TF.argument _name
        ]

instance HasCookieExpirationPeriod LbCookieStickinessPolicyResource Text where
    cookieExpirationPeriod =
        lens (_cookie_expiration_period :: LbCookieStickinessPolicyResource -> TF.Argument "cookie_expiration_period" Text)
             (\s a -> s { _cookie_expiration_period = a } :: LbCookieStickinessPolicyResource)

instance HasLbPort LbCookieStickinessPolicyResource TF.Word16 where
    lbPort =
        lens (_lb_port :: LbCookieStickinessPolicyResource -> TF.Argument "lb_port" TF.Word16)
             (\s a -> s { _lb_port = a } :: LbCookieStickinessPolicyResource)

instance HasLoadBalancer LbCookieStickinessPolicyResource Text where
    loadBalancer =
        lens (_load_balancer :: LbCookieStickinessPolicyResource -> TF.Argument "load_balancer" Text)
             (\s a -> s { _load_balancer = a } :: LbCookieStickinessPolicyResource)

instance HasName LbCookieStickinessPolicyResource Text where
    name =
        lens (_name :: LbCookieStickinessPolicyResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: LbCookieStickinessPolicyResource)

instance HasComputedCookieExpirationPeriod LbCookieStickinessPolicyResource Text where
    computedCookieExpirationPeriod =
        to (\_  -> TF.Compute "cookie_expiration_period")

instance HasComputedId LbCookieStickinessPolicyResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedLbPort LbCookieStickinessPolicyResource TF.Word16 where
    computedLbPort =
        to (\_  -> TF.Compute "lb_port")

instance HasComputedLoadBalancer LbCookieStickinessPolicyResource Text where
    computedLoadBalancer =
        to (\_  -> TF.Compute "load_balancer")

instance HasComputedName LbCookieStickinessPolicyResource Text where
    computedName =
        to (\_  -> TF.Compute "name")

lbCookieStickinessPolicyResource :: TF.Resource TF.AWS LbCookieStickinessPolicyResource
lbCookieStickinessPolicyResource =
    TF.newResource "aws_lb_cookie_stickiness_policy" $
        LbCookieStickinessPolicyResource {
            _cookie_expiration_period = TF.Nil
            , _lb_port = TF.Nil
            , _load_balancer = TF.Nil
            , _name = TF.Nil
            }

{- | The @aws_lb_listener@ AWS resource.

Provides a Load Balancer Listener resource. ~> Note:  @aws_alb_listener@ is
known as @aws_lb_listener@ . The functionality is identical.
-}
data LbListenerResource = LbListenerResource {
      _certificate_arn :: !(TF.Argument "certificate_arn" Text)
    {- ^ (Optional) The ARN of the SSL server certificate. Exactly one certificate is required if the protocol is HTTPS. -}
    , _default_action :: !(TF.Argument "default_action" Text)
    {- ^ (Required) An Action block. Action blocks are documented below. -}
    , _load_balancer_arn :: !(TF.Argument "load_balancer_arn" Text)
    {- ^ (Required, Forces New Resource) The ARN of the load balancer. -}
    , _port :: !(TF.Argument "port" Text)
    {- ^ (Required) The port on which the load balancer is listening. -}
    , _protocol :: !(TF.Argument "protocol" Text)
    {- ^ (Optional) The protocol for connections from clients to the load balancer. Valid values are @TCP@ , @HTTP@ and @HTTPS@ . Defaults to @HTTP@ . -}
    , _ssl_policy :: !(TF.Argument "ssl_policy" Text)
    {- ^ (Optional) The name of the SSL Policy for the listener. Required if @protocol@ is @HTTPS@ . -}
    } deriving (Show, Eq)

instance TF.ToHCL LbListenerResource where
    toHCL LbListenerResource{..} = TF.block $ catMaybes
        [ TF.argument _certificate_arn
        , TF.argument _default_action
        , TF.argument _load_balancer_arn
        , TF.argument _port
        , TF.argument _protocol
        , TF.argument _ssl_policy
        ]

instance HasCertificateArn LbListenerResource Text where
    certificateArn =
        lens (_certificate_arn :: LbListenerResource -> TF.Argument "certificate_arn" Text)
             (\s a -> s { _certificate_arn = a } :: LbListenerResource)

instance HasDefaultAction LbListenerResource Text where
    defaultAction =
        lens (_default_action :: LbListenerResource -> TF.Argument "default_action" Text)
             (\s a -> s { _default_action = a } :: LbListenerResource)

instance HasLoadBalancerArn LbListenerResource Text where
    loadBalancerArn =
        lens (_load_balancer_arn :: LbListenerResource -> TF.Argument "load_balancer_arn" Text)
             (\s a -> s { _load_balancer_arn = a } :: LbListenerResource)

instance HasPort LbListenerResource Text where
    port =
        lens (_port :: LbListenerResource -> TF.Argument "port" Text)
             (\s a -> s { _port = a } :: LbListenerResource)

instance HasProtocol LbListenerResource Text where
    protocol =
        lens (_protocol :: LbListenerResource -> TF.Argument "protocol" Text)
             (\s a -> s { _protocol = a } :: LbListenerResource)

instance HasSslPolicy LbListenerResource Text where
    sslPolicy =
        lens (_ssl_policy :: LbListenerResource -> TF.Argument "ssl_policy" Text)
             (\s a -> s { _ssl_policy = a } :: LbListenerResource)

instance HasComputedArn LbListenerResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

instance HasComputedId LbListenerResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

lbListenerResource :: TF.Resource TF.AWS LbListenerResource
lbListenerResource =
    TF.newResource "aws_lb_listener" $
        LbListenerResource {
            _certificate_arn = TF.Nil
            , _default_action = TF.Nil
            , _load_balancer_arn = TF.Nil
            , _port = TF.Nil
            , _protocol = TF.Nil
            , _ssl_policy = TF.Nil
            }

{- | The @aws_lb_listener_rule@ AWS resource.

Provides a Load Balancer Listener Rule resource. ~> Note:
@aws_alb_listener_rule@ is known as @aws_lb_listener_rule@ . The
functionality is identical.
-}
data LbListenerRuleResource = LbListenerRuleResource {
      _action :: !(TF.Argument "action" Text)
    {- ^ (Required) An Action block. Action blocks are documented below. -}
    , _condition :: !(TF.Argument "condition" Text)
    {- ^ (Required) A Condition block. Condition blocks are documented below. -}
    , _listener_arn :: !(TF.Argument "listener_arn" Text)
    {- ^ (Required, Forces New Resource) The ARN of the listener to which to attach the rule. -}
    , _priority :: !(TF.Argument "priority" Text)
    {- ^ (Required) The priority for the rule. A listener can't have multiple rules with the same priority. -}
    } deriving (Show, Eq)

instance TF.ToHCL LbListenerRuleResource where
    toHCL LbListenerRuleResource{..} = TF.block $ catMaybes
        [ TF.argument _action
        , TF.argument _condition
        , TF.argument _listener_arn
        , TF.argument _priority
        ]

instance HasAction LbListenerRuleResource Text where
    action =
        lens (_action :: LbListenerRuleResource -> TF.Argument "action" Text)
             (\s a -> s { _action = a } :: LbListenerRuleResource)

instance HasCondition LbListenerRuleResource Text where
    condition =
        lens (_condition :: LbListenerRuleResource -> TF.Argument "condition" Text)
             (\s a -> s { _condition = a } :: LbListenerRuleResource)

instance HasListenerArn LbListenerRuleResource Text where
    listenerArn =
        lens (_listener_arn :: LbListenerRuleResource -> TF.Argument "listener_arn" Text)
             (\s a -> s { _listener_arn = a } :: LbListenerRuleResource)

instance HasPriority LbListenerRuleResource Text where
    priority =
        lens (_priority :: LbListenerRuleResource -> TF.Argument "priority" Text)
             (\s a -> s { _priority = a } :: LbListenerRuleResource)

instance HasComputedArn LbListenerRuleResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

instance HasComputedId LbListenerRuleResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

lbListenerRuleResource :: TF.Resource TF.AWS LbListenerRuleResource
lbListenerRuleResource =
    TF.newResource "aws_lb_listener_rule" $
        LbListenerRuleResource {
            _action = TF.Nil
            , _condition = TF.Nil
            , _listener_arn = TF.Nil
            , _priority = TF.Nil
            }

{- | The @aws_lb@ AWS resource.

Provides a Load Balancer resource. ~> Note:  @aws_alb@ is known as @aws_lb@
. The functionality is identical.
-}
data LbResource = LbResource {
      _access_logs :: !(TF.Argument "access_logs" Text)
    {- ^ (Optional) An Access Logs block. Access Logs documented below. -}
    , _enable_deletion_protection :: !(TF.Argument "enable_deletion_protection" TF.Bool)
    {- ^ (Optional) If true, deletion of the load balancer will be disabled via the AWS API. This will prevent Terraform from deleting the load balancer. Defaults to @false@ . -}
    , _idle_timeout :: !(TF.Argument "idle_timeout" Text)
    {- ^ (Optional) The time in seconds that the connection is allowed to be idle. Default: 60. -}
    , _internal :: !(TF.Argument "internal" Text)
    {- ^ (Optional) If true, the LB will be internal. -}
    , _ip_address_type :: !(TF.Argument "ip_address_type" Text)
    {- ^ (Optional) The type of IP addresses used by the subnets for your load balancer. The possible values are @ipv4@ and @dualstack@ -}
    , _load_balancer_type :: !(TF.Argument "load_balancer_type" Text)
    {- ^ (Optional) The type of load balancer to create. Possible values are @application@ or @network@ . The default value is @application@ . -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Optional) The name of the LB. This name must be unique within your AWS account, can have a maximum of 32 characters, must contain only alphanumeric characters or hyphens, and must not begin or end with a hyphen. If not specified, Terraform will autogenerate a name beginning with @tf-lb@ . -}
    , _name_prefix :: !(TF.Argument "name_prefix" Text)
    {- ^ (Optional) Creates a unique name beginning with the specified prefix. Conflicts with @name@ . -}
    , _security_groups :: !(TF.Argument "security_groups" Text)
    {- ^ (Optional) A list of security group IDs to assign to the LB. Only valid for Load Balancers of type @application@ . -}
    , _subnet_mapping :: !(TF.Argument "subnet_mapping" Text)
    {- ^ (Optional) A subnet mapping block as documented below. -}
    , _subnets :: !(TF.Argument "subnets" Text)
    {- ^ (Optional) A list of subnet IDs to attach to the LB. Subnets cannot be updated for Load Balancers of type @network@ . Changing this value will for load balancers of type @network@ will force a recreation of the resource. -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    } deriving (Show, Eq)

instance TF.ToHCL LbResource where
    toHCL LbResource{..} = TF.block $ catMaybes
        [ TF.argument _access_logs
        , TF.argument _enable_deletion_protection
        , TF.argument _idle_timeout
        , TF.argument _internal
        , TF.argument _ip_address_type
        , TF.argument _load_balancer_type
        , TF.argument _name
        , TF.argument _name_prefix
        , TF.argument _security_groups
        , TF.argument _subnet_mapping
        , TF.argument _subnets
        , TF.argument _tags
        ]

instance HasAccessLogs LbResource Text where
    accessLogs =
        lens (_access_logs :: LbResource -> TF.Argument "access_logs" Text)
             (\s a -> s { _access_logs = a } :: LbResource)

instance HasEnableDeletionProtection LbResource TF.Bool where
    enableDeletionProtection =
        lens (_enable_deletion_protection :: LbResource -> TF.Argument "enable_deletion_protection" TF.Bool)
             (\s a -> s { _enable_deletion_protection = a } :: LbResource)

instance HasIdleTimeout LbResource Text where
    idleTimeout =
        lens (_idle_timeout :: LbResource -> TF.Argument "idle_timeout" Text)
             (\s a -> s { _idle_timeout = a } :: LbResource)

instance HasInternal LbResource Text where
    internal =
        lens (_internal :: LbResource -> TF.Argument "internal" Text)
             (\s a -> s { _internal = a } :: LbResource)

instance HasIpAddressType LbResource Text where
    ipAddressType =
        lens (_ip_address_type :: LbResource -> TF.Argument "ip_address_type" Text)
             (\s a -> s { _ip_address_type = a } :: LbResource)

instance HasLoadBalancerType LbResource Text where
    loadBalancerType =
        lens (_load_balancer_type :: LbResource -> TF.Argument "load_balancer_type" Text)
             (\s a -> s { _load_balancer_type = a } :: LbResource)

instance HasName LbResource Text where
    name =
        lens (_name :: LbResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: LbResource)

instance HasNamePrefix LbResource Text where
    namePrefix =
        lens (_name_prefix :: LbResource -> TF.Argument "name_prefix" Text)
             (\s a -> s { _name_prefix = a } :: LbResource)

instance HasSecurityGroups LbResource Text where
    securityGroups =
        lens (_security_groups :: LbResource -> TF.Argument "security_groups" Text)
             (\s a -> s { _security_groups = a } :: LbResource)

instance HasSubnetMapping LbResource Text where
    subnetMapping =
        lens (_subnet_mapping :: LbResource -> TF.Argument "subnet_mapping" Text)
             (\s a -> s { _subnet_mapping = a } :: LbResource)

instance HasSubnets LbResource Text where
    subnets =
        lens (_subnets :: LbResource -> TF.Argument "subnets" Text)
             (\s a -> s { _subnets = a } :: LbResource)

instance HasTags LbResource TF.Tags where
    tags =
        lens (_tags :: LbResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: LbResource)

instance HasComputedArn LbResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

instance HasComputedArnSuffix LbResource Text where
    computedArnSuffix =
        to (\_  -> TF.Compute "arn_suffix")

instance HasComputedCanonicalHostedZoneId LbResource Text where
    computedCanonicalHostedZoneId =
        to (\_  -> TF.Compute "canonical_hosted_zone_id")

instance HasComputedDnsName LbResource Text where
    computedDnsName =
        to (\_  -> TF.Compute "dns_name")

instance HasComputedId LbResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedZoneId LbResource Text where
    computedZoneId =
        to (\_  -> TF.Compute "zone_id")

lbResource :: TF.Resource TF.AWS LbResource
lbResource =
    TF.newResource "aws_lb" $
        LbResource {
            _access_logs = TF.Nil
            , _enable_deletion_protection = TF.Nil
            , _idle_timeout = TF.Nil
            , _internal = TF.Nil
            , _ip_address_type = TF.Nil
            , _load_balancer_type = TF.Nil
            , _name = TF.Nil
            , _name_prefix = TF.Nil
            , _security_groups = TF.Nil
            , _subnet_mapping = TF.Nil
            , _subnets = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_lb_ssl_negotiation_policy@ AWS resource.

Provides a load balancer SSL negotiation policy, which allows an ELB to
control the ciphers and protocols that are supported during SSL negotiations
between a client and a load balancer.
-}
data LbSslNegotiationPolicyResource = LbSslNegotiationPolicyResource {
      _attribute :: !(TF.Argument "attribute" Text)
    {- ^ (Optional) An SSL Negotiation policy attribute. Each has two properties: -}
    , _lb_port :: !(TF.Argument "lb_port" TF.Word16)
    {- ^ (Required) The load balancer port to which the policy should be applied. This must be an active listener on the load balancer. -}
    , _load_balancer :: !(TF.Argument "load_balancer" Text)
    {- ^ (Required) The load balancer to which the policy should be attached. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the SSL negotiation policy. -}
    } deriving (Show, Eq)

instance TF.ToHCL LbSslNegotiationPolicyResource where
    toHCL LbSslNegotiationPolicyResource{..} = TF.block $ catMaybes
        [ TF.argument _attribute
        , TF.argument _lb_port
        , TF.argument _load_balancer
        , TF.argument _name
        ]

instance HasAttribute LbSslNegotiationPolicyResource Text where
    attribute =
        lens (_attribute :: LbSslNegotiationPolicyResource -> TF.Argument "attribute" Text)
             (\s a -> s { _attribute = a } :: LbSslNegotiationPolicyResource)

instance HasLbPort LbSslNegotiationPolicyResource TF.Word16 where
    lbPort =
        lens (_lb_port :: LbSslNegotiationPolicyResource -> TF.Argument "lb_port" TF.Word16)
             (\s a -> s { _lb_port = a } :: LbSslNegotiationPolicyResource)

instance HasLoadBalancer LbSslNegotiationPolicyResource Text where
    loadBalancer =
        lens (_load_balancer :: LbSslNegotiationPolicyResource -> TF.Argument "load_balancer" Text)
             (\s a -> s { _load_balancer = a } :: LbSslNegotiationPolicyResource)

instance HasName LbSslNegotiationPolicyResource Text where
    name =
        lens (_name :: LbSslNegotiationPolicyResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: LbSslNegotiationPolicyResource)

instance HasComputedAttribute LbSslNegotiationPolicyResource Text where
    computedAttribute =
        to (\_  -> TF.Compute "attribute")

instance HasComputedId LbSslNegotiationPolicyResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedLbPort LbSslNegotiationPolicyResource TF.Word16 where
    computedLbPort =
        to (\_  -> TF.Compute "lb_port")

instance HasComputedLoadBalancer LbSslNegotiationPolicyResource Text where
    computedLoadBalancer =
        to (\_  -> TF.Compute "load_balancer")

instance HasComputedName LbSslNegotiationPolicyResource Text where
    computedName =
        to (\_  -> TF.Compute "name")

lbSslNegotiationPolicyResource :: TF.Resource TF.AWS LbSslNegotiationPolicyResource
lbSslNegotiationPolicyResource =
    TF.newResource "aws_lb_ssl_negotiation_policy" $
        LbSslNegotiationPolicyResource {
            _attribute = TF.Nil
            , _lb_port = TF.Nil
            , _load_balancer = TF.Nil
            , _name = TF.Nil
            }

{- | The @aws_lb_target_group_attachment@ AWS resource.

Provides the ability to register instances and containers with a LB target
group ~> Note:  @aws_alb_target_group_attachment@ is known as
@aws_lb_target_group_attachment@ . The functionality is identical.
-}
data LbTargetGroupAttachmentResource = LbTargetGroupAttachmentResource {
      _availability_zone :: !(TF.Argument "availability_zone" TF.Zone)
    {- ^ (Optional) The Availability Zone where the IP address of the target is to be registered. -}
    , _port :: !(TF.Argument "port" Text)
    {- ^ (Optional) The port on which targets receive traffic. -}
    , _target_group_arn :: !(TF.Argument "target_group_arn" Text)
    {- ^ (Required) The ARN of the target group with which to register targets -}
    , _target_id :: !(TF.Argument "target_id" Text)
    {- ^ (Required) The ID of the target. This is the Instance ID for an instance, or the container ID for an ECS container. If the target type is ip, specify an IP address. -}
    } deriving (Show, Eq)

instance TF.ToHCL LbTargetGroupAttachmentResource where
    toHCL LbTargetGroupAttachmentResource{..} = TF.block $ catMaybes
        [ TF.argument _availability_zone
        , TF.argument _port
        , TF.argument _target_group_arn
        , TF.argument _target_id
        ]

instance HasAvailabilityZone LbTargetGroupAttachmentResource TF.Zone where
    availabilityZone =
        lens (_availability_zone :: LbTargetGroupAttachmentResource -> TF.Argument "availability_zone" TF.Zone)
             (\s a -> s { _availability_zone = a } :: LbTargetGroupAttachmentResource)

instance HasPort LbTargetGroupAttachmentResource Text where
    port =
        lens (_port :: LbTargetGroupAttachmentResource -> TF.Argument "port" Text)
             (\s a -> s { _port = a } :: LbTargetGroupAttachmentResource)

instance HasTargetGroupArn LbTargetGroupAttachmentResource Text where
    targetGroupArn =
        lens (_target_group_arn :: LbTargetGroupAttachmentResource -> TF.Argument "target_group_arn" Text)
             (\s a -> s { _target_group_arn = a } :: LbTargetGroupAttachmentResource)

instance HasTargetId LbTargetGroupAttachmentResource Text where
    targetId =
        lens (_target_id :: LbTargetGroupAttachmentResource -> TF.Argument "target_id" Text)
             (\s a -> s { _target_id = a } :: LbTargetGroupAttachmentResource)

instance HasComputedId LbTargetGroupAttachmentResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

lbTargetGroupAttachmentResource :: TF.Resource TF.AWS LbTargetGroupAttachmentResource
lbTargetGroupAttachmentResource =
    TF.newResource "aws_lb_target_group_attachment" $
        LbTargetGroupAttachmentResource {
            _availability_zone = TF.Nil
            , _port = TF.Nil
            , _target_group_arn = TF.Nil
            , _target_id = TF.Nil
            }

{- | The @aws_lb_target_group@ AWS resource.

Provides a Target Group resource for use with Load Balancer resources. ~>
Note:  @aws_alb_target_group@ is known as @aws_lb_target_group@ . The
functionality is identical.
-}
data LbTargetGroupResource = LbTargetGroupResource {
      _deregistration_delay :: !(TF.Argument "deregistration_delay" Text)
    {- ^ (Optional) The amount time for Elastic Load Balancing to wait before changing the state of a deregistering target from draining to unused. The range is 0-3600 seconds. The default value is 300 seconds. -}
    , _health_check :: !(TF.Argument "health_check" Text)
    {- ^ (Optional) A Health Check block. Health Check blocks are documented below. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Optional, Forces new resource) The name of the target group. If omitted, Terraform will assign a random, unique name. -}
    , _name_prefix :: !(TF.Argument "name_prefix" Text)
    {- ^ (Optional, Forces new resource) Creates a unique name beginning with the specified prefix. Conflicts with @name@ . -}
    , _port :: !(TF.Argument "port" Text)
    {- ^ (Required) The port on which targets receive traffic, unless overridden when registering a specific target. -}
    , _protocol :: !(TF.Argument "protocol" Text)
    {- ^ (Required) The protocol to use for routing traffic to the targets. -}
    , _stickiness :: !(TF.Argument "stickiness" Text)
    {- ^ (Optional) A Stickiness block. Stickiness blocks are documented below. @stickiness@ is only valid if used with Load Balancers of type @Application@ -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    , _target_type :: !(TF.Argument "target_type" Text)
    {- ^ (Optional) The type of target that you must specify when registering targets with this target group. The possible values are @instance@ (targets are specified by instance ID) or @ip@ (targets are specified by IP address). The default is @instance@ . Note that you can't specify targets for a target group using both instance IDs and IP addresses. If the target type is @ip@ , specify IP addresses from the subnets of the virtual private cloud (VPC) for the target group, the RFC 1918 range (10.0.0.0/8, 172.16.0.0/12, and 192.168.0.0/16), and the RFC 6598 range (100.64.0.0/10). You can't specify publicly routable IP addresses. -}
    , _vpc_id :: !(TF.Argument "vpc_id" Text)
    {- ^ (Required) The identifier of the VPC in which to create the target group. -}
    } deriving (Show, Eq)

instance TF.ToHCL LbTargetGroupResource where
    toHCL LbTargetGroupResource{..} = TF.block $ catMaybes
        [ TF.argument _deregistration_delay
        , TF.argument _health_check
        , TF.argument _name
        , TF.argument _name_prefix
        , TF.argument _port
        , TF.argument _protocol
        , TF.argument _stickiness
        , TF.argument _tags
        , TF.argument _target_type
        , TF.argument _vpc_id
        ]

instance HasDeregistrationDelay LbTargetGroupResource Text where
    deregistrationDelay =
        lens (_deregistration_delay :: LbTargetGroupResource -> TF.Argument "deregistration_delay" Text)
             (\s a -> s { _deregistration_delay = a } :: LbTargetGroupResource)

instance HasHealthCheck LbTargetGroupResource Text where
    healthCheck =
        lens (_health_check :: LbTargetGroupResource -> TF.Argument "health_check" Text)
             (\s a -> s { _health_check = a } :: LbTargetGroupResource)

instance HasName LbTargetGroupResource Text where
    name =
        lens (_name :: LbTargetGroupResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: LbTargetGroupResource)

instance HasNamePrefix LbTargetGroupResource Text where
    namePrefix =
        lens (_name_prefix :: LbTargetGroupResource -> TF.Argument "name_prefix" Text)
             (\s a -> s { _name_prefix = a } :: LbTargetGroupResource)

instance HasPort LbTargetGroupResource Text where
    port =
        lens (_port :: LbTargetGroupResource -> TF.Argument "port" Text)
             (\s a -> s { _port = a } :: LbTargetGroupResource)

instance HasProtocol LbTargetGroupResource Text where
    protocol =
        lens (_protocol :: LbTargetGroupResource -> TF.Argument "protocol" Text)
             (\s a -> s { _protocol = a } :: LbTargetGroupResource)

instance HasStickiness LbTargetGroupResource Text where
    stickiness =
        lens (_stickiness :: LbTargetGroupResource -> TF.Argument "stickiness" Text)
             (\s a -> s { _stickiness = a } :: LbTargetGroupResource)

instance HasTags LbTargetGroupResource TF.Tags where
    tags =
        lens (_tags :: LbTargetGroupResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: LbTargetGroupResource)

instance HasTargetType LbTargetGroupResource Text where
    targetType =
        lens (_target_type :: LbTargetGroupResource -> TF.Argument "target_type" Text)
             (\s a -> s { _target_type = a } :: LbTargetGroupResource)

instance HasVpcId LbTargetGroupResource Text where
    vpcId =
        lens (_vpc_id :: LbTargetGroupResource -> TF.Argument "vpc_id" Text)
             (\s a -> s { _vpc_id = a } :: LbTargetGroupResource)

instance HasComputedArn LbTargetGroupResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

instance HasComputedArnSuffix LbTargetGroupResource Text where
    computedArnSuffix =
        to (\_  -> TF.Compute "arn_suffix")

instance HasComputedId LbTargetGroupResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedName LbTargetGroupResource Text where
    computedName =
        to (\_  -> TF.Compute "name")

lbTargetGroupResource :: TF.Resource TF.AWS LbTargetGroupResource
lbTargetGroupResource =
    TF.newResource "aws_lb_target_group" $
        LbTargetGroupResource {
            _deregistration_delay = TF.Nil
            , _health_check = TF.Nil
            , _name = TF.Nil
            , _name_prefix = TF.Nil
            , _port = TF.Nil
            , _protocol = TF.Nil
            , _stickiness = TF.Nil
            , _tags = TF.Nil
            , _target_type = TF.Nil
            , _vpc_id = TF.Nil
            }

{- | The @aws_lightsail_domain@ AWS resource.

Creates a domain resource for the specified domain (e.g., example.com). You
cannot register a new domain name using Lightsail. You must register a
domain name using Amazon Route 53 or another domain name registrar. If you
have already registered your domain, you can enter its name in this
parameter to manage the DNS records for that domain. ~> Note: Lightsail is
currently only supported in a limited number of AWS Regions, please see
<https://lightsail.aws.amazon.com/ls/docs/overview/article/understanding-regions-and-availability-zones-in-amazon-lightsail>
for more details
-}
data LightsailDomainResource = LightsailDomainResource {
      _domain_name :: !(TF.Argument "domain_name" Text)
    {- ^ (Required) The name of the Lightsail domain to manage -}
    } deriving (Show, Eq)

instance TF.ToHCL LightsailDomainResource where
    toHCL LightsailDomainResource{..} = TF.block $ catMaybes
        [ TF.argument _domain_name
        ]

instance HasDomainName LightsailDomainResource Text where
    domainName =
        lens (_domain_name :: LightsailDomainResource -> TF.Argument "domain_name" Text)
             (\s a -> s { _domain_name = a } :: LightsailDomainResource)

instance HasComputedArn LightsailDomainResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

instance HasComputedId LightsailDomainResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

lightsailDomainResource :: TF.Resource TF.AWS LightsailDomainResource
lightsailDomainResource =
    TF.newResource "aws_lightsail_domain" $
        LightsailDomainResource {
            _domain_name = TF.Nil
            }

{- | The @aws_lightsail_instance@ AWS resource.

Provides a Lightsail Instance. Amazon Lightsail is a service to provide easy
virtual private servers with custom software already setup. See
<https://lightsail.aws.amazon.com/ls/docs/getting-started/article/what-is-amazon-lightsail>
for more information. ~> Note: Lightsail is currently only supported in a
limited number of AWS Regions, please see
<https://lightsail.aws.amazon.com/ls/docs/overview/article/understanding-regions-and-availability-zones-in-amazon-lightsail>
for more details
-}
data LightsailInstanceResource = LightsailInstanceResource {
      _availability_zone :: !(TF.Argument "availability_zone" TF.Zone)
    {- ^ (Required) The Availability Zone in which to create your instance. At this time, must be in @us-east-1@ , @us-east-2@ , @us-west-2@ , @eu-west-1@ , @eu-west-2@ , @eu-central-1@ , @ap-southeast-1@ , @ap-southeast-2@ , @ap-northeast-1@ , @ap-south-1@ regions -}
    , _blueprint_id :: !(TF.Argument "blueprint_id" Text)
    {- ^ (Required) The ID for a virtual private server image (see list below) -}
    , _bundle_id :: !(TF.Argument "bundle_id" Text)
    {- ^ (Required) The bundle of specification information (see list below) -}
    , _key_pair_name :: !(TF.Argument "key_pair_name" Text)
    {- ^ (Required) The name of your key pair. Created in the Lightsail console (cannot use @aws_key_pair@ at this time) -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the Lightsail Instance -}
    , _user_data :: !(TF.Argument "user_data" Text)
    {- ^ (Optional) launch script to configure server with additional user data -}
    } deriving (Show, Eq)

instance TF.ToHCL LightsailInstanceResource where
    toHCL LightsailInstanceResource{..} = TF.block $ catMaybes
        [ TF.argument _availability_zone
        , TF.argument _blueprint_id
        , TF.argument _bundle_id
        , TF.argument _key_pair_name
        , TF.argument _name
        , TF.argument _user_data
        ]

instance HasAvailabilityZone LightsailInstanceResource TF.Zone where
    availabilityZone =
        lens (_availability_zone :: LightsailInstanceResource -> TF.Argument "availability_zone" TF.Zone)
             (\s a -> s { _availability_zone = a } :: LightsailInstanceResource)

instance HasBlueprintId LightsailInstanceResource Text where
    blueprintId =
        lens (_blueprint_id :: LightsailInstanceResource -> TF.Argument "blueprint_id" Text)
             (\s a -> s { _blueprint_id = a } :: LightsailInstanceResource)

instance HasBundleId LightsailInstanceResource Text where
    bundleId =
        lens (_bundle_id :: LightsailInstanceResource -> TF.Argument "bundle_id" Text)
             (\s a -> s { _bundle_id = a } :: LightsailInstanceResource)

instance HasKeyPairName LightsailInstanceResource Text where
    keyPairName =
        lens (_key_pair_name :: LightsailInstanceResource -> TF.Argument "key_pair_name" Text)
             (\s a -> s { _key_pair_name = a } :: LightsailInstanceResource)

instance HasName LightsailInstanceResource Text where
    name =
        lens (_name :: LightsailInstanceResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: LightsailInstanceResource)

instance HasUserData LightsailInstanceResource Text where
    userData =
        lens (_user_data :: LightsailInstanceResource -> TF.Argument "user_data" Text)
             (\s a -> s { _user_data = a } :: LightsailInstanceResource)

lightsailInstanceResource :: TF.Resource TF.AWS LightsailInstanceResource
lightsailInstanceResource =
    TF.newResource "aws_lightsail_instance" $
        LightsailInstanceResource {
            _availability_zone = TF.Nil
            , _blueprint_id = TF.Nil
            , _bundle_id = TF.Nil
            , _key_pair_name = TF.Nil
            , _name = TF.Nil
            , _user_data = TF.Nil
            }

{- | The @aws_lightsail_key_pair@ AWS resource.

Provides a Lightsail Key Pair, for use with Lightsail Instances. These key
pairs are seperate from EC2 Key Pairs, and must be created or imported for
use with Lightsail. ~> Note: Lightsail is currently only supported in a
limited number of AWS Regions, please see
<https://lightsail.aws.amazon.com/ls/docs/overview/article/understanding-regions-and-availability-zones-in-amazon-lightsail>
for more details
-}
data LightsailKeyPairResource = LightsailKeyPairResource {
      _name :: !(TF.Argument "name" Text)
    {- ^ (Optional) The name of the Lightsail Key Pair. If omitted, a unique name will be generated by Terraform -}
    , _pgp_key :: !(TF.Argument "pgp_key" Text)
    {- ^ (Optional) An optional PGP key to encrypt the resulting private key material. Only used when creating a new key pair -}
    , _public_key :: !(TF.Argument "public_key" Text)
    {- ^ (Required) The public key material. This public key will be imported into Lightsail -}
    } deriving (Show, Eq)

instance TF.ToHCL LightsailKeyPairResource where
    toHCL LightsailKeyPairResource{..} = TF.block $ catMaybes
        [ TF.argument _name
        , TF.argument _pgp_key
        , TF.argument _public_key
        ]

instance HasName LightsailKeyPairResource Text where
    name =
        lens (_name :: LightsailKeyPairResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: LightsailKeyPairResource)

instance HasPgpKey LightsailKeyPairResource Text where
    pgpKey =
        lens (_pgp_key :: LightsailKeyPairResource -> TF.Argument "pgp_key" Text)
             (\s a -> s { _pgp_key = a } :: LightsailKeyPairResource)

instance HasPublicKey LightsailKeyPairResource Text where
    publicKey =
        lens (_public_key :: LightsailKeyPairResource -> TF.Argument "public_key" Text)
             (\s a -> s { _public_key = a } :: LightsailKeyPairResource)

instance HasComputedArn LightsailKeyPairResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

instance HasComputedEncryptedFingerprint LightsailKeyPairResource Text where
    computedEncryptedFingerprint =
        to (\_  -> TF.Compute "encrypted_fingerprint")

instance HasComputedEncryptedPrivateKey LightsailKeyPairResource Text where
    computedEncryptedPrivateKey =
        to (\_  -> TF.Compute "encrypted_private_key")

instance HasComputedFingerprint LightsailKeyPairResource Text where
    computedFingerprint =
        to (\_  -> TF.Compute "fingerprint")

instance HasComputedId LightsailKeyPairResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedPrivateKey LightsailKeyPairResource Text where
    computedPrivateKey =
        to (\_  -> TF.Compute "private_key")

instance HasComputedPublicKey LightsailKeyPairResource Text where
    computedPublicKey =
        to (\_  -> TF.Compute "public_key")

lightsailKeyPairResource :: TF.Resource TF.AWS LightsailKeyPairResource
lightsailKeyPairResource =
    TF.newResource "aws_lightsail_key_pair" $
        LightsailKeyPairResource {
            _name = TF.Nil
            , _pgp_key = TF.Nil
            , _public_key = TF.Nil
            }

{- | The @aws_lightsail_static_ip_attachment@ AWS resource.

Provides a static IP address attachment - relationship between a Lightsail
static IP & Lightsail instance. ~> Note: Lightsail is currently only
supported in a limited number of AWS Regions, please see
<https://lightsail.aws.amazon.com/ls/docs/overview/article/understanding-regions-and-availability-zones-in-amazon-lightsail>
for more details
-}
data LightsailStaticIpAttachmentResource = LightsailStaticIpAttachmentResource {
      _instance_name :: !(TF.Argument "instance_name" Text)
    {- ^ (Required) The name of the Lightsail instance to attach the IP to -}
    , _static_ip_name :: !(TF.Argument "static_ip_name" Text)
    {- ^ (Required) The name of the allocated static IP -}
    } deriving (Show, Eq)

instance TF.ToHCL LightsailStaticIpAttachmentResource where
    toHCL LightsailStaticIpAttachmentResource{..} = TF.block $ catMaybes
        [ TF.argument _instance_name
        , TF.argument _static_ip_name
        ]

instance HasInstanceName LightsailStaticIpAttachmentResource Text where
    instanceName =
        lens (_instance_name :: LightsailStaticIpAttachmentResource -> TF.Argument "instance_name" Text)
             (\s a -> s { _instance_name = a } :: LightsailStaticIpAttachmentResource)

instance HasStaticIpName LightsailStaticIpAttachmentResource Text where
    staticIpName =
        lens (_static_ip_name :: LightsailStaticIpAttachmentResource -> TF.Argument "static_ip_name" Text)
             (\s a -> s { _static_ip_name = a } :: LightsailStaticIpAttachmentResource)

instance HasComputedArn LightsailStaticIpAttachmentResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

instance HasComputedIpAddress LightsailStaticIpAttachmentResource Text where
    computedIpAddress =
        to (\_  -> TF.Compute "ip_address")

instance HasComputedSupportCode LightsailStaticIpAttachmentResource Text where
    computedSupportCode =
        to (\_  -> TF.Compute "support_code")

lightsailStaticIpAttachmentResource :: TF.Resource TF.AWS LightsailStaticIpAttachmentResource
lightsailStaticIpAttachmentResource =
    TF.newResource "aws_lightsail_static_ip_attachment" $
        LightsailStaticIpAttachmentResource {
            _instance_name = TF.Nil
            , _static_ip_name = TF.Nil
            }

{- | The @aws_lightsail_static_ip@ AWS resource.

Allocates a static IP address. ~> Note: Lightsail is currently only
supported in a limited number of AWS Regions, please see
<https://lightsail.aws.amazon.com/ls/docs/overview/article/understanding-regions-and-availability-zones-in-amazon-lightsail>
for more details
-}
data LightsailStaticIpResource = LightsailStaticIpResource {
      _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name for the allocated static IP -}
    } deriving (Show, Eq)

instance TF.ToHCL LightsailStaticIpResource where
    toHCL LightsailStaticIpResource{..} = TF.block $ catMaybes
        [ TF.argument _name
        ]

instance HasName LightsailStaticIpResource Text where
    name =
        lens (_name :: LightsailStaticIpResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: LightsailStaticIpResource)

instance HasComputedArn LightsailStaticIpResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

instance HasComputedIpAddress LightsailStaticIpResource Text where
    computedIpAddress =
        to (\_  -> TF.Compute "ip_address")

instance HasComputedSupportCode LightsailStaticIpResource Text where
    computedSupportCode =
        to (\_  -> TF.Compute "support_code")

lightsailStaticIpResource :: TF.Resource TF.AWS LightsailStaticIpResource
lightsailStaticIpResource =
    TF.newResource "aws_lightsail_static_ip" $
        LightsailStaticIpResource {
            _name = TF.Nil
            }

{- | The @aws_main_route_table_association@ AWS resource.

Provides a resource for managing the main routing table of a VPC.
-}
data MainRouteTableAssociationResource = MainRouteTableAssociationResource {
      _route_table_id :: !(TF.Argument "route_table_id" Text)
    {- ^ (Required) The ID of the Route Table to set as the new main route table for the target VPC -}
    , _vpc_id :: !(TF.Argument "vpc_id" Text)
    {- ^ (Required) The ID of the VPC whose main route table should be set -}
    } deriving (Show, Eq)

instance TF.ToHCL MainRouteTableAssociationResource where
    toHCL MainRouteTableAssociationResource{..} = TF.block $ catMaybes
        [ TF.argument _route_table_id
        , TF.argument _vpc_id
        ]

instance HasRouteTableId MainRouteTableAssociationResource Text where
    routeTableId =
        lens (_route_table_id :: MainRouteTableAssociationResource -> TF.Argument "route_table_id" Text)
             (\s a -> s { _route_table_id = a } :: MainRouteTableAssociationResource)

instance HasVpcId MainRouteTableAssociationResource Text where
    vpcId =
        lens (_vpc_id :: MainRouteTableAssociationResource -> TF.Argument "vpc_id" Text)
             (\s a -> s { _vpc_id = a } :: MainRouteTableAssociationResource)

instance HasComputedId MainRouteTableAssociationResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedOriginalRouteTableId MainRouteTableAssociationResource Text where
    computedOriginalRouteTableId =
        to (\_  -> TF.Compute "original_route_table_id")

mainRouteTableAssociationResource :: TF.Resource TF.AWS MainRouteTableAssociationResource
mainRouteTableAssociationResource =
    TF.newResource "aws_main_route_table_association" $
        MainRouteTableAssociationResource {
            _route_table_id = TF.Nil
            , _vpc_id = TF.Nil
            }

{- | The @aws_media_store_container@ AWS resource.

Provides a MediaStore Container.
-}
data MediaStoreContainerResource = MediaStoreContainerResource {
      _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the container. Must contain alphanumeric characters or underscores. -}
    } deriving (Show, Eq)

instance TF.ToHCL MediaStoreContainerResource where
    toHCL MediaStoreContainerResource{..} = TF.block $ catMaybes
        [ TF.argument _name
        ]

instance HasName MediaStoreContainerResource Text where
    name =
        lens (_name :: MediaStoreContainerResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: MediaStoreContainerResource)

instance HasComputedArn MediaStoreContainerResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

instance HasComputedEndpoint MediaStoreContainerResource Text where
    computedEndpoint =
        to (\_  -> TF.Compute "endpoint")

mediaStoreContainerResource :: TF.Resource TF.AWS MediaStoreContainerResource
mediaStoreContainerResource =
    TF.newResource "aws_media_store_container" $
        MediaStoreContainerResource {
            _name = TF.Nil
            }

{- | The @aws_mq_broker@ AWS resource.

Provides an MQ Broker Resource. This resources also manages users for the
broker. For more information on Amazon MQ, see
<https://docs.aws.amazon.com/amazon-mq/latest/developer-guide/welcome.html>
. Changes to an MQ Broker can occur when you change a parameter, such as
@configuration@ or @user@ , and are reflected in the next maintenance
window. Because of this, Terraform may report a difference in its planning
phase because a modification has not yet taken place. You can use the
@apply_immediately@ flag to instruct the service to apply the change
immediately (see documentation below). ~> Note: using @apply_immediately@
can result in a brief downtime as the broker reboots. ~> Note: All arguments
including the username and password will be stored in the raw state as
plain-text. </docs/state/sensitive-data.html> .
-}
data MqBrokerResource = MqBrokerResource {
      _apply_immediately :: !(TF.Argument "apply_immediately" Text)
    {- ^ (Optional) Specifies whether any broker modifications are applied immediately, or during the next maintenance window. Default is @false@ . -}
    , _auto_minor_version_upgrade :: !(TF.Argument "auto_minor_version_upgrade" Text)
    {- ^ (Optional) Enables automatic upgrades to new minor versions for brokers, as Apache releases the versions. -}
    , _broker_name :: !(TF.Argument "broker_name" Text)
    {- ^ (Required) The name of the broker. -}
    , _configuration :: !(TF.Argument "configuration" Text)
    {- ^ (Optional) Configuration of the broker. See below. -}
    , _deployment_mode :: !(TF.Argument "deployment_mode" Text)
    {- ^ (Optional) The deployment mode of the broker. Supported: @SINGLE_INSTANCE@ and @ACTIVE_STANDBY_MULTI_AZ@ . Defaults to @SINGLE_INSTANCE@ . -}
    , _engine_type :: !(TF.Argument "engine_type" Text)
    {- ^ (Required) The type of broker engine. Currently, Amazon MQ supports only @ActiveMQ@ . -}
    , _engine_version :: !(TF.Argument "engine_version" Text)
    {- ^ (Required) The version of the broker engine. Currently, Amazon MQ supports only @5.15.0@ . -}
    , _host_instance_type :: !(TF.Argument "host_instance_type" Text)
    {- ^ (Required) The broker's instance type. e.g. @mq.t2.micro@ or @mq.m4.large@ -}
    , _maintenance_window_start_time :: !(TF.Argument "maintenance_window_start_time" Text)
    {- ^ (Optional) Maintenance window start time. See below. -}
    , _publicly_accessible :: !(TF.Argument "publicly_accessible" Text)
    {- ^ (Optional) Whether to enable connections from applications outside of the VPC that hosts the broker's subnets. -}
    , _security_groups :: !(TF.Argument "security_groups" Text)
    {- ^ (Required) The list of security group IDs assigned to the broker. -}
    , _subnet_ids :: !(TF.Argument "subnet_ids" Text)
    {- ^ (Optional) The list of subnet IDs in which to launch the broker. A @SINGLE_INSTANCE@ deployment requires one subnet. An @ACTIVE_STANDBY_MULTI_AZ@ deployment requires two subnets. -}
    , _user :: !(TF.Argument "user" Text)
    {- ^ (Optional) The list of all ActiveMQ usernames for the specified broker. See below. -}
    } deriving (Show, Eq)

instance TF.ToHCL MqBrokerResource where
    toHCL MqBrokerResource{..} = TF.block $ catMaybes
        [ TF.argument _apply_immediately
        , TF.argument _auto_minor_version_upgrade
        , TF.argument _broker_name
        , TF.argument _configuration
        , TF.argument _deployment_mode
        , TF.argument _engine_type
        , TF.argument _engine_version
        , TF.argument _host_instance_type
        , TF.argument _maintenance_window_start_time
        , TF.argument _publicly_accessible
        , TF.argument _security_groups
        , TF.argument _subnet_ids
        , TF.argument _user
        ]

instance HasApplyImmediately MqBrokerResource Text where
    applyImmediately =
        lens (_apply_immediately :: MqBrokerResource -> TF.Argument "apply_immediately" Text)
             (\s a -> s { _apply_immediately = a } :: MqBrokerResource)

instance HasAutoMinorVersionUpgrade MqBrokerResource Text where
    autoMinorVersionUpgrade =
        lens (_auto_minor_version_upgrade :: MqBrokerResource -> TF.Argument "auto_minor_version_upgrade" Text)
             (\s a -> s { _auto_minor_version_upgrade = a } :: MqBrokerResource)

instance HasBrokerName MqBrokerResource Text where
    brokerName =
        lens (_broker_name :: MqBrokerResource -> TF.Argument "broker_name" Text)
             (\s a -> s { _broker_name = a } :: MqBrokerResource)

instance HasConfiguration MqBrokerResource Text where
    configuration =
        lens (_configuration :: MqBrokerResource -> TF.Argument "configuration" Text)
             (\s a -> s { _configuration = a } :: MqBrokerResource)

instance HasDeploymentMode MqBrokerResource Text where
    deploymentMode =
        lens (_deployment_mode :: MqBrokerResource -> TF.Argument "deployment_mode" Text)
             (\s a -> s { _deployment_mode = a } :: MqBrokerResource)

instance HasEngineType MqBrokerResource Text where
    engineType =
        lens (_engine_type :: MqBrokerResource -> TF.Argument "engine_type" Text)
             (\s a -> s { _engine_type = a } :: MqBrokerResource)

instance HasEngineVersion MqBrokerResource Text where
    engineVersion =
        lens (_engine_version :: MqBrokerResource -> TF.Argument "engine_version" Text)
             (\s a -> s { _engine_version = a } :: MqBrokerResource)

instance HasHostInstanceType MqBrokerResource Text where
    hostInstanceType =
        lens (_host_instance_type :: MqBrokerResource -> TF.Argument "host_instance_type" Text)
             (\s a -> s { _host_instance_type = a } :: MqBrokerResource)

instance HasMaintenanceWindowStartTime MqBrokerResource Text where
    maintenanceWindowStartTime =
        lens (_maintenance_window_start_time :: MqBrokerResource -> TF.Argument "maintenance_window_start_time" Text)
             (\s a -> s { _maintenance_window_start_time = a } :: MqBrokerResource)

instance HasPubliclyAccessible MqBrokerResource Text where
    publiclyAccessible =
        lens (_publicly_accessible :: MqBrokerResource -> TF.Argument "publicly_accessible" Text)
             (\s a -> s { _publicly_accessible = a } :: MqBrokerResource)

instance HasSecurityGroups MqBrokerResource Text where
    securityGroups =
        lens (_security_groups :: MqBrokerResource -> TF.Argument "security_groups" Text)
             (\s a -> s { _security_groups = a } :: MqBrokerResource)

instance HasSubnetIds MqBrokerResource Text where
    subnetIds =
        lens (_subnet_ids :: MqBrokerResource -> TF.Argument "subnet_ids" Text)
             (\s a -> s { _subnet_ids = a } :: MqBrokerResource)

instance HasUser MqBrokerResource Text where
    user =
        lens (_user :: MqBrokerResource -> TF.Argument "user" Text)
             (\s a -> s { _user = a } :: MqBrokerResource)

mqBrokerResource :: TF.Resource TF.AWS MqBrokerResource
mqBrokerResource =
    TF.newResource "aws_mq_broker" $
        MqBrokerResource {
            _apply_immediately = TF.Nil
            , _auto_minor_version_upgrade = TF.Nil
            , _broker_name = TF.Nil
            , _configuration = TF.Nil
            , _deployment_mode = TF.Nil
            , _engine_type = TF.Nil
            , _engine_version = TF.Nil
            , _host_instance_type = TF.Nil
            , _maintenance_window_start_time = TF.Nil
            , _publicly_accessible = TF.Nil
            , _security_groups = TF.Nil
            , _subnet_ids = TF.Nil
            , _user = TF.Nil
            }

{- | The @aws_mq_configuration@ AWS resource.

Provides an MQ Configuration Resource. For more information on Amazon MQ,
see
<https://docs.aws.amazon.com/amazon-mq/latest/developer-guide/welcome.html>
.
-}
data MqConfigurationResource = MqConfigurationResource {
      _data' :: !(TF.Argument "data" Text)
    {- ^ (Required) The broker configuration in XML format. See <https://docs.aws.amazon.com/amazon-mq/latest/developer-guide/amazon-mq-broker-configuration-parameters.html> for supported parameters and format of the XML. -}
    , _description :: !(TF.Argument "description" Text)
    {- ^ (Optional) The description of the configuration. -}
    , _engine_type :: !(TF.Argument "engine_type" Text)
    {- ^ (Required) The type of broker engine. -}
    , _engine_version :: !(TF.Argument "engine_version" Text)
    {- ^ (Required) The version of the broker engine. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the configuration -}
    } deriving (Show, Eq)

instance TF.ToHCL MqConfigurationResource where
    toHCL MqConfigurationResource{..} = TF.block $ catMaybes
        [ TF.argument _data'
        , TF.argument _description
        , TF.argument _engine_type
        , TF.argument _engine_version
        , TF.argument _name
        ]

instance HasData' MqConfigurationResource Text where
    data' =
        lens (_data' :: MqConfigurationResource -> TF.Argument "data" Text)
             (\s a -> s { _data' = a } :: MqConfigurationResource)

instance HasDescription MqConfigurationResource Text where
    description =
        lens (_description :: MqConfigurationResource -> TF.Argument "description" Text)
             (\s a -> s { _description = a } :: MqConfigurationResource)

instance HasEngineType MqConfigurationResource Text where
    engineType =
        lens (_engine_type :: MqConfigurationResource -> TF.Argument "engine_type" Text)
             (\s a -> s { _engine_type = a } :: MqConfigurationResource)

instance HasEngineVersion MqConfigurationResource Text where
    engineVersion =
        lens (_engine_version :: MqConfigurationResource -> TF.Argument "engine_version" Text)
             (\s a -> s { _engine_version = a } :: MqConfigurationResource)

instance HasName MqConfigurationResource Text where
    name =
        lens (_name :: MqConfigurationResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: MqConfigurationResource)

instance HasComputedArn MqConfigurationResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

instance HasComputedId MqConfigurationResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedLatestRevision MqConfigurationResource Text where
    computedLatestRevision =
        to (\_  -> TF.Compute "latest_revision")

mqConfigurationResource :: TF.Resource TF.AWS MqConfigurationResource
mqConfigurationResource =
    TF.newResource "aws_mq_configuration" $
        MqConfigurationResource {
            _data' = TF.Nil
            , _description = TF.Nil
            , _engine_type = TF.Nil
            , _engine_version = TF.Nil
            , _name = TF.Nil
            }

{- | The @aws_nat_gateway@ AWS resource.

Provides a resource to create a VPC NAT Gateway.
-}
data NatGatewayResource = NatGatewayResource {
      _allocation_id :: !(TF.Argument "allocation_id" Text)
    {- ^ (Required) The Allocation ID of the Elastic IP address for the gateway. -}
    , _subnet_id :: !(TF.Argument "subnet_id" Text)
    {- ^ (Required) The Subnet ID of the subnet in which to place the gateway. -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    } deriving (Show, Eq)

instance TF.ToHCL NatGatewayResource where
    toHCL NatGatewayResource{..} = TF.block $ catMaybes
        [ TF.argument _allocation_id
        , TF.argument _subnet_id
        , TF.argument _tags
        ]

instance HasAllocationId NatGatewayResource Text where
    allocationId =
        lens (_allocation_id :: NatGatewayResource -> TF.Argument "allocation_id" Text)
             (\s a -> s { _allocation_id = a } :: NatGatewayResource)

instance HasSubnetId NatGatewayResource Text where
    subnetId =
        lens (_subnet_id :: NatGatewayResource -> TF.Argument "subnet_id" Text)
             (\s a -> s { _subnet_id = a } :: NatGatewayResource)

instance HasTags NatGatewayResource TF.Tags where
    tags =
        lens (_tags :: NatGatewayResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: NatGatewayResource)

instance HasComputedAllocationId NatGatewayResource Text where
    computedAllocationId =
        to (\_  -> TF.Compute "allocation_id")

instance HasComputedId NatGatewayResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedNetworkInterfaceId NatGatewayResource Text where
    computedNetworkInterfaceId =
        to (\_  -> TF.Compute "network_interface_id")

instance HasComputedPrivateIp NatGatewayResource Text where
    computedPrivateIp =
        to (\_  -> TF.Compute "private_ip")

instance HasComputedPublicIp NatGatewayResource Text where
    computedPublicIp =
        to (\_  -> TF.Compute "public_ip")

instance HasComputedSubnetId NatGatewayResource Text where
    computedSubnetId =
        to (\_  -> TF.Compute "subnet_id")

natGatewayResource :: TF.Resource TF.AWS NatGatewayResource
natGatewayResource =
    TF.newResource "aws_nat_gateway" $
        NatGatewayResource {
            _allocation_id = TF.Nil
            , _subnet_id = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_network_acl@ AWS resource.

Provides an network ACL resource. You might set up network ACLs with rules
similar to your security groups in order to add an additional layer of
security to your VPC.
-}
data NetworkAclResource = NetworkAclResource {
      _egress :: !(TF.Argument "egress" Text)
    {- ^ (Optional) Specifies an egress rule. Parameters defined below. -}
    , _ingress :: !(TF.Argument "ingress" Text)
    {- ^ (Optional) Specifies an ingress rule. Parameters defined below. -}
    , _subnet_id :: !(TF.Argument "subnet_id" Text)
    {- ^ (Optional, Deprecated) The ID of the associated Subnet. This attribute is deprecated, please use the @subnet_ids@ attribute instead -}
    , _subnet_ids :: !(TF.Argument "subnet_ids" Text)
    {- ^ (Optional) A list of Subnet IDs to apply the ACL to -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    , _vpc_id :: !(TF.Argument "vpc_id" Text)
    {- ^ (Required) The ID of the associated VPC. -}
    } deriving (Show, Eq)

instance TF.ToHCL NetworkAclResource where
    toHCL NetworkAclResource{..} = TF.block $ catMaybes
        [ TF.argument _egress
        , TF.argument _ingress
        , TF.argument _subnet_id
        , TF.argument _subnet_ids
        , TF.argument _tags
        , TF.argument _vpc_id
        ]

instance HasEgress NetworkAclResource Text where
    egress =
        lens (_egress :: NetworkAclResource -> TF.Argument "egress" Text)
             (\s a -> s { _egress = a } :: NetworkAclResource)

instance HasIngress NetworkAclResource Text where
    ingress =
        lens (_ingress :: NetworkAclResource -> TF.Argument "ingress" Text)
             (\s a -> s { _ingress = a } :: NetworkAclResource)

instance HasSubnetId NetworkAclResource Text where
    subnetId =
        lens (_subnet_id :: NetworkAclResource -> TF.Argument "subnet_id" Text)
             (\s a -> s { _subnet_id = a } :: NetworkAclResource)

instance HasSubnetIds NetworkAclResource Text where
    subnetIds =
        lens (_subnet_ids :: NetworkAclResource -> TF.Argument "subnet_ids" Text)
             (\s a -> s { _subnet_ids = a } :: NetworkAclResource)

instance HasTags NetworkAclResource TF.Tags where
    tags =
        lens (_tags :: NetworkAclResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: NetworkAclResource)

instance HasVpcId NetworkAclResource Text where
    vpcId =
        lens (_vpc_id :: NetworkAclResource -> TF.Argument "vpc_id" Text)
             (\s a -> s { _vpc_id = a } :: NetworkAclResource)

instance HasComputedId NetworkAclResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

networkAclResource :: TF.Resource TF.AWS NetworkAclResource
networkAclResource =
    TF.newResource "aws_network_acl" $
        NetworkAclResource {
            _egress = TF.Nil
            , _ingress = TF.Nil
            , _subnet_id = TF.Nil
            , _subnet_ids = TF.Nil
            , _tags = TF.Nil
            , _vpc_id = TF.Nil
            }

{- | The @aws_network_acl_rule@ AWS resource.

Creates an entry (a rule) in a network ACL with the specified rule number.
-}
data NetworkAclRuleResource = NetworkAclRuleResource {
      _cidr_block :: !(TF.Argument "cidr_block" TF.CIDR)
    {- ^ (Optional) The network range to allow or deny, in CIDR notation (for example 172.16.0.0/24 ). -}
    , _egress :: !(TF.Argument "egress" Text)
    {- ^ (Optional, bool) Indicates whether this is an egress rule (rule is applied to traffic leaving the subnet). Default @false@ . -}
    , _from_port :: !(TF.Argument "from_port" TF.Word16)
    {- ^ (Optional) The from port to match. -}
    , _icmp_code :: !(TF.Argument "icmp_code" Text)
    {- ^ (Optional) ICMP protocol: The ICMP code. Required if specifying ICMP for the protocol. e.g. -1 -}
    , _icmp_type :: !(TF.Argument "icmp_type" Text)
    {- ^ (Optional) ICMP protocol: The ICMP type. Required if specifying ICMP for the protocol. e.g. -1 -}
    , _ipv6_cidr_block :: !(TF.Argument "ipv6_cidr_block" TF.CIDR)
    {- ^ (Optional) The IPv6 CIDR block to allow or deny. -}
    , _network_acl_id :: !(TF.Argument "network_acl_id" Text)
    {- ^ (Required) The ID of the network ACL. -}
    , _protocol :: !(TF.Argument "protocol" Text)
    {- ^ (Required) The protocol. A value of -1 means all protocols. -}
    , _rule_action :: !(TF.Argument "rule_action" Text)
    {- ^ (Required) Indicates whether to allow or deny the traffic that matches the rule. Accepted values: @allow@ | @deny@ -}
    , _rule_number :: !(TF.Argument "rule_number" Text)
    {- ^ (Required) The rule number for the entry (for example, 100). ACL entries are processed in ascending order by rule number. -}
    , _to_port :: !(TF.Argument "to_port" TF.Word16)
    {- ^ (Optional) The to port to match. -}
    } deriving (Show, Eq)

instance TF.ToHCL NetworkAclRuleResource where
    toHCL NetworkAclRuleResource{..} = TF.block $ catMaybes
        [ TF.argument _cidr_block
        , TF.argument _egress
        , TF.argument _from_port
        , TF.argument _icmp_code
        , TF.argument _icmp_type
        , TF.argument _ipv6_cidr_block
        , TF.argument _network_acl_id
        , TF.argument _protocol
        , TF.argument _rule_action
        , TF.argument _rule_number
        , TF.argument _to_port
        ]

instance HasCidrBlock NetworkAclRuleResource TF.CIDR where
    cidrBlock =
        lens (_cidr_block :: NetworkAclRuleResource -> TF.Argument "cidr_block" TF.CIDR)
             (\s a -> s { _cidr_block = a } :: NetworkAclRuleResource)

instance HasEgress NetworkAclRuleResource Text where
    egress =
        lens (_egress :: NetworkAclRuleResource -> TF.Argument "egress" Text)
             (\s a -> s { _egress = a } :: NetworkAclRuleResource)

instance HasFromPort NetworkAclRuleResource TF.Word16 where
    fromPort =
        lens (_from_port :: NetworkAclRuleResource -> TF.Argument "from_port" TF.Word16)
             (\s a -> s { _from_port = a } :: NetworkAclRuleResource)

instance HasIcmpCode NetworkAclRuleResource Text where
    icmpCode =
        lens (_icmp_code :: NetworkAclRuleResource -> TF.Argument "icmp_code" Text)
             (\s a -> s { _icmp_code = a } :: NetworkAclRuleResource)

instance HasIcmpType NetworkAclRuleResource Text where
    icmpType =
        lens (_icmp_type :: NetworkAclRuleResource -> TF.Argument "icmp_type" Text)
             (\s a -> s { _icmp_type = a } :: NetworkAclRuleResource)

instance HasIpv6CidrBlock NetworkAclRuleResource TF.CIDR where
    ipv6CidrBlock =
        lens (_ipv6_cidr_block :: NetworkAclRuleResource -> TF.Argument "ipv6_cidr_block" TF.CIDR)
             (\s a -> s { _ipv6_cidr_block = a } :: NetworkAclRuleResource)

instance HasNetworkAclId NetworkAclRuleResource Text where
    networkAclId =
        lens (_network_acl_id :: NetworkAclRuleResource -> TF.Argument "network_acl_id" Text)
             (\s a -> s { _network_acl_id = a } :: NetworkAclRuleResource)

instance HasProtocol NetworkAclRuleResource Text where
    protocol =
        lens (_protocol :: NetworkAclRuleResource -> TF.Argument "protocol" Text)
             (\s a -> s { _protocol = a } :: NetworkAclRuleResource)

instance HasRuleAction NetworkAclRuleResource Text where
    ruleAction =
        lens (_rule_action :: NetworkAclRuleResource -> TF.Argument "rule_action" Text)
             (\s a -> s { _rule_action = a } :: NetworkAclRuleResource)

instance HasRuleNumber NetworkAclRuleResource Text where
    ruleNumber =
        lens (_rule_number :: NetworkAclRuleResource -> TF.Argument "rule_number" Text)
             (\s a -> s { _rule_number = a } :: NetworkAclRuleResource)

instance HasToPort NetworkAclRuleResource TF.Word16 where
    toPort =
        lens (_to_port :: NetworkAclRuleResource -> TF.Argument "to_port" TF.Word16)
             (\s a -> s { _to_port = a } :: NetworkAclRuleResource)

instance HasComputedId NetworkAclRuleResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

networkAclRuleResource :: TF.Resource TF.AWS NetworkAclRuleResource
networkAclRuleResource =
    TF.newResource "aws_network_acl_rule" $
        NetworkAclRuleResource {
            _cidr_block = TF.Nil
            , _egress = TF.Nil
            , _from_port = TF.Nil
            , _icmp_code = TF.Nil
            , _icmp_type = TF.Nil
            , _ipv6_cidr_block = TF.Nil
            , _network_acl_id = TF.Nil
            , _protocol = TF.Nil
            , _rule_action = TF.Nil
            , _rule_number = TF.Nil
            , _to_port = TF.Nil
            }

{- | The @aws_network_interface_attachment@ AWS resource.

Attach an Elastic network interface (ENI) resource with EC2 instance.
-}
data NetworkInterfaceAttachmentResource = NetworkInterfaceAttachmentResource {
      _device_index :: !(TF.Argument "device_index" Text)
    {- ^ (Required) Network interface index (int). -}
    , _instance_id :: !(TF.Argument "instance_id" Text)
    {- ^ (Required) Instance ID to attach. -}
    , _network_interface_id :: !(TF.Argument "network_interface_id" Text)
    {- ^ (Required) ENI ID to attach. -}
    } deriving (Show, Eq)

instance TF.ToHCL NetworkInterfaceAttachmentResource where
    toHCL NetworkInterfaceAttachmentResource{..} = TF.block $ catMaybes
        [ TF.argument _device_index
        , TF.argument _instance_id
        , TF.argument _network_interface_id
        ]

instance HasDeviceIndex NetworkInterfaceAttachmentResource Text where
    deviceIndex =
        lens (_device_index :: NetworkInterfaceAttachmentResource -> TF.Argument "device_index" Text)
             (\s a -> s { _device_index = a } :: NetworkInterfaceAttachmentResource)

instance HasInstanceId NetworkInterfaceAttachmentResource Text where
    instanceId =
        lens (_instance_id :: NetworkInterfaceAttachmentResource -> TF.Argument "instance_id" Text)
             (\s a -> s { _instance_id = a } :: NetworkInterfaceAttachmentResource)

instance HasNetworkInterfaceId NetworkInterfaceAttachmentResource Text where
    networkInterfaceId =
        lens (_network_interface_id :: NetworkInterfaceAttachmentResource -> TF.Argument "network_interface_id" Text)
             (\s a -> s { _network_interface_id = a } :: NetworkInterfaceAttachmentResource)

instance HasComputedAttachmentId NetworkInterfaceAttachmentResource Text where
    computedAttachmentId =
        to (\_  -> TF.Compute "attachment_id")

instance HasComputedInstanceId NetworkInterfaceAttachmentResource Text where
    computedInstanceId =
        to (\_  -> TF.Compute "instance_id")

instance HasComputedNetworkInterfaceId NetworkInterfaceAttachmentResource Text where
    computedNetworkInterfaceId =
        to (\_  -> TF.Compute "network_interface_id")

instance HasComputedStatus NetworkInterfaceAttachmentResource Text where
    computedStatus =
        to (\_  -> TF.Compute "status")

networkInterfaceAttachmentResource :: TF.Resource TF.AWS NetworkInterfaceAttachmentResource
networkInterfaceAttachmentResource =
    TF.newResource "aws_network_interface_attachment" $
        NetworkInterfaceAttachmentResource {
            _device_index = TF.Nil
            , _instance_id = TF.Nil
            , _network_interface_id = TF.Nil
            }

{- | The @aws_network_interface@ AWS resource.

Provides an Elastic network interface (ENI) resource.
-}
data NetworkInterfaceResource = NetworkInterfaceResource {
      _attachment :: !(TF.Argument "attachment" Text)
    {- ^ (Optional) Block to define the attachment of the ENI. Documented below. -}
    , _description :: !(TF.Argument "description" Text)
    {- ^ (Optional) A description for the network interface. -}
    , _private_ips :: !(TF.Argument "private_ips" Text)
    {- ^ (Optional) List of private IPs to assign to the ENI. -}
    , _private_ips_count :: !(TF.Argument "private_ips_count" Text)
    {- ^ (Optional) Number of private IPs to assign to the ENI. -}
    , _security_groups :: !(TF.Argument "security_groups" Text)
    {- ^ (Optional) List of security group IDs to assign to the ENI. -}
    , _source_dest_check :: !(TF.Argument "source_dest_check" Text)
    {- ^ (Optional) Whether to enable source destination checking for the ENI. Default true. -}
    , _subnet_id :: !(TF.Argument "subnet_id" Text)
    {- ^ (Required) Subnet ID to create the ENI in. -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    } deriving (Show, Eq)

instance TF.ToHCL NetworkInterfaceResource where
    toHCL NetworkInterfaceResource{..} = TF.block $ catMaybes
        [ TF.argument _attachment
        , TF.argument _description
        , TF.argument _private_ips
        , TF.argument _private_ips_count
        , TF.argument _security_groups
        , TF.argument _source_dest_check
        , TF.argument _subnet_id
        , TF.argument _tags
        ]

instance HasAttachment NetworkInterfaceResource Text where
    attachment =
        lens (_attachment :: NetworkInterfaceResource -> TF.Argument "attachment" Text)
             (\s a -> s { _attachment = a } :: NetworkInterfaceResource)

instance HasDescription NetworkInterfaceResource Text where
    description =
        lens (_description :: NetworkInterfaceResource -> TF.Argument "description" Text)
             (\s a -> s { _description = a } :: NetworkInterfaceResource)

instance HasPrivateIps NetworkInterfaceResource Text where
    privateIps =
        lens (_private_ips :: NetworkInterfaceResource -> TF.Argument "private_ips" Text)
             (\s a -> s { _private_ips = a } :: NetworkInterfaceResource)

instance HasPrivateIpsCount NetworkInterfaceResource Text where
    privateIpsCount =
        lens (_private_ips_count :: NetworkInterfaceResource -> TF.Argument "private_ips_count" Text)
             (\s a -> s { _private_ips_count = a } :: NetworkInterfaceResource)

instance HasSecurityGroups NetworkInterfaceResource Text where
    securityGroups =
        lens (_security_groups :: NetworkInterfaceResource -> TF.Argument "security_groups" Text)
             (\s a -> s { _security_groups = a } :: NetworkInterfaceResource)

instance HasSourceDestCheck NetworkInterfaceResource Text where
    sourceDestCheck =
        lens (_source_dest_check :: NetworkInterfaceResource -> TF.Argument "source_dest_check" Text)
             (\s a -> s { _source_dest_check = a } :: NetworkInterfaceResource)

instance HasSubnetId NetworkInterfaceResource Text where
    subnetId =
        lens (_subnet_id :: NetworkInterfaceResource -> TF.Argument "subnet_id" Text)
             (\s a -> s { _subnet_id = a } :: NetworkInterfaceResource)

instance HasTags NetworkInterfaceResource TF.Tags where
    tags =
        lens (_tags :: NetworkInterfaceResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: NetworkInterfaceResource)

instance HasComputedAttachment NetworkInterfaceResource Text where
    computedAttachment =
        to (\_  -> TF.Compute "attachment")

instance HasComputedDescription NetworkInterfaceResource Text where
    computedDescription =
        to (\_  -> TF.Compute "description")

instance HasComputedId NetworkInterfaceResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedPrivateIps NetworkInterfaceResource Text where
    computedPrivateIps =
        to (\_  -> TF.Compute "private_ips")

instance HasComputedSecurityGroups NetworkInterfaceResource Text where
    computedSecurityGroups =
        to (\_  -> TF.Compute "security_groups")

instance HasComputedSourceDestCheck NetworkInterfaceResource Text where
    computedSourceDestCheck =
        to (\_  -> TF.Compute "source_dest_check")

instance HasComputedSubnetId NetworkInterfaceResource Text where
    computedSubnetId =
        to (\_  -> TF.Compute "subnet_id")

instance HasComputedTags NetworkInterfaceResource TF.Tags where
    computedTags =
        to (\_  -> TF.Compute "tags")

networkInterfaceResource :: TF.Resource TF.AWS NetworkInterfaceResource
networkInterfaceResource =
    TF.newResource "aws_network_interface" $
        NetworkInterfaceResource {
            _attachment = TF.Nil
            , _description = TF.Nil
            , _private_ips = TF.Nil
            , _private_ips_count = TF.Nil
            , _security_groups = TF.Nil
            , _source_dest_check = TF.Nil
            , _subnet_id = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_network_interface_sg_attachment@ AWS resource.

This resource attaches a security group to an Elastic Network Interface
(ENI). It can be used to attach a security group to any existing ENI, be it
a secondary ENI or one attached as the primary interface on an instance. ~>
NOTE on instances, interfaces, and security groups: Terraform currently
provides the capability to assign security groups via the
</docs/providers/aws/d/instance.html> and the
</docs/providers/aws/r/network_interface.html> resources. Using this
resource in conjunction with security groups provided in-line in those
resources will cause conflicts, and will lead to spurious diffs and
undefined behavior - please use one or the other.
-}
data NetworkInterfaceSgAttachmentResource = NetworkInterfaceSgAttachmentResource {
      _network_interface_id :: !(TF.Argument "network_interface_id" Text)
    {- ^ (Required) The ID of the network interface to attach to. -}
    , _security_group_id :: !(TF.Argument "security_group_id" Text)
    {- ^ (Required) The ID of the security group. -}
    } deriving (Show, Eq)

instance TF.ToHCL NetworkInterfaceSgAttachmentResource where
    toHCL NetworkInterfaceSgAttachmentResource{..} = TF.block $ catMaybes
        [ TF.argument _network_interface_id
        , TF.argument _security_group_id
        ]

instance HasNetworkInterfaceId NetworkInterfaceSgAttachmentResource Text where
    networkInterfaceId =
        lens (_network_interface_id :: NetworkInterfaceSgAttachmentResource -> TF.Argument "network_interface_id" Text)
             (\s a -> s { _network_interface_id = a } :: NetworkInterfaceSgAttachmentResource)

instance HasSecurityGroupId NetworkInterfaceSgAttachmentResource Text where
    securityGroupId =
        lens (_security_group_id :: NetworkInterfaceSgAttachmentResource -> TF.Argument "security_group_id" Text)
             (\s a -> s { _security_group_id = a } :: NetworkInterfaceSgAttachmentResource)

networkInterfaceSgAttachmentResource :: TF.Resource TF.AWS NetworkInterfaceSgAttachmentResource
networkInterfaceSgAttachmentResource =
    TF.newResource "aws_network_interface_sg_attachment" $
        NetworkInterfaceSgAttachmentResource {
            _network_interface_id = TF.Nil
            , _security_group_id = TF.Nil
            }

{- | The @aws_opsworks_application@ AWS resource.

Provides an OpsWorks application resource.
-}
data OpsworksApplicationResource = OpsworksApplicationResource {
      _app_source :: !(TF.Argument "app_source" Text)
    {- ^ (Optional) SCM configuration of the app as described below. -}
    , _auto_bundle_on_deploy :: !(TF.Argument "auto_bundle_on_deploy" Text)
    {- ^ (Optional) Run bundle install when deploying for application of type @rails@ . -}
    , _aws_flow_ruby_settings :: !(TF.Argument "aws_flow_ruby_settings" Text)
    {- ^ (Optional) Specify activity and workflow workers for your app using the aws-flow gem. -}
    , _data_source_arn :: !(TF.Argument "data_source_arn" Text)
    {- ^ (Optional) The data source's ARN. -}
    , _data_source_database_name :: !(TF.Argument "data_source_database_name" Text)
    {- ^ (Optional) The database name. -}
    , _data_source_type :: !(TF.Argument "data_source_type" Text)
    {- ^ (Optional) The data source's type one of @AutoSelectOpsworksMysqlInstance@ , @OpsworksMysqlInstance@ , or @RdsDbInstance@ . -}
    , _description :: !(TF.Argument "description" Text)
    {- ^ (Optional) A description of the app. -}
    , _document_root :: !(TF.Argument "document_root" Text)
    {- ^ (Optional) Subfolder for the document root for application of type @rails@ . -}
    , _domains :: !(TF.Argument "domains" Text)
    {- ^ -  (Optional) A list of virtual host alias. -}
    , _enable_ssl :: !(TF.Argument "enable_ssl" TF.Bool)
    {- ^ (Optional) Whether to enable SSL for the app. This must be set in order to let @ssl_configuration.private_key@ , @ssl_configuration.certificate@ and @ssl_configuration.chain@ take effect. -}
    , _environment :: !(TF.Argument "environment" Text)
    {- ^ (Optional) Object to define environment variables.  Object is described below. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) A human-readable name for the application. -}
    , _rails_env :: !(TF.Argument "rails_env" Text)
    {- ^ (Required if @type@ = @rails@ ) The name of the Rails environment for application of type @rails@ . -}
    , _short_name :: !(TF.Argument "short_name" Text)
    {- ^ (Required) A short, machine-readable name for the application. This can only be defined on resource creation and ignored on resource update. -}
    , _ssl_configuration :: !(TF.Argument "ssl_configuration" Text)
    {- ^ (Optional) The SSL configuration of the app. Object is described below. -}
    , _stack_id :: !(TF.Argument "stack_id" Text)
    {- ^ (Required) The id of the stack the application will belong to. -}
    , _type' :: !(TF.Argument "type" Text)
    {- ^ (Required) Opsworks application type. One of @aws-flow-ruby@ , @java@ , @rails@ , @php@ , @nodejs@ , @static@ or @other@ . -}
    } deriving (Show, Eq)

instance TF.ToHCL OpsworksApplicationResource where
    toHCL OpsworksApplicationResource{..} = TF.block $ catMaybes
        [ TF.argument _app_source
        , TF.argument _auto_bundle_on_deploy
        , TF.argument _aws_flow_ruby_settings
        , TF.argument _data_source_arn
        , TF.argument _data_source_database_name
        , TF.argument _data_source_type
        , TF.argument _description
        , TF.argument _document_root
        , TF.argument _domains
        , TF.argument _enable_ssl
        , TF.argument _environment
        , TF.argument _name
        , TF.argument _rails_env
        , TF.argument _short_name
        , TF.argument _ssl_configuration
        , TF.argument _stack_id
        , TF.argument _type'
        ]

instance HasAppSource OpsworksApplicationResource Text where
    appSource =
        lens (_app_source :: OpsworksApplicationResource -> TF.Argument "app_source" Text)
             (\s a -> s { _app_source = a } :: OpsworksApplicationResource)

instance HasAutoBundleOnDeploy OpsworksApplicationResource Text where
    autoBundleOnDeploy =
        lens (_auto_bundle_on_deploy :: OpsworksApplicationResource -> TF.Argument "auto_bundle_on_deploy" Text)
             (\s a -> s { _auto_bundle_on_deploy = a } :: OpsworksApplicationResource)

instance HasAwsFlowRubySettings OpsworksApplicationResource Text where
    awsFlowRubySettings =
        lens (_aws_flow_ruby_settings :: OpsworksApplicationResource -> TF.Argument "aws_flow_ruby_settings" Text)
             (\s a -> s { _aws_flow_ruby_settings = a } :: OpsworksApplicationResource)

instance HasDataSourceArn OpsworksApplicationResource Text where
    dataSourceArn =
        lens (_data_source_arn :: OpsworksApplicationResource -> TF.Argument "data_source_arn" Text)
             (\s a -> s { _data_source_arn = a } :: OpsworksApplicationResource)

instance HasDataSourceDatabaseName OpsworksApplicationResource Text where
    dataSourceDatabaseName =
        lens (_data_source_database_name :: OpsworksApplicationResource -> TF.Argument "data_source_database_name" Text)
             (\s a -> s { _data_source_database_name = a } :: OpsworksApplicationResource)

instance HasDataSourceType OpsworksApplicationResource Text where
    dataSourceType =
        lens (_data_source_type :: OpsworksApplicationResource -> TF.Argument "data_source_type" Text)
             (\s a -> s { _data_source_type = a } :: OpsworksApplicationResource)

instance HasDescription OpsworksApplicationResource Text where
    description =
        lens (_description :: OpsworksApplicationResource -> TF.Argument "description" Text)
             (\s a -> s { _description = a } :: OpsworksApplicationResource)

instance HasDocumentRoot OpsworksApplicationResource Text where
    documentRoot =
        lens (_document_root :: OpsworksApplicationResource -> TF.Argument "document_root" Text)
             (\s a -> s { _document_root = a } :: OpsworksApplicationResource)

instance HasDomains OpsworksApplicationResource Text where
    domains =
        lens (_domains :: OpsworksApplicationResource -> TF.Argument "domains" Text)
             (\s a -> s { _domains = a } :: OpsworksApplicationResource)

instance HasEnableSsl OpsworksApplicationResource TF.Bool where
    enableSsl =
        lens (_enable_ssl :: OpsworksApplicationResource -> TF.Argument "enable_ssl" TF.Bool)
             (\s a -> s { _enable_ssl = a } :: OpsworksApplicationResource)

instance HasEnvironment OpsworksApplicationResource Text where
    environment =
        lens (_environment :: OpsworksApplicationResource -> TF.Argument "environment" Text)
             (\s a -> s { _environment = a } :: OpsworksApplicationResource)

instance HasName OpsworksApplicationResource Text where
    name =
        lens (_name :: OpsworksApplicationResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: OpsworksApplicationResource)

instance HasRailsEnv OpsworksApplicationResource Text where
    railsEnv =
        lens (_rails_env :: OpsworksApplicationResource -> TF.Argument "rails_env" Text)
             (\s a -> s { _rails_env = a } :: OpsworksApplicationResource)

instance HasShortName OpsworksApplicationResource Text where
    shortName =
        lens (_short_name :: OpsworksApplicationResource -> TF.Argument "short_name" Text)
             (\s a -> s { _short_name = a } :: OpsworksApplicationResource)

instance HasSslConfiguration OpsworksApplicationResource Text where
    sslConfiguration =
        lens (_ssl_configuration :: OpsworksApplicationResource -> TF.Argument "ssl_configuration" Text)
             (\s a -> s { _ssl_configuration = a } :: OpsworksApplicationResource)

instance HasStackId OpsworksApplicationResource Text where
    stackId =
        lens (_stack_id :: OpsworksApplicationResource -> TF.Argument "stack_id" Text)
             (\s a -> s { _stack_id = a } :: OpsworksApplicationResource)

instance HasType' OpsworksApplicationResource Text where
    type' =
        lens (_type' :: OpsworksApplicationResource -> TF.Argument "type" Text)
             (\s a -> s { _type' = a } :: OpsworksApplicationResource)

instance HasComputedId OpsworksApplicationResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

opsworksApplicationResource :: TF.Resource TF.AWS OpsworksApplicationResource
opsworksApplicationResource =
    TF.newResource "aws_opsworks_application" $
        OpsworksApplicationResource {
            _app_source = TF.Nil
            , _auto_bundle_on_deploy = TF.Nil
            , _aws_flow_ruby_settings = TF.Nil
            , _data_source_arn = TF.Nil
            , _data_source_database_name = TF.Nil
            , _data_source_type = TF.Nil
            , _description = TF.Nil
            , _document_root = TF.Nil
            , _domains = TF.Nil
            , _enable_ssl = TF.Nil
            , _environment = TF.Nil
            , _name = TF.Nil
            , _rails_env = TF.Nil
            , _short_name = TF.Nil
            , _ssl_configuration = TF.Nil
            , _stack_id = TF.Nil
            , _type' = TF.Nil
            }

{- | The @aws_opsworks_custom_layer@ AWS resource.

Provides an OpsWorks custom layer resource.
-}
data OpsworksCustomLayerResource = OpsworksCustomLayerResource {
      _auto_assign_elastic_ips :: !(TF.Argument "auto_assign_elastic_ips" Text)
    {- ^ (Optional) Whether to automatically assign an elastic IP address to the layer's instances. -}
    , _auto_assign_public_ips :: !(TF.Argument "auto_assign_public_ips" Text)
    {- ^ (Optional) For stacks belonging to a VPC, whether to automatically assign a public IP address to each of the layer's instances. -}
    , _auto_healing :: !(TF.Argument "auto_healing" Text)
    {- ^ (Optional) Whether to enable auto-healing for the layer. -}
    , _custom_instance_profile_arn :: !(TF.Argument "custom_instance_profile_arn" Text)
    {- ^ (Optional) The ARN of an IAM profile that will be used for the layer's instances. -}
    , _custom_json :: !(TF.Argument "custom_json" Text)
    {- ^ (Optional) Custom JSON attributes to apply to the layer. -}
    , _custom_security_group_ids :: !(TF.Argument "custom_security_group_ids" Text)
    {- ^ (Optional) Ids for a set of security groups to apply to the layer's instances. -}
    , _drain_elb_on_shutdown :: !(TF.Argument "drain_elb_on_shutdown" Text)
    {- ^ (Optional) Whether to enable Elastic Load Balancing connection draining. -}
    , _ebs_volume :: !(TF.Argument "ebs_volume" Text)
    {- ^ (Optional) @ebs_volume@ blocks, as described below, will each create an EBS volume and connect it to the layer's instances. -}
    , _elastic_load_balancer :: !(TF.Argument "elastic_load_balancer" Text)
    {- ^ (Optional) Name of an Elastic Load Balancer to attach to this layer -}
    , _install_updates_on_boot :: !(TF.Argument "install_updates_on_boot" Text)
    {- ^ (Optional) Whether to install OS and package updates on each instance when it boots. -}
    , _instance_shutdown_timeout :: !(TF.Argument "instance_shutdown_timeout" Text)
    {- ^ (Optional) The time, in seconds, that OpsWorks will wait for Chef to complete after triggering the Shutdown event. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) A human-readable name for the layer. -}
    , _short_name :: !(TF.Argument "short_name" Text)
    {- ^ (Required) A short, machine-readable name for the layer, which will be used to identify it in the Chef node JSON. -}
    , _stack_id :: !(TF.Argument "stack_id" Text)
    {- ^ (Required) The id of the stack the layer will belong to. -}
    , _system_packages :: !(TF.Argument "system_packages" Text)
    {- ^ (Optional) Names of a set of system packages to install on the layer's instances. -}
    , _use_ebs_optimized_instances :: !(TF.Argument "use_ebs_optimized_instances" Text)
    {- ^ (Optional) Whether to use EBS-optimized instances. -}
    } deriving (Show, Eq)

instance TF.ToHCL OpsworksCustomLayerResource where
    toHCL OpsworksCustomLayerResource{..} = TF.block $ catMaybes
        [ TF.argument _auto_assign_elastic_ips
        , TF.argument _auto_assign_public_ips
        , TF.argument _auto_healing
        , TF.argument _custom_instance_profile_arn
        , TF.argument _custom_json
        , TF.argument _custom_security_group_ids
        , TF.argument _drain_elb_on_shutdown
        , TF.argument _ebs_volume
        , TF.argument _elastic_load_balancer
        , TF.argument _install_updates_on_boot
        , TF.argument _instance_shutdown_timeout
        , TF.argument _name
        , TF.argument _short_name
        , TF.argument _stack_id
        , TF.argument _system_packages
        , TF.argument _use_ebs_optimized_instances
        ]

instance HasAutoAssignElasticIps OpsworksCustomLayerResource Text where
    autoAssignElasticIps =
        lens (_auto_assign_elastic_ips :: OpsworksCustomLayerResource -> TF.Argument "auto_assign_elastic_ips" Text)
             (\s a -> s { _auto_assign_elastic_ips = a } :: OpsworksCustomLayerResource)

instance HasAutoAssignPublicIps OpsworksCustomLayerResource Text where
    autoAssignPublicIps =
        lens (_auto_assign_public_ips :: OpsworksCustomLayerResource -> TF.Argument "auto_assign_public_ips" Text)
             (\s a -> s { _auto_assign_public_ips = a } :: OpsworksCustomLayerResource)

instance HasAutoHealing OpsworksCustomLayerResource Text where
    autoHealing =
        lens (_auto_healing :: OpsworksCustomLayerResource -> TF.Argument "auto_healing" Text)
             (\s a -> s { _auto_healing = a } :: OpsworksCustomLayerResource)

instance HasCustomInstanceProfileArn OpsworksCustomLayerResource Text where
    customInstanceProfileArn =
        lens (_custom_instance_profile_arn :: OpsworksCustomLayerResource -> TF.Argument "custom_instance_profile_arn" Text)
             (\s a -> s { _custom_instance_profile_arn = a } :: OpsworksCustomLayerResource)

instance HasCustomJson OpsworksCustomLayerResource Text where
    customJson =
        lens (_custom_json :: OpsworksCustomLayerResource -> TF.Argument "custom_json" Text)
             (\s a -> s { _custom_json = a } :: OpsworksCustomLayerResource)

instance HasCustomSecurityGroupIds OpsworksCustomLayerResource Text where
    customSecurityGroupIds =
        lens (_custom_security_group_ids :: OpsworksCustomLayerResource -> TF.Argument "custom_security_group_ids" Text)
             (\s a -> s { _custom_security_group_ids = a } :: OpsworksCustomLayerResource)

instance HasDrainElbOnShutdown OpsworksCustomLayerResource Text where
    drainElbOnShutdown =
        lens (_drain_elb_on_shutdown :: OpsworksCustomLayerResource -> TF.Argument "drain_elb_on_shutdown" Text)
             (\s a -> s { _drain_elb_on_shutdown = a } :: OpsworksCustomLayerResource)

instance HasEbsVolume OpsworksCustomLayerResource Text where
    ebsVolume =
        lens (_ebs_volume :: OpsworksCustomLayerResource -> TF.Argument "ebs_volume" Text)
             (\s a -> s { _ebs_volume = a } :: OpsworksCustomLayerResource)

instance HasElasticLoadBalancer OpsworksCustomLayerResource Text where
    elasticLoadBalancer =
        lens (_elastic_load_balancer :: OpsworksCustomLayerResource -> TF.Argument "elastic_load_balancer" Text)
             (\s a -> s { _elastic_load_balancer = a } :: OpsworksCustomLayerResource)

instance HasInstallUpdatesOnBoot OpsworksCustomLayerResource Text where
    installUpdatesOnBoot =
        lens (_install_updates_on_boot :: OpsworksCustomLayerResource -> TF.Argument "install_updates_on_boot" Text)
             (\s a -> s { _install_updates_on_boot = a } :: OpsworksCustomLayerResource)

instance HasInstanceShutdownTimeout OpsworksCustomLayerResource Text where
    instanceShutdownTimeout =
        lens (_instance_shutdown_timeout :: OpsworksCustomLayerResource -> TF.Argument "instance_shutdown_timeout" Text)
             (\s a -> s { _instance_shutdown_timeout = a } :: OpsworksCustomLayerResource)

instance HasName OpsworksCustomLayerResource Text where
    name =
        lens (_name :: OpsworksCustomLayerResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: OpsworksCustomLayerResource)

instance HasShortName OpsworksCustomLayerResource Text where
    shortName =
        lens (_short_name :: OpsworksCustomLayerResource -> TF.Argument "short_name" Text)
             (\s a -> s { _short_name = a } :: OpsworksCustomLayerResource)

instance HasStackId OpsworksCustomLayerResource Text where
    stackId =
        lens (_stack_id :: OpsworksCustomLayerResource -> TF.Argument "stack_id" Text)
             (\s a -> s { _stack_id = a } :: OpsworksCustomLayerResource)

instance HasSystemPackages OpsworksCustomLayerResource Text where
    systemPackages =
        lens (_system_packages :: OpsworksCustomLayerResource -> TF.Argument "system_packages" Text)
             (\s a -> s { _system_packages = a } :: OpsworksCustomLayerResource)

instance HasUseEbsOptimizedInstances OpsworksCustomLayerResource Text where
    useEbsOptimizedInstances =
        lens (_use_ebs_optimized_instances :: OpsworksCustomLayerResource -> TF.Argument "use_ebs_optimized_instances" Text)
             (\s a -> s { _use_ebs_optimized_instances = a } :: OpsworksCustomLayerResource)

instance HasComputedId OpsworksCustomLayerResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

opsworksCustomLayerResource :: TF.Resource TF.AWS OpsworksCustomLayerResource
opsworksCustomLayerResource =
    TF.newResource "aws_opsworks_custom_layer" $
        OpsworksCustomLayerResource {
            _auto_assign_elastic_ips = TF.Nil
            , _auto_assign_public_ips = TF.Nil
            , _auto_healing = TF.Nil
            , _custom_instance_profile_arn = TF.Nil
            , _custom_json = TF.Nil
            , _custom_security_group_ids = TF.Nil
            , _drain_elb_on_shutdown = TF.Nil
            , _ebs_volume = TF.Nil
            , _elastic_load_balancer = TF.Nil
            , _install_updates_on_boot = TF.Nil
            , _instance_shutdown_timeout = TF.Nil
            , _name = TF.Nil
            , _short_name = TF.Nil
            , _stack_id = TF.Nil
            , _system_packages = TF.Nil
            , _use_ebs_optimized_instances = TF.Nil
            }

{- | The @aws_opsworks_ganglia_layer@ AWS resource.

Provides an OpsWorks Ganglia layer resource.
-}
data OpsworksGangliaLayerResource = OpsworksGangliaLayerResource {
      _auto_assign_elastic_ips :: !(TF.Argument "auto_assign_elastic_ips" Text)
    {- ^ (Optional) Whether to automatically assign an elastic IP address to the layer's instances. -}
    , _auto_assign_public_ips :: !(TF.Argument "auto_assign_public_ips" Text)
    {- ^ (Optional) For stacks belonging to a VPC, whether to automatically assign a public IP address to each of the layer's instances. -}
    , _auto_healing :: !(TF.Argument "auto_healing" Text)
    {- ^ (Optional) Whether to enable auto-healing for the layer. -}
    , _custom_instance_profile_arn :: !(TF.Argument "custom_instance_profile_arn" Text)
    {- ^ (Optional) The ARN of an IAM profile that will be used for the layer's instances. -}
    , _custom_json :: !(TF.Argument "custom_json" Text)
    {- ^ (Optional) Custom JSON attributes to apply to the layer. -}
    , _custom_security_group_ids :: !(TF.Argument "custom_security_group_ids" Text)
    {- ^ (Optional) Ids for a set of security groups to apply to the layer's instances. -}
    , _drain_elb_on_shutdown :: !(TF.Argument "drain_elb_on_shutdown" Text)
    {- ^ (Optional) Whether to enable Elastic Load Balancing connection draining. -}
    , _ebs_volume :: !(TF.Argument "ebs_volume" Text)
    {- ^ (Optional) @ebs_volume@ blocks, as described below, will each create an EBS volume and connect it to the layer's instances. -}
    , _elastic_load_balancer :: !(TF.Argument "elastic_load_balancer" Text)
    {- ^ (Optional) Name of an Elastic Load Balancer to attach to this layer -}
    , _install_updates_on_boot :: !(TF.Argument "install_updates_on_boot" Text)
    {- ^ (Optional) Whether to install OS and package updates on each instance when it boots. -}
    , _instance_shutdown_timeout :: !(TF.Argument "instance_shutdown_timeout" Text)
    {- ^ (Optional) The time, in seconds, that OpsWorks will wait for Chef to complete after triggering the Shutdown event. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Optional) A human-readable name for the layer. -}
    , _password :: !(TF.Argument "password" Text)
    {- ^ (Required) The password to use for Ganglia. -}
    , _stack_id :: !(TF.Argument "stack_id" Text)
    {- ^ (Required) The id of the stack the layer will belong to. -}
    , _system_packages :: !(TF.Argument "system_packages" Text)
    {- ^ (Optional) Names of a set of system packages to install on the layer's instances. -}
    , _url :: !(TF.Argument "url" Text)
    {- ^ (Optional) The URL path to use for Ganglia. Defaults to "/ganglia". -}
    , _use_ebs_optimized_instances :: !(TF.Argument "use_ebs_optimized_instances" Text)
    {- ^ (Optional) Whether to use EBS-optimized instances. -}
    , _username :: !(TF.Argument "username" Text)
    {- ^ - (Optiona) The username to use for Ganglia. Defaults to "opsworks". -}
    } deriving (Show, Eq)

instance TF.ToHCL OpsworksGangliaLayerResource where
    toHCL OpsworksGangliaLayerResource{..} = TF.block $ catMaybes
        [ TF.argument _auto_assign_elastic_ips
        , TF.argument _auto_assign_public_ips
        , TF.argument _auto_healing
        , TF.argument _custom_instance_profile_arn
        , TF.argument _custom_json
        , TF.argument _custom_security_group_ids
        , TF.argument _drain_elb_on_shutdown
        , TF.argument _ebs_volume
        , TF.argument _elastic_load_balancer
        , TF.argument _install_updates_on_boot
        , TF.argument _instance_shutdown_timeout
        , TF.argument _name
        , TF.argument _password
        , TF.argument _stack_id
        , TF.argument _system_packages
        , TF.argument _url
        , TF.argument _use_ebs_optimized_instances
        , TF.argument _username
        ]

instance HasAutoAssignElasticIps OpsworksGangliaLayerResource Text where
    autoAssignElasticIps =
        lens (_auto_assign_elastic_ips :: OpsworksGangliaLayerResource -> TF.Argument "auto_assign_elastic_ips" Text)
             (\s a -> s { _auto_assign_elastic_ips = a } :: OpsworksGangliaLayerResource)

instance HasAutoAssignPublicIps OpsworksGangliaLayerResource Text where
    autoAssignPublicIps =
        lens (_auto_assign_public_ips :: OpsworksGangliaLayerResource -> TF.Argument "auto_assign_public_ips" Text)
             (\s a -> s { _auto_assign_public_ips = a } :: OpsworksGangliaLayerResource)

instance HasAutoHealing OpsworksGangliaLayerResource Text where
    autoHealing =
        lens (_auto_healing :: OpsworksGangliaLayerResource -> TF.Argument "auto_healing" Text)
             (\s a -> s { _auto_healing = a } :: OpsworksGangliaLayerResource)

instance HasCustomInstanceProfileArn OpsworksGangliaLayerResource Text where
    customInstanceProfileArn =
        lens (_custom_instance_profile_arn :: OpsworksGangliaLayerResource -> TF.Argument "custom_instance_profile_arn" Text)
             (\s a -> s { _custom_instance_profile_arn = a } :: OpsworksGangliaLayerResource)

instance HasCustomJson OpsworksGangliaLayerResource Text where
    customJson =
        lens (_custom_json :: OpsworksGangliaLayerResource -> TF.Argument "custom_json" Text)
             (\s a -> s { _custom_json = a } :: OpsworksGangliaLayerResource)

instance HasCustomSecurityGroupIds OpsworksGangliaLayerResource Text where
    customSecurityGroupIds =
        lens (_custom_security_group_ids :: OpsworksGangliaLayerResource -> TF.Argument "custom_security_group_ids" Text)
             (\s a -> s { _custom_security_group_ids = a } :: OpsworksGangliaLayerResource)

instance HasDrainElbOnShutdown OpsworksGangliaLayerResource Text where
    drainElbOnShutdown =
        lens (_drain_elb_on_shutdown :: OpsworksGangliaLayerResource -> TF.Argument "drain_elb_on_shutdown" Text)
             (\s a -> s { _drain_elb_on_shutdown = a } :: OpsworksGangliaLayerResource)

instance HasEbsVolume OpsworksGangliaLayerResource Text where
    ebsVolume =
        lens (_ebs_volume :: OpsworksGangliaLayerResource -> TF.Argument "ebs_volume" Text)
             (\s a -> s { _ebs_volume = a } :: OpsworksGangliaLayerResource)

instance HasElasticLoadBalancer OpsworksGangliaLayerResource Text where
    elasticLoadBalancer =
        lens (_elastic_load_balancer :: OpsworksGangliaLayerResource -> TF.Argument "elastic_load_balancer" Text)
             (\s a -> s { _elastic_load_balancer = a } :: OpsworksGangliaLayerResource)

instance HasInstallUpdatesOnBoot OpsworksGangliaLayerResource Text where
    installUpdatesOnBoot =
        lens (_install_updates_on_boot :: OpsworksGangliaLayerResource -> TF.Argument "install_updates_on_boot" Text)
             (\s a -> s { _install_updates_on_boot = a } :: OpsworksGangliaLayerResource)

instance HasInstanceShutdownTimeout OpsworksGangliaLayerResource Text where
    instanceShutdownTimeout =
        lens (_instance_shutdown_timeout :: OpsworksGangliaLayerResource -> TF.Argument "instance_shutdown_timeout" Text)
             (\s a -> s { _instance_shutdown_timeout = a } :: OpsworksGangliaLayerResource)

instance HasName OpsworksGangliaLayerResource Text where
    name =
        lens (_name :: OpsworksGangliaLayerResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: OpsworksGangliaLayerResource)

instance HasPassword OpsworksGangliaLayerResource Text where
    password =
        lens (_password :: OpsworksGangliaLayerResource -> TF.Argument "password" Text)
             (\s a -> s { _password = a } :: OpsworksGangliaLayerResource)

instance HasStackId OpsworksGangliaLayerResource Text where
    stackId =
        lens (_stack_id :: OpsworksGangliaLayerResource -> TF.Argument "stack_id" Text)
             (\s a -> s { _stack_id = a } :: OpsworksGangliaLayerResource)

instance HasSystemPackages OpsworksGangliaLayerResource Text where
    systemPackages =
        lens (_system_packages :: OpsworksGangliaLayerResource -> TF.Argument "system_packages" Text)
             (\s a -> s { _system_packages = a } :: OpsworksGangliaLayerResource)

instance HasUrl OpsworksGangliaLayerResource Text where
    url =
        lens (_url :: OpsworksGangliaLayerResource -> TF.Argument "url" Text)
             (\s a -> s { _url = a } :: OpsworksGangliaLayerResource)

instance HasUseEbsOptimizedInstances OpsworksGangliaLayerResource Text where
    useEbsOptimizedInstances =
        lens (_use_ebs_optimized_instances :: OpsworksGangliaLayerResource -> TF.Argument "use_ebs_optimized_instances" Text)
             (\s a -> s { _use_ebs_optimized_instances = a } :: OpsworksGangliaLayerResource)

instance HasUsername OpsworksGangliaLayerResource Text where
    username =
        lens (_username :: OpsworksGangliaLayerResource -> TF.Argument "username" Text)
             (\s a -> s { _username = a } :: OpsworksGangliaLayerResource)

instance HasComputedId OpsworksGangliaLayerResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

opsworksGangliaLayerResource :: TF.Resource TF.AWS OpsworksGangliaLayerResource
opsworksGangliaLayerResource =
    TF.newResource "aws_opsworks_ganglia_layer" $
        OpsworksGangliaLayerResource {
            _auto_assign_elastic_ips = TF.Nil
            , _auto_assign_public_ips = TF.Nil
            , _auto_healing = TF.Nil
            , _custom_instance_profile_arn = TF.Nil
            , _custom_json = TF.Nil
            , _custom_security_group_ids = TF.Nil
            , _drain_elb_on_shutdown = TF.Nil
            , _ebs_volume = TF.Nil
            , _elastic_load_balancer = TF.Nil
            , _install_updates_on_boot = TF.Nil
            , _instance_shutdown_timeout = TF.Nil
            , _name = TF.Nil
            , _password = TF.Nil
            , _stack_id = TF.Nil
            , _system_packages = TF.Nil
            , _url = TF.Nil
            , _use_ebs_optimized_instances = TF.Nil
            , _username = TF.Nil
            }

{- | The @aws_opsworks_haproxy_layer@ AWS resource.

Provides an OpsWorks haproxy layer resource.
-}
data OpsworksHaproxyLayerResource = OpsworksHaproxyLayerResource {
      _auto_assign_elastic_ips :: !(TF.Argument "auto_assign_elastic_ips" Text)
    {- ^ (Optional) Whether to automatically assign an elastic IP address to the layer's instances. -}
    , _auto_assign_public_ips :: !(TF.Argument "auto_assign_public_ips" Text)
    {- ^ (Optional) For stacks belonging to a VPC, whether to automatically assign a public IP address to each of the layer's instances. -}
    , _auto_healing :: !(TF.Argument "auto_healing" Text)
    {- ^ (Optional) Whether to enable auto-healing for the layer. -}
    , _custom_instance_profile_arn :: !(TF.Argument "custom_instance_profile_arn" Text)
    {- ^ (Optional) The ARN of an IAM profile that will be used for the layer's instances. -}
    , _custom_json :: !(TF.Argument "custom_json" Text)
    {- ^ (Optional) Custom JSON attributes to apply to the layer. -}
    , _custom_security_group_ids :: !(TF.Argument "custom_security_group_ids" Text)
    {- ^ (Optional) Ids for a set of security groups to apply to the layer's instances. -}
    , _drain_elb_on_shutdown :: !(TF.Argument "drain_elb_on_shutdown" Text)
    {- ^ (Optional) Whether to enable Elastic Load Balancing connection draining. -}
    , _ebs_volume :: !(TF.Argument "ebs_volume" Text)
    {- ^ (Optional) @ebs_volume@ blocks, as described below, will each create an EBS volume and connect it to the layer's instances. -}
    , _elastic_load_balancer :: !(TF.Argument "elastic_load_balancer" Text)
    {- ^ (Optional) Name of an Elastic Load Balancer to attach to this layer -}
    , _healthcheck_method :: !(TF.Argument "healthcheck_method" Text)
    {- ^ (Optional) HTTP method to use for instance healthchecks. Defaults to "OPTIONS". -}
    , _healthcheck_url :: !(TF.Argument "healthcheck_url" Text)
    {- ^ (Optional) URL path to use for instance healthchecks. Defaults to "/". -}
    , _install_updates_on_boot :: !(TF.Argument "install_updates_on_boot" Text)
    {- ^ (Optional) Whether to install OS and package updates on each instance when it boots. -}
    , _instance_shutdown_timeout :: !(TF.Argument "instance_shutdown_timeout" Text)
    {- ^ (Optional) The time, in seconds, that OpsWorks will wait for Chef to complete after triggering the Shutdown event. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Optional) A human-readable name for the layer. -}
    , _stack_id :: !(TF.Argument "stack_id" Text)
    {- ^ (Required) The id of the stack the layer will belong to. -}
    , _stats_enabled :: !(TF.Argument "stats_enabled" TF.Bool)
    {- ^ (Optional) Whether to enable HAProxy stats. -}
    , _stats_password :: !(TF.Argument "stats_password" Text)
    {- ^ (Required) The password to use for HAProxy stats. -}
    , _stats_url :: !(TF.Argument "stats_url" Text)
    {- ^ (Optional) The HAProxy stats URL. Defaults to "/haproxy?stats". -}
    , _stats_user :: !(TF.Argument "stats_user" Text)
    {- ^ (Optional) The username for HAProxy stats. Defaults to "opsworks". -}
    , _system_packages :: !(TF.Argument "system_packages" Text)
    {- ^ (Optional) Names of a set of system packages to install on the layer's instances. -}
    , _use_ebs_optimized_instances :: !(TF.Argument "use_ebs_optimized_instances" Text)
    {- ^ (Optional) Whether to use EBS-optimized instances. -}
    } deriving (Show, Eq)

instance TF.ToHCL OpsworksHaproxyLayerResource where
    toHCL OpsworksHaproxyLayerResource{..} = TF.block $ catMaybes
        [ TF.argument _auto_assign_elastic_ips
        , TF.argument _auto_assign_public_ips
        , TF.argument _auto_healing
        , TF.argument _custom_instance_profile_arn
        , TF.argument _custom_json
        , TF.argument _custom_security_group_ids
        , TF.argument _drain_elb_on_shutdown
        , TF.argument _ebs_volume
        , TF.argument _elastic_load_balancer
        , TF.argument _healthcheck_method
        , TF.argument _healthcheck_url
        , TF.argument _install_updates_on_boot
        , TF.argument _instance_shutdown_timeout
        , TF.argument _name
        , TF.argument _stack_id
        , TF.argument _stats_enabled
        , TF.argument _stats_password
        , TF.argument _stats_url
        , TF.argument _stats_user
        , TF.argument _system_packages
        , TF.argument _use_ebs_optimized_instances
        ]

instance HasAutoAssignElasticIps OpsworksHaproxyLayerResource Text where
    autoAssignElasticIps =
        lens (_auto_assign_elastic_ips :: OpsworksHaproxyLayerResource -> TF.Argument "auto_assign_elastic_ips" Text)
             (\s a -> s { _auto_assign_elastic_ips = a } :: OpsworksHaproxyLayerResource)

instance HasAutoAssignPublicIps OpsworksHaproxyLayerResource Text where
    autoAssignPublicIps =
        lens (_auto_assign_public_ips :: OpsworksHaproxyLayerResource -> TF.Argument "auto_assign_public_ips" Text)
             (\s a -> s { _auto_assign_public_ips = a } :: OpsworksHaproxyLayerResource)

instance HasAutoHealing OpsworksHaproxyLayerResource Text where
    autoHealing =
        lens (_auto_healing :: OpsworksHaproxyLayerResource -> TF.Argument "auto_healing" Text)
             (\s a -> s { _auto_healing = a } :: OpsworksHaproxyLayerResource)

instance HasCustomInstanceProfileArn OpsworksHaproxyLayerResource Text where
    customInstanceProfileArn =
        lens (_custom_instance_profile_arn :: OpsworksHaproxyLayerResource -> TF.Argument "custom_instance_profile_arn" Text)
             (\s a -> s { _custom_instance_profile_arn = a } :: OpsworksHaproxyLayerResource)

instance HasCustomJson OpsworksHaproxyLayerResource Text where
    customJson =
        lens (_custom_json :: OpsworksHaproxyLayerResource -> TF.Argument "custom_json" Text)
             (\s a -> s { _custom_json = a } :: OpsworksHaproxyLayerResource)

instance HasCustomSecurityGroupIds OpsworksHaproxyLayerResource Text where
    customSecurityGroupIds =
        lens (_custom_security_group_ids :: OpsworksHaproxyLayerResource -> TF.Argument "custom_security_group_ids" Text)
             (\s a -> s { _custom_security_group_ids = a } :: OpsworksHaproxyLayerResource)

instance HasDrainElbOnShutdown OpsworksHaproxyLayerResource Text where
    drainElbOnShutdown =
        lens (_drain_elb_on_shutdown :: OpsworksHaproxyLayerResource -> TF.Argument "drain_elb_on_shutdown" Text)
             (\s a -> s { _drain_elb_on_shutdown = a } :: OpsworksHaproxyLayerResource)

instance HasEbsVolume OpsworksHaproxyLayerResource Text where
    ebsVolume =
        lens (_ebs_volume :: OpsworksHaproxyLayerResource -> TF.Argument "ebs_volume" Text)
             (\s a -> s { _ebs_volume = a } :: OpsworksHaproxyLayerResource)

instance HasElasticLoadBalancer OpsworksHaproxyLayerResource Text where
    elasticLoadBalancer =
        lens (_elastic_load_balancer :: OpsworksHaproxyLayerResource -> TF.Argument "elastic_load_balancer" Text)
             (\s a -> s { _elastic_load_balancer = a } :: OpsworksHaproxyLayerResource)

instance HasHealthcheckMethod OpsworksHaproxyLayerResource Text where
    healthcheckMethod =
        lens (_healthcheck_method :: OpsworksHaproxyLayerResource -> TF.Argument "healthcheck_method" Text)
             (\s a -> s { _healthcheck_method = a } :: OpsworksHaproxyLayerResource)

instance HasHealthcheckUrl OpsworksHaproxyLayerResource Text where
    healthcheckUrl =
        lens (_healthcheck_url :: OpsworksHaproxyLayerResource -> TF.Argument "healthcheck_url" Text)
             (\s a -> s { _healthcheck_url = a } :: OpsworksHaproxyLayerResource)

instance HasInstallUpdatesOnBoot OpsworksHaproxyLayerResource Text where
    installUpdatesOnBoot =
        lens (_install_updates_on_boot :: OpsworksHaproxyLayerResource -> TF.Argument "install_updates_on_boot" Text)
             (\s a -> s { _install_updates_on_boot = a } :: OpsworksHaproxyLayerResource)

instance HasInstanceShutdownTimeout OpsworksHaproxyLayerResource Text where
    instanceShutdownTimeout =
        lens (_instance_shutdown_timeout :: OpsworksHaproxyLayerResource -> TF.Argument "instance_shutdown_timeout" Text)
             (\s a -> s { _instance_shutdown_timeout = a } :: OpsworksHaproxyLayerResource)

instance HasName OpsworksHaproxyLayerResource Text where
    name =
        lens (_name :: OpsworksHaproxyLayerResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: OpsworksHaproxyLayerResource)

instance HasStackId OpsworksHaproxyLayerResource Text where
    stackId =
        lens (_stack_id :: OpsworksHaproxyLayerResource -> TF.Argument "stack_id" Text)
             (\s a -> s { _stack_id = a } :: OpsworksHaproxyLayerResource)

instance HasStatsEnabled OpsworksHaproxyLayerResource TF.Bool where
    statsEnabled =
        lens (_stats_enabled :: OpsworksHaproxyLayerResource -> TF.Argument "stats_enabled" TF.Bool)
             (\s a -> s { _stats_enabled = a } :: OpsworksHaproxyLayerResource)

instance HasStatsPassword OpsworksHaproxyLayerResource Text where
    statsPassword =
        lens (_stats_password :: OpsworksHaproxyLayerResource -> TF.Argument "stats_password" Text)
             (\s a -> s { _stats_password = a } :: OpsworksHaproxyLayerResource)

instance HasStatsUrl OpsworksHaproxyLayerResource Text where
    statsUrl =
        lens (_stats_url :: OpsworksHaproxyLayerResource -> TF.Argument "stats_url" Text)
             (\s a -> s { _stats_url = a } :: OpsworksHaproxyLayerResource)

instance HasStatsUser OpsworksHaproxyLayerResource Text where
    statsUser =
        lens (_stats_user :: OpsworksHaproxyLayerResource -> TF.Argument "stats_user" Text)
             (\s a -> s { _stats_user = a } :: OpsworksHaproxyLayerResource)

instance HasSystemPackages OpsworksHaproxyLayerResource Text where
    systemPackages =
        lens (_system_packages :: OpsworksHaproxyLayerResource -> TF.Argument "system_packages" Text)
             (\s a -> s { _system_packages = a } :: OpsworksHaproxyLayerResource)

instance HasUseEbsOptimizedInstances OpsworksHaproxyLayerResource Text where
    useEbsOptimizedInstances =
        lens (_use_ebs_optimized_instances :: OpsworksHaproxyLayerResource -> TF.Argument "use_ebs_optimized_instances" Text)
             (\s a -> s { _use_ebs_optimized_instances = a } :: OpsworksHaproxyLayerResource)

instance HasComputedId OpsworksHaproxyLayerResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

opsworksHaproxyLayerResource :: TF.Resource TF.AWS OpsworksHaproxyLayerResource
opsworksHaproxyLayerResource =
    TF.newResource "aws_opsworks_haproxy_layer" $
        OpsworksHaproxyLayerResource {
            _auto_assign_elastic_ips = TF.Nil
            , _auto_assign_public_ips = TF.Nil
            , _auto_healing = TF.Nil
            , _custom_instance_profile_arn = TF.Nil
            , _custom_json = TF.Nil
            , _custom_security_group_ids = TF.Nil
            , _drain_elb_on_shutdown = TF.Nil
            , _ebs_volume = TF.Nil
            , _elastic_load_balancer = TF.Nil
            , _healthcheck_method = TF.Nil
            , _healthcheck_url = TF.Nil
            , _install_updates_on_boot = TF.Nil
            , _instance_shutdown_timeout = TF.Nil
            , _name = TF.Nil
            , _stack_id = TF.Nil
            , _stats_enabled = TF.Nil
            , _stats_password = TF.Nil
            , _stats_url = TF.Nil
            , _stats_user = TF.Nil
            , _system_packages = TF.Nil
            , _use_ebs_optimized_instances = TF.Nil
            }

{- | The @aws_opsworks_instance@ AWS resource.

Provides an OpsWorks instance resource.
-}
data OpsworksInstanceResource = OpsworksInstanceResource {
      _agent_version :: !(TF.Argument "agent_version" Text)
    {- ^ (Optional) The AWS OpsWorks agent to install.  Defaults to @"INHERIT"@ . -}
    , _ami_id :: !(TF.Argument "ami_id" Text)
    {- ^ (Optional) The AMI to use for the instance.  If an AMI is specified, @os@ must be @"Custom"@ . -}
    , _architecture :: !(TF.Argument "architecture" Text)
    {- ^ (Optional) Machine architecture for created instances.  Can be either @"x86_64"@ (the default) or @"i386"@ -}
    , _auto_scaling_type :: !(TF.Argument "auto_scaling_type" Text)
    {- ^ (Optional) Creates load-based or time-based instances.  If set, can be either: @"load"@ or @"timer"@ . -}
    , _availability_zone :: !(TF.Argument "availability_zone" TF.Zone)
    {- ^ (Optional) Name of the availability zone where instances will be created by default. -}
    , _ebs_block_device :: !(TF.Argument "ebs_block_device" Text)
    {- ^ (Optional) Additional EBS block devices to attach to the instance.  See <#block-devices> below for details. -}
    , _ebs_optimized :: !(TF.Argument "ebs_optimized" Text)
    {- ^ (Optional) If true, the launched EC2 instance will be EBS-optimized. -}
    , _ephemeral_block_device :: !(TF.Argument "ephemeral_block_device" Text)
    {- ^ (Optional) Customize Ephemeral (also known as "Instance Store") volumes on the instance. See <#block-devices> below for details. -}
    , _hostname :: !(TF.Argument "hostname" Text)
    {- ^ (Optional) The instance's host name. -}
    , _install_updates_on_boot :: !(TF.Argument "install_updates_on_boot" Text)
    {- ^ (Optional) Controls where to install OS and package updates when the instance boots.  Defaults to @true@ . -}
    , _instance_type :: !(TF.Argument "instance_type" Text)
    {- ^ (Required) The type of instance to start -}
    , _layer_ids :: !(TF.Argument "layer_ids" Text)
    {- ^ (Required) The ids of the layers the instance will belong to. -}
    , _os :: !(TF.Argument "os" Text)
    {- ^ (Optional) Name of operating system that will be installed. -}
    , _root_block_device :: !(TF.Argument "root_block_device" Text)
    {- ^ (Optional) Customize details about the root block device of the instance. See <#block-devices> below for details. -}
    , _root_device_type :: !(TF.Argument "root_device_type" Text)
    {- ^ (Optional) Name of the type of root device instances will have by default.  Can be either @"ebs"@ or @"instance-store"@ -}
    , _ssh_key_name :: !(TF.Argument "ssh_key_name" Text)
    {- ^ (Optional) Name of the SSH keypair that instances will have by default. -}
    , _stack_id :: !(TF.Argument "stack_id" Text)
    {- ^ (Required) The id of the stack the instance will belong to. -}
    , _state :: !(TF.Argument "state" Text)
    {- ^ (Optional) The desired state of the instance.  Can be either @"running"@ or @"stopped"@ . -}
    , _subnet_id :: !(TF.Argument "subnet_id" Text)
    {- ^ (Optional) Subnet ID to attach to -}
    , _tenancy :: !(TF.Argument "tenancy" Text)
    {- ^ (Optional) Instance tenancy to use. Can be one of @"default"@ , @"dedicated"@ or @"host"@ -}
    , _virtualization_type :: !(TF.Argument "virtualization_type" Text)
    {- ^ (Optional) Keyword to choose what virtualization mode created instances will use. Can be either @"paravirtual"@ or @"hvm"@ . -}
    } deriving (Show, Eq)

instance TF.ToHCL OpsworksInstanceResource where
    toHCL OpsworksInstanceResource{..} = TF.block $ catMaybes
        [ TF.argument _agent_version
        , TF.argument _ami_id
        , TF.argument _architecture
        , TF.argument _auto_scaling_type
        , TF.argument _availability_zone
        , TF.argument _ebs_block_device
        , TF.argument _ebs_optimized
        , TF.argument _ephemeral_block_device
        , TF.argument _hostname
        , TF.argument _install_updates_on_boot
        , TF.argument _instance_type
        , TF.argument _layer_ids
        , TF.argument _os
        , TF.argument _root_block_device
        , TF.argument _root_device_type
        , TF.argument _ssh_key_name
        , TF.argument _stack_id
        , TF.argument _state
        , TF.argument _subnet_id
        , TF.argument _tenancy
        , TF.argument _virtualization_type
        ]

instance HasAgentVersion OpsworksInstanceResource Text where
    agentVersion =
        lens (_agent_version :: OpsworksInstanceResource -> TF.Argument "agent_version" Text)
             (\s a -> s { _agent_version = a } :: OpsworksInstanceResource)

instance HasAmiId OpsworksInstanceResource Text where
    amiId =
        lens (_ami_id :: OpsworksInstanceResource -> TF.Argument "ami_id" Text)
             (\s a -> s { _ami_id = a } :: OpsworksInstanceResource)

instance HasArchitecture OpsworksInstanceResource Text where
    architecture =
        lens (_architecture :: OpsworksInstanceResource -> TF.Argument "architecture" Text)
             (\s a -> s { _architecture = a } :: OpsworksInstanceResource)

instance HasAutoScalingType OpsworksInstanceResource Text where
    autoScalingType =
        lens (_auto_scaling_type :: OpsworksInstanceResource -> TF.Argument "auto_scaling_type" Text)
             (\s a -> s { _auto_scaling_type = a } :: OpsworksInstanceResource)

instance HasAvailabilityZone OpsworksInstanceResource TF.Zone where
    availabilityZone =
        lens (_availability_zone :: OpsworksInstanceResource -> TF.Argument "availability_zone" TF.Zone)
             (\s a -> s { _availability_zone = a } :: OpsworksInstanceResource)

instance HasEbsBlockDevice OpsworksInstanceResource Text where
    ebsBlockDevice =
        lens (_ebs_block_device :: OpsworksInstanceResource -> TF.Argument "ebs_block_device" Text)
             (\s a -> s { _ebs_block_device = a } :: OpsworksInstanceResource)

instance HasEbsOptimized OpsworksInstanceResource Text where
    ebsOptimized =
        lens (_ebs_optimized :: OpsworksInstanceResource -> TF.Argument "ebs_optimized" Text)
             (\s a -> s { _ebs_optimized = a } :: OpsworksInstanceResource)

instance HasEphemeralBlockDevice OpsworksInstanceResource Text where
    ephemeralBlockDevice =
        lens (_ephemeral_block_device :: OpsworksInstanceResource -> TF.Argument "ephemeral_block_device" Text)
             (\s a -> s { _ephemeral_block_device = a } :: OpsworksInstanceResource)

instance HasHostname OpsworksInstanceResource Text where
    hostname =
        lens (_hostname :: OpsworksInstanceResource -> TF.Argument "hostname" Text)
             (\s a -> s { _hostname = a } :: OpsworksInstanceResource)

instance HasInstallUpdatesOnBoot OpsworksInstanceResource Text where
    installUpdatesOnBoot =
        lens (_install_updates_on_boot :: OpsworksInstanceResource -> TF.Argument "install_updates_on_boot" Text)
             (\s a -> s { _install_updates_on_boot = a } :: OpsworksInstanceResource)

instance HasInstanceType OpsworksInstanceResource Text where
    instanceType =
        lens (_instance_type :: OpsworksInstanceResource -> TF.Argument "instance_type" Text)
             (\s a -> s { _instance_type = a } :: OpsworksInstanceResource)

instance HasLayerIds OpsworksInstanceResource Text where
    layerIds =
        lens (_layer_ids :: OpsworksInstanceResource -> TF.Argument "layer_ids" Text)
             (\s a -> s { _layer_ids = a } :: OpsworksInstanceResource)

instance HasOs OpsworksInstanceResource Text where
    os =
        lens (_os :: OpsworksInstanceResource -> TF.Argument "os" Text)
             (\s a -> s { _os = a } :: OpsworksInstanceResource)

instance HasRootBlockDevice OpsworksInstanceResource Text where
    rootBlockDevice =
        lens (_root_block_device :: OpsworksInstanceResource -> TF.Argument "root_block_device" Text)
             (\s a -> s { _root_block_device = a } :: OpsworksInstanceResource)

instance HasRootDeviceType OpsworksInstanceResource Text where
    rootDeviceType =
        lens (_root_device_type :: OpsworksInstanceResource -> TF.Argument "root_device_type" Text)
             (\s a -> s { _root_device_type = a } :: OpsworksInstanceResource)

instance HasSshKeyName OpsworksInstanceResource Text where
    sshKeyName =
        lens (_ssh_key_name :: OpsworksInstanceResource -> TF.Argument "ssh_key_name" Text)
             (\s a -> s { _ssh_key_name = a } :: OpsworksInstanceResource)

instance HasStackId OpsworksInstanceResource Text where
    stackId =
        lens (_stack_id :: OpsworksInstanceResource -> TF.Argument "stack_id" Text)
             (\s a -> s { _stack_id = a } :: OpsworksInstanceResource)

instance HasState OpsworksInstanceResource Text where
    state =
        lens (_state :: OpsworksInstanceResource -> TF.Argument "state" Text)
             (\s a -> s { _state = a } :: OpsworksInstanceResource)

instance HasSubnetId OpsworksInstanceResource Text where
    subnetId =
        lens (_subnet_id :: OpsworksInstanceResource -> TF.Argument "subnet_id" Text)
             (\s a -> s { _subnet_id = a } :: OpsworksInstanceResource)

instance HasTenancy OpsworksInstanceResource Text where
    tenancy =
        lens (_tenancy :: OpsworksInstanceResource -> TF.Argument "tenancy" Text)
             (\s a -> s { _tenancy = a } :: OpsworksInstanceResource)

instance HasVirtualizationType OpsworksInstanceResource Text where
    virtualizationType =
        lens (_virtualization_type :: OpsworksInstanceResource -> TF.Argument "virtualization_type" Text)
             (\s a -> s { _virtualization_type = a } :: OpsworksInstanceResource)

opsworksInstanceResource :: TF.Resource TF.AWS OpsworksInstanceResource
opsworksInstanceResource =
    TF.newResource "aws_opsworks_instance" $
        OpsworksInstanceResource {
            _agent_version = TF.Nil
            , _ami_id = TF.Nil
            , _architecture = TF.Nil
            , _auto_scaling_type = TF.Nil
            , _availability_zone = TF.Nil
            , _ebs_block_device = TF.Nil
            , _ebs_optimized = TF.Nil
            , _ephemeral_block_device = TF.Nil
            , _hostname = TF.Nil
            , _install_updates_on_boot = TF.Nil
            , _instance_type = TF.Nil
            , _layer_ids = TF.Nil
            , _os = TF.Nil
            , _root_block_device = TF.Nil
            , _root_device_type = TF.Nil
            , _ssh_key_name = TF.Nil
            , _stack_id = TF.Nil
            , _state = TF.Nil
            , _subnet_id = TF.Nil
            , _tenancy = TF.Nil
            , _virtualization_type = TF.Nil
            }

{- | The @aws_opsworks_java_app_layer@ AWS resource.

Provides an OpsWorks Java application layer resource.
-}
data OpsworksJavaAppLayerResource = OpsworksJavaAppLayerResource {
      _app_server :: !(TF.Argument "app_server" Text)
    {- ^ (Optional) Keyword for the application container to use. Defaults to "tomcat". -}
    , _app_server_version :: !(TF.Argument "app_server_version" Text)
    {- ^ (Optional) Version of the selected application container to use. Defaults to "7". -}
    , _auto_assign_elastic_ips :: !(TF.Argument "auto_assign_elastic_ips" Text)
    {- ^ (Optional) Whether to automatically assign an elastic IP address to the layer's instances. -}
    , _auto_assign_public_ips :: !(TF.Argument "auto_assign_public_ips" Text)
    {- ^ (Optional) For stacks belonging to a VPC, whether to automatically assign a public IP address to each of the layer's instances. -}
    , _auto_healing :: !(TF.Argument "auto_healing" Text)
    {- ^ (Optional) Whether to enable auto-healing for the layer. -}
    , _custom_instance_profile_arn :: !(TF.Argument "custom_instance_profile_arn" Text)
    {- ^ (Optional) The ARN of an IAM profile that will be used for the layer's instances. -}
    , _custom_json :: !(TF.Argument "custom_json" Text)
    {- ^ (Optional) Custom JSON attributes to apply to the layer. -}
    , _custom_security_group_ids :: !(TF.Argument "custom_security_group_ids" Text)
    {- ^ (Optional) Ids for a set of security groups to apply to the layer's instances. -}
    , _drain_elb_on_shutdown :: !(TF.Argument "drain_elb_on_shutdown" Text)
    {- ^ (Optional) Whether to enable Elastic Load Balancing connection draining. -}
    , _ebs_volume :: !(TF.Argument "ebs_volume" Text)
    {- ^ (Optional) @ebs_volume@ blocks, as described below, will each create an EBS volume and connect it to the layer's instances. -}
    , _elastic_load_balancer :: !(TF.Argument "elastic_load_balancer" Text)
    {- ^ (Optional) Name of an Elastic Load Balancer to attach to this layer -}
    , _install_updates_on_boot :: !(TF.Argument "install_updates_on_boot" Text)
    {- ^ (Optional) Whether to install OS and package updates on each instance when it boots. -}
    , _instance_shutdown_timeout :: !(TF.Argument "instance_shutdown_timeout" Text)
    {- ^ (Optional) The time, in seconds, that OpsWorks will wait for Chef to complete after triggering the Shutdown event. -}
    , _jvm_options :: !(TF.Argument "jvm_options" Text)
    {- ^ (Optional) Options to set for the JVM. -}
    , _jvm_type :: !(TF.Argument "jvm_type" Text)
    {- ^ (Optional) Keyword for the type of JVM to use. Defaults to @openjdk@ . -}
    , _jvm_version :: !(TF.Argument "jvm_version" Text)
    {- ^ (Optional) Version of JVM to use. Defaults to "7". -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Optional) A human-readable name for the layer. -}
    , _stack_id :: !(TF.Argument "stack_id" Text)
    {- ^ (Required) The id of the stack the layer will belong to. -}
    , _system_packages :: !(TF.Argument "system_packages" Text)
    {- ^ (Optional) Names of a set of system packages to install on the layer's instances. -}
    , _use_ebs_optimized_instances :: !(TF.Argument "use_ebs_optimized_instances" Text)
    {- ^ (Optional) Whether to use EBS-optimized instances. -}
    } deriving (Show, Eq)

instance TF.ToHCL OpsworksJavaAppLayerResource where
    toHCL OpsworksJavaAppLayerResource{..} = TF.block $ catMaybes
        [ TF.argument _app_server
        , TF.argument _app_server_version
        , TF.argument _auto_assign_elastic_ips
        , TF.argument _auto_assign_public_ips
        , TF.argument _auto_healing
        , TF.argument _custom_instance_profile_arn
        , TF.argument _custom_json
        , TF.argument _custom_security_group_ids
        , TF.argument _drain_elb_on_shutdown
        , TF.argument _ebs_volume
        , TF.argument _elastic_load_balancer
        , TF.argument _install_updates_on_boot
        , TF.argument _instance_shutdown_timeout
        , TF.argument _jvm_options
        , TF.argument _jvm_type
        , TF.argument _jvm_version
        , TF.argument _name
        , TF.argument _stack_id
        , TF.argument _system_packages
        , TF.argument _use_ebs_optimized_instances
        ]

instance HasAppServer OpsworksJavaAppLayerResource Text where
    appServer =
        lens (_app_server :: OpsworksJavaAppLayerResource -> TF.Argument "app_server" Text)
             (\s a -> s { _app_server = a } :: OpsworksJavaAppLayerResource)

instance HasAppServerVersion OpsworksJavaAppLayerResource Text where
    appServerVersion =
        lens (_app_server_version :: OpsworksJavaAppLayerResource -> TF.Argument "app_server_version" Text)
             (\s a -> s { _app_server_version = a } :: OpsworksJavaAppLayerResource)

instance HasAutoAssignElasticIps OpsworksJavaAppLayerResource Text where
    autoAssignElasticIps =
        lens (_auto_assign_elastic_ips :: OpsworksJavaAppLayerResource -> TF.Argument "auto_assign_elastic_ips" Text)
             (\s a -> s { _auto_assign_elastic_ips = a } :: OpsworksJavaAppLayerResource)

instance HasAutoAssignPublicIps OpsworksJavaAppLayerResource Text where
    autoAssignPublicIps =
        lens (_auto_assign_public_ips :: OpsworksJavaAppLayerResource -> TF.Argument "auto_assign_public_ips" Text)
             (\s a -> s { _auto_assign_public_ips = a } :: OpsworksJavaAppLayerResource)

instance HasAutoHealing OpsworksJavaAppLayerResource Text where
    autoHealing =
        lens (_auto_healing :: OpsworksJavaAppLayerResource -> TF.Argument "auto_healing" Text)
             (\s a -> s { _auto_healing = a } :: OpsworksJavaAppLayerResource)

instance HasCustomInstanceProfileArn OpsworksJavaAppLayerResource Text where
    customInstanceProfileArn =
        lens (_custom_instance_profile_arn :: OpsworksJavaAppLayerResource -> TF.Argument "custom_instance_profile_arn" Text)
             (\s a -> s { _custom_instance_profile_arn = a } :: OpsworksJavaAppLayerResource)

instance HasCustomJson OpsworksJavaAppLayerResource Text where
    customJson =
        lens (_custom_json :: OpsworksJavaAppLayerResource -> TF.Argument "custom_json" Text)
             (\s a -> s { _custom_json = a } :: OpsworksJavaAppLayerResource)

instance HasCustomSecurityGroupIds OpsworksJavaAppLayerResource Text where
    customSecurityGroupIds =
        lens (_custom_security_group_ids :: OpsworksJavaAppLayerResource -> TF.Argument "custom_security_group_ids" Text)
             (\s a -> s { _custom_security_group_ids = a } :: OpsworksJavaAppLayerResource)

instance HasDrainElbOnShutdown OpsworksJavaAppLayerResource Text where
    drainElbOnShutdown =
        lens (_drain_elb_on_shutdown :: OpsworksJavaAppLayerResource -> TF.Argument "drain_elb_on_shutdown" Text)
             (\s a -> s { _drain_elb_on_shutdown = a } :: OpsworksJavaAppLayerResource)

instance HasEbsVolume OpsworksJavaAppLayerResource Text where
    ebsVolume =
        lens (_ebs_volume :: OpsworksJavaAppLayerResource -> TF.Argument "ebs_volume" Text)
             (\s a -> s { _ebs_volume = a } :: OpsworksJavaAppLayerResource)

instance HasElasticLoadBalancer OpsworksJavaAppLayerResource Text where
    elasticLoadBalancer =
        lens (_elastic_load_balancer :: OpsworksJavaAppLayerResource -> TF.Argument "elastic_load_balancer" Text)
             (\s a -> s { _elastic_load_balancer = a } :: OpsworksJavaAppLayerResource)

instance HasInstallUpdatesOnBoot OpsworksJavaAppLayerResource Text where
    installUpdatesOnBoot =
        lens (_install_updates_on_boot :: OpsworksJavaAppLayerResource -> TF.Argument "install_updates_on_boot" Text)
             (\s a -> s { _install_updates_on_boot = a } :: OpsworksJavaAppLayerResource)

instance HasInstanceShutdownTimeout OpsworksJavaAppLayerResource Text where
    instanceShutdownTimeout =
        lens (_instance_shutdown_timeout :: OpsworksJavaAppLayerResource -> TF.Argument "instance_shutdown_timeout" Text)
             (\s a -> s { _instance_shutdown_timeout = a } :: OpsworksJavaAppLayerResource)

instance HasJvmOptions OpsworksJavaAppLayerResource Text where
    jvmOptions =
        lens (_jvm_options :: OpsworksJavaAppLayerResource -> TF.Argument "jvm_options" Text)
             (\s a -> s { _jvm_options = a } :: OpsworksJavaAppLayerResource)

instance HasJvmType OpsworksJavaAppLayerResource Text where
    jvmType =
        lens (_jvm_type :: OpsworksJavaAppLayerResource -> TF.Argument "jvm_type" Text)
             (\s a -> s { _jvm_type = a } :: OpsworksJavaAppLayerResource)

instance HasJvmVersion OpsworksJavaAppLayerResource Text where
    jvmVersion =
        lens (_jvm_version :: OpsworksJavaAppLayerResource -> TF.Argument "jvm_version" Text)
             (\s a -> s { _jvm_version = a } :: OpsworksJavaAppLayerResource)

instance HasName OpsworksJavaAppLayerResource Text where
    name =
        lens (_name :: OpsworksJavaAppLayerResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: OpsworksJavaAppLayerResource)

instance HasStackId OpsworksJavaAppLayerResource Text where
    stackId =
        lens (_stack_id :: OpsworksJavaAppLayerResource -> TF.Argument "stack_id" Text)
             (\s a -> s { _stack_id = a } :: OpsworksJavaAppLayerResource)

instance HasSystemPackages OpsworksJavaAppLayerResource Text where
    systemPackages =
        lens (_system_packages :: OpsworksJavaAppLayerResource -> TF.Argument "system_packages" Text)
             (\s a -> s { _system_packages = a } :: OpsworksJavaAppLayerResource)

instance HasUseEbsOptimizedInstances OpsworksJavaAppLayerResource Text where
    useEbsOptimizedInstances =
        lens (_use_ebs_optimized_instances :: OpsworksJavaAppLayerResource -> TF.Argument "use_ebs_optimized_instances" Text)
             (\s a -> s { _use_ebs_optimized_instances = a } :: OpsworksJavaAppLayerResource)

instance HasComputedId OpsworksJavaAppLayerResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

opsworksJavaAppLayerResource :: TF.Resource TF.AWS OpsworksJavaAppLayerResource
opsworksJavaAppLayerResource =
    TF.newResource "aws_opsworks_java_app_layer" $
        OpsworksJavaAppLayerResource {
            _app_server = TF.Nil
            , _app_server_version = TF.Nil
            , _auto_assign_elastic_ips = TF.Nil
            , _auto_assign_public_ips = TF.Nil
            , _auto_healing = TF.Nil
            , _custom_instance_profile_arn = TF.Nil
            , _custom_json = TF.Nil
            , _custom_security_group_ids = TF.Nil
            , _drain_elb_on_shutdown = TF.Nil
            , _ebs_volume = TF.Nil
            , _elastic_load_balancer = TF.Nil
            , _install_updates_on_boot = TF.Nil
            , _instance_shutdown_timeout = TF.Nil
            , _jvm_options = TF.Nil
            , _jvm_type = TF.Nil
            , _jvm_version = TF.Nil
            , _name = TF.Nil
            , _stack_id = TF.Nil
            , _system_packages = TF.Nil
            , _use_ebs_optimized_instances = TF.Nil
            }

{- | The @aws_opsworks_memcached_layer@ AWS resource.

Provides an OpsWorks memcached layer resource.
-}
data OpsworksMemcachedLayerResource = OpsworksMemcachedLayerResource {
      _allocated_memory :: !(TF.Argument "allocated_memory" Text)
    {- ^ (Optional) Amount of memory to allocate for the cache on each instance, in megabytes. Defaults to 512MB. -}
    , _auto_assign_elastic_ips :: !(TF.Argument "auto_assign_elastic_ips" Text)
    {- ^ (Optional) Whether to automatically assign an elastic IP address to the layer's instances. -}
    , _auto_assign_public_ips :: !(TF.Argument "auto_assign_public_ips" Text)
    {- ^ (Optional) For stacks belonging to a VPC, whether to automatically assign a public IP address to each of the layer's instances. -}
    , _auto_healing :: !(TF.Argument "auto_healing" Text)
    {- ^ (Optional) Whether to enable auto-healing for the layer. -}
    , _custom_instance_profile_arn :: !(TF.Argument "custom_instance_profile_arn" Text)
    {- ^ (Optional) The ARN of an IAM profile that will be used for the layer's instances. -}
    , _custom_json :: !(TF.Argument "custom_json" Text)
    {- ^ (Optional) Custom JSON attributes to apply to the layer. -}
    , _custom_security_group_ids :: !(TF.Argument "custom_security_group_ids" Text)
    {- ^ (Optional) Ids for a set of security groups to apply to the layer's instances. -}
    , _drain_elb_on_shutdown :: !(TF.Argument "drain_elb_on_shutdown" Text)
    {- ^ (Optional) Whether to enable Elastic Load Balancing connection draining. -}
    , _ebs_volume :: !(TF.Argument "ebs_volume" Text)
    {- ^ (Optional) @ebs_volume@ blocks, as described below, will each create an EBS volume and connect it to the layer's instances. -}
    , _elastic_load_balancer :: !(TF.Argument "elastic_load_balancer" Text)
    {- ^ (Optional) Name of an Elastic Load Balancer to attach to this layer -}
    , _install_updates_on_boot :: !(TF.Argument "install_updates_on_boot" Text)
    {- ^ (Optional) Whether to install OS and package updates on each instance when it boots. -}
    , _instance_shutdown_timeout :: !(TF.Argument "instance_shutdown_timeout" Text)
    {- ^ (Optional) The time, in seconds, that OpsWorks will wait for Chef to complete after triggering the Shutdown event. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Optional) A human-readable name for the layer. -}
    , _stack_id :: !(TF.Argument "stack_id" Text)
    {- ^ (Required) The id of the stack the layer will belong to. -}
    , _system_packages :: !(TF.Argument "system_packages" Text)
    {- ^ (Optional) Names of a set of system packages to install on the layer's instances. -}
    , _use_ebs_optimized_instances :: !(TF.Argument "use_ebs_optimized_instances" Text)
    {- ^ (Optional) Whether to use EBS-optimized instances. -}
    } deriving (Show, Eq)

instance TF.ToHCL OpsworksMemcachedLayerResource where
    toHCL OpsworksMemcachedLayerResource{..} = TF.block $ catMaybes
        [ TF.argument _allocated_memory
        , TF.argument _auto_assign_elastic_ips
        , TF.argument _auto_assign_public_ips
        , TF.argument _auto_healing
        , TF.argument _custom_instance_profile_arn
        , TF.argument _custom_json
        , TF.argument _custom_security_group_ids
        , TF.argument _drain_elb_on_shutdown
        , TF.argument _ebs_volume
        , TF.argument _elastic_load_balancer
        , TF.argument _install_updates_on_boot
        , TF.argument _instance_shutdown_timeout
        , TF.argument _name
        , TF.argument _stack_id
        , TF.argument _system_packages
        , TF.argument _use_ebs_optimized_instances
        ]

instance HasAllocatedMemory OpsworksMemcachedLayerResource Text where
    allocatedMemory =
        lens (_allocated_memory :: OpsworksMemcachedLayerResource -> TF.Argument "allocated_memory" Text)
             (\s a -> s { _allocated_memory = a } :: OpsworksMemcachedLayerResource)

instance HasAutoAssignElasticIps OpsworksMemcachedLayerResource Text where
    autoAssignElasticIps =
        lens (_auto_assign_elastic_ips :: OpsworksMemcachedLayerResource -> TF.Argument "auto_assign_elastic_ips" Text)
             (\s a -> s { _auto_assign_elastic_ips = a } :: OpsworksMemcachedLayerResource)

instance HasAutoAssignPublicIps OpsworksMemcachedLayerResource Text where
    autoAssignPublicIps =
        lens (_auto_assign_public_ips :: OpsworksMemcachedLayerResource -> TF.Argument "auto_assign_public_ips" Text)
             (\s a -> s { _auto_assign_public_ips = a } :: OpsworksMemcachedLayerResource)

instance HasAutoHealing OpsworksMemcachedLayerResource Text where
    autoHealing =
        lens (_auto_healing :: OpsworksMemcachedLayerResource -> TF.Argument "auto_healing" Text)
             (\s a -> s { _auto_healing = a } :: OpsworksMemcachedLayerResource)

instance HasCustomInstanceProfileArn OpsworksMemcachedLayerResource Text where
    customInstanceProfileArn =
        lens (_custom_instance_profile_arn :: OpsworksMemcachedLayerResource -> TF.Argument "custom_instance_profile_arn" Text)
             (\s a -> s { _custom_instance_profile_arn = a } :: OpsworksMemcachedLayerResource)

instance HasCustomJson OpsworksMemcachedLayerResource Text where
    customJson =
        lens (_custom_json :: OpsworksMemcachedLayerResource -> TF.Argument "custom_json" Text)
             (\s a -> s { _custom_json = a } :: OpsworksMemcachedLayerResource)

instance HasCustomSecurityGroupIds OpsworksMemcachedLayerResource Text where
    customSecurityGroupIds =
        lens (_custom_security_group_ids :: OpsworksMemcachedLayerResource -> TF.Argument "custom_security_group_ids" Text)
             (\s a -> s { _custom_security_group_ids = a } :: OpsworksMemcachedLayerResource)

instance HasDrainElbOnShutdown OpsworksMemcachedLayerResource Text where
    drainElbOnShutdown =
        lens (_drain_elb_on_shutdown :: OpsworksMemcachedLayerResource -> TF.Argument "drain_elb_on_shutdown" Text)
             (\s a -> s { _drain_elb_on_shutdown = a } :: OpsworksMemcachedLayerResource)

instance HasEbsVolume OpsworksMemcachedLayerResource Text where
    ebsVolume =
        lens (_ebs_volume :: OpsworksMemcachedLayerResource -> TF.Argument "ebs_volume" Text)
             (\s a -> s { _ebs_volume = a } :: OpsworksMemcachedLayerResource)

instance HasElasticLoadBalancer OpsworksMemcachedLayerResource Text where
    elasticLoadBalancer =
        lens (_elastic_load_balancer :: OpsworksMemcachedLayerResource -> TF.Argument "elastic_load_balancer" Text)
             (\s a -> s { _elastic_load_balancer = a } :: OpsworksMemcachedLayerResource)

instance HasInstallUpdatesOnBoot OpsworksMemcachedLayerResource Text where
    installUpdatesOnBoot =
        lens (_install_updates_on_boot :: OpsworksMemcachedLayerResource -> TF.Argument "install_updates_on_boot" Text)
             (\s a -> s { _install_updates_on_boot = a } :: OpsworksMemcachedLayerResource)

instance HasInstanceShutdownTimeout OpsworksMemcachedLayerResource Text where
    instanceShutdownTimeout =
        lens (_instance_shutdown_timeout :: OpsworksMemcachedLayerResource -> TF.Argument "instance_shutdown_timeout" Text)
             (\s a -> s { _instance_shutdown_timeout = a } :: OpsworksMemcachedLayerResource)

instance HasName OpsworksMemcachedLayerResource Text where
    name =
        lens (_name :: OpsworksMemcachedLayerResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: OpsworksMemcachedLayerResource)

instance HasStackId OpsworksMemcachedLayerResource Text where
    stackId =
        lens (_stack_id :: OpsworksMemcachedLayerResource -> TF.Argument "stack_id" Text)
             (\s a -> s { _stack_id = a } :: OpsworksMemcachedLayerResource)

instance HasSystemPackages OpsworksMemcachedLayerResource Text where
    systemPackages =
        lens (_system_packages :: OpsworksMemcachedLayerResource -> TF.Argument "system_packages" Text)
             (\s a -> s { _system_packages = a } :: OpsworksMemcachedLayerResource)

instance HasUseEbsOptimizedInstances OpsworksMemcachedLayerResource Text where
    useEbsOptimizedInstances =
        lens (_use_ebs_optimized_instances :: OpsworksMemcachedLayerResource -> TF.Argument "use_ebs_optimized_instances" Text)
             (\s a -> s { _use_ebs_optimized_instances = a } :: OpsworksMemcachedLayerResource)

instance HasComputedId OpsworksMemcachedLayerResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

opsworksMemcachedLayerResource :: TF.Resource TF.AWS OpsworksMemcachedLayerResource
opsworksMemcachedLayerResource =
    TF.newResource "aws_opsworks_memcached_layer" $
        OpsworksMemcachedLayerResource {
            _allocated_memory = TF.Nil
            , _auto_assign_elastic_ips = TF.Nil
            , _auto_assign_public_ips = TF.Nil
            , _auto_healing = TF.Nil
            , _custom_instance_profile_arn = TF.Nil
            , _custom_json = TF.Nil
            , _custom_security_group_ids = TF.Nil
            , _drain_elb_on_shutdown = TF.Nil
            , _ebs_volume = TF.Nil
            , _elastic_load_balancer = TF.Nil
            , _install_updates_on_boot = TF.Nil
            , _instance_shutdown_timeout = TF.Nil
            , _name = TF.Nil
            , _stack_id = TF.Nil
            , _system_packages = TF.Nil
            , _use_ebs_optimized_instances = TF.Nil
            }

{- | The @aws_opsworks_mysql_layer@ AWS resource.

Provides an OpsWorks MySQL layer resource. ~> Note: All arguments including
the root password will be stored in the raw state as plain-text.
</docs/state/sensitive-data.html> .
-}
data OpsworksMysqlLayerResource = OpsworksMysqlLayerResource {
      _auto_assign_elastic_ips :: !(TF.Argument "auto_assign_elastic_ips" Text)
    {- ^ (Optional) Whether to automatically assign an elastic IP address to the layer's instances. -}
    , _auto_assign_public_ips :: !(TF.Argument "auto_assign_public_ips" Text)
    {- ^ (Optional) For stacks belonging to a VPC, whether to automatically assign a public IP address to each of the layer's instances. -}
    , _auto_healing :: !(TF.Argument "auto_healing" Text)
    {- ^ (Optional) Whether to enable auto-healing for the layer. -}
    , _custom_instance_profile_arn :: !(TF.Argument "custom_instance_profile_arn" Text)
    {- ^ (Optional) The ARN of an IAM profile that will be used for the layer's instances. -}
    , _custom_json :: !(TF.Argument "custom_json" Text)
    {- ^ (Optional) Custom JSON attributes to apply to the layer. -}
    , _custom_security_group_ids :: !(TF.Argument "custom_security_group_ids" Text)
    {- ^ (Optional) Ids for a set of security groups to apply to the layer's instances. -}
    , _drain_elb_on_shutdown :: !(TF.Argument "drain_elb_on_shutdown" Text)
    {- ^ (Optional) Whether to enable Elastic Load Balancing connection draining. -}
    , _ebs_volume :: !(TF.Argument "ebs_volume" Text)
    {- ^ (Optional) @ebs_volume@ blocks, as described below, will each create an EBS volume and connect it to the layer's instances. -}
    , _elastic_load_balancer :: !(TF.Argument "elastic_load_balancer" Text)
    {- ^ (Optional) Name of an Elastic Load Balancer to attach to this layer -}
    , _install_updates_on_boot :: !(TF.Argument "install_updates_on_boot" Text)
    {- ^ (Optional) Whether to install OS and package updates on each instance when it boots. -}
    , _instance_shutdown_timeout :: !(TF.Argument "instance_shutdown_timeout" Text)
    {- ^ (Optional) The time, in seconds, that OpsWorks will wait for Chef to complete after triggering the Shutdown event. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Optional) A human-readable name for the layer. -}
    , _root_password :: !(TF.Argument "root_password" Text)
    {- ^ (Optional) Root password to use for MySQL. -}
    , _root_password_on_all_instances :: !(TF.Argument "root_password_on_all_instances" Text)
    {- ^ (Optional) Whether to set the root user password to all instances in the stack so they can access the instances in this layer. -}
    , _stack_id :: !(TF.Argument "stack_id" Text)
    {- ^ (Required) The id of the stack the layer will belong to. -}
    , _system_packages :: !(TF.Argument "system_packages" Text)
    {- ^ (Optional) Names of a set of system packages to install on the layer's instances. -}
    , _use_ebs_optimized_instances :: !(TF.Argument "use_ebs_optimized_instances" Text)
    {- ^ (Optional) Whether to use EBS-optimized instances. -}
    } deriving (Show, Eq)

instance TF.ToHCL OpsworksMysqlLayerResource where
    toHCL OpsworksMysqlLayerResource{..} = TF.block $ catMaybes
        [ TF.argument _auto_assign_elastic_ips
        , TF.argument _auto_assign_public_ips
        , TF.argument _auto_healing
        , TF.argument _custom_instance_profile_arn
        , TF.argument _custom_json
        , TF.argument _custom_security_group_ids
        , TF.argument _drain_elb_on_shutdown
        , TF.argument _ebs_volume
        , TF.argument _elastic_load_balancer
        , TF.argument _install_updates_on_boot
        , TF.argument _instance_shutdown_timeout
        , TF.argument _name
        , TF.argument _root_password
        , TF.argument _root_password_on_all_instances
        , TF.argument _stack_id
        , TF.argument _system_packages
        , TF.argument _use_ebs_optimized_instances
        ]

instance HasAutoAssignElasticIps OpsworksMysqlLayerResource Text where
    autoAssignElasticIps =
        lens (_auto_assign_elastic_ips :: OpsworksMysqlLayerResource -> TF.Argument "auto_assign_elastic_ips" Text)
             (\s a -> s { _auto_assign_elastic_ips = a } :: OpsworksMysqlLayerResource)

instance HasAutoAssignPublicIps OpsworksMysqlLayerResource Text where
    autoAssignPublicIps =
        lens (_auto_assign_public_ips :: OpsworksMysqlLayerResource -> TF.Argument "auto_assign_public_ips" Text)
             (\s a -> s { _auto_assign_public_ips = a } :: OpsworksMysqlLayerResource)

instance HasAutoHealing OpsworksMysqlLayerResource Text where
    autoHealing =
        lens (_auto_healing :: OpsworksMysqlLayerResource -> TF.Argument "auto_healing" Text)
             (\s a -> s { _auto_healing = a } :: OpsworksMysqlLayerResource)

instance HasCustomInstanceProfileArn OpsworksMysqlLayerResource Text where
    customInstanceProfileArn =
        lens (_custom_instance_profile_arn :: OpsworksMysqlLayerResource -> TF.Argument "custom_instance_profile_arn" Text)
             (\s a -> s { _custom_instance_profile_arn = a } :: OpsworksMysqlLayerResource)

instance HasCustomJson OpsworksMysqlLayerResource Text where
    customJson =
        lens (_custom_json :: OpsworksMysqlLayerResource -> TF.Argument "custom_json" Text)
             (\s a -> s { _custom_json = a } :: OpsworksMysqlLayerResource)

instance HasCustomSecurityGroupIds OpsworksMysqlLayerResource Text where
    customSecurityGroupIds =
        lens (_custom_security_group_ids :: OpsworksMysqlLayerResource -> TF.Argument "custom_security_group_ids" Text)
             (\s a -> s { _custom_security_group_ids = a } :: OpsworksMysqlLayerResource)

instance HasDrainElbOnShutdown OpsworksMysqlLayerResource Text where
    drainElbOnShutdown =
        lens (_drain_elb_on_shutdown :: OpsworksMysqlLayerResource -> TF.Argument "drain_elb_on_shutdown" Text)
             (\s a -> s { _drain_elb_on_shutdown = a } :: OpsworksMysqlLayerResource)

instance HasEbsVolume OpsworksMysqlLayerResource Text where
    ebsVolume =
        lens (_ebs_volume :: OpsworksMysqlLayerResource -> TF.Argument "ebs_volume" Text)
             (\s a -> s { _ebs_volume = a } :: OpsworksMysqlLayerResource)

instance HasElasticLoadBalancer OpsworksMysqlLayerResource Text where
    elasticLoadBalancer =
        lens (_elastic_load_balancer :: OpsworksMysqlLayerResource -> TF.Argument "elastic_load_balancer" Text)
             (\s a -> s { _elastic_load_balancer = a } :: OpsworksMysqlLayerResource)

instance HasInstallUpdatesOnBoot OpsworksMysqlLayerResource Text where
    installUpdatesOnBoot =
        lens (_install_updates_on_boot :: OpsworksMysqlLayerResource -> TF.Argument "install_updates_on_boot" Text)
             (\s a -> s { _install_updates_on_boot = a } :: OpsworksMysqlLayerResource)

instance HasInstanceShutdownTimeout OpsworksMysqlLayerResource Text where
    instanceShutdownTimeout =
        lens (_instance_shutdown_timeout :: OpsworksMysqlLayerResource -> TF.Argument "instance_shutdown_timeout" Text)
             (\s a -> s { _instance_shutdown_timeout = a } :: OpsworksMysqlLayerResource)

instance HasName OpsworksMysqlLayerResource Text where
    name =
        lens (_name :: OpsworksMysqlLayerResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: OpsworksMysqlLayerResource)

instance HasRootPassword OpsworksMysqlLayerResource Text where
    rootPassword =
        lens (_root_password :: OpsworksMysqlLayerResource -> TF.Argument "root_password" Text)
             (\s a -> s { _root_password = a } :: OpsworksMysqlLayerResource)

instance HasRootPasswordOnAllInstances OpsworksMysqlLayerResource Text where
    rootPasswordOnAllInstances =
        lens (_root_password_on_all_instances :: OpsworksMysqlLayerResource -> TF.Argument "root_password_on_all_instances" Text)
             (\s a -> s { _root_password_on_all_instances = a } :: OpsworksMysqlLayerResource)

instance HasStackId OpsworksMysqlLayerResource Text where
    stackId =
        lens (_stack_id :: OpsworksMysqlLayerResource -> TF.Argument "stack_id" Text)
             (\s a -> s { _stack_id = a } :: OpsworksMysqlLayerResource)

instance HasSystemPackages OpsworksMysqlLayerResource Text where
    systemPackages =
        lens (_system_packages :: OpsworksMysqlLayerResource -> TF.Argument "system_packages" Text)
             (\s a -> s { _system_packages = a } :: OpsworksMysqlLayerResource)

instance HasUseEbsOptimizedInstances OpsworksMysqlLayerResource Text where
    useEbsOptimizedInstances =
        lens (_use_ebs_optimized_instances :: OpsworksMysqlLayerResource -> TF.Argument "use_ebs_optimized_instances" Text)
             (\s a -> s { _use_ebs_optimized_instances = a } :: OpsworksMysqlLayerResource)

instance HasComputedId OpsworksMysqlLayerResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

opsworksMysqlLayerResource :: TF.Resource TF.AWS OpsworksMysqlLayerResource
opsworksMysqlLayerResource =
    TF.newResource "aws_opsworks_mysql_layer" $
        OpsworksMysqlLayerResource {
            _auto_assign_elastic_ips = TF.Nil
            , _auto_assign_public_ips = TF.Nil
            , _auto_healing = TF.Nil
            , _custom_instance_profile_arn = TF.Nil
            , _custom_json = TF.Nil
            , _custom_security_group_ids = TF.Nil
            , _drain_elb_on_shutdown = TF.Nil
            , _ebs_volume = TF.Nil
            , _elastic_load_balancer = TF.Nil
            , _install_updates_on_boot = TF.Nil
            , _instance_shutdown_timeout = TF.Nil
            , _name = TF.Nil
            , _root_password = TF.Nil
            , _root_password_on_all_instances = TF.Nil
            , _stack_id = TF.Nil
            , _system_packages = TF.Nil
            , _use_ebs_optimized_instances = TF.Nil
            }

{- | The @aws_opsworks_nodejs_app_layer@ AWS resource.

Provides an OpsWorks NodeJS application layer resource.
-}
data OpsworksNodejsAppLayerResource = OpsworksNodejsAppLayerResource {
      _auto_assign_elastic_ips :: !(TF.Argument "auto_assign_elastic_ips" Text)
    {- ^ (Optional) Whether to automatically assign an elastic IP address to the layer's instances. -}
    , _auto_assign_public_ips :: !(TF.Argument "auto_assign_public_ips" Text)
    {- ^ (Optional) For stacks belonging to a VPC, whether to automatically assign a public IP address to each of the layer's instances. -}
    , _auto_healing :: !(TF.Argument "auto_healing" Text)
    {- ^ (Optional) Whether to enable auto-healing for the layer. -}
    , _custom_instance_profile_arn :: !(TF.Argument "custom_instance_profile_arn" Text)
    {- ^ (Optional) The ARN of an IAM profile that will be used for the layer's instances. -}
    , _custom_json :: !(TF.Argument "custom_json" Text)
    {- ^ (Optional) Custom JSON attributes to apply to the layer. -}
    , _custom_security_group_ids :: !(TF.Argument "custom_security_group_ids" Text)
    {- ^ (Optional) Ids for a set of security groups to apply to the layer's instances. -}
    , _drain_elb_on_shutdown :: !(TF.Argument "drain_elb_on_shutdown" Text)
    {- ^ (Optional) Whether to enable Elastic Load Balancing connection draining. -}
    , _ebs_volume :: !(TF.Argument "ebs_volume" Text)
    {- ^ (Optional) @ebs_volume@ blocks, as described below, will each create an EBS volume and connect it to the layer's instances. -}
    , _elastic_load_balancer :: !(TF.Argument "elastic_load_balancer" Text)
    {- ^ (Optional) Name of an Elastic Load Balancer to attach to this layer -}
    , _install_updates_on_boot :: !(TF.Argument "install_updates_on_boot" Text)
    {- ^ (Optional) Whether to install OS and package updates on each instance when it boots. -}
    , _instance_shutdown_timeout :: !(TF.Argument "instance_shutdown_timeout" Text)
    {- ^ (Optional) The time, in seconds, that OpsWorks will wait for Chef to complete after triggering the Shutdown event. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Optional) A human-readable name for the layer. -}
    , _nodejs_version :: !(TF.Argument "nodejs_version" Text)
    {- ^ (Optional) The version of NodeJS to use. Defaults to "0.10.38". -}
    , _stack_id :: !(TF.Argument "stack_id" Text)
    {- ^ (Required) The id of the stack the layer will belong to. -}
    , _system_packages :: !(TF.Argument "system_packages" Text)
    {- ^ (Optional) Names of a set of system packages to install on the layer's instances. -}
    , _use_ebs_optimized_instances :: !(TF.Argument "use_ebs_optimized_instances" Text)
    {- ^ (Optional) Whether to use EBS-optimized instances. -}
    } deriving (Show, Eq)

instance TF.ToHCL OpsworksNodejsAppLayerResource where
    toHCL OpsworksNodejsAppLayerResource{..} = TF.block $ catMaybes
        [ TF.argument _auto_assign_elastic_ips
        , TF.argument _auto_assign_public_ips
        , TF.argument _auto_healing
        , TF.argument _custom_instance_profile_arn
        , TF.argument _custom_json
        , TF.argument _custom_security_group_ids
        , TF.argument _drain_elb_on_shutdown
        , TF.argument _ebs_volume
        , TF.argument _elastic_load_balancer
        , TF.argument _install_updates_on_boot
        , TF.argument _instance_shutdown_timeout
        , TF.argument _name
        , TF.argument _nodejs_version
        , TF.argument _stack_id
        , TF.argument _system_packages
        , TF.argument _use_ebs_optimized_instances
        ]

instance HasAutoAssignElasticIps OpsworksNodejsAppLayerResource Text where
    autoAssignElasticIps =
        lens (_auto_assign_elastic_ips :: OpsworksNodejsAppLayerResource -> TF.Argument "auto_assign_elastic_ips" Text)
             (\s a -> s { _auto_assign_elastic_ips = a } :: OpsworksNodejsAppLayerResource)

instance HasAutoAssignPublicIps OpsworksNodejsAppLayerResource Text where
    autoAssignPublicIps =
        lens (_auto_assign_public_ips :: OpsworksNodejsAppLayerResource -> TF.Argument "auto_assign_public_ips" Text)
             (\s a -> s { _auto_assign_public_ips = a } :: OpsworksNodejsAppLayerResource)

instance HasAutoHealing OpsworksNodejsAppLayerResource Text where
    autoHealing =
        lens (_auto_healing :: OpsworksNodejsAppLayerResource -> TF.Argument "auto_healing" Text)
             (\s a -> s { _auto_healing = a } :: OpsworksNodejsAppLayerResource)

instance HasCustomInstanceProfileArn OpsworksNodejsAppLayerResource Text where
    customInstanceProfileArn =
        lens (_custom_instance_profile_arn :: OpsworksNodejsAppLayerResource -> TF.Argument "custom_instance_profile_arn" Text)
             (\s a -> s { _custom_instance_profile_arn = a } :: OpsworksNodejsAppLayerResource)

instance HasCustomJson OpsworksNodejsAppLayerResource Text where
    customJson =
        lens (_custom_json :: OpsworksNodejsAppLayerResource -> TF.Argument "custom_json" Text)
             (\s a -> s { _custom_json = a } :: OpsworksNodejsAppLayerResource)

instance HasCustomSecurityGroupIds OpsworksNodejsAppLayerResource Text where
    customSecurityGroupIds =
        lens (_custom_security_group_ids :: OpsworksNodejsAppLayerResource -> TF.Argument "custom_security_group_ids" Text)
             (\s a -> s { _custom_security_group_ids = a } :: OpsworksNodejsAppLayerResource)

instance HasDrainElbOnShutdown OpsworksNodejsAppLayerResource Text where
    drainElbOnShutdown =
        lens (_drain_elb_on_shutdown :: OpsworksNodejsAppLayerResource -> TF.Argument "drain_elb_on_shutdown" Text)
             (\s a -> s { _drain_elb_on_shutdown = a } :: OpsworksNodejsAppLayerResource)

instance HasEbsVolume OpsworksNodejsAppLayerResource Text where
    ebsVolume =
        lens (_ebs_volume :: OpsworksNodejsAppLayerResource -> TF.Argument "ebs_volume" Text)
             (\s a -> s { _ebs_volume = a } :: OpsworksNodejsAppLayerResource)

instance HasElasticLoadBalancer OpsworksNodejsAppLayerResource Text where
    elasticLoadBalancer =
        lens (_elastic_load_balancer :: OpsworksNodejsAppLayerResource -> TF.Argument "elastic_load_balancer" Text)
             (\s a -> s { _elastic_load_balancer = a } :: OpsworksNodejsAppLayerResource)

instance HasInstallUpdatesOnBoot OpsworksNodejsAppLayerResource Text where
    installUpdatesOnBoot =
        lens (_install_updates_on_boot :: OpsworksNodejsAppLayerResource -> TF.Argument "install_updates_on_boot" Text)
             (\s a -> s { _install_updates_on_boot = a } :: OpsworksNodejsAppLayerResource)

instance HasInstanceShutdownTimeout OpsworksNodejsAppLayerResource Text where
    instanceShutdownTimeout =
        lens (_instance_shutdown_timeout :: OpsworksNodejsAppLayerResource -> TF.Argument "instance_shutdown_timeout" Text)
             (\s a -> s { _instance_shutdown_timeout = a } :: OpsworksNodejsAppLayerResource)

instance HasName OpsworksNodejsAppLayerResource Text where
    name =
        lens (_name :: OpsworksNodejsAppLayerResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: OpsworksNodejsAppLayerResource)

instance HasNodejsVersion OpsworksNodejsAppLayerResource Text where
    nodejsVersion =
        lens (_nodejs_version :: OpsworksNodejsAppLayerResource -> TF.Argument "nodejs_version" Text)
             (\s a -> s { _nodejs_version = a } :: OpsworksNodejsAppLayerResource)

instance HasStackId OpsworksNodejsAppLayerResource Text where
    stackId =
        lens (_stack_id :: OpsworksNodejsAppLayerResource -> TF.Argument "stack_id" Text)
             (\s a -> s { _stack_id = a } :: OpsworksNodejsAppLayerResource)

instance HasSystemPackages OpsworksNodejsAppLayerResource Text where
    systemPackages =
        lens (_system_packages :: OpsworksNodejsAppLayerResource -> TF.Argument "system_packages" Text)
             (\s a -> s { _system_packages = a } :: OpsworksNodejsAppLayerResource)

instance HasUseEbsOptimizedInstances OpsworksNodejsAppLayerResource Text where
    useEbsOptimizedInstances =
        lens (_use_ebs_optimized_instances :: OpsworksNodejsAppLayerResource -> TF.Argument "use_ebs_optimized_instances" Text)
             (\s a -> s { _use_ebs_optimized_instances = a } :: OpsworksNodejsAppLayerResource)

instance HasComputedId OpsworksNodejsAppLayerResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

opsworksNodejsAppLayerResource :: TF.Resource TF.AWS OpsworksNodejsAppLayerResource
opsworksNodejsAppLayerResource =
    TF.newResource "aws_opsworks_nodejs_app_layer" $
        OpsworksNodejsAppLayerResource {
            _auto_assign_elastic_ips = TF.Nil
            , _auto_assign_public_ips = TF.Nil
            , _auto_healing = TF.Nil
            , _custom_instance_profile_arn = TF.Nil
            , _custom_json = TF.Nil
            , _custom_security_group_ids = TF.Nil
            , _drain_elb_on_shutdown = TF.Nil
            , _ebs_volume = TF.Nil
            , _elastic_load_balancer = TF.Nil
            , _install_updates_on_boot = TF.Nil
            , _instance_shutdown_timeout = TF.Nil
            , _name = TF.Nil
            , _nodejs_version = TF.Nil
            , _stack_id = TF.Nil
            , _system_packages = TF.Nil
            , _use_ebs_optimized_instances = TF.Nil
            }

{- | The @aws_opsworks_permission@ AWS resource.

Provides an OpsWorks permission resource.
-}
data OpsworksPermissionResource = OpsworksPermissionResource {
      _allow_ssh :: !(TF.Argument "allow_ssh" Text)
    {- ^ (Optional) Whether the user is allowed to use SSH to communicate with the instance -}
    , _allow_sudo :: !(TF.Argument "allow_sudo" Text)
    {- ^ (Optional) Whether the user is allowed to use sudo to elevate privileges -}
    , _level :: !(TF.Argument "level" Text)
    {- ^ (Optional) The users permission level. Mus be one of @deny@ , @show@ , @deploy@ , @manage@ , @iam_only@ -}
    , _stack_id :: !(TF.Argument "stack_id" Text)
    {- ^ (Required) The stack to set the permissions for -}
    , _user_arn :: !(TF.Argument "user_arn" Text)
    {- ^ (Required) The user's IAM ARN to set permissions for -}
    } deriving (Show, Eq)

instance TF.ToHCL OpsworksPermissionResource where
    toHCL OpsworksPermissionResource{..} = TF.block $ catMaybes
        [ TF.argument _allow_ssh
        , TF.argument _allow_sudo
        , TF.argument _level
        , TF.argument _stack_id
        , TF.argument _user_arn
        ]

instance HasAllowSsh OpsworksPermissionResource Text where
    allowSsh =
        lens (_allow_ssh :: OpsworksPermissionResource -> TF.Argument "allow_ssh" Text)
             (\s a -> s { _allow_ssh = a } :: OpsworksPermissionResource)

instance HasAllowSudo OpsworksPermissionResource Text where
    allowSudo =
        lens (_allow_sudo :: OpsworksPermissionResource -> TF.Argument "allow_sudo" Text)
             (\s a -> s { _allow_sudo = a } :: OpsworksPermissionResource)

instance HasLevel OpsworksPermissionResource Text where
    level =
        lens (_level :: OpsworksPermissionResource -> TF.Argument "level" Text)
             (\s a -> s { _level = a } :: OpsworksPermissionResource)

instance HasStackId OpsworksPermissionResource Text where
    stackId =
        lens (_stack_id :: OpsworksPermissionResource -> TF.Argument "stack_id" Text)
             (\s a -> s { _stack_id = a } :: OpsworksPermissionResource)

instance HasUserArn OpsworksPermissionResource Text where
    userArn =
        lens (_user_arn :: OpsworksPermissionResource -> TF.Argument "user_arn" Text)
             (\s a -> s { _user_arn = a } :: OpsworksPermissionResource)

instance HasComputedId OpsworksPermissionResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

opsworksPermissionResource :: TF.Resource TF.AWS OpsworksPermissionResource
opsworksPermissionResource =
    TF.newResource "aws_opsworks_permission" $
        OpsworksPermissionResource {
            _allow_ssh = TF.Nil
            , _allow_sudo = TF.Nil
            , _level = TF.Nil
            , _stack_id = TF.Nil
            , _user_arn = TF.Nil
            }

{- | The @aws_opsworks_php_app_layer@ AWS resource.

Provides an OpsWorks PHP application layer resource.
-}
data OpsworksPhpAppLayerResource = OpsworksPhpAppLayerResource {
      _auto_assign_elastic_ips :: !(TF.Argument "auto_assign_elastic_ips" Text)
    {- ^ (Optional) Whether to automatically assign an elastic IP address to the layer's instances. -}
    , _auto_assign_public_ips :: !(TF.Argument "auto_assign_public_ips" Text)
    {- ^ (Optional) For stacks belonging to a VPC, whether to automatically assign a public IP address to each of the layer's instances. -}
    , _auto_healing :: !(TF.Argument "auto_healing" Text)
    {- ^ (Optional) Whether to enable auto-healing for the layer. -}
    , _custom_instance_profile_arn :: !(TF.Argument "custom_instance_profile_arn" Text)
    {- ^ (Optional) The ARN of an IAM profile that will be used for the layer's instances. -}
    , _custom_json :: !(TF.Argument "custom_json" Text)
    {- ^ (Optional) Custom JSON attributes to apply to the layer. -}
    , _custom_security_group_ids :: !(TF.Argument "custom_security_group_ids" Text)
    {- ^ (Optional) Ids for a set of security groups to apply to the layer's instances. -}
    , _drain_elb_on_shutdown :: !(TF.Argument "drain_elb_on_shutdown" Text)
    {- ^ (Optional) Whether to enable Elastic Load Balancing connection draining. -}
    , _ebs_volume :: !(TF.Argument "ebs_volume" Text)
    {- ^ (Optional) @ebs_volume@ blocks, as described below, will each create an EBS volume and connect it to the layer's instances. -}
    , _elastic_load_balancer :: !(TF.Argument "elastic_load_balancer" Text)
    {- ^ (Optional) Name of an Elastic Load Balancer to attach to this layer -}
    , _install_updates_on_boot :: !(TF.Argument "install_updates_on_boot" Text)
    {- ^ (Optional) Whether to install OS and package updates on each instance when it boots. -}
    , _instance_shutdown_timeout :: !(TF.Argument "instance_shutdown_timeout" Text)
    {- ^ (Optional) The time, in seconds, that OpsWorks will wait for Chef to complete after triggering the Shutdown event. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Optional) A human-readable name for the layer. -}
    , _stack_id :: !(TF.Argument "stack_id" Text)
    {- ^ (Required) The id of the stack the layer will belong to. -}
    , _system_packages :: !(TF.Argument "system_packages" Text)
    {- ^ (Optional) Names of a set of system packages to install on the layer's instances. -}
    , _use_ebs_optimized_instances :: !(TF.Argument "use_ebs_optimized_instances" Text)
    {- ^ (Optional) Whether to use EBS-optimized instances. -}
    } deriving (Show, Eq)

instance TF.ToHCL OpsworksPhpAppLayerResource where
    toHCL OpsworksPhpAppLayerResource{..} = TF.block $ catMaybes
        [ TF.argument _auto_assign_elastic_ips
        , TF.argument _auto_assign_public_ips
        , TF.argument _auto_healing
        , TF.argument _custom_instance_profile_arn
        , TF.argument _custom_json
        , TF.argument _custom_security_group_ids
        , TF.argument _drain_elb_on_shutdown
        , TF.argument _ebs_volume
        , TF.argument _elastic_load_balancer
        , TF.argument _install_updates_on_boot
        , TF.argument _instance_shutdown_timeout
        , TF.argument _name
        , TF.argument _stack_id
        , TF.argument _system_packages
        , TF.argument _use_ebs_optimized_instances
        ]

instance HasAutoAssignElasticIps OpsworksPhpAppLayerResource Text where
    autoAssignElasticIps =
        lens (_auto_assign_elastic_ips :: OpsworksPhpAppLayerResource -> TF.Argument "auto_assign_elastic_ips" Text)
             (\s a -> s { _auto_assign_elastic_ips = a } :: OpsworksPhpAppLayerResource)

instance HasAutoAssignPublicIps OpsworksPhpAppLayerResource Text where
    autoAssignPublicIps =
        lens (_auto_assign_public_ips :: OpsworksPhpAppLayerResource -> TF.Argument "auto_assign_public_ips" Text)
             (\s a -> s { _auto_assign_public_ips = a } :: OpsworksPhpAppLayerResource)

instance HasAutoHealing OpsworksPhpAppLayerResource Text where
    autoHealing =
        lens (_auto_healing :: OpsworksPhpAppLayerResource -> TF.Argument "auto_healing" Text)
             (\s a -> s { _auto_healing = a } :: OpsworksPhpAppLayerResource)

instance HasCustomInstanceProfileArn OpsworksPhpAppLayerResource Text where
    customInstanceProfileArn =
        lens (_custom_instance_profile_arn :: OpsworksPhpAppLayerResource -> TF.Argument "custom_instance_profile_arn" Text)
             (\s a -> s { _custom_instance_profile_arn = a } :: OpsworksPhpAppLayerResource)

instance HasCustomJson OpsworksPhpAppLayerResource Text where
    customJson =
        lens (_custom_json :: OpsworksPhpAppLayerResource -> TF.Argument "custom_json" Text)
             (\s a -> s { _custom_json = a } :: OpsworksPhpAppLayerResource)

instance HasCustomSecurityGroupIds OpsworksPhpAppLayerResource Text where
    customSecurityGroupIds =
        lens (_custom_security_group_ids :: OpsworksPhpAppLayerResource -> TF.Argument "custom_security_group_ids" Text)
             (\s a -> s { _custom_security_group_ids = a } :: OpsworksPhpAppLayerResource)

instance HasDrainElbOnShutdown OpsworksPhpAppLayerResource Text where
    drainElbOnShutdown =
        lens (_drain_elb_on_shutdown :: OpsworksPhpAppLayerResource -> TF.Argument "drain_elb_on_shutdown" Text)
             (\s a -> s { _drain_elb_on_shutdown = a } :: OpsworksPhpAppLayerResource)

instance HasEbsVolume OpsworksPhpAppLayerResource Text where
    ebsVolume =
        lens (_ebs_volume :: OpsworksPhpAppLayerResource -> TF.Argument "ebs_volume" Text)
             (\s a -> s { _ebs_volume = a } :: OpsworksPhpAppLayerResource)

instance HasElasticLoadBalancer OpsworksPhpAppLayerResource Text where
    elasticLoadBalancer =
        lens (_elastic_load_balancer :: OpsworksPhpAppLayerResource -> TF.Argument "elastic_load_balancer" Text)
             (\s a -> s { _elastic_load_balancer = a } :: OpsworksPhpAppLayerResource)

instance HasInstallUpdatesOnBoot OpsworksPhpAppLayerResource Text where
    installUpdatesOnBoot =
        lens (_install_updates_on_boot :: OpsworksPhpAppLayerResource -> TF.Argument "install_updates_on_boot" Text)
             (\s a -> s { _install_updates_on_boot = a } :: OpsworksPhpAppLayerResource)

instance HasInstanceShutdownTimeout OpsworksPhpAppLayerResource Text where
    instanceShutdownTimeout =
        lens (_instance_shutdown_timeout :: OpsworksPhpAppLayerResource -> TF.Argument "instance_shutdown_timeout" Text)
             (\s a -> s { _instance_shutdown_timeout = a } :: OpsworksPhpAppLayerResource)

instance HasName OpsworksPhpAppLayerResource Text where
    name =
        lens (_name :: OpsworksPhpAppLayerResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: OpsworksPhpAppLayerResource)

instance HasStackId OpsworksPhpAppLayerResource Text where
    stackId =
        lens (_stack_id :: OpsworksPhpAppLayerResource -> TF.Argument "stack_id" Text)
             (\s a -> s { _stack_id = a } :: OpsworksPhpAppLayerResource)

instance HasSystemPackages OpsworksPhpAppLayerResource Text where
    systemPackages =
        lens (_system_packages :: OpsworksPhpAppLayerResource -> TF.Argument "system_packages" Text)
             (\s a -> s { _system_packages = a } :: OpsworksPhpAppLayerResource)

instance HasUseEbsOptimizedInstances OpsworksPhpAppLayerResource Text where
    useEbsOptimizedInstances =
        lens (_use_ebs_optimized_instances :: OpsworksPhpAppLayerResource -> TF.Argument "use_ebs_optimized_instances" Text)
             (\s a -> s { _use_ebs_optimized_instances = a } :: OpsworksPhpAppLayerResource)

instance HasComputedId OpsworksPhpAppLayerResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

opsworksPhpAppLayerResource :: TF.Resource TF.AWS OpsworksPhpAppLayerResource
opsworksPhpAppLayerResource =
    TF.newResource "aws_opsworks_php_app_layer" $
        OpsworksPhpAppLayerResource {
            _auto_assign_elastic_ips = TF.Nil
            , _auto_assign_public_ips = TF.Nil
            , _auto_healing = TF.Nil
            , _custom_instance_profile_arn = TF.Nil
            , _custom_json = TF.Nil
            , _custom_security_group_ids = TF.Nil
            , _drain_elb_on_shutdown = TF.Nil
            , _ebs_volume = TF.Nil
            , _elastic_load_balancer = TF.Nil
            , _install_updates_on_boot = TF.Nil
            , _instance_shutdown_timeout = TF.Nil
            , _name = TF.Nil
            , _stack_id = TF.Nil
            , _system_packages = TF.Nil
            , _use_ebs_optimized_instances = TF.Nil
            }

{- | The @aws_opsworks_rails_app_layer@ AWS resource.

Provides an OpsWorks Ruby on Rails application layer resource.
-}
data OpsworksRailsAppLayerResource = OpsworksRailsAppLayerResource {
      _app_server :: !(TF.Argument "app_server" Text)
    {- ^ (Optional) Keyword for the app server to use. Defaults to "apache_passenger". -}
    , _auto_assign_elastic_ips :: !(TF.Argument "auto_assign_elastic_ips" Text)
    {- ^ (Optional) Whether to automatically assign an elastic IP address to the layer's instances. -}
    , _auto_assign_public_ips :: !(TF.Argument "auto_assign_public_ips" Text)
    {- ^ (Optional) For stacks belonging to a VPC, whether to automatically assign a public IP address to each of the layer's instances. -}
    , _auto_healing :: !(TF.Argument "auto_healing" Text)
    {- ^ (Optional) Whether to enable auto-healing for the layer. -}
    , _bundler_version :: !(TF.Argument "bundler_version" Text)
    {- ^ (Optional) When OpsWorks is managing Bundler, which version to use. Defaults to "1.5.3". -}
    , _custom_instance_profile_arn :: !(TF.Argument "custom_instance_profile_arn" Text)
    {- ^ (Optional) The ARN of an IAM profile that will be used for the layer's instances. -}
    , _custom_json :: !(TF.Argument "custom_json" Text)
    {- ^ (Optional) Custom JSON attributes to apply to the layer. -}
    , _custom_security_group_ids :: !(TF.Argument "custom_security_group_ids" Text)
    {- ^ (Optional) Ids for a set of security groups to apply to the layer's instances. -}
    , _drain_elb_on_shutdown :: !(TF.Argument "drain_elb_on_shutdown" Text)
    {- ^ (Optional) Whether to enable Elastic Load Balancing connection draining. -}
    , _ebs_volume :: !(TF.Argument "ebs_volume" Text)
    {- ^ (Optional) @ebs_volume@ blocks, as described below, will each create an EBS volume and connect it to the layer's instances. -}
    , _elastic_load_balancer :: !(TF.Argument "elastic_load_balancer" Text)
    {- ^ (Optional) Name of an Elastic Load Balancer to attach to this layer -}
    , _install_updates_on_boot :: !(TF.Argument "install_updates_on_boot" Text)
    {- ^ (Optional) Whether to install OS and package updates on each instance when it boots. -}
    , _instance_shutdown_timeout :: !(TF.Argument "instance_shutdown_timeout" Text)
    {- ^ (Optional) The time, in seconds, that OpsWorks will wait for Chef to complete after triggering the Shutdown event. -}
    , _manage_bundler :: !(TF.Argument "manage_bundler" Text)
    {- ^ (Optional) Whether OpsWorks should manage bundler. On by default. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Optional) A human-readable name for the layer. -}
    , _passenger_version :: !(TF.Argument "passenger_version" Text)
    {- ^ (Optional) The version of Passenger to use. Defaults to "4.0.46". -}
    , _ruby_version :: !(TF.Argument "ruby_version" Text)
    {- ^ (Optional) The version of Ruby to use. Defaults to "2.0.0". -}
    , _rubygems_version :: !(TF.Argument "rubygems_version" Text)
    {- ^ (Optional) The version of RubyGems to use. Defaults to "2.2.2". -}
    , _stack_id :: !(TF.Argument "stack_id" Text)
    {- ^ (Required) The id of the stack the layer will belong to. -}
    , _system_packages :: !(TF.Argument "system_packages" Text)
    {- ^ (Optional) Names of a set of system packages to install on the layer's instances. -}
    , _use_ebs_optimized_instances :: !(TF.Argument "use_ebs_optimized_instances" Text)
    {- ^ (Optional) Whether to use EBS-optimized instances. -}
    } deriving (Show, Eq)

instance TF.ToHCL OpsworksRailsAppLayerResource where
    toHCL OpsworksRailsAppLayerResource{..} = TF.block $ catMaybes
        [ TF.argument _app_server
        , TF.argument _auto_assign_elastic_ips
        , TF.argument _auto_assign_public_ips
        , TF.argument _auto_healing
        , TF.argument _bundler_version
        , TF.argument _custom_instance_profile_arn
        , TF.argument _custom_json
        , TF.argument _custom_security_group_ids
        , TF.argument _drain_elb_on_shutdown
        , TF.argument _ebs_volume
        , TF.argument _elastic_load_balancer
        , TF.argument _install_updates_on_boot
        , TF.argument _instance_shutdown_timeout
        , TF.argument _manage_bundler
        , TF.argument _name
        , TF.argument _passenger_version
        , TF.argument _ruby_version
        , TF.argument _rubygems_version
        , TF.argument _stack_id
        , TF.argument _system_packages
        , TF.argument _use_ebs_optimized_instances
        ]

instance HasAppServer OpsworksRailsAppLayerResource Text where
    appServer =
        lens (_app_server :: OpsworksRailsAppLayerResource -> TF.Argument "app_server" Text)
             (\s a -> s { _app_server = a } :: OpsworksRailsAppLayerResource)

instance HasAutoAssignElasticIps OpsworksRailsAppLayerResource Text where
    autoAssignElasticIps =
        lens (_auto_assign_elastic_ips :: OpsworksRailsAppLayerResource -> TF.Argument "auto_assign_elastic_ips" Text)
             (\s a -> s { _auto_assign_elastic_ips = a } :: OpsworksRailsAppLayerResource)

instance HasAutoAssignPublicIps OpsworksRailsAppLayerResource Text where
    autoAssignPublicIps =
        lens (_auto_assign_public_ips :: OpsworksRailsAppLayerResource -> TF.Argument "auto_assign_public_ips" Text)
             (\s a -> s { _auto_assign_public_ips = a } :: OpsworksRailsAppLayerResource)

instance HasAutoHealing OpsworksRailsAppLayerResource Text where
    autoHealing =
        lens (_auto_healing :: OpsworksRailsAppLayerResource -> TF.Argument "auto_healing" Text)
             (\s a -> s { _auto_healing = a } :: OpsworksRailsAppLayerResource)

instance HasBundlerVersion OpsworksRailsAppLayerResource Text where
    bundlerVersion =
        lens (_bundler_version :: OpsworksRailsAppLayerResource -> TF.Argument "bundler_version" Text)
             (\s a -> s { _bundler_version = a } :: OpsworksRailsAppLayerResource)

instance HasCustomInstanceProfileArn OpsworksRailsAppLayerResource Text where
    customInstanceProfileArn =
        lens (_custom_instance_profile_arn :: OpsworksRailsAppLayerResource -> TF.Argument "custom_instance_profile_arn" Text)
             (\s a -> s { _custom_instance_profile_arn = a } :: OpsworksRailsAppLayerResource)

instance HasCustomJson OpsworksRailsAppLayerResource Text where
    customJson =
        lens (_custom_json :: OpsworksRailsAppLayerResource -> TF.Argument "custom_json" Text)
             (\s a -> s { _custom_json = a } :: OpsworksRailsAppLayerResource)

instance HasCustomSecurityGroupIds OpsworksRailsAppLayerResource Text where
    customSecurityGroupIds =
        lens (_custom_security_group_ids :: OpsworksRailsAppLayerResource -> TF.Argument "custom_security_group_ids" Text)
             (\s a -> s { _custom_security_group_ids = a } :: OpsworksRailsAppLayerResource)

instance HasDrainElbOnShutdown OpsworksRailsAppLayerResource Text where
    drainElbOnShutdown =
        lens (_drain_elb_on_shutdown :: OpsworksRailsAppLayerResource -> TF.Argument "drain_elb_on_shutdown" Text)
             (\s a -> s { _drain_elb_on_shutdown = a } :: OpsworksRailsAppLayerResource)

instance HasEbsVolume OpsworksRailsAppLayerResource Text where
    ebsVolume =
        lens (_ebs_volume :: OpsworksRailsAppLayerResource -> TF.Argument "ebs_volume" Text)
             (\s a -> s { _ebs_volume = a } :: OpsworksRailsAppLayerResource)

instance HasElasticLoadBalancer OpsworksRailsAppLayerResource Text where
    elasticLoadBalancer =
        lens (_elastic_load_balancer :: OpsworksRailsAppLayerResource -> TF.Argument "elastic_load_balancer" Text)
             (\s a -> s { _elastic_load_balancer = a } :: OpsworksRailsAppLayerResource)

instance HasInstallUpdatesOnBoot OpsworksRailsAppLayerResource Text where
    installUpdatesOnBoot =
        lens (_install_updates_on_boot :: OpsworksRailsAppLayerResource -> TF.Argument "install_updates_on_boot" Text)
             (\s a -> s { _install_updates_on_boot = a } :: OpsworksRailsAppLayerResource)

instance HasInstanceShutdownTimeout OpsworksRailsAppLayerResource Text where
    instanceShutdownTimeout =
        lens (_instance_shutdown_timeout :: OpsworksRailsAppLayerResource -> TF.Argument "instance_shutdown_timeout" Text)
             (\s a -> s { _instance_shutdown_timeout = a } :: OpsworksRailsAppLayerResource)

instance HasManageBundler OpsworksRailsAppLayerResource Text where
    manageBundler =
        lens (_manage_bundler :: OpsworksRailsAppLayerResource -> TF.Argument "manage_bundler" Text)
             (\s a -> s { _manage_bundler = a } :: OpsworksRailsAppLayerResource)

instance HasName OpsworksRailsAppLayerResource Text where
    name =
        lens (_name :: OpsworksRailsAppLayerResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: OpsworksRailsAppLayerResource)

instance HasPassengerVersion OpsworksRailsAppLayerResource Text where
    passengerVersion =
        lens (_passenger_version :: OpsworksRailsAppLayerResource -> TF.Argument "passenger_version" Text)
             (\s a -> s { _passenger_version = a } :: OpsworksRailsAppLayerResource)

instance HasRubyVersion OpsworksRailsAppLayerResource Text where
    rubyVersion =
        lens (_ruby_version :: OpsworksRailsAppLayerResource -> TF.Argument "ruby_version" Text)
             (\s a -> s { _ruby_version = a } :: OpsworksRailsAppLayerResource)

instance HasRubygemsVersion OpsworksRailsAppLayerResource Text where
    rubygemsVersion =
        lens (_rubygems_version :: OpsworksRailsAppLayerResource -> TF.Argument "rubygems_version" Text)
             (\s a -> s { _rubygems_version = a } :: OpsworksRailsAppLayerResource)

instance HasStackId OpsworksRailsAppLayerResource Text where
    stackId =
        lens (_stack_id :: OpsworksRailsAppLayerResource -> TF.Argument "stack_id" Text)
             (\s a -> s { _stack_id = a } :: OpsworksRailsAppLayerResource)

instance HasSystemPackages OpsworksRailsAppLayerResource Text where
    systemPackages =
        lens (_system_packages :: OpsworksRailsAppLayerResource -> TF.Argument "system_packages" Text)
             (\s a -> s { _system_packages = a } :: OpsworksRailsAppLayerResource)

instance HasUseEbsOptimizedInstances OpsworksRailsAppLayerResource Text where
    useEbsOptimizedInstances =
        lens (_use_ebs_optimized_instances :: OpsworksRailsAppLayerResource -> TF.Argument "use_ebs_optimized_instances" Text)
             (\s a -> s { _use_ebs_optimized_instances = a } :: OpsworksRailsAppLayerResource)

instance HasComputedId OpsworksRailsAppLayerResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

opsworksRailsAppLayerResource :: TF.Resource TF.AWS OpsworksRailsAppLayerResource
opsworksRailsAppLayerResource =
    TF.newResource "aws_opsworks_rails_app_layer" $
        OpsworksRailsAppLayerResource {
            _app_server = TF.Nil
            , _auto_assign_elastic_ips = TF.Nil
            , _auto_assign_public_ips = TF.Nil
            , _auto_healing = TF.Nil
            , _bundler_version = TF.Nil
            , _custom_instance_profile_arn = TF.Nil
            , _custom_json = TF.Nil
            , _custom_security_group_ids = TF.Nil
            , _drain_elb_on_shutdown = TF.Nil
            , _ebs_volume = TF.Nil
            , _elastic_load_balancer = TF.Nil
            , _install_updates_on_boot = TF.Nil
            , _instance_shutdown_timeout = TF.Nil
            , _manage_bundler = TF.Nil
            , _name = TF.Nil
            , _passenger_version = TF.Nil
            , _ruby_version = TF.Nil
            , _rubygems_version = TF.Nil
            , _stack_id = TF.Nil
            , _system_packages = TF.Nil
            , _use_ebs_optimized_instances = TF.Nil
            }

{- | The @aws_opsworks_rds_db_instance@ AWS resource.

Provides an OpsWorks RDS DB Instance resource. ~> Note: All arguments
including the username and password will be stored in the raw state as
plain-text. </docs/state/sensitive-data.html> .
-}
data OpsworksRdsDbInstanceResource = OpsworksRdsDbInstanceResource {
      _db_password :: !(TF.Argument "db_password" Text)
    {- ^ (Required) A db password -}
    , _db_user :: !(TF.Argument "db_user" Text)
    {- ^ (Required) A db username -}
    , _rds_db_instance_arn :: !(TF.Argument "rds_db_instance_arn" Text)
    {- ^ (Required) The db instance to register for this stack. Changing this will force a new resource. -}
    , _stack_id :: !(TF.Argument "stack_id" Text)
    {- ^ (Required) The stack to register a db inatance for. Changing this will force a new resource. -}
    } deriving (Show, Eq)

instance TF.ToHCL OpsworksRdsDbInstanceResource where
    toHCL OpsworksRdsDbInstanceResource{..} = TF.block $ catMaybes
        [ TF.argument _db_password
        , TF.argument _db_user
        , TF.argument _rds_db_instance_arn
        , TF.argument _stack_id
        ]

instance HasDbPassword OpsworksRdsDbInstanceResource Text where
    dbPassword =
        lens (_db_password :: OpsworksRdsDbInstanceResource -> TF.Argument "db_password" Text)
             (\s a -> s { _db_password = a } :: OpsworksRdsDbInstanceResource)

instance HasDbUser OpsworksRdsDbInstanceResource Text where
    dbUser =
        lens (_db_user :: OpsworksRdsDbInstanceResource -> TF.Argument "db_user" Text)
             (\s a -> s { _db_user = a } :: OpsworksRdsDbInstanceResource)

instance HasRdsDbInstanceArn OpsworksRdsDbInstanceResource Text where
    rdsDbInstanceArn =
        lens (_rds_db_instance_arn :: OpsworksRdsDbInstanceResource -> TF.Argument "rds_db_instance_arn" Text)
             (\s a -> s { _rds_db_instance_arn = a } :: OpsworksRdsDbInstanceResource)

instance HasStackId OpsworksRdsDbInstanceResource Text where
    stackId =
        lens (_stack_id :: OpsworksRdsDbInstanceResource -> TF.Argument "stack_id" Text)
             (\s a -> s { _stack_id = a } :: OpsworksRdsDbInstanceResource)

instance HasComputedId OpsworksRdsDbInstanceResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

opsworksRdsDbInstanceResource :: TF.Resource TF.AWS OpsworksRdsDbInstanceResource
opsworksRdsDbInstanceResource =
    TF.newResource "aws_opsworks_rds_db_instance" $
        OpsworksRdsDbInstanceResource {
            _db_password = TF.Nil
            , _db_user = TF.Nil
            , _rds_db_instance_arn = TF.Nil
            , _stack_id = TF.Nil
            }

{- | The @aws_opsworks_stack@ AWS resource.

Provides an OpsWorks stack resource.
-}
data OpsworksStackResource = OpsworksStackResource {
      _agent_version :: !(TF.Argument "agent_version" Text)
    {- ^ (Optional) If set to @"LATEST"@ , OpsWorks will automatically install the latest version. -}
    , _berkshelf_version :: !(TF.Argument "berkshelf_version" Text)
    {- ^ (Optional) If @manage_berkshelf@ is enabled, the version of Berkshelf to use. -}
    , _color :: !(TF.Argument "color" Text)
    {- ^ (Optional) Color to paint next to the stack's resources in the OpsWorks console. -}
    , _configuration_manager_name :: !(TF.Argument "configuration_manager_name" Text)
    {- ^ (Optional) Name of the configuration manager to use. Defaults to "Chef". -}
    , _configuration_manager_version :: !(TF.Argument "configuration_manager_version" Text)
    {- ^ (Optional) Version of the configuration manager to use. Defaults to "11.4". -}
    , _custom_cookbooks_source :: !(TF.Argument "custom_cookbooks_source" Text)
    {- ^ (Optional) When @use_custom_cookbooks@ is set, provide this sub-object as described below. -}
    , _custom_json :: !(TF.Argument "custom_json" Text)
    {- ^ (Optional) Custom JSON attributes to apply to the entire stack. -}
    , _default_availability_zone :: !(TF.Argument "default_availability_zone" TF.Zone)
    {- ^ (Optional) Name of the availability zone where instances will be created by default. This is required unless you set @vpc_id@ . -}
    , _default_instance_profile_arn :: !(TF.Argument "default_instance_profile_arn" Text)
    {- ^ (Required) The ARN of an IAM Instance Profile that created instances will have by default. -}
    , _default_os :: !(TF.Argument "default_os" Text)
    {- ^ (Optional) Name of OS that will be installed on instances by default. -}
    , _default_root_device_type :: !(TF.Argument "default_root_device_type" Text)
    {- ^ (Optional) Name of the type of root device instances will have by default. -}
    , _default_ssh_key_name :: !(TF.Argument "default_ssh_key_name" Text)
    {- ^ (Optional) Name of the SSH keypair that instances will have by default. -}
    , _default_subnet_id :: !(TF.Argument "default_subnet_id" Text)
    {- ^ (Optional) Id of the subnet in which instances will be created by default. Mandatory if @vpc_id@ is set, and forbidden if it isn't. -}
    , _hostname_theme :: !(TF.Argument "hostname_theme" Text)
    {- ^ (Optional) Keyword representing the naming scheme that will be used for instance hostnames within this stack. -}
    , _manage_berkshelf :: !(TF.Argument "manage_berkshelf" Text)
    {- ^ (Optional) Boolean value controlling whether Opsworks will run Berkshelf for this stack. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the stack. -}
    , _region :: !(TF.Argument "region" TF.Region)
    {- ^ (Required) The name of the region where the stack will exist. -}
    , _service_role_arn :: !(TF.Argument "service_role_arn" Text)
    {- ^ (Required) The ARN of an IAM role that the OpsWorks service will act as. -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    , _use_custom_cookbooks :: !(TF.Argument "use_custom_cookbooks" Text)
    {- ^ (Optional) Boolean value controlling whether the custom cookbook settings are enabled. -}
    , _use_opsworks_security_groups :: !(TF.Argument "use_opsworks_security_groups" Text)
    {- ^ (Optional) Boolean value controlling whether the standard OpsWorks security groups apply to created instances. -}
    , _vpc_id :: !(TF.Argument "vpc_id" Text)
    {- ^ (Optional) The id of the VPC that this stack belongs to. -}
    } deriving (Show, Eq)

instance TF.ToHCL OpsworksStackResource where
    toHCL OpsworksStackResource{..} = TF.block $ catMaybes
        [ TF.argument _agent_version
        , TF.argument _berkshelf_version
        , TF.argument _color
        , TF.argument _configuration_manager_name
        , TF.argument _configuration_manager_version
        , TF.argument _custom_cookbooks_source
        , TF.argument _custom_json
        , TF.argument _default_availability_zone
        , TF.argument _default_instance_profile_arn
        , TF.argument _default_os
        , TF.argument _default_root_device_type
        , TF.argument _default_ssh_key_name
        , TF.argument _default_subnet_id
        , TF.argument _hostname_theme
        , TF.argument _manage_berkshelf
        , TF.argument _name
        , TF.argument _region
        , TF.argument _service_role_arn
        , TF.argument _tags
        , TF.argument _use_custom_cookbooks
        , TF.argument _use_opsworks_security_groups
        , TF.argument _vpc_id
        ]

instance HasAgentVersion OpsworksStackResource Text where
    agentVersion =
        lens (_agent_version :: OpsworksStackResource -> TF.Argument "agent_version" Text)
             (\s a -> s { _agent_version = a } :: OpsworksStackResource)

instance HasBerkshelfVersion OpsworksStackResource Text where
    berkshelfVersion =
        lens (_berkshelf_version :: OpsworksStackResource -> TF.Argument "berkshelf_version" Text)
             (\s a -> s { _berkshelf_version = a } :: OpsworksStackResource)

instance HasColor OpsworksStackResource Text where
    color =
        lens (_color :: OpsworksStackResource -> TF.Argument "color" Text)
             (\s a -> s { _color = a } :: OpsworksStackResource)

instance HasConfigurationManagerName OpsworksStackResource Text where
    configurationManagerName =
        lens (_configuration_manager_name :: OpsworksStackResource -> TF.Argument "configuration_manager_name" Text)
             (\s a -> s { _configuration_manager_name = a } :: OpsworksStackResource)

instance HasConfigurationManagerVersion OpsworksStackResource Text where
    configurationManagerVersion =
        lens (_configuration_manager_version :: OpsworksStackResource -> TF.Argument "configuration_manager_version" Text)
             (\s a -> s { _configuration_manager_version = a } :: OpsworksStackResource)

instance HasCustomCookbooksSource OpsworksStackResource Text where
    customCookbooksSource =
        lens (_custom_cookbooks_source :: OpsworksStackResource -> TF.Argument "custom_cookbooks_source" Text)
             (\s a -> s { _custom_cookbooks_source = a } :: OpsworksStackResource)

instance HasCustomJson OpsworksStackResource Text where
    customJson =
        lens (_custom_json :: OpsworksStackResource -> TF.Argument "custom_json" Text)
             (\s a -> s { _custom_json = a } :: OpsworksStackResource)

instance HasDefaultAvailabilityZone OpsworksStackResource TF.Zone where
    defaultAvailabilityZone =
        lens (_default_availability_zone :: OpsworksStackResource -> TF.Argument "default_availability_zone" TF.Zone)
             (\s a -> s { _default_availability_zone = a } :: OpsworksStackResource)

instance HasDefaultInstanceProfileArn OpsworksStackResource Text where
    defaultInstanceProfileArn =
        lens (_default_instance_profile_arn :: OpsworksStackResource -> TF.Argument "default_instance_profile_arn" Text)
             (\s a -> s { _default_instance_profile_arn = a } :: OpsworksStackResource)

instance HasDefaultOs OpsworksStackResource Text where
    defaultOs =
        lens (_default_os :: OpsworksStackResource -> TF.Argument "default_os" Text)
             (\s a -> s { _default_os = a } :: OpsworksStackResource)

instance HasDefaultRootDeviceType OpsworksStackResource Text where
    defaultRootDeviceType =
        lens (_default_root_device_type :: OpsworksStackResource -> TF.Argument "default_root_device_type" Text)
             (\s a -> s { _default_root_device_type = a } :: OpsworksStackResource)

instance HasDefaultSshKeyName OpsworksStackResource Text where
    defaultSshKeyName =
        lens (_default_ssh_key_name :: OpsworksStackResource -> TF.Argument "default_ssh_key_name" Text)
             (\s a -> s { _default_ssh_key_name = a } :: OpsworksStackResource)

instance HasDefaultSubnetId OpsworksStackResource Text where
    defaultSubnetId =
        lens (_default_subnet_id :: OpsworksStackResource -> TF.Argument "default_subnet_id" Text)
             (\s a -> s { _default_subnet_id = a } :: OpsworksStackResource)

instance HasHostnameTheme OpsworksStackResource Text where
    hostnameTheme =
        lens (_hostname_theme :: OpsworksStackResource -> TF.Argument "hostname_theme" Text)
             (\s a -> s { _hostname_theme = a } :: OpsworksStackResource)

instance HasManageBerkshelf OpsworksStackResource Text where
    manageBerkshelf =
        lens (_manage_berkshelf :: OpsworksStackResource -> TF.Argument "manage_berkshelf" Text)
             (\s a -> s { _manage_berkshelf = a } :: OpsworksStackResource)

instance HasName OpsworksStackResource Text where
    name =
        lens (_name :: OpsworksStackResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: OpsworksStackResource)

instance HasRegion OpsworksStackResource TF.Region where
    region =
        lens (_region :: OpsworksStackResource -> TF.Argument "region" TF.Region)
             (\s a -> s { _region = a } :: OpsworksStackResource)

instance HasServiceRoleArn OpsworksStackResource Text where
    serviceRoleArn =
        lens (_service_role_arn :: OpsworksStackResource -> TF.Argument "service_role_arn" Text)
             (\s a -> s { _service_role_arn = a } :: OpsworksStackResource)

instance HasTags OpsworksStackResource TF.Tags where
    tags =
        lens (_tags :: OpsworksStackResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: OpsworksStackResource)

instance HasUseCustomCookbooks OpsworksStackResource Text where
    useCustomCookbooks =
        lens (_use_custom_cookbooks :: OpsworksStackResource -> TF.Argument "use_custom_cookbooks" Text)
             (\s a -> s { _use_custom_cookbooks = a } :: OpsworksStackResource)

instance HasUseOpsworksSecurityGroups OpsworksStackResource Text where
    useOpsworksSecurityGroups =
        lens (_use_opsworks_security_groups :: OpsworksStackResource -> TF.Argument "use_opsworks_security_groups" Text)
             (\s a -> s { _use_opsworks_security_groups = a } :: OpsworksStackResource)

instance HasVpcId OpsworksStackResource Text where
    vpcId =
        lens (_vpc_id :: OpsworksStackResource -> TF.Argument "vpc_id" Text)
             (\s a -> s { _vpc_id = a } :: OpsworksStackResource)

instance HasComputedId OpsworksStackResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

opsworksStackResource :: TF.Resource TF.AWS OpsworksStackResource
opsworksStackResource =
    TF.newResource "aws_opsworks_stack" $
        OpsworksStackResource {
            _agent_version = TF.Nil
            , _berkshelf_version = TF.Nil
            , _color = TF.Nil
            , _configuration_manager_name = TF.Nil
            , _configuration_manager_version = TF.Nil
            , _custom_cookbooks_source = TF.Nil
            , _custom_json = TF.Nil
            , _default_availability_zone = TF.Nil
            , _default_instance_profile_arn = TF.Nil
            , _default_os = TF.Nil
            , _default_root_device_type = TF.Nil
            , _default_ssh_key_name = TF.Nil
            , _default_subnet_id = TF.Nil
            , _hostname_theme = TF.Nil
            , _manage_berkshelf = TF.Nil
            , _name = TF.Nil
            , _region = TF.Nil
            , _service_role_arn = TF.Nil
            , _tags = TF.Nil
            , _use_custom_cookbooks = TF.Nil
            , _use_opsworks_security_groups = TF.Nil
            , _vpc_id = TF.Nil
            }

{- | The @aws_opsworks_static_web_layer@ AWS resource.

Provides an OpsWorks static web server layer resource.
-}
data OpsworksStaticWebLayerResource = OpsworksStaticWebLayerResource {
      _auto_assign_elastic_ips :: !(TF.Argument "auto_assign_elastic_ips" Text)
    {- ^ (Optional) Whether to automatically assign an elastic IP address to the layer's instances. -}
    , _auto_assign_public_ips :: !(TF.Argument "auto_assign_public_ips" Text)
    {- ^ (Optional) For stacks belonging to a VPC, whether to automatically assign a public IP address to each of the layer's instances. -}
    , _auto_healing :: !(TF.Argument "auto_healing" Text)
    {- ^ (Optional) Whether to enable auto-healing for the layer. -}
    , _custom_instance_profile_arn :: !(TF.Argument "custom_instance_profile_arn" Text)
    {- ^ (Optional) The ARN of an IAM profile that will be used for the layer's instances. -}
    , _custom_security_group_ids :: !(TF.Argument "custom_security_group_ids" Text)
    {- ^ (Optional) Ids for a set of security groups to apply to the layer's instances. -}
    , _drain_elb_on_shutdown :: !(TF.Argument "drain_elb_on_shutdown" Text)
    {- ^ (Optional) Whether to enable Elastic Load Balancing connection draining. -}
    , _ebs_volume :: !(TF.Argument "ebs_volume" Text)
    {- ^ (Optional) @ebs_volume@ blocks, as described below, will each create an EBS volume and connect it to the layer's instances. -}
    , _elastic_load_balancer :: !(TF.Argument "elastic_load_balancer" Text)
    {- ^ (Optional) Name of an Elastic Load Balancer to attach to this layer -}
    , _install_updates_on_boot :: !(TF.Argument "install_updates_on_boot" Text)
    {- ^ (Optional) Whether to install OS and package updates on each instance when it boots. -}
    , _instance_shutdown_timeout :: !(TF.Argument "instance_shutdown_timeout" Text)
    {- ^ (Optional) The time, in seconds, that OpsWorks will wait for Chef to complete after triggering the Shutdown event. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Optional) A human-readable name for the layer. -}
    , _stack_id :: !(TF.Argument "stack_id" Text)
    {- ^ (Required) The id of the stack the layer will belong to. -}
    , _system_packages :: !(TF.Argument "system_packages" Text)
    {- ^ (Optional) Names of a set of system packages to install on the layer's instances. -}
    , _use_ebs_optimized_instances :: !(TF.Argument "use_ebs_optimized_instances" Text)
    {- ^ (Optional) Whether to use EBS-optimized instances. -}
    } deriving (Show, Eq)

instance TF.ToHCL OpsworksStaticWebLayerResource where
    toHCL OpsworksStaticWebLayerResource{..} = TF.block $ catMaybes
        [ TF.argument _auto_assign_elastic_ips
        , TF.argument _auto_assign_public_ips
        , TF.argument _auto_healing
        , TF.argument _custom_instance_profile_arn
        , TF.argument _custom_security_group_ids
        , TF.argument _drain_elb_on_shutdown
        , TF.argument _ebs_volume
        , TF.argument _elastic_load_balancer
        , TF.argument _install_updates_on_boot
        , TF.argument _instance_shutdown_timeout
        , TF.argument _name
        , TF.argument _stack_id
        , TF.argument _system_packages
        , TF.argument _use_ebs_optimized_instances
        ]

instance HasAutoAssignElasticIps OpsworksStaticWebLayerResource Text where
    autoAssignElasticIps =
        lens (_auto_assign_elastic_ips :: OpsworksStaticWebLayerResource -> TF.Argument "auto_assign_elastic_ips" Text)
             (\s a -> s { _auto_assign_elastic_ips = a } :: OpsworksStaticWebLayerResource)

instance HasAutoAssignPublicIps OpsworksStaticWebLayerResource Text where
    autoAssignPublicIps =
        lens (_auto_assign_public_ips :: OpsworksStaticWebLayerResource -> TF.Argument "auto_assign_public_ips" Text)
             (\s a -> s { _auto_assign_public_ips = a } :: OpsworksStaticWebLayerResource)

instance HasAutoHealing OpsworksStaticWebLayerResource Text where
    autoHealing =
        lens (_auto_healing :: OpsworksStaticWebLayerResource -> TF.Argument "auto_healing" Text)
             (\s a -> s { _auto_healing = a } :: OpsworksStaticWebLayerResource)

instance HasCustomInstanceProfileArn OpsworksStaticWebLayerResource Text where
    customInstanceProfileArn =
        lens (_custom_instance_profile_arn :: OpsworksStaticWebLayerResource -> TF.Argument "custom_instance_profile_arn" Text)
             (\s a -> s { _custom_instance_profile_arn = a } :: OpsworksStaticWebLayerResource)

instance HasCustomSecurityGroupIds OpsworksStaticWebLayerResource Text where
    customSecurityGroupIds =
        lens (_custom_security_group_ids :: OpsworksStaticWebLayerResource -> TF.Argument "custom_security_group_ids" Text)
             (\s a -> s { _custom_security_group_ids = a } :: OpsworksStaticWebLayerResource)

instance HasDrainElbOnShutdown OpsworksStaticWebLayerResource Text where
    drainElbOnShutdown =
        lens (_drain_elb_on_shutdown :: OpsworksStaticWebLayerResource -> TF.Argument "drain_elb_on_shutdown" Text)
             (\s a -> s { _drain_elb_on_shutdown = a } :: OpsworksStaticWebLayerResource)

instance HasEbsVolume OpsworksStaticWebLayerResource Text where
    ebsVolume =
        lens (_ebs_volume :: OpsworksStaticWebLayerResource -> TF.Argument "ebs_volume" Text)
             (\s a -> s { _ebs_volume = a } :: OpsworksStaticWebLayerResource)

instance HasElasticLoadBalancer OpsworksStaticWebLayerResource Text where
    elasticLoadBalancer =
        lens (_elastic_load_balancer :: OpsworksStaticWebLayerResource -> TF.Argument "elastic_load_balancer" Text)
             (\s a -> s { _elastic_load_balancer = a } :: OpsworksStaticWebLayerResource)

instance HasInstallUpdatesOnBoot OpsworksStaticWebLayerResource Text where
    installUpdatesOnBoot =
        lens (_install_updates_on_boot :: OpsworksStaticWebLayerResource -> TF.Argument "install_updates_on_boot" Text)
             (\s a -> s { _install_updates_on_boot = a } :: OpsworksStaticWebLayerResource)

instance HasInstanceShutdownTimeout OpsworksStaticWebLayerResource Text where
    instanceShutdownTimeout =
        lens (_instance_shutdown_timeout :: OpsworksStaticWebLayerResource -> TF.Argument "instance_shutdown_timeout" Text)
             (\s a -> s { _instance_shutdown_timeout = a } :: OpsworksStaticWebLayerResource)

instance HasName OpsworksStaticWebLayerResource Text where
    name =
        lens (_name :: OpsworksStaticWebLayerResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: OpsworksStaticWebLayerResource)

instance HasStackId OpsworksStaticWebLayerResource Text where
    stackId =
        lens (_stack_id :: OpsworksStaticWebLayerResource -> TF.Argument "stack_id" Text)
             (\s a -> s { _stack_id = a } :: OpsworksStaticWebLayerResource)

instance HasSystemPackages OpsworksStaticWebLayerResource Text where
    systemPackages =
        lens (_system_packages :: OpsworksStaticWebLayerResource -> TF.Argument "system_packages" Text)
             (\s a -> s { _system_packages = a } :: OpsworksStaticWebLayerResource)

instance HasUseEbsOptimizedInstances OpsworksStaticWebLayerResource Text where
    useEbsOptimizedInstances =
        lens (_use_ebs_optimized_instances :: OpsworksStaticWebLayerResource -> TF.Argument "use_ebs_optimized_instances" Text)
             (\s a -> s { _use_ebs_optimized_instances = a } :: OpsworksStaticWebLayerResource)

instance HasComputedId OpsworksStaticWebLayerResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

opsworksStaticWebLayerResource :: TF.Resource TF.AWS OpsworksStaticWebLayerResource
opsworksStaticWebLayerResource =
    TF.newResource "aws_opsworks_static_web_layer" $
        OpsworksStaticWebLayerResource {
            _auto_assign_elastic_ips = TF.Nil
            , _auto_assign_public_ips = TF.Nil
            , _auto_healing = TF.Nil
            , _custom_instance_profile_arn = TF.Nil
            , _custom_security_group_ids = TF.Nil
            , _drain_elb_on_shutdown = TF.Nil
            , _ebs_volume = TF.Nil
            , _elastic_load_balancer = TF.Nil
            , _install_updates_on_boot = TF.Nil
            , _instance_shutdown_timeout = TF.Nil
            , _name = TF.Nil
            , _stack_id = TF.Nil
            , _system_packages = TF.Nil
            , _use_ebs_optimized_instances = TF.Nil
            }

{- | The @aws_opsworks_user_profile@ AWS resource.

Provides an OpsWorks User Profile resource.
-}
data OpsworksUserProfileResource = OpsworksUserProfileResource {
      _allow_self_management :: !(TF.Argument "allow_self_management" Text)
    {- ^ (Optional) Whether users can specify their own SSH public key through the My Settings page -}
    , _ssh_public_key :: !(TF.Argument "ssh_public_key" Text)
    {- ^ (Optional) The users public key -}
    , _ssh_username :: !(TF.Argument "ssh_username" Text)
    {- ^ (Required) The ssh username, with witch this user wants to log in -}
    , _user_arn :: !(TF.Argument "user_arn" Text)
    {- ^ (Required) The user's IAM ARN -}
    } deriving (Show, Eq)

instance TF.ToHCL OpsworksUserProfileResource where
    toHCL OpsworksUserProfileResource{..} = TF.block $ catMaybes
        [ TF.argument _allow_self_management
        , TF.argument _ssh_public_key
        , TF.argument _ssh_username
        , TF.argument _user_arn
        ]

instance HasAllowSelfManagement OpsworksUserProfileResource Text where
    allowSelfManagement =
        lens (_allow_self_management :: OpsworksUserProfileResource -> TF.Argument "allow_self_management" Text)
             (\s a -> s { _allow_self_management = a } :: OpsworksUserProfileResource)

instance HasSshPublicKey OpsworksUserProfileResource Text where
    sshPublicKey =
        lens (_ssh_public_key :: OpsworksUserProfileResource -> TF.Argument "ssh_public_key" Text)
             (\s a -> s { _ssh_public_key = a } :: OpsworksUserProfileResource)

instance HasSshUsername OpsworksUserProfileResource Text where
    sshUsername =
        lens (_ssh_username :: OpsworksUserProfileResource -> TF.Argument "ssh_username" Text)
             (\s a -> s { _ssh_username = a } :: OpsworksUserProfileResource)

instance HasUserArn OpsworksUserProfileResource Text where
    userArn =
        lens (_user_arn :: OpsworksUserProfileResource -> TF.Argument "user_arn" Text)
             (\s a -> s { _user_arn = a } :: OpsworksUserProfileResource)

instance HasComputedId OpsworksUserProfileResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

opsworksUserProfileResource :: TF.Resource TF.AWS OpsworksUserProfileResource
opsworksUserProfileResource =
    TF.newResource "aws_opsworks_user_profile" $
        OpsworksUserProfileResource {
            _allow_self_management = TF.Nil
            , _ssh_public_key = TF.Nil
            , _ssh_username = TF.Nil
            , _user_arn = TF.Nil
            }

{- | The @aws_placement_group@ AWS resource.

Provides an EC2 placement group. Read more about placement groups in
<https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/placement-groups.html>
.
-}
data PlacementGroupResource = PlacementGroupResource {
      _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the placement group. -}
    , _strategy :: !(TF.Argument "strategy" Text)
    {- ^ (Required) The placement strategy. -}
    } deriving (Show, Eq)

instance TF.ToHCL PlacementGroupResource where
    toHCL PlacementGroupResource{..} = TF.block $ catMaybes
        [ TF.argument _name
        , TF.argument _strategy
        ]

instance HasName PlacementGroupResource Text where
    name =
        lens (_name :: PlacementGroupResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: PlacementGroupResource)

instance HasStrategy PlacementGroupResource Text where
    strategy =
        lens (_strategy :: PlacementGroupResource -> TF.Argument "strategy" Text)
             (\s a -> s { _strategy = a } :: PlacementGroupResource)

instance HasComputedId PlacementGroupResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

placementGroupResource :: TF.Resource TF.AWS PlacementGroupResource
placementGroupResource =
    TF.newResource "aws_placement_group" $
        PlacementGroupResource {
            _name = TF.Nil
            , _strategy = TF.Nil
            }

{- | The @aws_proxy_protocol_policy@ AWS resource.

Provides a proxy protocol policy, which allows an ELB to carry a client
connection information to a backend.
-}
data ProxyProtocolPolicyResource = ProxyProtocolPolicyResource {
      _instance_ports :: !(TF.Argument "instance_ports" Text)
    {- ^ (Required) List of instance ports to which the policy should be applied. This can be specified if the protocol is SSL or TCP. -}
    , _load_balancer :: !(TF.Argument "load_balancer" Text)
    {- ^ (Required) The load balancer to which the policy should be attached. -}
    } deriving (Show, Eq)

instance TF.ToHCL ProxyProtocolPolicyResource where
    toHCL ProxyProtocolPolicyResource{..} = TF.block $ catMaybes
        [ TF.argument _instance_ports
        , TF.argument _load_balancer
        ]

instance HasInstancePorts ProxyProtocolPolicyResource Text where
    instancePorts =
        lens (_instance_ports :: ProxyProtocolPolicyResource -> TF.Argument "instance_ports" Text)
             (\s a -> s { _instance_ports = a } :: ProxyProtocolPolicyResource)

instance HasLoadBalancer ProxyProtocolPolicyResource Text where
    loadBalancer =
        lens (_load_balancer :: ProxyProtocolPolicyResource -> TF.Argument "load_balancer" Text)
             (\s a -> s { _load_balancer = a } :: ProxyProtocolPolicyResource)

instance HasComputedId ProxyProtocolPolicyResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedLoadBalancer ProxyProtocolPolicyResource Text where
    computedLoadBalancer =
        to (\_  -> TF.Compute "load_balancer")

proxyProtocolPolicyResource :: TF.Resource TF.AWS ProxyProtocolPolicyResource
proxyProtocolPolicyResource =
    TF.newResource "aws_proxy_protocol_policy" $
        ProxyProtocolPolicyResource {
            _instance_ports = TF.Nil
            , _load_balancer = TF.Nil
            }

{- | The @aws_rds_cluster_instance@ AWS resource.

Provides an RDS Cluster Resource Instance. A Cluster Instance Resource
defines attributes that are specific to a single instance in a
</docs/providers/aws/r/rds_cluster.html> , specifically running Amazon
Aurora. Unlike other RDS resources that support replication, with Amazon
Aurora you do not designate a primary and subsequent replicas. Instead, you
simply add RDS Instances and Aurora manages the replication. You can use the
</docs/configuration/resources.html#count> meta-parameter to make multiple
instances and join them all to the same RDS Cluster, or you may specify
different Cluster Instance resources with various @instance_class@ sizes.
For more information on Amazon Aurora, see
<https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Aurora.html> in
the Amazon RDS User Guide.
-}
data RdsClusterInstanceResource = RdsClusterInstanceResource {
      _apply_immediately :: !(TF.Argument "apply_immediately" Text)
    {- ^ (Optional) Specifies whether any database modifications are applied immediately, or during the next maintenance window. Default is @false@ . -}
    , _auto_minor_version_upgrade :: !(TF.Argument "auto_minor_version_upgrade" Text)
    {- ^ (Optional) Indicates that minor engine upgrades will be applied automatically to the DB instance during the maintenance window. Default @true@ . -}
    , _cluster_identifier :: !(TF.Argument "cluster_identifier" Text)
    {- ^ (Required) The identifier of the </docs/providers/aws/r/rds_cluster.html> in which to launch this instance. -}
    , _db_parameter_group_name :: !(TF.Argument "db_parameter_group_name" Text)
    {- ^ (Optional) The name of the DB parameter group to associate with this instance. -}
    , _db_subnet_group_name :: !(TF.Argument "db_subnet_group_name" Text)
    {- ^ (Required if @publicly_accessible = false@ , Optional otherwise) A DB subnet group to associate with this DB instance. NOTE: This must match the @db_subnet_group_name@ of the attached </docs/providers/aws/r/rds_cluster.html> . -}
    , _engine :: !(TF.Argument "engine" Text)
    {- ^ (Optional) The name of the database engine to be used for the RDS instance. Defaults to @aurora@ . -}
    , _engine_version :: !(TF.Argument "engine_version" Text)
    {- ^ (Optional) The database engine version. -}
    , _identifier :: !(TF.Argument "identifier" Text)
    {- ^ (Optional, Forces new resource) The indentifier for the RDS instance, if omitted, Terraform will assign a random, unique identifier. -}
    , _identifier_prefix :: !(TF.Argument "identifier_prefix" Text)
    {- ^ (Optional, Forces new resource) Creates a unique identifier beginning with the specified prefix. Conflicts with @identifer@ . -}
    , _instance_class :: !(TF.Argument "instance_class" Text)
    {- ^ (Required) The instance class to use. For details on CPU and memory, see <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Aurora.Managing.html> . Aurora currently supports the below instance classes. -}
    , _monitoring_interval :: !(TF.Argument "monitoring_interval" Text)
    {- ^ (Optional) The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB instance. To disable collecting Enhanced Monitoring metrics, specify 0. The default is 0. Valid Values: 0, 1, 5, 10, 15, 30, 60. -}
    , _monitoring_role_arn :: !(TF.Argument "monitoring_role_arn" Text)
    {- ^ (Optional) The ARN for the IAM role that permits RDS to send enhanced monitoring metrics to CloudWatch Logs. You can find more information on the <http://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Monitoring.html> what IAM permissions are needed to allow Enhanced Monitoring for RDS Instances. -}
    , _performance_insights_enabled :: !(TF.Argument "performance_insights_enabled" TF.Bool)
    {- ^ (Optional) Specifies whether Performance Insights is enabled or not. -}
    , _performance_insights_kms_key_id :: !(TF.Argument "performance_insights_kms_key_id" Text)
    {- ^ (Optional) The ARN for the KMS key to encrypt Performance Insights data. When specifying @performance_insights_kms_key_id@ , @performance_insights_enabled@ needs to be set to true. -}
    , _preferred_backup_window :: !(TF.Argument "preferred_backup_window" Text)
    {- ^ (Optional) The daily time range during which automated backups are created if automated backups are enabled. Eg: "04:00-09:00" -}
    , _preferred_maintenance_window :: !(TF.Argument "preferred_maintenance_window" Text)
    {- ^ (Optional) The window to perform maintenance in. Syntax: "ddd:hh24:mi-ddd:hh24:mi". Eg: "Mon:00:00-Mon:03:00". -}
    , _promotion_tier :: !(TF.Argument "promotion_tier" Text)
    {- ^ (Optional) Default 0. Failover Priority setting on instance level. The reader who has lower tier has higher priority to get promoter to writer. -}
    , _publicly_accessible :: !(TF.Argument "publicly_accessible" Text)
    {- ^ (Optional) Bool to control if instance is publicly accessible. Default @false@ . See the documentation on <https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_CreateDBInstance.html> for more details on controlling this property. -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the instance. -}
    } deriving (Show, Eq)

instance TF.ToHCL RdsClusterInstanceResource where
    toHCL RdsClusterInstanceResource{..} = TF.block $ catMaybes
        [ TF.argument _apply_immediately
        , TF.argument _auto_minor_version_upgrade
        , TF.argument _cluster_identifier
        , TF.argument _db_parameter_group_name
        , TF.argument _db_subnet_group_name
        , TF.argument _engine
        , TF.argument _engine_version
        , TF.argument _identifier
        , TF.argument _identifier_prefix
        , TF.argument _instance_class
        , TF.argument _monitoring_interval
        , TF.argument _monitoring_role_arn
        , TF.argument _performance_insights_enabled
        , TF.argument _performance_insights_kms_key_id
        , TF.argument _preferred_backup_window
        , TF.argument _preferred_maintenance_window
        , TF.argument _promotion_tier
        , TF.argument _publicly_accessible
        , TF.argument _tags
        ]

instance HasApplyImmediately RdsClusterInstanceResource Text where
    applyImmediately =
        lens (_apply_immediately :: RdsClusterInstanceResource -> TF.Argument "apply_immediately" Text)
             (\s a -> s { _apply_immediately = a } :: RdsClusterInstanceResource)

instance HasAutoMinorVersionUpgrade RdsClusterInstanceResource Text where
    autoMinorVersionUpgrade =
        lens (_auto_minor_version_upgrade :: RdsClusterInstanceResource -> TF.Argument "auto_minor_version_upgrade" Text)
             (\s a -> s { _auto_minor_version_upgrade = a } :: RdsClusterInstanceResource)

instance HasClusterIdentifier RdsClusterInstanceResource Text where
    clusterIdentifier =
        lens (_cluster_identifier :: RdsClusterInstanceResource -> TF.Argument "cluster_identifier" Text)
             (\s a -> s { _cluster_identifier = a } :: RdsClusterInstanceResource)

instance HasDbParameterGroupName RdsClusterInstanceResource Text where
    dbParameterGroupName =
        lens (_db_parameter_group_name :: RdsClusterInstanceResource -> TF.Argument "db_parameter_group_name" Text)
             (\s a -> s { _db_parameter_group_name = a } :: RdsClusterInstanceResource)

instance HasDbSubnetGroupName RdsClusterInstanceResource Text where
    dbSubnetGroupName =
        lens (_db_subnet_group_name :: RdsClusterInstanceResource -> TF.Argument "db_subnet_group_name" Text)
             (\s a -> s { _db_subnet_group_name = a } :: RdsClusterInstanceResource)

instance HasEngine RdsClusterInstanceResource Text where
    engine =
        lens (_engine :: RdsClusterInstanceResource -> TF.Argument "engine" Text)
             (\s a -> s { _engine = a } :: RdsClusterInstanceResource)

instance HasEngineVersion RdsClusterInstanceResource Text where
    engineVersion =
        lens (_engine_version :: RdsClusterInstanceResource -> TF.Argument "engine_version" Text)
             (\s a -> s { _engine_version = a } :: RdsClusterInstanceResource)

instance HasIdentifier RdsClusterInstanceResource Text where
    identifier =
        lens (_identifier :: RdsClusterInstanceResource -> TF.Argument "identifier" Text)
             (\s a -> s { _identifier = a } :: RdsClusterInstanceResource)

instance HasIdentifierPrefix RdsClusterInstanceResource Text where
    identifierPrefix =
        lens (_identifier_prefix :: RdsClusterInstanceResource -> TF.Argument "identifier_prefix" Text)
             (\s a -> s { _identifier_prefix = a } :: RdsClusterInstanceResource)

instance HasInstanceClass RdsClusterInstanceResource Text where
    instanceClass =
        lens (_instance_class :: RdsClusterInstanceResource -> TF.Argument "instance_class" Text)
             (\s a -> s { _instance_class = a } :: RdsClusterInstanceResource)

instance HasMonitoringInterval RdsClusterInstanceResource Text where
    monitoringInterval =
        lens (_monitoring_interval :: RdsClusterInstanceResource -> TF.Argument "monitoring_interval" Text)
             (\s a -> s { _monitoring_interval = a } :: RdsClusterInstanceResource)

instance HasMonitoringRoleArn RdsClusterInstanceResource Text where
    monitoringRoleArn =
        lens (_monitoring_role_arn :: RdsClusterInstanceResource -> TF.Argument "monitoring_role_arn" Text)
             (\s a -> s { _monitoring_role_arn = a } :: RdsClusterInstanceResource)

instance HasPerformanceInsightsEnabled RdsClusterInstanceResource TF.Bool where
    performanceInsightsEnabled =
        lens (_performance_insights_enabled :: RdsClusterInstanceResource -> TF.Argument "performance_insights_enabled" TF.Bool)
             (\s a -> s { _performance_insights_enabled = a } :: RdsClusterInstanceResource)

instance HasPerformanceInsightsKmsKeyId RdsClusterInstanceResource Text where
    performanceInsightsKmsKeyId =
        lens (_performance_insights_kms_key_id :: RdsClusterInstanceResource -> TF.Argument "performance_insights_kms_key_id" Text)
             (\s a -> s { _performance_insights_kms_key_id = a } :: RdsClusterInstanceResource)

instance HasPreferredBackupWindow RdsClusterInstanceResource Text where
    preferredBackupWindow =
        lens (_preferred_backup_window :: RdsClusterInstanceResource -> TF.Argument "preferred_backup_window" Text)
             (\s a -> s { _preferred_backup_window = a } :: RdsClusterInstanceResource)

instance HasPreferredMaintenanceWindow RdsClusterInstanceResource Text where
    preferredMaintenanceWindow =
        lens (_preferred_maintenance_window :: RdsClusterInstanceResource -> TF.Argument "preferred_maintenance_window" Text)
             (\s a -> s { _preferred_maintenance_window = a } :: RdsClusterInstanceResource)

instance HasPromotionTier RdsClusterInstanceResource Text where
    promotionTier =
        lens (_promotion_tier :: RdsClusterInstanceResource -> TF.Argument "promotion_tier" Text)
             (\s a -> s { _promotion_tier = a } :: RdsClusterInstanceResource)

instance HasPubliclyAccessible RdsClusterInstanceResource Text where
    publiclyAccessible =
        lens (_publicly_accessible :: RdsClusterInstanceResource -> TF.Argument "publicly_accessible" Text)
             (\s a -> s { _publicly_accessible = a } :: RdsClusterInstanceResource)

instance HasTags RdsClusterInstanceResource TF.Tags where
    tags =
        lens (_tags :: RdsClusterInstanceResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: RdsClusterInstanceResource)

instance HasComputedAllocatedStorage RdsClusterInstanceResource Text where
    computedAllocatedStorage =
        to (\_  -> TF.Compute "allocated_storage")

instance HasComputedAvailabilityZone RdsClusterInstanceResource TF.Zone where
    computedAvailabilityZone =
        to (\_  -> TF.Compute "availability_zone")

instance HasComputedClusterIdentifier RdsClusterInstanceResource Text where
    computedClusterIdentifier =
        to (\_  -> TF.Compute "cluster_identifier")

instance HasComputedDatabaseName RdsClusterInstanceResource Text where
    computedDatabaseName =
        to (\_  -> TF.Compute "database_name")

instance HasComputedDbiResourceId RdsClusterInstanceResource Text where
    computedDbiResourceId =
        to (\_  -> TF.Compute "dbi_resource_id")

instance HasComputedEndpoint RdsClusterInstanceResource Text where
    computedEndpoint =
        to (\_  -> TF.Compute "endpoint")

instance HasComputedEngine RdsClusterInstanceResource Text where
    computedEngine =
        to (\_  -> TF.Compute "engine")

instance HasComputedEngineVersion RdsClusterInstanceResource Text where
    computedEngineVersion =
        to (\_  -> TF.Compute "engine_version")

instance HasComputedId RdsClusterInstanceResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedIdentifier RdsClusterInstanceResource Text where
    computedIdentifier =
        to (\_  -> TF.Compute "identifier")

instance HasComputedKmsKeyId RdsClusterInstanceResource Text where
    computedKmsKeyId =
        to (\_  -> TF.Compute "kms_key_id")

instance HasComputedPerformanceInsightsEnabled RdsClusterInstanceResource TF.Bool where
    computedPerformanceInsightsEnabled =
        to (\_  -> TF.Compute "performance_insights_enabled")

instance HasComputedPerformanceInsightsKmsKeyId RdsClusterInstanceResource Text where
    computedPerformanceInsightsKmsKeyId =
        to (\_  -> TF.Compute "performance_insights_kms_key_id")

instance HasComputedPort RdsClusterInstanceResource Text where
    computedPort =
        to (\_  -> TF.Compute "port")

instance HasComputedStatus RdsClusterInstanceResource Text where
    computedStatus =
        to (\_  -> TF.Compute "status")

instance HasComputedStorageEncrypted RdsClusterInstanceResource Text where
    computedStorageEncrypted =
        to (\_  -> TF.Compute "storage_encrypted")

instance HasComputedWriter RdsClusterInstanceResource Text where
    computedWriter =
        to (\_  -> TF.Compute "writer")

rdsClusterInstanceResource :: TF.Resource TF.AWS RdsClusterInstanceResource
rdsClusterInstanceResource =
    TF.newResource "aws_rds_cluster_instance" $
        RdsClusterInstanceResource {
            _apply_immediately = TF.Nil
            , _auto_minor_version_upgrade = TF.Nil
            , _cluster_identifier = TF.Nil
            , _db_parameter_group_name = TF.Nil
            , _db_subnet_group_name = TF.Nil
            , _engine = TF.Nil
            , _engine_version = TF.Nil
            , _identifier = TF.Nil
            , _identifier_prefix = TF.Nil
            , _instance_class = TF.Nil
            , _monitoring_interval = TF.Nil
            , _monitoring_role_arn = TF.Nil
            , _performance_insights_enabled = TF.Nil
            , _performance_insights_kms_key_id = TF.Nil
            , _preferred_backup_window = TF.Nil
            , _preferred_maintenance_window = TF.Nil
            , _promotion_tier = TF.Nil
            , _publicly_accessible = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_rds_cluster_parameter_group@ AWS resource.

Provides an RDS DB cluster parameter group resource.
-}
data RdsClusterParameterGroupResource = RdsClusterParameterGroupResource {
      _description :: !(TF.Argument "description" Text)
    {- ^ (Optional) The description of the DB cluster parameter group. Defaults to "Managed by Terraform". -}
    , _family' :: !(TF.Argument "family" Text)
    {- ^ (Required) The family of the DB cluster parameter group. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Optional, Forces new resource) The name of the DB cluster parameter group. If omitted, Terraform will assign a random, unique name. -}
    , _name_prefix :: !(TF.Argument "name_prefix" Text)
    {- ^ (Optional, Forces new resource) Creates a unique name beginning with the specified prefix. Conflicts with @name@ . -}
    , _parameter :: !(TF.Argument "parameter" Text)
    {- ^ (Optional) A list of DB parameters to apply. Note that parameters may differ from a family to an other. Full list of all parameters can be discovered via <https://docs.aws.amazon.com/cli/latest/reference/rds/describe-db-cluster-parameters.html> after initial creation of the group. -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    } deriving (Show, Eq)

instance TF.ToHCL RdsClusterParameterGroupResource where
    toHCL RdsClusterParameterGroupResource{..} = TF.block $ catMaybes
        [ TF.argument _description
        , TF.argument _family'
        , TF.argument _name
        , TF.argument _name_prefix
        , TF.argument _parameter
        , TF.argument _tags
        ]

instance HasDescription RdsClusterParameterGroupResource Text where
    description =
        lens (_description :: RdsClusterParameterGroupResource -> TF.Argument "description" Text)
             (\s a -> s { _description = a } :: RdsClusterParameterGroupResource)

instance HasFamily' RdsClusterParameterGroupResource Text where
    family' =
        lens (_family' :: RdsClusterParameterGroupResource -> TF.Argument "family" Text)
             (\s a -> s { _family' = a } :: RdsClusterParameterGroupResource)

instance HasName RdsClusterParameterGroupResource Text where
    name =
        lens (_name :: RdsClusterParameterGroupResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: RdsClusterParameterGroupResource)

instance HasNamePrefix RdsClusterParameterGroupResource Text where
    namePrefix =
        lens (_name_prefix :: RdsClusterParameterGroupResource -> TF.Argument "name_prefix" Text)
             (\s a -> s { _name_prefix = a } :: RdsClusterParameterGroupResource)

instance HasParameter RdsClusterParameterGroupResource Text where
    parameter =
        lens (_parameter :: RdsClusterParameterGroupResource -> TF.Argument "parameter" Text)
             (\s a -> s { _parameter = a } :: RdsClusterParameterGroupResource)

instance HasTags RdsClusterParameterGroupResource TF.Tags where
    tags =
        lens (_tags :: RdsClusterParameterGroupResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: RdsClusterParameterGroupResource)

instance HasComputedArn RdsClusterParameterGroupResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

instance HasComputedId RdsClusterParameterGroupResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

rdsClusterParameterGroupResource :: TF.Resource TF.AWS RdsClusterParameterGroupResource
rdsClusterParameterGroupResource =
    TF.newResource "aws_rds_cluster_parameter_group" $
        RdsClusterParameterGroupResource {
            _description = TF.Nil
            , _family' = TF.Nil
            , _name = TF.Nil
            , _name_prefix = TF.Nil
            , _parameter = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_rds_cluster@ AWS resource.

Provides an RDS Cluster Resource. A Cluster Resource defines attributes that
are applied to the entire cluster of
</docs/providers/aws/r/rds_cluster_instance.html> . Use the RDS Cluster
resource and RDS Cluster Instances to create and use Amazon Aurora, a
MySQL-compatible database engine. For more information on Amazon Aurora, see
<https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Aurora.html> in
the Amazon RDS User Guide. Changes to a RDS Cluster can occur when you
manually change a parameter, such as @port@ , and are reflected in the next
maintenance window. Because of this, Terraform may report a difference in
its planning phase because a modification has not yet taken place. You can
use the @apply_immediately@ flag to instruct the service to apply the change
immediately (see documentation below). ~> Note: using @apply_immediately@
can result in a brief downtime as the server reboots. See the AWS Docs on
<https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_UpgradeDBInstance.Maintenance.html>
for more information. ~> Note: All arguments including the username and
password will be stored in the raw state as plain-text.
</docs/state/sensitive-data.html> .
-}
data RdsClusterResource = RdsClusterResource {
      _apply_immediately :: !(TF.Argument "apply_immediately" Text)
    {- ^ (Optional) Specifies whether any cluster modifications are applied immediately, or during the next maintenance window. Default is @false@ . See <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Overview.DBInstance.Modifying.html> -}
    , _availability_zones :: !(TF.Argument "availability_zones" Text)
    {- ^ (Optional) A list of EC2 Availability Zones that instances in the DB cluster can be created in -}
    , _backup_retention_period :: !(TF.Argument "backup_retention_period" Text)
    {- ^ (Optional) The days to retain backups for. Default 1 -}
    , _cluster_identifier :: !(TF.Argument "cluster_identifier" Text)
    {- ^ (Optional, Forces new resources) The cluster identifier. If omitted, Terraform will assign a random, unique identifier. -}
    , _cluster_identifier_prefix :: !(TF.Argument "cluster_identifier_prefix" Text)
    {- ^ (Optional, Forces new resource) Creates a unique cluster identifier beginning with the specified prefix. Conflicts with @cluster_identifer@ . -}
    , _database_name :: !(TF.Argument "database_name" Text)
    {- ^ (Optional) Name for an automatically created database on cluster creation. There are different naming restrictions per database engine: <http://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Limits.html#RDS_Limits.Constraints> -}
    , _db_cluster_parameter_group_name :: !(TF.Argument "db_cluster_parameter_group_name" Text)
    {- ^ (Optional) A cluster parameter group to associate with the cluster. -}
    , _db_subnet_group_name :: !(TF.Argument "db_subnet_group_name" Text)
    {- ^ (Optional) A DB subnet group to associate with this DB instance. NOTE: This must match the @db_subnet_group_name@ specified on every </docs/providers/aws/r/rds_cluster_instance.html> in the cluster. -}
    , _engine :: !(TF.Argument "engine" Text)
    {- ^ (Optional) The name of the database engine to be used for this DB cluster. Defaults to @aurora@ . -}
    , _engine_version :: !(TF.Argument "engine_version" Text)
    {- ^ (Optional) The database engine version. -}
    , _final_snapshot_identifier :: !(TF.Argument "final_snapshot_identifier" Text)
    {- ^ (Optional) The name of your final DB snapshot when this DB cluster is deleted. If omitted, no final snapshot will be made. -}
    , _iam_database_authentication_enabled :: !(TF.Argument "iam_database_authentication_enabled" TF.Bool)
    {- ^ (Optional) Specifies whether or mappings of AWS Identity and Access Management (IAM) accounts to database accounts is enabled. -}
    , _iam_roles :: !(TF.Argument "iam_roles" Text)
    {- ^ (Optional) A List of ARNs for the IAM roles to associate to the RDS Cluster. -}
    , _kms_key_id :: !(TF.Argument "kms_key_id" Text)
    {- ^ (Optional) The ARN for the KMS encryption key. When specifying @kms_key_id@ , @storage_encrypted@ needs to be set to true. -}
    , _master_password :: !(TF.Argument "master_password" Text)
    {- ^ (Required unless a @snapshot_identifier@ is provided) Password for the master DB user. Note that this may show up in logs, and it will be stored in the state file. Please refer to the <http://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Limits.html#RDS_Limits.Constraints> -}
    , _master_username :: !(TF.Argument "master_username" Text)
    {- ^ (Required unless a @snapshot_identifier@ is provided) Username for the master DB user. Please refer to the <http://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Limits.html#RDS_Limits.Constraints> -}
    , _port :: !(TF.Argument "port" Text)
    {- ^ (Optional) The port on which the DB accepts connections -}
    , _preferred_backup_window :: !(TF.Argument "preferred_backup_window" Text)
    {- ^ (Optional) The daily time range during which automated backups are created if automated backups are enabled using the BackupRetentionPeriod parameter.Time in UTC Default: A 30-minute window selected at random from an 8-hour block of time per region. e.g. 04:00-09:00 -}
    , _preferred_maintenance_window :: !(TF.Argument "preferred_maintenance_window" Text)
    {- ^ (Optional) The weekly time range during which system maintenance can occur, in (UTC) e.g. wed:04:00-wed:04:30 -}
    , _skip_final_snapshot :: !(TF.Argument "skip_final_snapshot" Text)
    {- ^ (Optional) Determines whether a final DB snapshot is created before the DB cluster is deleted. If true is specified, no DB snapshot is created. If false is specified, a DB snapshot is created before the DB cluster is deleted, using the value from @final_snapshot_identifier@ . Default is @false@ . -}
    , _snapshot_identifier :: !(TF.Argument "snapshot_identifier" Text)
    {- ^ (Optional) Specifies whether or not to create this cluster from a snapshot. This correlates to the snapshot ID you'd find in the RDS console, e.g: rds:production-2015-06-26-06-05. -}
    , _storage_encrypted :: !(TF.Argument "storage_encrypted" Text)
    {- ^ (Optional) Specifies whether the DB cluster is encrypted. The default is @false@ if not specified. -}
    , _vpc_security_group_ids :: !(TF.Argument "vpc_security_group_ids" Text)
    {- ^ (Optional) List of VPC security groups to associate with the Cluster -}
    } deriving (Show, Eq)

instance TF.ToHCL RdsClusterResource where
    toHCL RdsClusterResource{..} = TF.block $ catMaybes
        [ TF.argument _apply_immediately
        , TF.argument _availability_zones
        , TF.argument _backup_retention_period
        , TF.argument _cluster_identifier
        , TF.argument _cluster_identifier_prefix
        , TF.argument _database_name
        , TF.argument _db_cluster_parameter_group_name
        , TF.argument _db_subnet_group_name
        , TF.argument _engine
        , TF.argument _engine_version
        , TF.argument _final_snapshot_identifier
        , TF.argument _iam_database_authentication_enabled
        , TF.argument _iam_roles
        , TF.argument _kms_key_id
        , TF.argument _master_password
        , TF.argument _master_username
        , TF.argument _port
        , TF.argument _preferred_backup_window
        , TF.argument _preferred_maintenance_window
        , TF.argument _skip_final_snapshot
        , TF.argument _snapshot_identifier
        , TF.argument _storage_encrypted
        , TF.argument _vpc_security_group_ids
        ]

instance HasApplyImmediately RdsClusterResource Text where
    applyImmediately =
        lens (_apply_immediately :: RdsClusterResource -> TF.Argument "apply_immediately" Text)
             (\s a -> s { _apply_immediately = a } :: RdsClusterResource)

instance HasAvailabilityZones RdsClusterResource Text where
    availabilityZones =
        lens (_availability_zones :: RdsClusterResource -> TF.Argument "availability_zones" Text)
             (\s a -> s { _availability_zones = a } :: RdsClusterResource)

instance HasBackupRetentionPeriod RdsClusterResource Text where
    backupRetentionPeriod =
        lens (_backup_retention_period :: RdsClusterResource -> TF.Argument "backup_retention_period" Text)
             (\s a -> s { _backup_retention_period = a } :: RdsClusterResource)

instance HasClusterIdentifier RdsClusterResource Text where
    clusterIdentifier =
        lens (_cluster_identifier :: RdsClusterResource -> TF.Argument "cluster_identifier" Text)
             (\s a -> s { _cluster_identifier = a } :: RdsClusterResource)

instance HasClusterIdentifierPrefix RdsClusterResource Text where
    clusterIdentifierPrefix =
        lens (_cluster_identifier_prefix :: RdsClusterResource -> TF.Argument "cluster_identifier_prefix" Text)
             (\s a -> s { _cluster_identifier_prefix = a } :: RdsClusterResource)

instance HasDatabaseName RdsClusterResource Text where
    databaseName =
        lens (_database_name :: RdsClusterResource -> TF.Argument "database_name" Text)
             (\s a -> s { _database_name = a } :: RdsClusterResource)

instance HasDbClusterParameterGroupName RdsClusterResource Text where
    dbClusterParameterGroupName =
        lens (_db_cluster_parameter_group_name :: RdsClusterResource -> TF.Argument "db_cluster_parameter_group_name" Text)
             (\s a -> s { _db_cluster_parameter_group_name = a } :: RdsClusterResource)

instance HasDbSubnetGroupName RdsClusterResource Text where
    dbSubnetGroupName =
        lens (_db_subnet_group_name :: RdsClusterResource -> TF.Argument "db_subnet_group_name" Text)
             (\s a -> s { _db_subnet_group_name = a } :: RdsClusterResource)

instance HasEngine RdsClusterResource Text where
    engine =
        lens (_engine :: RdsClusterResource -> TF.Argument "engine" Text)
             (\s a -> s { _engine = a } :: RdsClusterResource)

instance HasEngineVersion RdsClusterResource Text where
    engineVersion =
        lens (_engine_version :: RdsClusterResource -> TF.Argument "engine_version" Text)
             (\s a -> s { _engine_version = a } :: RdsClusterResource)

instance HasFinalSnapshotIdentifier RdsClusterResource Text where
    finalSnapshotIdentifier =
        lens (_final_snapshot_identifier :: RdsClusterResource -> TF.Argument "final_snapshot_identifier" Text)
             (\s a -> s { _final_snapshot_identifier = a } :: RdsClusterResource)

instance HasIamDatabaseAuthenticationEnabled RdsClusterResource TF.Bool where
    iamDatabaseAuthenticationEnabled =
        lens (_iam_database_authentication_enabled :: RdsClusterResource -> TF.Argument "iam_database_authentication_enabled" TF.Bool)
             (\s a -> s { _iam_database_authentication_enabled = a } :: RdsClusterResource)

instance HasIamRoles RdsClusterResource Text where
    iamRoles =
        lens (_iam_roles :: RdsClusterResource -> TF.Argument "iam_roles" Text)
             (\s a -> s { _iam_roles = a } :: RdsClusterResource)

instance HasKmsKeyId RdsClusterResource Text where
    kmsKeyId =
        lens (_kms_key_id :: RdsClusterResource -> TF.Argument "kms_key_id" Text)
             (\s a -> s { _kms_key_id = a } :: RdsClusterResource)

instance HasMasterPassword RdsClusterResource Text where
    masterPassword =
        lens (_master_password :: RdsClusterResource -> TF.Argument "master_password" Text)
             (\s a -> s { _master_password = a } :: RdsClusterResource)

instance HasMasterUsername RdsClusterResource Text where
    masterUsername =
        lens (_master_username :: RdsClusterResource -> TF.Argument "master_username" Text)
             (\s a -> s { _master_username = a } :: RdsClusterResource)

instance HasPort RdsClusterResource Text where
    port =
        lens (_port :: RdsClusterResource -> TF.Argument "port" Text)
             (\s a -> s { _port = a } :: RdsClusterResource)

instance HasPreferredBackupWindow RdsClusterResource Text where
    preferredBackupWindow =
        lens (_preferred_backup_window :: RdsClusterResource -> TF.Argument "preferred_backup_window" Text)
             (\s a -> s { _preferred_backup_window = a } :: RdsClusterResource)

instance HasPreferredMaintenanceWindow RdsClusterResource Text where
    preferredMaintenanceWindow =
        lens (_preferred_maintenance_window :: RdsClusterResource -> TF.Argument "preferred_maintenance_window" Text)
             (\s a -> s { _preferred_maintenance_window = a } :: RdsClusterResource)

instance HasSkipFinalSnapshot RdsClusterResource Text where
    skipFinalSnapshot =
        lens (_skip_final_snapshot :: RdsClusterResource -> TF.Argument "skip_final_snapshot" Text)
             (\s a -> s { _skip_final_snapshot = a } :: RdsClusterResource)

instance HasSnapshotIdentifier RdsClusterResource Text where
    snapshotIdentifier =
        lens (_snapshot_identifier :: RdsClusterResource -> TF.Argument "snapshot_identifier" Text)
             (\s a -> s { _snapshot_identifier = a } :: RdsClusterResource)

instance HasStorageEncrypted RdsClusterResource Text where
    storageEncrypted =
        lens (_storage_encrypted :: RdsClusterResource -> TF.Argument "storage_encrypted" Text)
             (\s a -> s { _storage_encrypted = a } :: RdsClusterResource)

instance HasVpcSecurityGroupIds RdsClusterResource Text where
    vpcSecurityGroupIds =
        lens (_vpc_security_group_ids :: RdsClusterResource -> TF.Argument "vpc_security_group_ids" Text)
             (\s a -> s { _vpc_security_group_ids = a } :: RdsClusterResource)

instance HasComputedAllocatedStorage RdsClusterResource Text where
    computedAllocatedStorage =
        to (\_  -> TF.Compute "allocated_storage")

instance HasComputedAvailabilityZones RdsClusterResource Text where
    computedAvailabilityZones =
        to (\_  -> TF.Compute "availability_zones")

instance HasComputedBackupRetentionPeriod RdsClusterResource Text where
    computedBackupRetentionPeriod =
        to (\_  -> TF.Compute "backup_retention_period")

instance HasComputedClusterIdentifier RdsClusterResource Text where
    computedClusterIdentifier =
        to (\_  -> TF.Compute "cluster_identifier")

instance HasComputedClusterMembers RdsClusterResource Text where
    computedClusterMembers =
        to (\_  -> TF.Compute "cluster_members")

instance HasComputedClusterResourceId RdsClusterResource Text where
    computedClusterResourceId =
        to (\_  -> TF.Compute "cluster_resource_id")

instance HasComputedDatabaseName RdsClusterResource Text where
    computedDatabaseName =
        to (\_  -> TF.Compute "database_name")

instance HasComputedEndpoint RdsClusterResource Text where
    computedEndpoint =
        to (\_  -> TF.Compute "endpoint")

instance HasComputedEngine RdsClusterResource Text where
    computedEngine =
        to (\_  -> TF.Compute "engine")

instance HasComputedEngineVersion RdsClusterResource Text where
    computedEngineVersion =
        to (\_  -> TF.Compute "engine_version")

instance HasComputedId RdsClusterResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedMaintenanceWindow RdsClusterResource Text where
    computedMaintenanceWindow =
        to (\_  -> TF.Compute "maintenance_window")

instance HasComputedMasterUsername RdsClusterResource Text where
    computedMasterUsername =
        to (\_  -> TF.Compute "master_username")

instance HasComputedPort RdsClusterResource Text where
    computedPort =
        to (\_  -> TF.Compute "port")

instance HasComputedPreferredBackupWindow RdsClusterResource Text where
    computedPreferredBackupWindow =
        to (\_  -> TF.Compute "preferred_backup_window")

instance HasComputedPreferredMaintenanceWindow RdsClusterResource Text where
    computedPreferredMaintenanceWindow =
        to (\_  -> TF.Compute "preferred_maintenance_window")

instance HasComputedReaderEndpoint RdsClusterResource Text where
    computedReaderEndpoint =
        to (\_  -> TF.Compute "reader_endpoint")

instance HasComputedReplicationSourceIdentifier RdsClusterResource Text where
    computedReplicationSourceIdentifier =
        to (\_  -> TF.Compute "replication_source_identifier")

instance HasComputedStatus RdsClusterResource Text where
    computedStatus =
        to (\_  -> TF.Compute "status")

instance HasComputedStorageEncrypted RdsClusterResource Text where
    computedStorageEncrypted =
        to (\_  -> TF.Compute "storage_encrypted")

rdsClusterResource :: TF.Resource TF.AWS RdsClusterResource
rdsClusterResource =
    TF.newResource "aws_rds_cluster" $
        RdsClusterResource {
            _apply_immediately = TF.Nil
            , _availability_zones = TF.Nil
            , _backup_retention_period = TF.Nil
            , _cluster_identifier = TF.Nil
            , _cluster_identifier_prefix = TF.Nil
            , _database_name = TF.Nil
            , _db_cluster_parameter_group_name = TF.Nil
            , _db_subnet_group_name = TF.Nil
            , _engine = TF.Nil
            , _engine_version = TF.Nil
            , _final_snapshot_identifier = TF.Nil
            , _iam_database_authentication_enabled = TF.Nil
            , _iam_roles = TF.Nil
            , _kms_key_id = TF.Nil
            , _master_password = TF.Nil
            , _master_username = TF.Nil
            , _port = TF.Nil
            , _preferred_backup_window = TF.Nil
            , _preferred_maintenance_window = TF.Nil
            , _skip_final_snapshot = TF.Nil
            , _snapshot_identifier = TF.Nil
            , _storage_encrypted = TF.Nil
            , _vpc_security_group_ids = TF.Nil
            }

{- | The @aws_redshift_cluster@ AWS resource.

Provides a Redshift Cluster Resource. ~> Note: All arguments including the
username and password will be stored in the raw state as plain-text.
</docs/state/sensitive-data.html> .
-}
data RedshiftClusterResource = RedshiftClusterResource {
      _allow_version_upgrade :: !(TF.Argument "allow_version_upgrade" Text)
    {- ^ (Optional) If true , major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. Default is true -}
    , _automated_snapshot_retention_period :: !(TF.Argument "automated_snapshot_retention_period" Text)
    {- ^ (Optional) The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with create-cluster-snapshot. Default is 1. -}
    , _availability_zone :: !(TF.Argument "availability_zone" TF.Zone)
    {- ^ (Optional) The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency. -}
    , _cluster_identifier :: !(TF.Argument "cluster_identifier" Text)
    {- ^ (Required) The Cluster Identifier. Must be a lower case string. -}
    , _cluster_parameter_group_name :: !(TF.Argument "cluster_parameter_group_name" Text)
    {- ^ (Optional) The name of the parameter group to be associated with this cluster. -}
    , _cluster_security_groups :: !(TF.Argument "cluster_security_groups" Text)
    {- ^ (Optional) A list of security groups to be associated with this cluster. -}
    , _cluster_subnet_group_name :: !(TF.Argument "cluster_subnet_group_name" Text)
    {- ^ (Optional) The name of a cluster subnet group to be associated with this cluster. If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC). -}
    , _cluster_type :: !(TF.Argument "cluster_type" Text)
    {- ^ (Optional) The cluster type to use. Either @single-node@ or @multi-node@ . -}
    , _cluster_version :: !(TF.Argument "cluster_version" Text)
    {- ^ (Optional) The version of the Amazon Redshift engine software that you want to deploy on the cluster. The version selected runs on all the nodes in the cluster. -}
    , _database_name :: !(TF.Argument "database_name" Text)
    {- ^ (Optional) The name of the first database to be created when the cluster is created. If you do not provide a name, Amazon Redshift will create a default database called @dev@ . -}
    , _elastic_ip :: !(TF.Argument "elastic_ip" Text)
    {- ^ (Optional) The Elastic IP (EIP) address for the cluster. -}
    , _encrypted :: !(TF.Argument "encrypted" Text)
    {- ^ (Optional) If true , the data in the cluster is encrypted at rest. -}
    , _enhanced_vpc_routing :: !(TF.Argument "enhanced_vpc_routing" Text)
    {- ^ (Optional) If true , enhanced VPC routing is enabled. -}
    , _final_snapshot_identifier :: !(TF.Argument "final_snapshot_identifier" Text)
    {- ^ (Optional) The identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, @skip_final_snapshot@ must be false. -}
    , _iam_roles :: !(TF.Argument "iam_roles" Text)
    {- ^ (Optional) A list of IAM Role ARNs to associate with the cluster. A Maximum of 10 can be associated to the cluster at any time. -}
    , _kms_key_id :: !(TF.Argument "kms_key_id" Text)
    {- ^ (Optional) The ARN for the KMS encryption key. When specifying @kms_key_id@ , @encrypted@ needs to be set to true. -}
    , _logging :: !(TF.Argument "logging" Text)
    {- ^ (Optional) Logging, documented below. -}
    , _master_password :: !(TF.Argument "master_password" Text)
    {- ^ (Required unless a @snapshot_identifier@ is provided) Password for the master DB user. Note that this may show up in logs, and it will be stored in the state file. Password must contain at least 8 chars and contain at least one uppercase letter, one lowercase letter, and one number. -}
    , _master_username :: !(TF.Argument "master_username" Text)
    {- ^ (Required unless a @snapshot_identifier@ is provided) Username for the master DB user. -}
    , _node_type :: !(TF.Argument "node_type" Text)
    {- ^ (Required) The node type to be provisioned for the cluster. -}
    , _number_of_nodes :: !(TF.Argument "number_of_nodes" Text)
    {- ^ (Optional) The number of compute nodes in the cluster. This parameter is required when the ClusterType parameter is specified as multi-node. Default is 1. -}
    , _owner_account :: !(TF.Argument "owner_account" Text)
    {- ^ (Optional) The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot. -}
    , _port :: !(TF.Argument "port" Text)
    {- ^ (Optional) The port number on which the cluster accepts incoming connections. The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections. Default port is 5439. -}
    , _preferred_maintenance_window :: !(TF.Argument "preferred_maintenance_window" Text)
    {- ^ (Optional) The weekly time range (in UTC) during which automated cluster maintenance can occur. Format: ddd:hh24:mi-ddd:hh24:mi -}
    , _publicly_accessible :: !(TF.Argument "publicly_accessible" Text)
    {- ^ (Optional) If true, the cluster can be accessed from a public network. Default is @true@ . -}
    , _skip_final_snapshot :: !(TF.Argument "skip_final_snapshot" Text)
    {- ^ (Optional) Determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If true , a final cluster snapshot is not created. If false , a final cluster snapshot is created before the cluster is deleted. Default is false. -}
    , _snapshot_cluster_identifier :: !(TF.Argument "snapshot_cluster_identifier" Text)
    {- ^ (Optional) The name of the cluster the source snapshot was created from. -}
    , _snapshot_copy :: !(TF.Argument "snapshot_copy" Text)
    {- ^ (Optional) Configuration of automatic copy of snapshots from one region to another. Documented below. -}
    , _snapshot_identifier :: !(TF.Argument "snapshot_identifier" Text)
    {- ^ (Optional) The name of the snapshot from which to create the new cluster. -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    , _vpc_security_group_ids :: !(TF.Argument "vpc_security_group_ids" Text)
    {- ^ (Optional) A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster. -}
    } deriving (Show, Eq)

instance TF.ToHCL RedshiftClusterResource where
    toHCL RedshiftClusterResource{..} = TF.block $ catMaybes
        [ TF.argument _allow_version_upgrade
        , TF.argument _automated_snapshot_retention_period
        , TF.argument _availability_zone
        , TF.argument _cluster_identifier
        , TF.argument _cluster_parameter_group_name
        , TF.argument _cluster_security_groups
        , TF.argument _cluster_subnet_group_name
        , TF.argument _cluster_type
        , TF.argument _cluster_version
        , TF.argument _database_name
        , TF.argument _elastic_ip
        , TF.argument _encrypted
        , TF.argument _enhanced_vpc_routing
        , TF.argument _final_snapshot_identifier
        , TF.argument _iam_roles
        , TF.argument _kms_key_id
        , TF.argument _logging
        , TF.argument _master_password
        , TF.argument _master_username
        , TF.argument _node_type
        , TF.argument _number_of_nodes
        , TF.argument _owner_account
        , TF.argument _port
        , TF.argument _preferred_maintenance_window
        , TF.argument _publicly_accessible
        , TF.argument _skip_final_snapshot
        , TF.argument _snapshot_cluster_identifier
        , TF.argument _snapshot_copy
        , TF.argument _snapshot_identifier
        , TF.argument _tags
        , TF.argument _vpc_security_group_ids
        ]

instance HasAllowVersionUpgrade RedshiftClusterResource Text where
    allowVersionUpgrade =
        lens (_allow_version_upgrade :: RedshiftClusterResource -> TF.Argument "allow_version_upgrade" Text)
             (\s a -> s { _allow_version_upgrade = a } :: RedshiftClusterResource)

instance HasAutomatedSnapshotRetentionPeriod RedshiftClusterResource Text where
    automatedSnapshotRetentionPeriod =
        lens (_automated_snapshot_retention_period :: RedshiftClusterResource -> TF.Argument "automated_snapshot_retention_period" Text)
             (\s a -> s { _automated_snapshot_retention_period = a } :: RedshiftClusterResource)

instance HasAvailabilityZone RedshiftClusterResource TF.Zone where
    availabilityZone =
        lens (_availability_zone :: RedshiftClusterResource -> TF.Argument "availability_zone" TF.Zone)
             (\s a -> s { _availability_zone = a } :: RedshiftClusterResource)

instance HasClusterIdentifier RedshiftClusterResource Text where
    clusterIdentifier =
        lens (_cluster_identifier :: RedshiftClusterResource -> TF.Argument "cluster_identifier" Text)
             (\s a -> s { _cluster_identifier = a } :: RedshiftClusterResource)

instance HasClusterParameterGroupName RedshiftClusterResource Text where
    clusterParameterGroupName =
        lens (_cluster_parameter_group_name :: RedshiftClusterResource -> TF.Argument "cluster_parameter_group_name" Text)
             (\s a -> s { _cluster_parameter_group_name = a } :: RedshiftClusterResource)

instance HasClusterSecurityGroups RedshiftClusterResource Text where
    clusterSecurityGroups =
        lens (_cluster_security_groups :: RedshiftClusterResource -> TF.Argument "cluster_security_groups" Text)
             (\s a -> s { _cluster_security_groups = a } :: RedshiftClusterResource)

instance HasClusterSubnetGroupName RedshiftClusterResource Text where
    clusterSubnetGroupName =
        lens (_cluster_subnet_group_name :: RedshiftClusterResource -> TF.Argument "cluster_subnet_group_name" Text)
             (\s a -> s { _cluster_subnet_group_name = a } :: RedshiftClusterResource)

instance HasClusterType RedshiftClusterResource Text where
    clusterType =
        lens (_cluster_type :: RedshiftClusterResource -> TF.Argument "cluster_type" Text)
             (\s a -> s { _cluster_type = a } :: RedshiftClusterResource)

instance HasClusterVersion RedshiftClusterResource Text where
    clusterVersion =
        lens (_cluster_version :: RedshiftClusterResource -> TF.Argument "cluster_version" Text)
             (\s a -> s { _cluster_version = a } :: RedshiftClusterResource)

instance HasDatabaseName RedshiftClusterResource Text where
    databaseName =
        lens (_database_name :: RedshiftClusterResource -> TF.Argument "database_name" Text)
             (\s a -> s { _database_name = a } :: RedshiftClusterResource)

instance HasElasticIp RedshiftClusterResource Text where
    elasticIp =
        lens (_elastic_ip :: RedshiftClusterResource -> TF.Argument "elastic_ip" Text)
             (\s a -> s { _elastic_ip = a } :: RedshiftClusterResource)

instance HasEncrypted RedshiftClusterResource Text where
    encrypted =
        lens (_encrypted :: RedshiftClusterResource -> TF.Argument "encrypted" Text)
             (\s a -> s { _encrypted = a } :: RedshiftClusterResource)

instance HasEnhancedVpcRouting RedshiftClusterResource Text where
    enhancedVpcRouting =
        lens (_enhanced_vpc_routing :: RedshiftClusterResource -> TF.Argument "enhanced_vpc_routing" Text)
             (\s a -> s { _enhanced_vpc_routing = a } :: RedshiftClusterResource)

instance HasFinalSnapshotIdentifier RedshiftClusterResource Text where
    finalSnapshotIdentifier =
        lens (_final_snapshot_identifier :: RedshiftClusterResource -> TF.Argument "final_snapshot_identifier" Text)
             (\s a -> s { _final_snapshot_identifier = a } :: RedshiftClusterResource)

instance HasIamRoles RedshiftClusterResource Text where
    iamRoles =
        lens (_iam_roles :: RedshiftClusterResource -> TF.Argument "iam_roles" Text)
             (\s a -> s { _iam_roles = a } :: RedshiftClusterResource)

instance HasKmsKeyId RedshiftClusterResource Text where
    kmsKeyId =
        lens (_kms_key_id :: RedshiftClusterResource -> TF.Argument "kms_key_id" Text)
             (\s a -> s { _kms_key_id = a } :: RedshiftClusterResource)

instance HasLogging RedshiftClusterResource Text where
    logging =
        lens (_logging :: RedshiftClusterResource -> TF.Argument "logging" Text)
             (\s a -> s { _logging = a } :: RedshiftClusterResource)

instance HasMasterPassword RedshiftClusterResource Text where
    masterPassword =
        lens (_master_password :: RedshiftClusterResource -> TF.Argument "master_password" Text)
             (\s a -> s { _master_password = a } :: RedshiftClusterResource)

instance HasMasterUsername RedshiftClusterResource Text where
    masterUsername =
        lens (_master_username :: RedshiftClusterResource -> TF.Argument "master_username" Text)
             (\s a -> s { _master_username = a } :: RedshiftClusterResource)

instance HasNodeType RedshiftClusterResource Text where
    nodeType =
        lens (_node_type :: RedshiftClusterResource -> TF.Argument "node_type" Text)
             (\s a -> s { _node_type = a } :: RedshiftClusterResource)

instance HasNumberOfNodes RedshiftClusterResource Text where
    numberOfNodes =
        lens (_number_of_nodes :: RedshiftClusterResource -> TF.Argument "number_of_nodes" Text)
             (\s a -> s { _number_of_nodes = a } :: RedshiftClusterResource)

instance HasOwnerAccount RedshiftClusterResource Text where
    ownerAccount =
        lens (_owner_account :: RedshiftClusterResource -> TF.Argument "owner_account" Text)
             (\s a -> s { _owner_account = a } :: RedshiftClusterResource)

instance HasPort RedshiftClusterResource Text where
    port =
        lens (_port :: RedshiftClusterResource -> TF.Argument "port" Text)
             (\s a -> s { _port = a } :: RedshiftClusterResource)

instance HasPreferredMaintenanceWindow RedshiftClusterResource Text where
    preferredMaintenanceWindow =
        lens (_preferred_maintenance_window :: RedshiftClusterResource -> TF.Argument "preferred_maintenance_window" Text)
             (\s a -> s { _preferred_maintenance_window = a } :: RedshiftClusterResource)

instance HasPubliclyAccessible RedshiftClusterResource Text where
    publiclyAccessible =
        lens (_publicly_accessible :: RedshiftClusterResource -> TF.Argument "publicly_accessible" Text)
             (\s a -> s { _publicly_accessible = a } :: RedshiftClusterResource)

instance HasSkipFinalSnapshot RedshiftClusterResource Text where
    skipFinalSnapshot =
        lens (_skip_final_snapshot :: RedshiftClusterResource -> TF.Argument "skip_final_snapshot" Text)
             (\s a -> s { _skip_final_snapshot = a } :: RedshiftClusterResource)

instance HasSnapshotClusterIdentifier RedshiftClusterResource Text where
    snapshotClusterIdentifier =
        lens (_snapshot_cluster_identifier :: RedshiftClusterResource -> TF.Argument "snapshot_cluster_identifier" Text)
             (\s a -> s { _snapshot_cluster_identifier = a } :: RedshiftClusterResource)

instance HasSnapshotCopy RedshiftClusterResource Text where
    snapshotCopy =
        lens (_snapshot_copy :: RedshiftClusterResource -> TF.Argument "snapshot_copy" Text)
             (\s a -> s { _snapshot_copy = a } :: RedshiftClusterResource)

instance HasSnapshotIdentifier RedshiftClusterResource Text where
    snapshotIdentifier =
        lens (_snapshot_identifier :: RedshiftClusterResource -> TF.Argument "snapshot_identifier" Text)
             (\s a -> s { _snapshot_identifier = a } :: RedshiftClusterResource)

instance HasTags RedshiftClusterResource TF.Tags where
    tags =
        lens (_tags :: RedshiftClusterResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: RedshiftClusterResource)

instance HasVpcSecurityGroupIds RedshiftClusterResource Text where
    vpcSecurityGroupIds =
        lens (_vpc_security_group_ids :: RedshiftClusterResource -> TF.Argument "vpc_security_group_ids" Text)
             (\s a -> s { _vpc_security_group_ids = a } :: RedshiftClusterResource)

redshiftClusterResource :: TF.Resource TF.AWS RedshiftClusterResource
redshiftClusterResource =
    TF.newResource "aws_redshift_cluster" $
        RedshiftClusterResource {
            _allow_version_upgrade = TF.Nil
            , _automated_snapshot_retention_period = TF.Nil
            , _availability_zone = TF.Nil
            , _cluster_identifier = TF.Nil
            , _cluster_parameter_group_name = TF.Nil
            , _cluster_security_groups = TF.Nil
            , _cluster_subnet_group_name = TF.Nil
            , _cluster_type = TF.Nil
            , _cluster_version = TF.Nil
            , _database_name = TF.Nil
            , _elastic_ip = TF.Nil
            , _encrypted = TF.Nil
            , _enhanced_vpc_routing = TF.Nil
            , _final_snapshot_identifier = TF.Nil
            , _iam_roles = TF.Nil
            , _kms_key_id = TF.Nil
            , _logging = TF.Nil
            , _master_password = TF.Nil
            , _master_username = TF.Nil
            , _node_type = TF.Nil
            , _number_of_nodes = TF.Nil
            , _owner_account = TF.Nil
            , _port = TF.Nil
            , _preferred_maintenance_window = TF.Nil
            , _publicly_accessible = TF.Nil
            , _skip_final_snapshot = TF.Nil
            , _snapshot_cluster_identifier = TF.Nil
            , _snapshot_copy = TF.Nil
            , _snapshot_identifier = TF.Nil
            , _tags = TF.Nil
            , _vpc_security_group_ids = TF.Nil
            }

{- | The @aws_redshift_parameter_group@ AWS resource.

Provides a Redshift Cluster parameter group resource.
-}
data RedshiftParameterGroupResource = RedshiftParameterGroupResource {
      _description :: !(TF.Argument "description" Text)
    {- ^ (Optional) The description of the Redshift parameter group. Defaults to "Managed by Terraform". -}
    , _family' :: !(TF.Argument "family" Text)
    {- ^ (Required) The family of the Redshift parameter group. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the Redshift parameter group. -}
    , _parameter :: !(TF.Argument "parameter" Text)
    {- ^ (Optional) A list of Redshift parameters to apply. -}
    } deriving (Show, Eq)

instance TF.ToHCL RedshiftParameterGroupResource where
    toHCL RedshiftParameterGroupResource{..} = TF.block $ catMaybes
        [ TF.argument _description
        , TF.argument _family'
        , TF.argument _name
        , TF.argument _parameter
        ]

instance HasDescription RedshiftParameterGroupResource Text where
    description =
        lens (_description :: RedshiftParameterGroupResource -> TF.Argument "description" Text)
             (\s a -> s { _description = a } :: RedshiftParameterGroupResource)

instance HasFamily' RedshiftParameterGroupResource Text where
    family' =
        lens (_family' :: RedshiftParameterGroupResource -> TF.Argument "family" Text)
             (\s a -> s { _family' = a } :: RedshiftParameterGroupResource)

instance HasName RedshiftParameterGroupResource Text where
    name =
        lens (_name :: RedshiftParameterGroupResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: RedshiftParameterGroupResource)

instance HasParameter RedshiftParameterGroupResource Text where
    parameter =
        lens (_parameter :: RedshiftParameterGroupResource -> TF.Argument "parameter" Text)
             (\s a -> s { _parameter = a } :: RedshiftParameterGroupResource)

instance HasComputedId RedshiftParameterGroupResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

redshiftParameterGroupResource :: TF.Resource TF.AWS RedshiftParameterGroupResource
redshiftParameterGroupResource =
    TF.newResource "aws_redshift_parameter_group" $
        RedshiftParameterGroupResource {
            _description = TF.Nil
            , _family' = TF.Nil
            , _name = TF.Nil
            , _parameter = TF.Nil
            }

{- | The @aws_redshift_security_group@ AWS resource.

Creates a new Amazon Redshift security group. You use security groups to
control access to non-VPC clusters
-}
data RedshiftSecurityGroupResource = RedshiftSecurityGroupResource {
      _description :: !(TF.Argument "description" Text)
    {- ^ (Optional) The description of the Redshift security group. Defaults to "Managed by Terraform". -}
    , _ingress :: !(TF.Argument "ingress" Text)
    {- ^ (Optional) A list of ingress rules. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the Redshift security group. -}
    } deriving (Show, Eq)

instance TF.ToHCL RedshiftSecurityGroupResource where
    toHCL RedshiftSecurityGroupResource{..} = TF.block $ catMaybes
        [ TF.argument _description
        , TF.argument _ingress
        , TF.argument _name
        ]

instance HasDescription RedshiftSecurityGroupResource Text where
    description =
        lens (_description :: RedshiftSecurityGroupResource -> TF.Argument "description" Text)
             (\s a -> s { _description = a } :: RedshiftSecurityGroupResource)

instance HasIngress RedshiftSecurityGroupResource Text where
    ingress =
        lens (_ingress :: RedshiftSecurityGroupResource -> TF.Argument "ingress" Text)
             (\s a -> s { _ingress = a } :: RedshiftSecurityGroupResource)

instance HasName RedshiftSecurityGroupResource Text where
    name =
        lens (_name :: RedshiftSecurityGroupResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: RedshiftSecurityGroupResource)

instance HasComputedId RedshiftSecurityGroupResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

redshiftSecurityGroupResource :: TF.Resource TF.AWS RedshiftSecurityGroupResource
redshiftSecurityGroupResource =
    TF.newResource "aws_redshift_security_group" $
        RedshiftSecurityGroupResource {
            _description = TF.Nil
            , _ingress = TF.Nil
            , _name = TF.Nil
            }

{- | The @aws_redshift_subnet_group@ AWS resource.

Creates a new Amazon Redshift subnet group. You must provide a list of one
or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC)
when creating Amazon Redshift subnet group.
-}
data RedshiftSubnetGroupResource = RedshiftSubnetGroupResource {
      _description :: !(TF.Argument "description" Text)
    {- ^ (Optional) The description of the Redshift Subnet group. Defaults to "Managed by Terraform". -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the Redshift Subnet group. -}
    , _subnet_ids :: !(TF.Argument "subnet_ids" Text)
    {- ^ (Required) An array of VPC subnet IDs. -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    } deriving (Show, Eq)

instance TF.ToHCL RedshiftSubnetGroupResource where
    toHCL RedshiftSubnetGroupResource{..} = TF.block $ catMaybes
        [ TF.argument _description
        , TF.argument _name
        , TF.argument _subnet_ids
        , TF.argument _tags
        ]

instance HasDescription RedshiftSubnetGroupResource Text where
    description =
        lens (_description :: RedshiftSubnetGroupResource -> TF.Argument "description" Text)
             (\s a -> s { _description = a } :: RedshiftSubnetGroupResource)

instance HasName RedshiftSubnetGroupResource Text where
    name =
        lens (_name :: RedshiftSubnetGroupResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: RedshiftSubnetGroupResource)

instance HasSubnetIds RedshiftSubnetGroupResource Text where
    subnetIds =
        lens (_subnet_ids :: RedshiftSubnetGroupResource -> TF.Argument "subnet_ids" Text)
             (\s a -> s { _subnet_ids = a } :: RedshiftSubnetGroupResource)

instance HasTags RedshiftSubnetGroupResource TF.Tags where
    tags =
        lens (_tags :: RedshiftSubnetGroupResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: RedshiftSubnetGroupResource)

instance HasComputedId RedshiftSubnetGroupResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

redshiftSubnetGroupResource :: TF.Resource TF.AWS RedshiftSubnetGroupResource
redshiftSubnetGroupResource =
    TF.newResource "aws_redshift_subnet_group" $
        RedshiftSubnetGroupResource {
            _description = TF.Nil
            , _name = TF.Nil
            , _subnet_ids = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_route53_delegation_set@ AWS resource.

Provides a
<https://docs.aws.amazon.com/Route53/latest/APIReference/actions-on-reusable-delegation-sets.html>
resource.
-}
data Route53DelegationSetResource = Route53DelegationSetResource {
      _reference_name :: !(TF.Argument "reference_name" Text)
    {- ^ (Optional) This is a reference name used in Caller Reference (helpful for identifying single delegation set amongst others) -}
    } deriving (Show, Eq)

instance TF.ToHCL Route53DelegationSetResource where
    toHCL Route53DelegationSetResource{..} = TF.block $ catMaybes
        [ TF.argument _reference_name
        ]

instance HasReferenceName Route53DelegationSetResource Text where
    referenceName =
        lens (_reference_name :: Route53DelegationSetResource -> TF.Argument "reference_name" Text)
             (\s a -> s { _reference_name = a } :: Route53DelegationSetResource)

instance HasComputedId Route53DelegationSetResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedNameServers Route53DelegationSetResource Text where
    computedNameServers =
        to (\_  -> TF.Compute "name_servers")

route53DelegationSetResource :: TF.Resource TF.AWS Route53DelegationSetResource
route53DelegationSetResource =
    TF.newResource "aws_route53_delegation_set" $
        Route53DelegationSetResource {
            _reference_name = TF.Nil
            }

{- | The @aws_route53_health_check@ AWS resource.

Provides a Route53 health check.
-}
data Route53HealthCheckResource = Route53HealthCheckResource {
      _child_health_threshold :: !(TF.Argument "child_health_threshold" Text)
    {- ^ (Optional) The minimum number of child health checks that must be healthy for Route 53 to consider the parent health check to be healthy. Valid values are integers between 0 and 256, inclusive -}
    , _child_healthchecks :: !(TF.Argument "child_healthchecks" Text)
    {- ^ (Optional) For a specified parent health check, a list of HealthCheckId values for the associated child health checks. -}
    , _cloudwatch_alarm_name :: !(TF.Argument "cloudwatch_alarm_name" Text)
    {- ^ (Optional) The name of the CloudWatch alarm. -}
    , _cloudwatch_alarm_region :: !(TF.Argument "cloudwatch_alarm_region" TF.Region)
    {- ^ (Optional) The CloudWatchRegion that the CloudWatch alarm was created in. -}
    , _enable_sni :: !(TF.Argument "enable_sni" TF.Bool)
    {- ^ (Optional) A boolean value that indicates whether Route53 should send the @fqdn@ to the endpoint when performing the health check. This defaults to AWS' defaults: when the @type@ is "HTTPS" @enable_sni@ defaults to @true@ , when @type@ is anything else @enable_sni@ defaults to @false@ . -}
    , _failure_threshold :: !(TF.Argument "failure_threshold" Text)
    {- ^ (Required) The number of consecutive health checks that an endpoint must pass or fail. -}
    , _fqdn :: !(TF.Argument "fqdn" Text)
    {- ^ (Optional) The fully qualified domain name of the endpoint to be checked. -}
    , _insufficient_data_health_status :: !(TF.Argument "insufficient_data_health_status" Text)
    {- ^ (Optional) The status of the health check when CloudWatch has insufficient data about the state of associated alarm. Valid values are @Healthy@ , @Unhealthy@ and @LastKnownStatus@ . -}
    , _invert_healthcheck :: !(TF.Argument "invert_healthcheck" Text)
    {- ^ (Optional) A boolean value that indicates whether the status of health check should be inverted. For example, if a health check is healthy but Inverted is True , then Route 53 considers the health check to be unhealthy. -}
    , _ip_address :: !(TF.Argument "ip_address" Text)
    {- ^ (Optional) The IP address of the endpoint to be checked. -}
    , _measure_latency :: !(TF.Argument "measure_latency" Text)
    {- ^ (Optional) A Boolean value that indicates whether you want Route 53 to measure the latency between health checkers in multiple AWS regions and your endpoint and to display CloudWatch latency graphs in the Route 53 console. -}
    , _port :: !(TF.Argument "port" Text)
    {- ^ (Optional) The port of the endpoint to be checked. -}
    , _reference_name :: !(TF.Argument "reference_name" Text)
    {- ^ (Optional) This is a reference name used in Caller Reference (helpful for identifying single health_check set amongst others) -}
    , _regions :: !(TF.Argument "regions" Text)
    {- ^ (Optional) A list of AWS regions that you want Amazon Route 53 health checkers to check the specified endpoint from. -}
    , _request_interval :: !(TF.Argument "request_interval" Text)
    {- ^ (Required) The number of seconds between the time that Amazon Route 53 gets a response from your endpoint and the time that it sends the next health-check request. -}
    , _resource_path :: !(TF.Argument "resource_path" Text)
    {- ^ (Optional) The path that you want Amazon Route 53 to request when performing health checks. -}
    , _search_string :: !(TF.Argument "search_string" Text)
    {- ^ (Optional) String searched in the first 5120 bytes of the response body for check to be considered healthy. -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the health check. -}
    , _type' :: !(TF.Argument "type" Text)
    {- ^ (Required) The protocol to use when performing health checks. Valid values are @HTTP@ , @HTTPS@ , @HTTP_STR_MATCH@ , @HTTPS_STR_MATCH@ , @TCP@ , @CALCULATED@ and @CLOUDWATCH_METRIC@ . -}
    } deriving (Show, Eq)

instance TF.ToHCL Route53HealthCheckResource where
    toHCL Route53HealthCheckResource{..} = TF.block $ catMaybes
        [ TF.argument _child_health_threshold
        , TF.argument _child_healthchecks
        , TF.argument _cloudwatch_alarm_name
        , TF.argument _cloudwatch_alarm_region
        , TF.argument _enable_sni
        , TF.argument _failure_threshold
        , TF.argument _fqdn
        , TF.argument _insufficient_data_health_status
        , TF.argument _invert_healthcheck
        , TF.argument _ip_address
        , TF.argument _measure_latency
        , TF.argument _port
        , TF.argument _reference_name
        , TF.argument _regions
        , TF.argument _request_interval
        , TF.argument _resource_path
        , TF.argument _search_string
        , TF.argument _tags
        , TF.argument _type'
        ]

instance HasChildHealthThreshold Route53HealthCheckResource Text where
    childHealthThreshold =
        lens (_child_health_threshold :: Route53HealthCheckResource -> TF.Argument "child_health_threshold" Text)
             (\s a -> s { _child_health_threshold = a } :: Route53HealthCheckResource)

instance HasChildHealthchecks Route53HealthCheckResource Text where
    childHealthchecks =
        lens (_child_healthchecks :: Route53HealthCheckResource -> TF.Argument "child_healthchecks" Text)
             (\s a -> s { _child_healthchecks = a } :: Route53HealthCheckResource)

instance HasCloudwatchAlarmName Route53HealthCheckResource Text where
    cloudwatchAlarmName =
        lens (_cloudwatch_alarm_name :: Route53HealthCheckResource -> TF.Argument "cloudwatch_alarm_name" Text)
             (\s a -> s { _cloudwatch_alarm_name = a } :: Route53HealthCheckResource)

instance HasCloudwatchAlarmRegion Route53HealthCheckResource TF.Region where
    cloudwatchAlarmRegion =
        lens (_cloudwatch_alarm_region :: Route53HealthCheckResource -> TF.Argument "cloudwatch_alarm_region" TF.Region)
             (\s a -> s { _cloudwatch_alarm_region = a } :: Route53HealthCheckResource)

instance HasEnableSni Route53HealthCheckResource TF.Bool where
    enableSni =
        lens (_enable_sni :: Route53HealthCheckResource -> TF.Argument "enable_sni" TF.Bool)
             (\s a -> s { _enable_sni = a } :: Route53HealthCheckResource)

instance HasFailureThreshold Route53HealthCheckResource Text where
    failureThreshold =
        lens (_failure_threshold :: Route53HealthCheckResource -> TF.Argument "failure_threshold" Text)
             (\s a -> s { _failure_threshold = a } :: Route53HealthCheckResource)

instance HasFqdn Route53HealthCheckResource Text where
    fqdn =
        lens (_fqdn :: Route53HealthCheckResource -> TF.Argument "fqdn" Text)
             (\s a -> s { _fqdn = a } :: Route53HealthCheckResource)

instance HasInsufficientDataHealthStatus Route53HealthCheckResource Text where
    insufficientDataHealthStatus =
        lens (_insufficient_data_health_status :: Route53HealthCheckResource -> TF.Argument "insufficient_data_health_status" Text)
             (\s a -> s { _insufficient_data_health_status = a } :: Route53HealthCheckResource)

instance HasInvertHealthcheck Route53HealthCheckResource Text where
    invertHealthcheck =
        lens (_invert_healthcheck :: Route53HealthCheckResource -> TF.Argument "invert_healthcheck" Text)
             (\s a -> s { _invert_healthcheck = a } :: Route53HealthCheckResource)

instance HasIpAddress Route53HealthCheckResource Text where
    ipAddress =
        lens (_ip_address :: Route53HealthCheckResource -> TF.Argument "ip_address" Text)
             (\s a -> s { _ip_address = a } :: Route53HealthCheckResource)

instance HasMeasureLatency Route53HealthCheckResource Text where
    measureLatency =
        lens (_measure_latency :: Route53HealthCheckResource -> TF.Argument "measure_latency" Text)
             (\s a -> s { _measure_latency = a } :: Route53HealthCheckResource)

instance HasPort Route53HealthCheckResource Text where
    port =
        lens (_port :: Route53HealthCheckResource -> TF.Argument "port" Text)
             (\s a -> s { _port = a } :: Route53HealthCheckResource)

instance HasReferenceName Route53HealthCheckResource Text where
    referenceName =
        lens (_reference_name :: Route53HealthCheckResource -> TF.Argument "reference_name" Text)
             (\s a -> s { _reference_name = a } :: Route53HealthCheckResource)

instance HasRegions Route53HealthCheckResource Text where
    regions =
        lens (_regions :: Route53HealthCheckResource -> TF.Argument "regions" Text)
             (\s a -> s { _regions = a } :: Route53HealthCheckResource)

instance HasRequestInterval Route53HealthCheckResource Text where
    requestInterval =
        lens (_request_interval :: Route53HealthCheckResource -> TF.Argument "request_interval" Text)
             (\s a -> s { _request_interval = a } :: Route53HealthCheckResource)

instance HasResourcePath Route53HealthCheckResource Text where
    resourcePath =
        lens (_resource_path :: Route53HealthCheckResource -> TF.Argument "resource_path" Text)
             (\s a -> s { _resource_path = a } :: Route53HealthCheckResource)

instance HasSearchString Route53HealthCheckResource Text where
    searchString =
        lens (_search_string :: Route53HealthCheckResource -> TF.Argument "search_string" Text)
             (\s a -> s { _search_string = a } :: Route53HealthCheckResource)

instance HasTags Route53HealthCheckResource TF.Tags where
    tags =
        lens (_tags :: Route53HealthCheckResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: Route53HealthCheckResource)

instance HasType' Route53HealthCheckResource Text where
    type' =
        lens (_type' :: Route53HealthCheckResource -> TF.Argument "type" Text)
             (\s a -> s { _type' = a } :: Route53HealthCheckResource)

route53HealthCheckResource :: TF.Resource TF.AWS Route53HealthCheckResource
route53HealthCheckResource =
    TF.newResource "aws_route53_health_check" $
        Route53HealthCheckResource {
            _child_health_threshold = TF.Nil
            , _child_healthchecks = TF.Nil
            , _cloudwatch_alarm_name = TF.Nil
            , _cloudwatch_alarm_region = TF.Nil
            , _enable_sni = TF.Nil
            , _failure_threshold = TF.Nil
            , _fqdn = TF.Nil
            , _insufficient_data_health_status = TF.Nil
            , _invert_healthcheck = TF.Nil
            , _ip_address = TF.Nil
            , _measure_latency = TF.Nil
            , _port = TF.Nil
            , _reference_name = TF.Nil
            , _regions = TF.Nil
            , _request_interval = TF.Nil
            , _resource_path = TF.Nil
            , _search_string = TF.Nil
            , _tags = TF.Nil
            , _type' = TF.Nil
            }

{- | The @aws_route53_query_log@ AWS resource.

Provides a Route53 query logging configuration resource. ~> NOTE: There are
restrictions on the configuration of query logging. Notably, the CloudWatch
log group must be in the @us-east-1@ region, a permissive CloudWatch log
resource policy must be in place, and the Route53 hosted zone must be
public. See
<https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/query-logs.html?console_help=true#query-logs-configuring>
for additional details.
-}
data Route53QueryLogResource = Route53QueryLogResource {
      _cloudwatch_log_group_arn :: !(TF.Argument "cloudwatch_log_group_arn" Text)
    {- ^ (Required) CloudWatch log group ARN to send query logs. -}
    , _zone_id :: !(TF.Argument "zone_id" Text)
    {- ^ (Required) Route53 hosted zone ID to enable query logs. -}
    } deriving (Show, Eq)

instance TF.ToHCL Route53QueryLogResource where
    toHCL Route53QueryLogResource{..} = TF.block $ catMaybes
        [ TF.argument _cloudwatch_log_group_arn
        , TF.argument _zone_id
        ]

instance HasCloudwatchLogGroupArn Route53QueryLogResource Text where
    cloudwatchLogGroupArn =
        lens (_cloudwatch_log_group_arn :: Route53QueryLogResource -> TF.Argument "cloudwatch_log_group_arn" Text)
             (\s a -> s { _cloudwatch_log_group_arn = a } :: Route53QueryLogResource)

instance HasZoneId Route53QueryLogResource Text where
    zoneId =
        lens (_zone_id :: Route53QueryLogResource -> TF.Argument "zone_id" Text)
             (\s a -> s { _zone_id = a } :: Route53QueryLogResource)

instance HasComputedId Route53QueryLogResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

route53QueryLogResource :: TF.Resource TF.AWS Route53QueryLogResource
route53QueryLogResource =
    TF.newResource "aws_route53_query_log" $
        Route53QueryLogResource {
            _cloudwatch_log_group_arn = TF.Nil
            , _zone_id = TF.Nil
            }

{- | The @aws_route53_record@ AWS resource.

Provides a Route53 record resource.
-}
data Route53RecordResource = Route53RecordResource {
      _alias :: !(TF.Argument "alias" Text)
    {- ^ (Optional) An alias block. Conflicts with @ttl@ & @records@ . Alias record documented below. -}
    , _failover_routing_policy :: !(TF.Argument "failover_routing_policy" Text)
    {- ^ (Optional) A block indicating the routing behavior when associated health check fails. Conflicts with any other routing policy. Documented below. -}
    , _geolocation_routing_policy :: !(TF.Argument "geolocation_routing_policy" Text)
    {- ^ (Optional) A block indicating a routing policy based on the geolocation of the requestor. Conflicts with any other routing policy. Documented below. -}
    , _health_check_id :: !(TF.Argument "health_check_id" Text)
    {- ^ (Optional) The health check the record should be associated with. -}
    , _latency_routing_policy :: !(TF.Argument "latency_routing_policy" Text)
    {- ^ (Optional) A block indicating a routing policy based on the latency between the requestor and an AWS region. Conflicts with any other routing policy. Documented below. -}
    , _multivalue_answer_routing_policy :: !(TF.Argument "multivalue_answer_routing_policy" Text)
    {- ^ (Optional) A block indicating a multivalue answer routing policy. Conflicts with any other routing policy. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the record. -}
    , _records :: !(TF.Argument "records" Text)
    {- ^ (Required for non-alias records) A string list of records. To specify a single record value longer than 255 characters such as a TXT record for DKIM, add @\"\"@ inside the Terraform configuration string (e.g. @"first255characters\"\"morecharacters"@ ). -}
    , _set_identifier :: !(TF.Argument "set_identifier" Text)
    {- ^ (Optional) Unique identifier to differentiate records with routing policies from one another. Required if using @failover@ , @geolocation@ , @latency@ , or @weighted@ routing policies documented below. -}
    , _ttl :: !(TF.Argument "ttl" Text)
    {- ^ (Required for non-alias records) The TTL of the record. -}
    , _type' :: !(TF.Argument "type" Text)
    {- ^ (Required) The record type. Valid values are @A@ , @AAAA@ , @CAA@ , @CNAME@ , @MX@ , @NAPTR@ , @NS@ , @PTR@ , @SOA@ , @SPF@ , @SRV@ and @TXT@ . -}
    , _weighted_routing_policy :: !(TF.Argument "weighted_routing_policy" Text)
    {- ^ (Optional) A block indicating a weighted routing policy. Conflicts with any other routing policy. Documented below. -}
    , _zone_id :: !(TF.Argument "zone_id" Text)
    {- ^ (Required) The ID of the hosted zone to contain this record. -}
    } deriving (Show, Eq)

instance TF.ToHCL Route53RecordResource where
    toHCL Route53RecordResource{..} = TF.block $ catMaybes
        [ TF.argument _alias
        , TF.argument _failover_routing_policy
        , TF.argument _geolocation_routing_policy
        , TF.argument _health_check_id
        , TF.argument _latency_routing_policy
        , TF.argument _multivalue_answer_routing_policy
        , TF.argument _name
        , TF.argument _records
        , TF.argument _set_identifier
        , TF.argument _ttl
        , TF.argument _type'
        , TF.argument _weighted_routing_policy
        , TF.argument _zone_id
        ]

instance HasAlias Route53RecordResource Text where
    alias =
        lens (_alias :: Route53RecordResource -> TF.Argument "alias" Text)
             (\s a -> s { _alias = a } :: Route53RecordResource)

instance HasFailoverRoutingPolicy Route53RecordResource Text where
    failoverRoutingPolicy =
        lens (_failover_routing_policy :: Route53RecordResource -> TF.Argument "failover_routing_policy" Text)
             (\s a -> s { _failover_routing_policy = a } :: Route53RecordResource)

instance HasGeolocationRoutingPolicy Route53RecordResource Text where
    geolocationRoutingPolicy =
        lens (_geolocation_routing_policy :: Route53RecordResource -> TF.Argument "geolocation_routing_policy" Text)
             (\s a -> s { _geolocation_routing_policy = a } :: Route53RecordResource)

instance HasHealthCheckId Route53RecordResource Text where
    healthCheckId =
        lens (_health_check_id :: Route53RecordResource -> TF.Argument "health_check_id" Text)
             (\s a -> s { _health_check_id = a } :: Route53RecordResource)

instance HasLatencyRoutingPolicy Route53RecordResource Text where
    latencyRoutingPolicy =
        lens (_latency_routing_policy :: Route53RecordResource -> TF.Argument "latency_routing_policy" Text)
             (\s a -> s { _latency_routing_policy = a } :: Route53RecordResource)

instance HasMultivalueAnswerRoutingPolicy Route53RecordResource Text where
    multivalueAnswerRoutingPolicy =
        lens (_multivalue_answer_routing_policy :: Route53RecordResource -> TF.Argument "multivalue_answer_routing_policy" Text)
             (\s a -> s { _multivalue_answer_routing_policy = a } :: Route53RecordResource)

instance HasName Route53RecordResource Text where
    name =
        lens (_name :: Route53RecordResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: Route53RecordResource)

instance HasRecords Route53RecordResource Text where
    records =
        lens (_records :: Route53RecordResource -> TF.Argument "records" Text)
             (\s a -> s { _records = a } :: Route53RecordResource)

instance HasSetIdentifier Route53RecordResource Text where
    setIdentifier =
        lens (_set_identifier :: Route53RecordResource -> TF.Argument "set_identifier" Text)
             (\s a -> s { _set_identifier = a } :: Route53RecordResource)

instance HasTtl Route53RecordResource Text where
    ttl =
        lens (_ttl :: Route53RecordResource -> TF.Argument "ttl" Text)
             (\s a -> s { _ttl = a } :: Route53RecordResource)

instance HasType' Route53RecordResource Text where
    type' =
        lens (_type' :: Route53RecordResource -> TF.Argument "type" Text)
             (\s a -> s { _type' = a } :: Route53RecordResource)

instance HasWeightedRoutingPolicy Route53RecordResource Text where
    weightedRoutingPolicy =
        lens (_weighted_routing_policy :: Route53RecordResource -> TF.Argument "weighted_routing_policy" Text)
             (\s a -> s { _weighted_routing_policy = a } :: Route53RecordResource)

instance HasZoneId Route53RecordResource Text where
    zoneId =
        lens (_zone_id :: Route53RecordResource -> TF.Argument "zone_id" Text)
             (\s a -> s { _zone_id = a } :: Route53RecordResource)

instance HasComputedFqdn Route53RecordResource Text where
    computedFqdn =
        to (\_  -> TF.Compute "fqdn")

route53RecordResource :: TF.Resource TF.AWS Route53RecordResource
route53RecordResource =
    TF.newResource "aws_route53_record" $
        Route53RecordResource {
            _alias = TF.Nil
            , _failover_routing_policy = TF.Nil
            , _geolocation_routing_policy = TF.Nil
            , _health_check_id = TF.Nil
            , _latency_routing_policy = TF.Nil
            , _multivalue_answer_routing_policy = TF.Nil
            , _name = TF.Nil
            , _records = TF.Nil
            , _set_identifier = TF.Nil
            , _ttl = TF.Nil
            , _type' = TF.Nil
            , _weighted_routing_policy = TF.Nil
            , _zone_id = TF.Nil
            }

{- | The @aws_route53_zone_association@ AWS resource.

Provides a Route53 private Hosted Zone to VPC association resource.
-}
data Route53ZoneAssociationResource = Route53ZoneAssociationResource {
      _vpc_id :: !(TF.Argument "vpc_id" Text)
    {- ^ (Required) The VPC to associate with the private hosted zone. -}
    , _vpc_region :: !(TF.Argument "vpc_region" TF.Region)
    {- ^ (Optional) The VPC's region. Defaults to the region of the AWS provider. -}
    , _zone_id :: !(TF.Argument "zone_id" Text)
    {- ^ (Required) The private hosted zone to associate. -}
    } deriving (Show, Eq)

instance TF.ToHCL Route53ZoneAssociationResource where
    toHCL Route53ZoneAssociationResource{..} = TF.block $ catMaybes
        [ TF.argument _vpc_id
        , TF.argument _vpc_region
        , TF.argument _zone_id
        ]

instance HasVpcId Route53ZoneAssociationResource Text where
    vpcId =
        lens (_vpc_id :: Route53ZoneAssociationResource -> TF.Argument "vpc_id" Text)
             (\s a -> s { _vpc_id = a } :: Route53ZoneAssociationResource)

instance HasVpcRegion Route53ZoneAssociationResource TF.Region where
    vpcRegion =
        lens (_vpc_region :: Route53ZoneAssociationResource -> TF.Argument "vpc_region" TF.Region)
             (\s a -> s { _vpc_region = a } :: Route53ZoneAssociationResource)

instance HasZoneId Route53ZoneAssociationResource Text where
    zoneId =
        lens (_zone_id :: Route53ZoneAssociationResource -> TF.Argument "zone_id" Text)
             (\s a -> s { _zone_id = a } :: Route53ZoneAssociationResource)

instance HasComputedId Route53ZoneAssociationResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedVpcId Route53ZoneAssociationResource Text where
    computedVpcId =
        to (\_  -> TF.Compute "vpc_id")

instance HasComputedVpcRegion Route53ZoneAssociationResource TF.Region where
    computedVpcRegion =
        to (\_  -> TF.Compute "vpc_region")

instance HasComputedZoneId Route53ZoneAssociationResource Text where
    computedZoneId =
        to (\_  -> TF.Compute "zone_id")

route53ZoneAssociationResource :: TF.Resource TF.AWS Route53ZoneAssociationResource
route53ZoneAssociationResource =
    TF.newResource "aws_route53_zone_association" $
        Route53ZoneAssociationResource {
            _vpc_id = TF.Nil
            , _vpc_region = TF.Nil
            , _zone_id = TF.Nil
            }

{- | The @aws_route53_zone@ AWS resource.

Provides a Route53 Hosted Zone resource.
-}
data Route53ZoneResource = Route53ZoneResource {
      _comment :: !(TF.Argument "comment" Text)
    {- ^ (Optional) A comment for the hosted zone. Defaults to 'Managed by Terraform'. -}
    , _delegation_set_id :: !(TF.Argument "delegation_set_id" Text)
    {- ^ (Optional) The ID of the reusable delegation set whose NS records you want to assign to the hosted zone. Conflicts w/ @vpc_id@ as delegation sets can only be used for public zones. -}
    , _force_destroy :: !(TF.Argument "force_destroy" Text)
    {- ^ (Optional) Whether to destroy all records (possibly managed outside of Terraform) in the zone when destroying the zone. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) This is the name of the hosted zone. -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the zone. -}
    , _vpc_id :: !(TF.Argument "vpc_id" Text)
    {- ^ (Optional) The VPC to associate with a private hosted zone. Specifying @vpc_id@ will create a private hosted zone. Conflicts w/ @delegation_set_id@ as delegation sets can only be used for public zones. -}
    , _vpc_region :: !(TF.Argument "vpc_region" TF.Region)
    {- ^ (Optional) The VPC's region. Defaults to the region of the AWS provider. -}
    } deriving (Show, Eq)

instance TF.ToHCL Route53ZoneResource where
    toHCL Route53ZoneResource{..} = TF.block $ catMaybes
        [ TF.argument _comment
        , TF.argument _delegation_set_id
        , TF.argument _force_destroy
        , TF.argument _name
        , TF.argument _tags
        , TF.argument _vpc_id
        , TF.argument _vpc_region
        ]

instance HasComment Route53ZoneResource Text where
    comment =
        lens (_comment :: Route53ZoneResource -> TF.Argument "comment" Text)
             (\s a -> s { _comment = a } :: Route53ZoneResource)

instance HasDelegationSetId Route53ZoneResource Text where
    delegationSetId =
        lens (_delegation_set_id :: Route53ZoneResource -> TF.Argument "delegation_set_id" Text)
             (\s a -> s { _delegation_set_id = a } :: Route53ZoneResource)

instance HasForceDestroy Route53ZoneResource Text where
    forceDestroy =
        lens (_force_destroy :: Route53ZoneResource -> TF.Argument "force_destroy" Text)
             (\s a -> s { _force_destroy = a } :: Route53ZoneResource)

instance HasName Route53ZoneResource Text where
    name =
        lens (_name :: Route53ZoneResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: Route53ZoneResource)

instance HasTags Route53ZoneResource TF.Tags where
    tags =
        lens (_tags :: Route53ZoneResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: Route53ZoneResource)

instance HasVpcId Route53ZoneResource Text where
    vpcId =
        lens (_vpc_id :: Route53ZoneResource -> TF.Argument "vpc_id" Text)
             (\s a -> s { _vpc_id = a } :: Route53ZoneResource)

instance HasVpcRegion Route53ZoneResource TF.Region where
    vpcRegion =
        lens (_vpc_region :: Route53ZoneResource -> TF.Argument "vpc_region" TF.Region)
             (\s a -> s { _vpc_region = a } :: Route53ZoneResource)

instance HasComputedNameServers Route53ZoneResource Text where
    computedNameServers =
        to (\_  -> TF.Compute "name_servers")

instance HasComputedZoneId Route53ZoneResource Text where
    computedZoneId =
        to (\_  -> TF.Compute "zone_id")

route53ZoneResource :: TF.Resource TF.AWS Route53ZoneResource
route53ZoneResource =
    TF.newResource "aws_route53_zone" $
        Route53ZoneResource {
            _comment = TF.Nil
            , _delegation_set_id = TF.Nil
            , _force_destroy = TF.Nil
            , _name = TF.Nil
            , _tags = TF.Nil
            , _vpc_id = TF.Nil
            , _vpc_region = TF.Nil
            }

{- | The @aws_route@ AWS resource.

Provides a resource to create a routing table entry (a route) in a VPC
routing table. ~> NOTE on Route Tables and Routes: Terraform currently
provides both a standalone Route resource and a <route_table.html> resource
with routes defined in-line. At this time you cannot use a Route Table with
in-line routes in conjunction with any Route resources. Doing so will cause
a conflict of rule settings and will overwrite rules.
-}
data RouteResource = RouteResource {
      _destination_cidr_block :: !(TF.Argument "destination_cidr_block" TF.CIDR)
    {- ^ (Optional) The destination CIDR block. -}
    , _destination_ipv6_cidr_block :: !(TF.Argument "destination_ipv6_cidr_block" TF.CIDR)
    {- ^ (Optional) The destination IPv6 CIDR block. -}
    , _egress_only_gateway_id :: !(TF.Argument "egress_only_gateway_id" Text)
    {- ^ (Optional) An ID of a VPC Egress Only Internet Gateway. -}
    , _gateway_id :: !(TF.Argument "gateway_id" Text)
    {- ^ (Optional) An ID of a VPC internet gateway or a virtual private gateway. -}
    , _instance_id :: !(TF.Argument "instance_id" Text)
    {- ^ (Optional) An ID of an EC2 instance. -}
    , _nat_gateway_id :: !(TF.Argument "nat_gateway_id" Text)
    {- ^ (Optional) An ID of a VPC NAT gateway. -}
    , _network_interface_id :: !(TF.Argument "network_interface_id" Text)
    {- ^ (Optional) An ID of a network interface. -}
    , _route_table_id :: !(TF.Argument "route_table_id" Text)
    {- ^ (Required) The ID of the routing table. -}
    , _vpc_peering_connection_id :: !(TF.Argument "vpc_peering_connection_id" Text)
    {- ^ (Optional) An ID of a VPC peering connection. -}
    } deriving (Show, Eq)

instance TF.ToHCL RouteResource where
    toHCL RouteResource{..} = TF.block $ catMaybes
        [ TF.argument _destination_cidr_block
        , TF.argument _destination_ipv6_cidr_block
        , TF.argument _egress_only_gateway_id
        , TF.argument _gateway_id
        , TF.argument _instance_id
        , TF.argument _nat_gateway_id
        , TF.argument _network_interface_id
        , TF.argument _route_table_id
        , TF.argument _vpc_peering_connection_id
        ]

instance HasDestinationCidrBlock RouteResource TF.CIDR where
    destinationCidrBlock =
        lens (_destination_cidr_block :: RouteResource -> TF.Argument "destination_cidr_block" TF.CIDR)
             (\s a -> s { _destination_cidr_block = a } :: RouteResource)

instance HasDestinationIpv6CidrBlock RouteResource TF.CIDR where
    destinationIpv6CidrBlock =
        lens (_destination_ipv6_cidr_block :: RouteResource -> TF.Argument "destination_ipv6_cidr_block" TF.CIDR)
             (\s a -> s { _destination_ipv6_cidr_block = a } :: RouteResource)

instance HasEgressOnlyGatewayId RouteResource Text where
    egressOnlyGatewayId =
        lens (_egress_only_gateway_id :: RouteResource -> TF.Argument "egress_only_gateway_id" Text)
             (\s a -> s { _egress_only_gateway_id = a } :: RouteResource)

instance HasGatewayId RouteResource Text where
    gatewayId =
        lens (_gateway_id :: RouteResource -> TF.Argument "gateway_id" Text)
             (\s a -> s { _gateway_id = a } :: RouteResource)

instance HasInstanceId RouteResource Text where
    instanceId =
        lens (_instance_id :: RouteResource -> TF.Argument "instance_id" Text)
             (\s a -> s { _instance_id = a } :: RouteResource)

instance HasNatGatewayId RouteResource Text where
    natGatewayId =
        lens (_nat_gateway_id :: RouteResource -> TF.Argument "nat_gateway_id" Text)
             (\s a -> s { _nat_gateway_id = a } :: RouteResource)

instance HasNetworkInterfaceId RouteResource Text where
    networkInterfaceId =
        lens (_network_interface_id :: RouteResource -> TF.Argument "network_interface_id" Text)
             (\s a -> s { _network_interface_id = a } :: RouteResource)

instance HasRouteTableId RouteResource Text where
    routeTableId =
        lens (_route_table_id :: RouteResource -> TF.Argument "route_table_id" Text)
             (\s a -> s { _route_table_id = a } :: RouteResource)

instance HasVpcPeeringConnectionId RouteResource Text where
    vpcPeeringConnectionId =
        lens (_vpc_peering_connection_id :: RouteResource -> TF.Argument "vpc_peering_connection_id" Text)
             (\s a -> s { _vpc_peering_connection_id = a } :: RouteResource)

instance HasComputedDestinationCidrBlock RouteResource TF.CIDR where
    computedDestinationCidrBlock =
        to (\_  -> TF.Compute "destination_cidr_block")

instance HasComputedDestinationIpv6CidrBlock RouteResource TF.CIDR where
    computedDestinationIpv6CidrBlock =
        to (\_  -> TF.Compute "destination_ipv6_cidr_block")

instance HasComputedEgressOnlyGatewayId RouteResource Text where
    computedEgressOnlyGatewayId =
        to (\_  -> TF.Compute "egress_only_gateway_id")

instance HasComputedGatewayId RouteResource Text where
    computedGatewayId =
        to (\_  -> TF.Compute "gateway_id")

instance HasComputedInstanceId RouteResource Text where
    computedInstanceId =
        to (\_  -> TF.Compute "instance_id")

instance HasComputedNatGatewayId RouteResource Text where
    computedNatGatewayId =
        to (\_  -> TF.Compute "nat_gateway_id")

instance HasComputedNetworkInterfaceId RouteResource Text where
    computedNetworkInterfaceId =
        to (\_  -> TF.Compute "network_interface_id")

instance HasComputedRouteTableId RouteResource Text where
    computedRouteTableId =
        to (\_  -> TF.Compute "route_table_id")

instance HasComputedVpcPeeringConnectionId RouteResource Text where
    computedVpcPeeringConnectionId =
        to (\_  -> TF.Compute "vpc_peering_connection_id")

routeResource :: TF.Resource TF.AWS RouteResource
routeResource =
    TF.newResource "aws_route" $
        RouteResource {
            _destination_cidr_block = TF.Nil
            , _destination_ipv6_cidr_block = TF.Nil
            , _egress_only_gateway_id = TF.Nil
            , _gateway_id = TF.Nil
            , _instance_id = TF.Nil
            , _nat_gateway_id = TF.Nil
            , _network_interface_id = TF.Nil
            , _route_table_id = TF.Nil
            , _vpc_peering_connection_id = TF.Nil
            }

{- | The @aws_route_table_association@ AWS resource.

Provides a resource to create an association between a subnet and routing
table.
-}
data RouteTableAssociationResource = RouteTableAssociationResource {
      _route_table_id :: !(TF.Argument "route_table_id" Text)
    {- ^ (Required) The ID of the routing table to associate with. -}
    , _subnet_id :: !(TF.Argument "subnet_id" Text)
    {- ^ (Required) The subnet ID to create an association. -}
    } deriving (Show, Eq)

instance TF.ToHCL RouteTableAssociationResource where
    toHCL RouteTableAssociationResource{..} = TF.block $ catMaybes
        [ TF.argument _route_table_id
        , TF.argument _subnet_id
        ]

instance HasRouteTableId RouteTableAssociationResource Text where
    routeTableId =
        lens (_route_table_id :: RouteTableAssociationResource -> TF.Argument "route_table_id" Text)
             (\s a -> s { _route_table_id = a } :: RouteTableAssociationResource)

instance HasSubnetId RouteTableAssociationResource Text where
    subnetId =
        lens (_subnet_id :: RouteTableAssociationResource -> TF.Argument "subnet_id" Text)
             (\s a -> s { _subnet_id = a } :: RouteTableAssociationResource)

instance HasComputedId RouteTableAssociationResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

routeTableAssociationResource :: TF.Resource TF.AWS RouteTableAssociationResource
routeTableAssociationResource =
    TF.newResource "aws_route_table_association" $
        RouteTableAssociationResource {
            _route_table_id = TF.Nil
            , _subnet_id = TF.Nil
            }

{- | The @aws_route_table@ AWS resource.

Provides a resource to create a VPC routing table. ~> NOTE on Route Tables
and Routes: Terraform currently provides both a standalone <route.html> and
a Route Table resource with routes defined in-line. At this time you cannot
use a Route Table with in-line routes in conjunction with any Route
resources. Doing so will cause a conflict of rule settings and will
overwrite rules. ~> NOTE on @gateway_id@ and @nat_gateway_id@ : The AWS API
is very forgiving with these two attributes and the @aws_route_table@
resource can be created with a NAT ID specified as a Gateway ID attribute.
This will lead to a permanent diff between your configuration and statefile,
as the API returns the correct parameters in the returned route table. If
you're experiencing constant diffs in your @aws_route_table@ resources, the
first thing to check is whether or not you're specifying a NAT ID instead of
a Gateway ID, or vice-versa. ~> NOTE on @propagating_vgws@ and the
@aws_vpn_gateway_route_propagation@ resource: If the @propagating_vgws@
argument is present, it's not supported to also define route propagations
using @aws_vpn_gateway_route_propagation@ , since this resource will delete
any propagating gateways not explicitly listed in @propagating_vgws@ . Omit
this argument when defining route propagation using the separate resource.
-}
data RouteTableResource = RouteTableResource {
      _propagating_vgws :: !(TF.Argument "propagating_vgws" Text)
    {- ^ (Optional) A list of virtual gateways for propagation. -}
    , _route :: !(TF.Argument "route" Text)
    {- ^ (Optional) A list of route objects. Their keys are documented below. -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    , _vpc_id :: !(TF.Argument "vpc_id" Text)
    {- ^ (Required) The VPC ID. -}
    } deriving (Show, Eq)

instance TF.ToHCL RouteTableResource where
    toHCL RouteTableResource{..} = TF.block $ catMaybes
        [ TF.argument _propagating_vgws
        , TF.argument _route
        , TF.argument _tags
        , TF.argument _vpc_id
        ]

instance HasPropagatingVgws RouteTableResource Text where
    propagatingVgws =
        lens (_propagating_vgws :: RouteTableResource -> TF.Argument "propagating_vgws" Text)
             (\s a -> s { _propagating_vgws = a } :: RouteTableResource)

instance HasRoute RouteTableResource Text where
    route =
        lens (_route :: RouteTableResource -> TF.Argument "route" Text)
             (\s a -> s { _route = a } :: RouteTableResource)

instance HasTags RouteTableResource TF.Tags where
    tags =
        lens (_tags :: RouteTableResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: RouteTableResource)

instance HasVpcId RouteTableResource Text where
    vpcId =
        lens (_vpc_id :: RouteTableResource -> TF.Argument "vpc_id" Text)
             (\s a -> s { _vpc_id = a } :: RouteTableResource)

instance HasComputedId RouteTableResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

routeTableResource :: TF.Resource TF.AWS RouteTableResource
routeTableResource =
    TF.newResource "aws_route_table" $
        RouteTableResource {
            _propagating_vgws = TF.Nil
            , _route = TF.Nil
            , _tags = TF.Nil
            , _vpc_id = TF.Nil
            }

{- | The @aws_s3_bucket_notification@ AWS resource.

Provides a S3 bucket notification resource.
-}
data S3BucketNotificationResource = S3BucketNotificationResource {
      _bucket :: !(TF.Argument "bucket" Text)
    {- ^ (Required) The name of the bucket to put notification configuration. -}
    , _lambda_function :: !(TF.Argument "lambda_function" Text)
    {- ^ (Optional, Multiple) Used to configure notifications to a Lambda Function (documented below). -}
    , _queue :: !(TF.Argument "queue" Text)
    {- ^ (Optional) The notification configuration to SQS Queue (documented below). -}
    , _topic :: !(TF.Argument "topic" Text)
    {- ^ (Optional) The notification configuration to SNS Topic (documented below). -}
    } deriving (Show, Eq)

instance TF.ToHCL S3BucketNotificationResource where
    toHCL S3BucketNotificationResource{..} = TF.block $ catMaybes
        [ TF.argument _bucket
        , TF.argument _lambda_function
        , TF.argument _queue
        , TF.argument _topic
        ]

instance HasBucket S3BucketNotificationResource Text where
    bucket =
        lens (_bucket :: S3BucketNotificationResource -> TF.Argument "bucket" Text)
             (\s a -> s { _bucket = a } :: S3BucketNotificationResource)

instance HasLambdaFunction S3BucketNotificationResource Text where
    lambdaFunction =
        lens (_lambda_function :: S3BucketNotificationResource -> TF.Argument "lambda_function" Text)
             (\s a -> s { _lambda_function = a } :: S3BucketNotificationResource)

instance HasQueue S3BucketNotificationResource Text where
    queue =
        lens (_queue :: S3BucketNotificationResource -> TF.Argument "queue" Text)
             (\s a -> s { _queue = a } :: S3BucketNotificationResource)

instance HasTopic S3BucketNotificationResource Text where
    topic =
        lens (_topic :: S3BucketNotificationResource -> TF.Argument "topic" Text)
             (\s a -> s { _topic = a } :: S3BucketNotificationResource)

s3BucketNotificationResource :: TF.Resource TF.AWS S3BucketNotificationResource
s3BucketNotificationResource =
    TF.newResource "aws_s3_bucket_notification" $
        S3BucketNotificationResource {
            _bucket = TF.Nil
            , _lambda_function = TF.Nil
            , _queue = TF.Nil
            , _topic = TF.Nil
            }

{- | The @aws_s3_bucket_object@ AWS resource.

Provides a S3 bucket object resource.
-}
data S3BucketObjectResource = S3BucketObjectResource {
      _acl :: !(TF.Argument "acl" Text)
    {- ^ (Optional) The <https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl> to apply. Defaults to "private". -}
    , _bucket :: !(TF.Argument "bucket" Text)
    {- ^ (Required) The name of the bucket to put the file in. -}
    , _cache_control :: !(TF.Argument "cache_control" Text)
    {- ^ (Optional) Specifies caching behavior along the request/reply chain Read <http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9> for further details. -}
    , _content :: !(TF.Argument "content" Text)
    {- ^ (Required unless @source@ given) The literal content being uploaded to the bucket. -}
    , _content_disposition :: !(TF.Argument "content_disposition" Text)
    {- ^ (Optional) Specifies presentational information for the object. Read <http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html#sec19.5.1> for further information. -}
    , _content_encoding :: !(TF.Argument "content_encoding" Text)
    {- ^ (Optional) Specifies what content encodings have been applied to the object and thus what decoding mechanisms must be applied to obtain the media-type referenced by the Content-Type header field. Read <http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11> for further information. -}
    , _content_language :: !(TF.Argument "content_language" Text)
    {- ^ (Optional) The language the content is in e.g. en-US or en-GB. -}
    , _content_type :: !(TF.Argument "content_type" Text)
    {- ^ (Optional) A standard MIME type describing the format of the object data, e.g. application/octet-stream. All Valid MIME Types are valid for this input. -}
    , _etag :: !(TF.Argument "etag" Text)
    {- ^ (Optional) Used to trigger updates. The only meaningful value is @${md5(file("path/to/file"))}@ . This attribute is not compatible with @kms_key_id@ . -}
    , _key :: !(TF.Argument "key" Text)
    {- ^ (Required) The name of the object once it is in the bucket. -}
    , _kms_key_id :: !(TF.Argument "kms_key_id" Text)
    {- ^ (Optional) Specifies the AWS KMS Key ARN to use for object encryption. This value is a fully qualified ARN of the KMS Key. If using @aws_kms_key@ , use the exported @arn@ attribute: @kms_key_id = "${aws_kms_key.foo.arn}"@ -}
    , _server_side_encryption :: !(TF.Argument "server_side_encryption" Text)
    {- ^ (Optional) Specifies server-side encryption of the object in S3. Valid values are " @AES256@ " and " @aws:kms@ ". -}
    , _source :: !(TF.Argument "source" Text)
    {- ^ (Required) The path to the source file being uploaded to the bucket. -}
    , _storage_class :: !(TF.Argument "storage_class" Text)
    {- ^ (Optional) Specifies the desired <http://docs.aws.amazon.com/AmazonS3/latest/dev/storage-class-intro.html> for the object. Can be either " @STANDARD@ ", " @REDUCED_REDUNDANCY@ ", or " @STANDARD_IA@ ". Defaults to " @STANDARD@ ". -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the object. -}
    , _website_redirect :: !(TF.Argument "website_redirect" Text)
    {- ^ (Optional) Specifies a target URL for <http://docs.aws.amazon.com/AmazonS3/latest/dev/how-to-page-redirect.html> . -}
    } deriving (Show, Eq)

instance TF.ToHCL S3BucketObjectResource where
    toHCL S3BucketObjectResource{..} = TF.block $ catMaybes
        [ TF.argument _acl
        , TF.argument _bucket
        , TF.argument _cache_control
        , TF.argument _content
        , TF.argument _content_disposition
        , TF.argument _content_encoding
        , TF.argument _content_language
        , TF.argument _content_type
        , TF.argument _etag
        , TF.argument _key
        , TF.argument _kms_key_id
        , TF.argument _server_side_encryption
        , TF.argument _source
        , TF.argument _storage_class
        , TF.argument _tags
        , TF.argument _website_redirect
        ]

instance HasAcl S3BucketObjectResource Text where
    acl =
        lens (_acl :: S3BucketObjectResource -> TF.Argument "acl" Text)
             (\s a -> s { _acl = a } :: S3BucketObjectResource)

instance HasBucket S3BucketObjectResource Text where
    bucket =
        lens (_bucket :: S3BucketObjectResource -> TF.Argument "bucket" Text)
             (\s a -> s { _bucket = a } :: S3BucketObjectResource)

instance HasCacheControl S3BucketObjectResource Text where
    cacheControl =
        lens (_cache_control :: S3BucketObjectResource -> TF.Argument "cache_control" Text)
             (\s a -> s { _cache_control = a } :: S3BucketObjectResource)

instance HasContent S3BucketObjectResource Text where
    content =
        lens (_content :: S3BucketObjectResource -> TF.Argument "content" Text)
             (\s a -> s { _content = a } :: S3BucketObjectResource)

instance HasContentDisposition S3BucketObjectResource Text where
    contentDisposition =
        lens (_content_disposition :: S3BucketObjectResource -> TF.Argument "content_disposition" Text)
             (\s a -> s { _content_disposition = a } :: S3BucketObjectResource)

instance HasContentEncoding S3BucketObjectResource Text where
    contentEncoding =
        lens (_content_encoding :: S3BucketObjectResource -> TF.Argument "content_encoding" Text)
             (\s a -> s { _content_encoding = a } :: S3BucketObjectResource)

instance HasContentLanguage S3BucketObjectResource Text where
    contentLanguage =
        lens (_content_language :: S3BucketObjectResource -> TF.Argument "content_language" Text)
             (\s a -> s { _content_language = a } :: S3BucketObjectResource)

instance HasContentType S3BucketObjectResource Text where
    contentType =
        lens (_content_type :: S3BucketObjectResource -> TF.Argument "content_type" Text)
             (\s a -> s { _content_type = a } :: S3BucketObjectResource)

instance HasEtag S3BucketObjectResource Text where
    etag =
        lens (_etag :: S3BucketObjectResource -> TF.Argument "etag" Text)
             (\s a -> s { _etag = a } :: S3BucketObjectResource)

instance HasKey S3BucketObjectResource Text where
    key =
        lens (_key :: S3BucketObjectResource -> TF.Argument "key" Text)
             (\s a -> s { _key = a } :: S3BucketObjectResource)

instance HasKmsKeyId S3BucketObjectResource Text where
    kmsKeyId =
        lens (_kms_key_id :: S3BucketObjectResource -> TF.Argument "kms_key_id" Text)
             (\s a -> s { _kms_key_id = a } :: S3BucketObjectResource)

instance HasServerSideEncryption S3BucketObjectResource Text where
    serverSideEncryption =
        lens (_server_side_encryption :: S3BucketObjectResource -> TF.Argument "server_side_encryption" Text)
             (\s a -> s { _server_side_encryption = a } :: S3BucketObjectResource)

instance HasSource S3BucketObjectResource Text where
    source =
        lens (_source :: S3BucketObjectResource -> TF.Argument "source" Text)
             (\s a -> s { _source = a } :: S3BucketObjectResource)

instance HasStorageClass S3BucketObjectResource Text where
    storageClass =
        lens (_storage_class :: S3BucketObjectResource -> TF.Argument "storage_class" Text)
             (\s a -> s { _storage_class = a } :: S3BucketObjectResource)

instance HasTags S3BucketObjectResource TF.Tags where
    tags =
        lens (_tags :: S3BucketObjectResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: S3BucketObjectResource)

instance HasWebsiteRedirect S3BucketObjectResource Text where
    websiteRedirect =
        lens (_website_redirect :: S3BucketObjectResource -> TF.Argument "website_redirect" Text)
             (\s a -> s { _website_redirect = a } :: S3BucketObjectResource)

instance HasComputedEtag S3BucketObjectResource Text where
    computedEtag =
        to (\_  -> TF.Compute "etag")

instance HasComputedId S3BucketObjectResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedVersionId S3BucketObjectResource Text where
    computedVersionId =
        to (\_  -> TF.Compute "version_id")

s3BucketObjectResource :: TF.Resource TF.AWS S3BucketObjectResource
s3BucketObjectResource =
    TF.newResource "aws_s3_bucket_object" $
        S3BucketObjectResource {
            _acl = TF.Nil
            , _bucket = TF.Nil
            , _cache_control = TF.Nil
            , _content = TF.Nil
            , _content_disposition = TF.Nil
            , _content_encoding = TF.Nil
            , _content_language = TF.Nil
            , _content_type = TF.Nil
            , _etag = TF.Nil
            , _key = TF.Nil
            , _kms_key_id = TF.Nil
            , _server_side_encryption = TF.Nil
            , _source = TF.Nil
            , _storage_class = TF.Nil
            , _tags = TF.Nil
            , _website_redirect = TF.Nil
            }

{- | The @aws_s3_bucket_policy@ AWS resource.

Attaches a policy to an S3 bucket resource.
-}
data S3BucketPolicyResource = S3BucketPolicyResource {
      _bucket :: !(TF.Argument "bucket" Text)
    {- ^ (Required) The name of the bucket to which to apply the policy. -}
    , _policy :: !(TF.Argument "policy" Text)
    {- ^ (Required) The text of the policy. -}
    } deriving (Show, Eq)

instance TF.ToHCL S3BucketPolicyResource where
    toHCL S3BucketPolicyResource{..} = TF.block $ catMaybes
        [ TF.argument _bucket
        , TF.argument _policy
        ]

instance HasBucket S3BucketPolicyResource Text where
    bucket =
        lens (_bucket :: S3BucketPolicyResource -> TF.Argument "bucket" Text)
             (\s a -> s { _bucket = a } :: S3BucketPolicyResource)

instance HasPolicy S3BucketPolicyResource Text where
    policy =
        lens (_policy :: S3BucketPolicyResource -> TF.Argument "policy" Text)
             (\s a -> s { _policy = a } :: S3BucketPolicyResource)

s3BucketPolicyResource :: TF.Resource TF.AWS S3BucketPolicyResource
s3BucketPolicyResource =
    TF.newResource "aws_s3_bucket_policy" $
        S3BucketPolicyResource {
            _bucket = TF.Nil
            , _policy = TF.Nil
            }

{- | The @aws_s3_bucket@ AWS resource.

Provides a S3 bucket resource.
-}
data S3BucketResource = S3BucketResource {
      _acceleration_status :: !(TF.Argument "acceleration_status" Text)
    {- ^ (Optional) Sets the accelerate configuration of an existing bucket. Can be @Enabled@ or @Suspended@ . -}
    , _acl :: !(TF.Argument "acl" Text)
    {- ^ (Optional) The <https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl> to apply. Defaults to "private". -}
    , _bucket :: !(TF.Argument "bucket" Text)
    {- ^ (Optional, Forces new resource) The name of the bucket. If omitted, Terraform will assign a random, unique name. -}
    , _bucket_prefix :: !(TF.Argument "bucket_prefix" Text)
    {- ^ (Optional, Forces new resource) Creates a unique bucket name beginning with the specified prefix. Conflicts with @bucket@ . -}
    , _cors_rule :: !(TF.Argument "cors_rule" Text)
    {- ^ (Optional) A rule of <https://docs.aws.amazon.com/AmazonS3/latest/dev/cors.html> (documented below). -}
    , _force_destroy :: !(TF.Argument "force_destroy" Text)
    {- ^ (Optional, Default:false ) A boolean that indicates all objects should be deleted from the bucket so that the bucket can be destroyed without error. These objects are not recoverable. -}
    , _lifecycle_rule :: !(TF.Argument "lifecycle_rule" Text)
    {- ^ (Optional) A configuration of <http://docs.aws.amazon.com/AmazonS3/latest/dev/object-lifecycle-mgmt.html> (documented below). -}
    , _logging :: !(TF.Argument "logging" Text)
    {- ^ (Optional) A settings of <https://docs.aws.amazon.com/AmazonS3/latest/UG/ManagingBucketLogging.html> (documented below). -}
    , _policy :: !(TF.Argument "policy" Text)
    {- ^ (Optional) A valid <https://docs.aws.amazon.com/AmazonS3/latest/dev/example-bucket-policies.html> JSON document. Note that if the policy document is not specific enough (but still valid), Terraform may view the policy as constantly changing in a @terraform plan@ . In this case, please make sure you use the verbose/specific version of the policy. -}
    , _region :: !(TF.Argument "region" TF.Region)
    {- ^ (Optional) If specified, the AWS region this bucket should reside in. Otherwise, the region used by the callee. -}
    , _replication_configuration :: !(TF.Argument "replication_configuration" Text)
    {- ^ (Optional) A configuration of <http://docs.aws.amazon.com/AmazonS3/latest/dev/crr.html> (documented below). -}
    , _request_payer :: !(TF.Argument "request_payer" Text)
    {- ^ (Optional) Specifies who should bear the cost of Amazon S3 data transfer. Can be either @BucketOwner@ or @Requester@ . By default, the owner of the S3 bucket would incur the costs of any data transfer. See <http://docs.aws.amazon.com/AmazonS3/latest/dev/RequesterPaysBuckets.html> developer guide for more information. -}
    , _server_side_encryption_configuration :: !(TF.Argument "server_side_encryption_configuration" Text)
    {- ^ (Optional) A configuration of <http://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-encryption.html> (documented below) -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the bucket. -}
    , _versioning :: !(TF.Argument "versioning" TF.S3BucketVersioning)
    {- ^ (Optional) A state of <https://docs.aws.amazon.com/AmazonS3/latest/dev/Versioning.html> (documented below) -}
    , _website :: !(TF.Argument "website" Text)
    {- ^ (Optional) A website object (documented below). -}
    } deriving (Show, Eq)

instance TF.ToHCL S3BucketResource where
    toHCL S3BucketResource{..} = TF.block $ catMaybes
        [ TF.argument _acceleration_status
        , TF.argument _acl
        , TF.argument _bucket
        , TF.argument _bucket_prefix
        , TF.argument _cors_rule
        , TF.argument _force_destroy
        , TF.argument _lifecycle_rule
        , TF.argument _logging
        , TF.argument _policy
        , TF.argument _region
        , TF.argument _replication_configuration
        , TF.argument _request_payer
        , TF.argument _server_side_encryption_configuration
        , TF.argument _tags
        , TF.argument _versioning
        , TF.argument _website
        ]

instance HasAccelerationStatus S3BucketResource Text where
    accelerationStatus =
        lens (_acceleration_status :: S3BucketResource -> TF.Argument "acceleration_status" Text)
             (\s a -> s { _acceleration_status = a } :: S3BucketResource)

instance HasAcl S3BucketResource Text where
    acl =
        lens (_acl :: S3BucketResource -> TF.Argument "acl" Text)
             (\s a -> s { _acl = a } :: S3BucketResource)

instance HasBucket S3BucketResource Text where
    bucket =
        lens (_bucket :: S3BucketResource -> TF.Argument "bucket" Text)
             (\s a -> s { _bucket = a } :: S3BucketResource)

instance HasBucketPrefix S3BucketResource Text where
    bucketPrefix =
        lens (_bucket_prefix :: S3BucketResource -> TF.Argument "bucket_prefix" Text)
             (\s a -> s { _bucket_prefix = a } :: S3BucketResource)

instance HasCorsRule S3BucketResource Text where
    corsRule =
        lens (_cors_rule :: S3BucketResource -> TF.Argument "cors_rule" Text)
             (\s a -> s { _cors_rule = a } :: S3BucketResource)

instance HasForceDestroy S3BucketResource Text where
    forceDestroy =
        lens (_force_destroy :: S3BucketResource -> TF.Argument "force_destroy" Text)
             (\s a -> s { _force_destroy = a } :: S3BucketResource)

instance HasLifecycleRule S3BucketResource Text where
    lifecycleRule =
        lens (_lifecycle_rule :: S3BucketResource -> TF.Argument "lifecycle_rule" Text)
             (\s a -> s { _lifecycle_rule = a } :: S3BucketResource)

instance HasLogging S3BucketResource Text where
    logging =
        lens (_logging :: S3BucketResource -> TF.Argument "logging" Text)
             (\s a -> s { _logging = a } :: S3BucketResource)

instance HasPolicy S3BucketResource Text where
    policy =
        lens (_policy :: S3BucketResource -> TF.Argument "policy" Text)
             (\s a -> s { _policy = a } :: S3BucketResource)

instance HasRegion S3BucketResource TF.Region where
    region =
        lens (_region :: S3BucketResource -> TF.Argument "region" TF.Region)
             (\s a -> s { _region = a } :: S3BucketResource)

instance HasReplicationConfiguration S3BucketResource Text where
    replicationConfiguration =
        lens (_replication_configuration :: S3BucketResource -> TF.Argument "replication_configuration" Text)
             (\s a -> s { _replication_configuration = a } :: S3BucketResource)

instance HasRequestPayer S3BucketResource Text where
    requestPayer =
        lens (_request_payer :: S3BucketResource -> TF.Argument "request_payer" Text)
             (\s a -> s { _request_payer = a } :: S3BucketResource)

instance HasServerSideEncryptionConfiguration S3BucketResource Text where
    serverSideEncryptionConfiguration =
        lens (_server_side_encryption_configuration :: S3BucketResource -> TF.Argument "server_side_encryption_configuration" Text)
             (\s a -> s { _server_side_encryption_configuration = a } :: S3BucketResource)

instance HasTags S3BucketResource TF.Tags where
    tags =
        lens (_tags :: S3BucketResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: S3BucketResource)

instance HasVersioning S3BucketResource TF.S3BucketVersioning where
    versioning =
        lens (_versioning :: S3BucketResource -> TF.Argument "versioning" TF.S3BucketVersioning)
             (\s a -> s { _versioning = a } :: S3BucketResource)

instance HasWebsite S3BucketResource Text where
    website =
        lens (_website :: S3BucketResource -> TF.Argument "website" Text)
             (\s a -> s { _website = a } :: S3BucketResource)

instance HasComputedArn S3BucketResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

instance HasComputedBucketDomainName S3BucketResource Text where
    computedBucketDomainName =
        to (\_  -> TF.Compute "bucket_domain_name")

instance HasComputedHostedZoneId S3BucketResource Text where
    computedHostedZoneId =
        to (\_  -> TF.Compute "hosted_zone_id")

instance HasComputedId S3BucketResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedRegion S3BucketResource TF.Region where
    computedRegion =
        to (\_  -> TF.Compute "region")

instance HasComputedWebsiteDomain S3BucketResource Text where
    computedWebsiteDomain =
        to (\_  -> TF.Compute "website_domain")

instance HasComputedWebsiteEndpoint S3BucketResource Text where
    computedWebsiteEndpoint =
        to (\_  -> TF.Compute "website_endpoint")

s3BucketResource :: TF.Resource TF.AWS S3BucketResource
s3BucketResource =
    TF.newResource "aws_s3_bucket" $
        S3BucketResource {
            _acceleration_status = TF.Nil
            , _acl = TF.Nil
            , _bucket = TF.Nil
            , _bucket_prefix = TF.Nil
            , _cors_rule = TF.Nil
            , _force_destroy = TF.Nil
            , _lifecycle_rule = TF.Nil
            , _logging = TF.Nil
            , _policy = TF.Nil
            , _region = TF.Nil
            , _replication_configuration = TF.Nil
            , _request_payer = TF.Nil
            , _server_side_encryption_configuration = TF.Nil
            , _tags = TF.Nil
            , _versioning = TF.Nil
            , _website = TF.Nil
            }

{- | The @aws_security_group@ AWS resource.

Provides a security group resource. ~> NOTE on Security Groups and Security
Group Rules: Terraform currently provides both a standalone
<security_group_rule.html> (a single @ingress@ or @egress@ rule), and a
Security Group resource with @ingress@ and @egress@ rules defined in-line.
At this time you cannot use a Security Group with in-line rules in
conjunction with any Security Group Rule resources. Doing so will cause a
conflict of rule settings and will overwrite rules.
-}
data SecurityGroupResource = SecurityGroupResource {
      _description :: !(TF.Argument "description" Text)
    {- ^ (Optional, Forces new resource) The security group description. Defaults to "Managed by Terraform". Cannot be "". NOTE : This field maps to the AWS @GroupDescription@ attribute, for which there is no Update API. If you'd like to classify your security groups in a way that can be updated, use @tags@ . -}
    , _egress :: !(TF.Argument "egress" Text)
    {- ^ (Optional, VPC only) Can be specified multiple times for each egress rule. Each egress block supports fields documented below. -}
    , _ingress :: !(TF.Argument "ingress" Text)
    {- ^ (Optional) Can be specified multiple times for each ingress rule. Each ingress block supports fields documented below. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Optional, Forces new resource) The name of the security group. If omitted, Terraform will assign a random, unique name -}
    , _name_prefix :: !(TF.Argument "name_prefix" Text)
    {- ^ (Optional, Forces new resource) Creates a unique name beginning with the specified prefix. Conflicts with @name@ . -}
    , _revoke_rules_on_delete :: !(TF.Argument "revoke_rules_on_delete" Text)
    {- ^ (Optional) Instruct Terraform to revoke all of the Security Groups attached ingress and egress rules before deleting the rule itself. This is normally not needed, however certain AWS services such as Elastic Map Reduce may automatically add required rules to security groups used with the service, and those rules may contain a cyclic dependency that prevent the security groups from being destroyed without removing the dependency first. Default @false@ -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    , _vpc_id :: !(TF.Argument "vpc_id" Text)
    {- ^ (Optional, Forces new resource) The VPC ID. -}
    } deriving (Show, Eq)

instance TF.ToHCL SecurityGroupResource where
    toHCL SecurityGroupResource{..} = TF.block $ catMaybes
        [ TF.argument _description
        , TF.argument _egress
        , TF.argument _ingress
        , TF.argument _name
        , TF.argument _name_prefix
        , TF.argument _revoke_rules_on_delete
        , TF.argument _tags
        , TF.argument _vpc_id
        ]

instance HasDescription SecurityGroupResource Text where
    description =
        lens (_description :: SecurityGroupResource -> TF.Argument "description" Text)
             (\s a -> s { _description = a } :: SecurityGroupResource)

instance HasEgress SecurityGroupResource Text where
    egress =
        lens (_egress :: SecurityGroupResource -> TF.Argument "egress" Text)
             (\s a -> s { _egress = a } :: SecurityGroupResource)

instance HasIngress SecurityGroupResource Text where
    ingress =
        lens (_ingress :: SecurityGroupResource -> TF.Argument "ingress" Text)
             (\s a -> s { _ingress = a } :: SecurityGroupResource)

instance HasName SecurityGroupResource Text where
    name =
        lens (_name :: SecurityGroupResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: SecurityGroupResource)

instance HasNamePrefix SecurityGroupResource Text where
    namePrefix =
        lens (_name_prefix :: SecurityGroupResource -> TF.Argument "name_prefix" Text)
             (\s a -> s { _name_prefix = a } :: SecurityGroupResource)

instance HasRevokeRulesOnDelete SecurityGroupResource Text where
    revokeRulesOnDelete =
        lens (_revoke_rules_on_delete :: SecurityGroupResource -> TF.Argument "revoke_rules_on_delete" Text)
             (\s a -> s { _revoke_rules_on_delete = a } :: SecurityGroupResource)

instance HasTags SecurityGroupResource TF.Tags where
    tags =
        lens (_tags :: SecurityGroupResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: SecurityGroupResource)

instance HasVpcId SecurityGroupResource Text where
    vpcId =
        lens (_vpc_id :: SecurityGroupResource -> TF.Argument "vpc_id" Text)
             (\s a -> s { _vpc_id = a } :: SecurityGroupResource)

securityGroupResource :: TF.Resource TF.AWS SecurityGroupResource
securityGroupResource =
    TF.newResource "aws_security_group" $
        SecurityGroupResource {
            _description = TF.Nil
            , _egress = TF.Nil
            , _ingress = TF.Nil
            , _name = TF.Nil
            , _name_prefix = TF.Nil
            , _revoke_rules_on_delete = TF.Nil
            , _tags = TF.Nil
            , _vpc_id = TF.Nil
            }

{- | The @aws_security_group_rule@ AWS resource.

Provides a security group rule resource. Represents a single @ingress@ or
@egress@ group rule, which can be added to external Security Groups. ~> NOTE
on Security Groups and Security Group Rules: Terraform currently provides
both a standalone Security Group Rule resource (a single @ingress@ or
@egress@ rule), and a <security_group.html> with @ingress@ and @egress@
rules defined in-line. At this time you cannot use a Security Group with
in-line rules in conjunction with any Security Group Rule resources. Doing
so will cause a conflict of rule settings and will overwrite rules.
-}
data SecurityGroupRuleResource = SecurityGroupRuleResource {
      _cidr_blocks :: !(TF.Argument "cidr_blocks" Text)
    {- ^ (Optional) List of CIDR blocks. Cannot be specified with @source_security_group_id@ . -}
    , _description :: !(TF.Argument "description" Text)
    {- ^ (Optional) Description of the rule. -}
    , _from_port :: !(TF.Argument "from_port" TF.Word16)
    {- ^ (Required) The start port (or ICMP type number if protocol is "icmp"). -}
    , _ipv6_cidr_blocks :: !(TF.Argument "ipv6_cidr_blocks" Text)
    {- ^ (Optional) List of IPv6 CIDR blocks. -}
    , _prefix_list_ids :: !(TF.Argument "prefix_list_ids" Text)
    {- ^ (Optional) List of prefix list IDs (for allowing access to VPC endpoints). Only valid with @egress@ . -}
    , _protocol :: !(TF.Argument "protocol" Text)
    {- ^ (Required) The protocol. If not icmp, tcp, udp, or all use the <https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml> -}
    , _security_group_id :: !(TF.Argument "security_group_id" Text)
    {- ^ (Required) The security group to apply this rule to. -}
    , _self :: !(TF.Argument "self" Text)
    {- ^ (Optional) If true, the security group itself will be added as a source to this ingress rule. -}
    , _source_security_group_id :: !(TF.Argument "source_security_group_id" Text)
    {- ^ (Optional) The security group id to allow access to/from, depending on the @type@ . Cannot be specified with @cidr_blocks@ . -}
    , _to_port :: !(TF.Argument "to_port" TF.Word16)
    {- ^ (Required) The end port (or ICMP code if protocol is "icmp"). -}
    , _type' :: !(TF.Argument "type" Text)
    {- ^ (Required) The type of rule being created. Valid options are @ingress@ (inbound) or @egress@ (outbound). -}
    } deriving (Show, Eq)

instance TF.ToHCL SecurityGroupRuleResource where
    toHCL SecurityGroupRuleResource{..} = TF.block $ catMaybes
        [ TF.argument _cidr_blocks
        , TF.argument _description
        , TF.argument _from_port
        , TF.argument _ipv6_cidr_blocks
        , TF.argument _prefix_list_ids
        , TF.argument _protocol
        , TF.argument _security_group_id
        , TF.argument _self
        , TF.argument _source_security_group_id
        , TF.argument _to_port
        , TF.argument _type'
        ]

instance HasCidrBlocks SecurityGroupRuleResource Text where
    cidrBlocks =
        lens (_cidr_blocks :: SecurityGroupRuleResource -> TF.Argument "cidr_blocks" Text)
             (\s a -> s { _cidr_blocks = a } :: SecurityGroupRuleResource)

instance HasDescription SecurityGroupRuleResource Text where
    description =
        lens (_description :: SecurityGroupRuleResource -> TF.Argument "description" Text)
             (\s a -> s { _description = a } :: SecurityGroupRuleResource)

instance HasFromPort SecurityGroupRuleResource TF.Word16 where
    fromPort =
        lens (_from_port :: SecurityGroupRuleResource -> TF.Argument "from_port" TF.Word16)
             (\s a -> s { _from_port = a } :: SecurityGroupRuleResource)

instance HasIpv6CidrBlocks SecurityGroupRuleResource Text where
    ipv6CidrBlocks =
        lens (_ipv6_cidr_blocks :: SecurityGroupRuleResource -> TF.Argument "ipv6_cidr_blocks" Text)
             (\s a -> s { _ipv6_cidr_blocks = a } :: SecurityGroupRuleResource)

instance HasPrefixListIds SecurityGroupRuleResource Text where
    prefixListIds =
        lens (_prefix_list_ids :: SecurityGroupRuleResource -> TF.Argument "prefix_list_ids" Text)
             (\s a -> s { _prefix_list_ids = a } :: SecurityGroupRuleResource)

instance HasProtocol SecurityGroupRuleResource Text where
    protocol =
        lens (_protocol :: SecurityGroupRuleResource -> TF.Argument "protocol" Text)
             (\s a -> s { _protocol = a } :: SecurityGroupRuleResource)

instance HasSecurityGroupId SecurityGroupRuleResource Text where
    securityGroupId =
        lens (_security_group_id :: SecurityGroupRuleResource -> TF.Argument "security_group_id" Text)
             (\s a -> s { _security_group_id = a } :: SecurityGroupRuleResource)

instance HasSelf SecurityGroupRuleResource Text where
    self =
        lens (_self :: SecurityGroupRuleResource -> TF.Argument "self" Text)
             (\s a -> s { _self = a } :: SecurityGroupRuleResource)

instance HasSourceSecurityGroupId SecurityGroupRuleResource Text where
    sourceSecurityGroupId =
        lens (_source_security_group_id :: SecurityGroupRuleResource -> TF.Argument "source_security_group_id" Text)
             (\s a -> s { _source_security_group_id = a } :: SecurityGroupRuleResource)

instance HasToPort SecurityGroupRuleResource TF.Word16 where
    toPort =
        lens (_to_port :: SecurityGroupRuleResource -> TF.Argument "to_port" TF.Word16)
             (\s a -> s { _to_port = a } :: SecurityGroupRuleResource)

instance HasType' SecurityGroupRuleResource Text where
    type' =
        lens (_type' :: SecurityGroupRuleResource -> TF.Argument "type" Text)
             (\s a -> s { _type' = a } :: SecurityGroupRuleResource)

securityGroupRuleResource :: TF.Resource TF.AWS SecurityGroupRuleResource
securityGroupRuleResource =
    TF.newResource "aws_security_group_rule" $
        SecurityGroupRuleResource {
            _cidr_blocks = TF.Nil
            , _description = TF.Nil
            , _from_port = TF.Nil
            , _ipv6_cidr_blocks = TF.Nil
            , _prefix_list_ids = TF.Nil
            , _protocol = TF.Nil
            , _security_group_id = TF.Nil
            , _self = TF.Nil
            , _source_security_group_id = TF.Nil
            , _to_port = TF.Nil
            , _type' = TF.Nil
            }

{- | The @aws_service_discovery_private_dns_namespace@ AWS resource.

Provides a Service Discovery Private DNS Namespace resource.
-}
data ServiceDiscoveryPrivateDnsNamespaceResource = ServiceDiscoveryPrivateDnsNamespaceResource {
      _description :: !(TF.Argument "description" Text)
    {- ^ (Optional) The description that you specify for the namespace when you create it. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the namespace. -}
    , _vpc :: !(TF.Argument "vpc" Text)
    {- ^ (Required) The ID of VPC that you want to associate the namespace with. -}
    } deriving (Show, Eq)

instance TF.ToHCL ServiceDiscoveryPrivateDnsNamespaceResource where
    toHCL ServiceDiscoveryPrivateDnsNamespaceResource{..} = TF.block $ catMaybes
        [ TF.argument _description
        , TF.argument _name
        , TF.argument _vpc
        ]

instance HasDescription ServiceDiscoveryPrivateDnsNamespaceResource Text where
    description =
        lens (_description :: ServiceDiscoveryPrivateDnsNamespaceResource -> TF.Argument "description" Text)
             (\s a -> s { _description = a } :: ServiceDiscoveryPrivateDnsNamespaceResource)

instance HasName ServiceDiscoveryPrivateDnsNamespaceResource Text where
    name =
        lens (_name :: ServiceDiscoveryPrivateDnsNamespaceResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: ServiceDiscoveryPrivateDnsNamespaceResource)

instance HasVpc ServiceDiscoveryPrivateDnsNamespaceResource Text where
    vpc =
        lens (_vpc :: ServiceDiscoveryPrivateDnsNamespaceResource -> TF.Argument "vpc" Text)
             (\s a -> s { _vpc = a } :: ServiceDiscoveryPrivateDnsNamespaceResource)

instance HasComputedArn ServiceDiscoveryPrivateDnsNamespaceResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

instance HasComputedHostedZone ServiceDiscoveryPrivateDnsNamespaceResource Text where
    computedHostedZone =
        to (\_  -> TF.Compute "hosted_zone")

instance HasComputedId ServiceDiscoveryPrivateDnsNamespaceResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

serviceDiscoveryPrivateDnsNamespaceResource :: TF.Resource TF.AWS ServiceDiscoveryPrivateDnsNamespaceResource
serviceDiscoveryPrivateDnsNamespaceResource =
    TF.newResource "aws_service_discovery_private_dns_namespace" $
        ServiceDiscoveryPrivateDnsNamespaceResource {
            _description = TF.Nil
            , _name = TF.Nil
            , _vpc = TF.Nil
            }

{- | The @aws_service_discovery_public_dns_namespace@ AWS resource.

Provides a Service Discovery Public DNS Namespace resource.
-}
data ServiceDiscoveryPublicDnsNamespaceResource = ServiceDiscoveryPublicDnsNamespaceResource {
      _description :: !(TF.Argument "description" Text)
    {- ^ (Optional) The description that you specify for the namespace when you create it. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the namespace. -}
    } deriving (Show, Eq)

instance TF.ToHCL ServiceDiscoveryPublicDnsNamespaceResource where
    toHCL ServiceDiscoveryPublicDnsNamespaceResource{..} = TF.block $ catMaybes
        [ TF.argument _description
        , TF.argument _name
        ]

instance HasDescription ServiceDiscoveryPublicDnsNamespaceResource Text where
    description =
        lens (_description :: ServiceDiscoveryPublicDnsNamespaceResource -> TF.Argument "description" Text)
             (\s a -> s { _description = a } :: ServiceDiscoveryPublicDnsNamespaceResource)

instance HasName ServiceDiscoveryPublicDnsNamespaceResource Text where
    name =
        lens (_name :: ServiceDiscoveryPublicDnsNamespaceResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: ServiceDiscoveryPublicDnsNamespaceResource)

instance HasComputedArn ServiceDiscoveryPublicDnsNamespaceResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

instance HasComputedHostedZone ServiceDiscoveryPublicDnsNamespaceResource Text where
    computedHostedZone =
        to (\_  -> TF.Compute "hosted_zone")

instance HasComputedId ServiceDiscoveryPublicDnsNamespaceResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

serviceDiscoveryPublicDnsNamespaceResource :: TF.Resource TF.AWS ServiceDiscoveryPublicDnsNamespaceResource
serviceDiscoveryPublicDnsNamespaceResource =
    TF.newResource "aws_service_discovery_public_dns_namespace" $
        ServiceDiscoveryPublicDnsNamespaceResource {
            _description = TF.Nil
            , _name = TF.Nil
            }

{- | The @aws_service_discovery_service@ AWS resource.

Provides a Service Discovery Service resource.
-}
data ServiceDiscoveryServiceResource = ServiceDiscoveryServiceResource {
      _description :: !(TF.Argument "description" Text)
    {- ^ (Optional) The description of the service. -}
    , _dns_config :: !(TF.Argument "dns_config" Text)
    {- ^ (Required) A complex type that contains information about the resource record sets that you want Amazon Route 53 to create when you register an instance. -}
    , _health_check_config :: !(TF.Argument "health_check_config" Text)
    {- ^ (Optional) A complex type that contains settings for an optional health check. Only for Public DNS namespaces. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required, ForceNew) The name of the service. -}
    } deriving (Show, Eq)

instance TF.ToHCL ServiceDiscoveryServiceResource where
    toHCL ServiceDiscoveryServiceResource{..} = TF.block $ catMaybes
        [ TF.argument _description
        , TF.argument _dns_config
        , TF.argument _health_check_config
        , TF.argument _name
        ]

instance HasDescription ServiceDiscoveryServiceResource Text where
    description =
        lens (_description :: ServiceDiscoveryServiceResource -> TF.Argument "description" Text)
             (\s a -> s { _description = a } :: ServiceDiscoveryServiceResource)

instance HasDnsConfig ServiceDiscoveryServiceResource Text where
    dnsConfig =
        lens (_dns_config :: ServiceDiscoveryServiceResource -> TF.Argument "dns_config" Text)
             (\s a -> s { _dns_config = a } :: ServiceDiscoveryServiceResource)

instance HasHealthCheckConfig ServiceDiscoveryServiceResource Text where
    healthCheckConfig =
        lens (_health_check_config :: ServiceDiscoveryServiceResource -> TF.Argument "health_check_config" Text)
             (\s a -> s { _health_check_config = a } :: ServiceDiscoveryServiceResource)

instance HasName ServiceDiscoveryServiceResource Text where
    name =
        lens (_name :: ServiceDiscoveryServiceResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: ServiceDiscoveryServiceResource)

serviceDiscoveryServiceResource :: TF.Resource TF.AWS ServiceDiscoveryServiceResource
serviceDiscoveryServiceResource =
    TF.newResource "aws_service_discovery_service" $
        ServiceDiscoveryServiceResource {
            _description = TF.Nil
            , _dns_config = TF.Nil
            , _health_check_config = TF.Nil
            , _name = TF.Nil
            }

{- | The @aws_servicecatalog_portfolio@ AWS resource.

Provides a resource to create a Service Catalog Portfolio.
-}
data ServicecatalogPortfolioResource = ServicecatalogPortfolioResource {
      _description :: !(TF.Argument "description" Text)
    {- ^ (Required) Description of the portfolio -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the portfolio. -}
    , _provider_name :: !(TF.Argument "provider_name" Text)
    {- ^ (Required) Name of the person or organization who owns the portfolio. -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) Tags to apply to the connection. -}
    } deriving (Show, Eq)

instance TF.ToHCL ServicecatalogPortfolioResource where
    toHCL ServicecatalogPortfolioResource{..} = TF.block $ catMaybes
        [ TF.argument _description
        , TF.argument _name
        , TF.argument _provider_name
        , TF.argument _tags
        ]

instance HasDescription ServicecatalogPortfolioResource Text where
    description =
        lens (_description :: ServicecatalogPortfolioResource -> TF.Argument "description" Text)
             (\s a -> s { _description = a } :: ServicecatalogPortfolioResource)

instance HasName ServicecatalogPortfolioResource Text where
    name =
        lens (_name :: ServicecatalogPortfolioResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: ServicecatalogPortfolioResource)

instance HasProviderName ServicecatalogPortfolioResource Text where
    providerName =
        lens (_provider_name :: ServicecatalogPortfolioResource -> TF.Argument "provider_name" Text)
             (\s a -> s { _provider_name = a } :: ServicecatalogPortfolioResource)

instance HasTags ServicecatalogPortfolioResource TF.Tags where
    tags =
        lens (_tags :: ServicecatalogPortfolioResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: ServicecatalogPortfolioResource)

instance HasComputedId ServicecatalogPortfolioResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

servicecatalogPortfolioResource :: TF.Resource TF.AWS ServicecatalogPortfolioResource
servicecatalogPortfolioResource =
    TF.newResource "aws_servicecatalog_portfolio" $
        ServicecatalogPortfolioResource {
            _description = TF.Nil
            , _name = TF.Nil
            , _provider_name = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_ses_active_receipt_rule_set@ AWS resource.

Provides a resource to designate the active SES receipt rule set
-}
data SesActiveReceiptRuleSetResource = SesActiveReceiptRuleSetResource {
      _rule_set_name :: !(TF.Argument "rule_set_name" Text)
    {- ^ (Required) The name of the rule set -}
    } deriving (Show, Eq)

instance TF.ToHCL SesActiveReceiptRuleSetResource where
    toHCL SesActiveReceiptRuleSetResource{..} = TF.block $ catMaybes
        [ TF.argument _rule_set_name
        ]

instance HasRuleSetName SesActiveReceiptRuleSetResource Text where
    ruleSetName =
        lens (_rule_set_name :: SesActiveReceiptRuleSetResource -> TF.Argument "rule_set_name" Text)
             (\s a -> s { _rule_set_name = a } :: SesActiveReceiptRuleSetResource)

sesActiveReceiptRuleSetResource :: TF.Resource TF.AWS SesActiveReceiptRuleSetResource
sesActiveReceiptRuleSetResource =
    TF.newResource "aws_ses_active_receipt_rule_set" $
        SesActiveReceiptRuleSetResource {
            _rule_set_name = TF.Nil
            }

{- | The @aws_ses_configuration_set@ AWS resource.

Provides an SES configuration set resource
-}
data SesConfigurationSetResource = SesConfigurationSetResource {
      _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the configuration set -}
    } deriving (Show, Eq)

instance TF.ToHCL SesConfigurationSetResource where
    toHCL SesConfigurationSetResource{..} = TF.block $ catMaybes
        [ TF.argument _name
        ]

instance HasName SesConfigurationSetResource Text where
    name =
        lens (_name :: SesConfigurationSetResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: SesConfigurationSetResource)

sesConfigurationSetResource :: TF.Resource TF.AWS SesConfigurationSetResource
sesConfigurationSetResource =
    TF.newResource "aws_ses_configuration_set" $
        SesConfigurationSetResource {
            _name = TF.Nil
            }

{- | The @aws_ses_domain_dkim@ AWS resource.

Provides an SES domain DKIM generation resource. Domain ownership needs to
be confirmed first using </docs/providers/aws/r/ses_domain_identity.html>
-}
data SesDomainDkimResource = SesDomainDkimResource {
      _domain :: !(TF.Argument "domain" Text)
    {- ^ (Required) Verified domain name to generate DKIM tokens for. -}
    } deriving (Show, Eq)

instance TF.ToHCL SesDomainDkimResource where
    toHCL SesDomainDkimResource{..} = TF.block $ catMaybes
        [ TF.argument _domain
        ]

instance HasDomain SesDomainDkimResource Text where
    domain =
        lens (_domain :: SesDomainDkimResource -> TF.Argument "domain" Text)
             (\s a -> s { _domain = a } :: SesDomainDkimResource)

instance HasComputedDkimTokens SesDomainDkimResource Text where
    computedDkimTokens =
        to (\_  -> TF.Compute "dkim_tokens")

sesDomainDkimResource :: TF.Resource TF.AWS SesDomainDkimResource
sesDomainDkimResource =
    TF.newResource "aws_ses_domain_dkim" $
        SesDomainDkimResource {
            _domain = TF.Nil
            }

{- | The @aws_ses_domain_identity@ AWS resource.

Provides an SES domain identity resource
-}
data SesDomainIdentityResource = SesDomainIdentityResource {
      _domain :: !(TF.Argument "domain" Text)
    {- ^ (Required) The domain name to assign to SES -}
    } deriving (Show, Eq)

instance TF.ToHCL SesDomainIdentityResource where
    toHCL SesDomainIdentityResource{..} = TF.block $ catMaybes
        [ TF.argument _domain
        ]

instance HasDomain SesDomainIdentityResource Text where
    domain =
        lens (_domain :: SesDomainIdentityResource -> TF.Argument "domain" Text)
             (\s a -> s { _domain = a } :: SesDomainIdentityResource)

instance HasComputedArn SesDomainIdentityResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

instance HasComputedVerificationToken SesDomainIdentityResource Text where
    computedVerificationToken =
        to (\_  -> TF.Compute "verification_token")

sesDomainIdentityResource :: TF.Resource TF.AWS SesDomainIdentityResource
sesDomainIdentityResource =
    TF.newResource "aws_ses_domain_identity" $
        SesDomainIdentityResource {
            _domain = TF.Nil
            }

{- | The @aws_ses_event_destination@ AWS resource.

Provides an SES event destination
-}
data SesEventDestinationResource = SesEventDestinationResource {
      _cloudwatch_destination :: !(TF.Argument "cloudwatch_destination" Text)
    {- ^ (Optional) CloudWatch destination for the events -}
    , _configuration_set_name :: !(TF.Argument "configuration_set_name" Text)
    {- ^ (Required) The name of the configuration set -}
    , _enabled :: !(TF.Argument "enabled" TF.Bool)
    {- ^ (Optional) If true, the event destination will be enabled -}
    , _kinesis_destination :: !(TF.Argument "kinesis_destination" Text)
    {- ^ (Optional) Send the events to a kinesis firehose destination -}
    , _matching_types :: !(TF.Argument "matching_types" Text)
    {- ^ (Required) A list of matching types. May be any of @"send"@ , @"reject"@ , @"bounce"@ , @"complaint"@ , @"delivery"@ , @"open"@ , or @"click"@ . -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the event destination -}
    , _sns_destination :: !(TF.Argument "sns_destination" Text)
    {- ^ (Optional) Send the events to an SNS Topic destination -}
    } deriving (Show, Eq)

instance TF.ToHCL SesEventDestinationResource where
    toHCL SesEventDestinationResource{..} = TF.block $ catMaybes
        [ TF.argument _cloudwatch_destination
        , TF.argument _configuration_set_name
        , TF.argument _enabled
        , TF.argument _kinesis_destination
        , TF.argument _matching_types
        , TF.argument _name
        , TF.argument _sns_destination
        ]

instance HasCloudwatchDestination SesEventDestinationResource Text where
    cloudwatchDestination =
        lens (_cloudwatch_destination :: SesEventDestinationResource -> TF.Argument "cloudwatch_destination" Text)
             (\s a -> s { _cloudwatch_destination = a } :: SesEventDestinationResource)

instance HasConfigurationSetName SesEventDestinationResource Text where
    configurationSetName =
        lens (_configuration_set_name :: SesEventDestinationResource -> TF.Argument "configuration_set_name" Text)
             (\s a -> s { _configuration_set_name = a } :: SesEventDestinationResource)

instance HasEnabled SesEventDestinationResource TF.Bool where
    enabled =
        lens (_enabled :: SesEventDestinationResource -> TF.Argument "enabled" TF.Bool)
             (\s a -> s { _enabled = a } :: SesEventDestinationResource)

instance HasKinesisDestination SesEventDestinationResource Text where
    kinesisDestination =
        lens (_kinesis_destination :: SesEventDestinationResource -> TF.Argument "kinesis_destination" Text)
             (\s a -> s { _kinesis_destination = a } :: SesEventDestinationResource)

instance HasMatchingTypes SesEventDestinationResource Text where
    matchingTypes =
        lens (_matching_types :: SesEventDestinationResource -> TF.Argument "matching_types" Text)
             (\s a -> s { _matching_types = a } :: SesEventDestinationResource)

instance HasName SesEventDestinationResource Text where
    name =
        lens (_name :: SesEventDestinationResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: SesEventDestinationResource)

instance HasSnsDestination SesEventDestinationResource Text where
    snsDestination =
        lens (_sns_destination :: SesEventDestinationResource -> TF.Argument "sns_destination" Text)
             (\s a -> s { _sns_destination = a } :: SesEventDestinationResource)

sesEventDestinationResource :: TF.Resource TF.AWS SesEventDestinationResource
sesEventDestinationResource =
    TF.newResource "aws_ses_event_destination" $
        SesEventDestinationResource {
            _cloudwatch_destination = TF.Nil
            , _configuration_set_name = TF.Nil
            , _enabled = TF.Nil
            , _kinesis_destination = TF.Nil
            , _matching_types = TF.Nil
            , _name = TF.Nil
            , _sns_destination = TF.Nil
            }

{- | The @aws_ses_receipt_filter@ AWS resource.

Provides an SES receipt filter resource
-}
data SesReceiptFilterResource = SesReceiptFilterResource {
      _cidr :: !(TF.Argument "cidr" Text)
    {- ^ (Required) The IP address or address range to filter, in CIDR notation -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the filter -}
    , _policy :: !(TF.Argument "policy" Text)
    {- ^ (Required) Block or Allow -}
    } deriving (Show, Eq)

instance TF.ToHCL SesReceiptFilterResource where
    toHCL SesReceiptFilterResource{..} = TF.block $ catMaybes
        [ TF.argument _cidr
        , TF.argument _name
        , TF.argument _policy
        ]

instance HasCidr SesReceiptFilterResource Text where
    cidr =
        lens (_cidr :: SesReceiptFilterResource -> TF.Argument "cidr" Text)
             (\s a -> s { _cidr = a } :: SesReceiptFilterResource)

instance HasName SesReceiptFilterResource Text where
    name =
        lens (_name :: SesReceiptFilterResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: SesReceiptFilterResource)

instance HasPolicy SesReceiptFilterResource Text where
    policy =
        lens (_policy :: SesReceiptFilterResource -> TF.Argument "policy" Text)
             (\s a -> s { _policy = a } :: SesReceiptFilterResource)

sesReceiptFilterResource :: TF.Resource TF.AWS SesReceiptFilterResource
sesReceiptFilterResource =
    TF.newResource "aws_ses_receipt_filter" $
        SesReceiptFilterResource {
            _cidr = TF.Nil
            , _name = TF.Nil
            , _policy = TF.Nil
            }

{- | The @aws_ses_receipt_rule@ AWS resource.

Provides an SES receipt rule resource
-}
data SesReceiptRuleResource = SesReceiptRuleResource {
      _add_header_action :: !(TF.Argument "add_header_action" Text)
    {- ^ (Optional) A list of Add Header Action blocks. Documented below. -}
    , _after :: !(TF.Argument "after" Text)
    {- ^ (Optional) The name of the rule to place this rule after -}
    , _bounce_action :: !(TF.Argument "bounce_action" Text)
    {- ^ (Optional) A list of Bounce Action blocks. Documented below. -}
    , _enabled :: !(TF.Argument "enabled" TF.Bool)
    {- ^ (Optional) If true, the rule will be enabled -}
    , _lambda_action :: !(TF.Argument "lambda_action" Text)
    {- ^ (Optional) A list of Lambda Action blocks. Documented below. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the rule -}
    , _recipients :: !(TF.Argument "recipients" Text)
    {- ^ (Optional) A list of email addresses -}
    , _rule_set_name :: !(TF.Argument "rule_set_name" Text)
    {- ^ (Required) The name of the rule set -}
    , _s3_action :: !(TF.Argument "s3_action" Text)
    {- ^ (Optional) A list of S3 Action blocks. Documented below. -}
    , _scan_enabled :: !(TF.Argument "scan_enabled" TF.Bool)
    {- ^ (Optional) If true, incoming emails will be scanned for spam and viruses -}
    , _sns_action :: !(TF.Argument "sns_action" Text)
    {- ^ (Optional) A list of SNS Action blocks. Documented below. -}
    , _stop_action :: !(TF.Argument "stop_action" Text)
    {- ^ (Optional) A list of Stop Action blocks. Documented below. -}
    , _tls_policy :: !(TF.Argument "tls_policy" Text)
    {- ^ (Optional) Require or Optional -}
    , _workmail_action :: !(TF.Argument "workmail_action" Text)
    {- ^ (Optional) A list of WorkMail Action blocks. Documented below. -}
    } deriving (Show, Eq)

instance TF.ToHCL SesReceiptRuleResource where
    toHCL SesReceiptRuleResource{..} = TF.block $ catMaybes
        [ TF.argument _add_header_action
        , TF.argument _after
        , TF.argument _bounce_action
        , TF.argument _enabled
        , TF.argument _lambda_action
        , TF.argument _name
        , TF.argument _recipients
        , TF.argument _rule_set_name
        , TF.argument _s3_action
        , TF.argument _scan_enabled
        , TF.argument _sns_action
        , TF.argument _stop_action
        , TF.argument _tls_policy
        , TF.argument _workmail_action
        ]

instance HasAddHeaderAction SesReceiptRuleResource Text where
    addHeaderAction =
        lens (_add_header_action :: SesReceiptRuleResource -> TF.Argument "add_header_action" Text)
             (\s a -> s { _add_header_action = a } :: SesReceiptRuleResource)

instance HasAfter SesReceiptRuleResource Text where
    after =
        lens (_after :: SesReceiptRuleResource -> TF.Argument "after" Text)
             (\s a -> s { _after = a } :: SesReceiptRuleResource)

instance HasBounceAction SesReceiptRuleResource Text where
    bounceAction =
        lens (_bounce_action :: SesReceiptRuleResource -> TF.Argument "bounce_action" Text)
             (\s a -> s { _bounce_action = a } :: SesReceiptRuleResource)

instance HasEnabled SesReceiptRuleResource TF.Bool where
    enabled =
        lens (_enabled :: SesReceiptRuleResource -> TF.Argument "enabled" TF.Bool)
             (\s a -> s { _enabled = a } :: SesReceiptRuleResource)

instance HasLambdaAction SesReceiptRuleResource Text where
    lambdaAction =
        lens (_lambda_action :: SesReceiptRuleResource -> TF.Argument "lambda_action" Text)
             (\s a -> s { _lambda_action = a } :: SesReceiptRuleResource)

instance HasName SesReceiptRuleResource Text where
    name =
        lens (_name :: SesReceiptRuleResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: SesReceiptRuleResource)

instance HasRecipients SesReceiptRuleResource Text where
    recipients =
        lens (_recipients :: SesReceiptRuleResource -> TF.Argument "recipients" Text)
             (\s a -> s { _recipients = a } :: SesReceiptRuleResource)

instance HasRuleSetName SesReceiptRuleResource Text where
    ruleSetName =
        lens (_rule_set_name :: SesReceiptRuleResource -> TF.Argument "rule_set_name" Text)
             (\s a -> s { _rule_set_name = a } :: SesReceiptRuleResource)

instance HasS3Action SesReceiptRuleResource Text where
    s3Action =
        lens (_s3_action :: SesReceiptRuleResource -> TF.Argument "s3_action" Text)
             (\s a -> s { _s3_action = a } :: SesReceiptRuleResource)

instance HasScanEnabled SesReceiptRuleResource TF.Bool where
    scanEnabled =
        lens (_scan_enabled :: SesReceiptRuleResource -> TF.Argument "scan_enabled" TF.Bool)
             (\s a -> s { _scan_enabled = a } :: SesReceiptRuleResource)

instance HasSnsAction SesReceiptRuleResource Text where
    snsAction =
        lens (_sns_action :: SesReceiptRuleResource -> TF.Argument "sns_action" Text)
             (\s a -> s { _sns_action = a } :: SesReceiptRuleResource)

instance HasStopAction SesReceiptRuleResource Text where
    stopAction =
        lens (_stop_action :: SesReceiptRuleResource -> TF.Argument "stop_action" Text)
             (\s a -> s { _stop_action = a } :: SesReceiptRuleResource)

instance HasTlsPolicy SesReceiptRuleResource Text where
    tlsPolicy =
        lens (_tls_policy :: SesReceiptRuleResource -> TF.Argument "tls_policy" Text)
             (\s a -> s { _tls_policy = a } :: SesReceiptRuleResource)

instance HasWorkmailAction SesReceiptRuleResource Text where
    workmailAction =
        lens (_workmail_action :: SesReceiptRuleResource -> TF.Argument "workmail_action" Text)
             (\s a -> s { _workmail_action = a } :: SesReceiptRuleResource)

sesReceiptRuleResource :: TF.Resource TF.AWS SesReceiptRuleResource
sesReceiptRuleResource =
    TF.newResource "aws_ses_receipt_rule" $
        SesReceiptRuleResource {
            _add_header_action = TF.Nil
            , _after = TF.Nil
            , _bounce_action = TF.Nil
            , _enabled = TF.Nil
            , _lambda_action = TF.Nil
            , _name = TF.Nil
            , _recipients = TF.Nil
            , _rule_set_name = TF.Nil
            , _s3_action = TF.Nil
            , _scan_enabled = TF.Nil
            , _sns_action = TF.Nil
            , _stop_action = TF.Nil
            , _tls_policy = TF.Nil
            , _workmail_action = TF.Nil
            }

{- | The @aws_ses_receipt_rule_set@ AWS resource.

Provides an SES receipt rule set resource
-}
data SesReceiptRuleSetResource = SesReceiptRuleSetResource {
      _rule_set_name :: !(TF.Argument "rule_set_name" Text)
    {- ^ (Required) The name of the rule set -}
    } deriving (Show, Eq)

instance TF.ToHCL SesReceiptRuleSetResource where
    toHCL SesReceiptRuleSetResource{..} = TF.block $ catMaybes
        [ TF.argument _rule_set_name
        ]

instance HasRuleSetName SesReceiptRuleSetResource Text where
    ruleSetName =
        lens (_rule_set_name :: SesReceiptRuleSetResource -> TF.Argument "rule_set_name" Text)
             (\s a -> s { _rule_set_name = a } :: SesReceiptRuleSetResource)

sesReceiptRuleSetResource :: TF.Resource TF.AWS SesReceiptRuleSetResource
sesReceiptRuleSetResource =
    TF.newResource "aws_ses_receipt_rule_set" $
        SesReceiptRuleSetResource {
            _rule_set_name = TF.Nil
            }

{- | The @aws_ses_template@ AWS resource.

Provides a resource to create a SES template.
-}
data SesTemplateResource = SesTemplateResource {
      _html :: !(TF.Argument "html" Text)
    {- ^ (Optional) The HTML body of the email. Must be less than 500KB in size, including both the text and HTML parts. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the template. Cannot exceed 64 characters. You will refer to this name when you send email. -}
    , _subject :: !(TF.Argument "subject" Text)
    {- ^ (Optional) The subject line of the email. -}
    , _text :: !(TF.Argument "text" Text)
    {- ^ (Optional) The email body that will be visible to recipients whose email clients do not display HTML. Must be less than 500KB in size, including both the text and HTML parts. -}
    } deriving (Show, Eq)

instance TF.ToHCL SesTemplateResource where
    toHCL SesTemplateResource{..} = TF.block $ catMaybes
        [ TF.argument _html
        , TF.argument _name
        , TF.argument _subject
        , TF.argument _text
        ]

instance HasHtml SesTemplateResource Text where
    html =
        lens (_html :: SesTemplateResource -> TF.Argument "html" Text)
             (\s a -> s { _html = a } :: SesTemplateResource)

instance HasName SesTemplateResource Text where
    name =
        lens (_name :: SesTemplateResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: SesTemplateResource)

instance HasSubject SesTemplateResource Text where
    subject =
        lens (_subject :: SesTemplateResource -> TF.Argument "subject" Text)
             (\s a -> s { _subject = a } :: SesTemplateResource)

instance HasText SesTemplateResource Text where
    text =
        lens (_text :: SesTemplateResource -> TF.Argument "text" Text)
             (\s a -> s { _text = a } :: SesTemplateResource)

instance HasComputedId SesTemplateResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

sesTemplateResource :: TF.Resource TF.AWS SesTemplateResource
sesTemplateResource =
    TF.newResource "aws_ses_template" $
        SesTemplateResource {
            _html = TF.Nil
            , _name = TF.Nil
            , _subject = TF.Nil
            , _text = TF.Nil
            }

{- | The @aws_simpledb_domain@ AWS resource.

Provides a SimpleDB domain resource
-}
data SimpledbDomainResource = SimpledbDomainResource {
      _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the SimpleDB domain -}
    } deriving (Show, Eq)

instance TF.ToHCL SimpledbDomainResource where
    toHCL SimpledbDomainResource{..} = TF.block $ catMaybes
        [ TF.argument _name
        ]

instance HasName SimpledbDomainResource Text where
    name =
        lens (_name :: SimpledbDomainResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: SimpledbDomainResource)

instance HasComputedId SimpledbDomainResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

simpledbDomainResource :: TF.Resource TF.AWS SimpledbDomainResource
simpledbDomainResource =
    TF.newResource "aws_simpledb_domain" $
        SimpledbDomainResource {
            _name = TF.Nil
            }

{- | The @aws_snapshot_create_volume_permission@ AWS resource.

Adds permission to create volumes off of a given EBS Snapshot.
-}
data SnapshotCreateVolumePermissionResource = SnapshotCreateVolumePermissionResource {
      _account_id :: !(TF.Argument "account_id" Text)
    {- ^ - (required) An AWS Account ID to add create volume permissions -}
    , _snapshot_id :: !(TF.Argument "snapshot_id" Text)
    {- ^ - (required) A snapshot ID -}
    } deriving (Show, Eq)

instance TF.ToHCL SnapshotCreateVolumePermissionResource where
    toHCL SnapshotCreateVolumePermissionResource{..} = TF.block $ catMaybes
        [ TF.argument _account_id
        , TF.argument _snapshot_id
        ]

instance HasAccountId SnapshotCreateVolumePermissionResource Text where
    accountId =
        lens (_account_id :: SnapshotCreateVolumePermissionResource -> TF.Argument "account_id" Text)
             (\s a -> s { _account_id = a } :: SnapshotCreateVolumePermissionResource)

instance HasSnapshotId SnapshotCreateVolumePermissionResource Text where
    snapshotId =
        lens (_snapshot_id :: SnapshotCreateVolumePermissionResource -> TF.Argument "snapshot_id" Text)
             (\s a -> s { _snapshot_id = a } :: SnapshotCreateVolumePermissionResource)

instance HasComputedId SnapshotCreateVolumePermissionResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

snapshotCreateVolumePermissionResource :: TF.Resource TF.AWS SnapshotCreateVolumePermissionResource
snapshotCreateVolumePermissionResource =
    TF.newResource "aws_snapshot_create_volume_permission" $
        SnapshotCreateVolumePermissionResource {
            _account_id = TF.Nil
            , _snapshot_id = TF.Nil
            }

{- | The @aws_sns_topic_policy@ AWS resource.

Provides an SNS topic policy resource ~> NOTE: If a Principal is specified
as just an AWS account ID rather than an ARN, AWS silently converts it to
the ARN for the root user, causing future terraform plans to differ. To
avoid this problem, just specify the full ARN, e.g.
@arn:aws:iam::123456789012:root@
-}
data SnsTopicPolicyResource = SnsTopicPolicyResource {
      _arn :: !(TF.Argument "arn" Text)
    {- ^ (Required) The ARN of the SNS topic -}
    , _policy :: !(TF.Argument "policy" Text)
    {- ^ (Required) The fully-formed AWS policy as JSON -}
    } deriving (Show, Eq)

instance TF.ToHCL SnsTopicPolicyResource where
    toHCL SnsTopicPolicyResource{..} = TF.block $ catMaybes
        [ TF.argument _arn
        , TF.argument _policy
        ]

instance HasArn SnsTopicPolicyResource Text where
    arn =
        lens (_arn :: SnsTopicPolicyResource -> TF.Argument "arn" Text)
             (\s a -> s { _arn = a } :: SnsTopicPolicyResource)

instance HasPolicy SnsTopicPolicyResource Text where
    policy =
        lens (_policy :: SnsTopicPolicyResource -> TF.Argument "policy" Text)
             (\s a -> s { _policy = a } :: SnsTopicPolicyResource)

snsTopicPolicyResource :: TF.Resource TF.AWS SnsTopicPolicyResource
snsTopicPolicyResource =
    TF.newResource "aws_sns_topic_policy" $
        SnsTopicPolicyResource {
            _arn = TF.Nil
            , _policy = TF.Nil
            }

{- | The @aws_sns_topic@ AWS resource.

Provides an SNS topic resource
-}
data SnsTopicResource = SnsTopicResource {
      _delivery_policy :: !(TF.Argument "delivery_policy" Text)
    {- ^ (Optional) The SNS delivery policy -}
    , _display_name :: !(TF.Argument "display_name" Text)
    {- ^ (Optional) The display name for the SNS topic -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The friendly name for the SNS topic -}
    , _policy :: !(TF.Argument "policy" Text)
    {- ^ (Optional) The fully-formed AWS policy as JSON -}
    } deriving (Show, Eq)

instance TF.ToHCL SnsTopicResource where
    toHCL SnsTopicResource{..} = TF.block $ catMaybes
        [ TF.argument _delivery_policy
        , TF.argument _display_name
        , TF.argument _name
        , TF.argument _policy
        ]

instance HasDeliveryPolicy SnsTopicResource Text where
    deliveryPolicy =
        lens (_delivery_policy :: SnsTopicResource -> TF.Argument "delivery_policy" Text)
             (\s a -> s { _delivery_policy = a } :: SnsTopicResource)

instance HasDisplayName SnsTopicResource Text where
    displayName =
        lens (_display_name :: SnsTopicResource -> TF.Argument "display_name" Text)
             (\s a -> s { _display_name = a } :: SnsTopicResource)

instance HasName SnsTopicResource Text where
    name =
        lens (_name :: SnsTopicResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: SnsTopicResource)

instance HasPolicy SnsTopicResource Text where
    policy =
        lens (_policy :: SnsTopicResource -> TF.Argument "policy" Text)
             (\s a -> s { _policy = a } :: SnsTopicResource)

instance HasComputedArn SnsTopicResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

instance HasComputedId SnsTopicResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

snsTopicResource :: TF.Resource TF.AWS SnsTopicResource
snsTopicResource =
    TF.newResource "aws_sns_topic" $
        SnsTopicResource {
            _delivery_policy = TF.Nil
            , _display_name = TF.Nil
            , _name = TF.Nil
            , _policy = TF.Nil
            }

{- | The @aws_sns_topic_subscription@ AWS resource.

Provides a resource for subscribing to SNS topics. Requires that an SNS
topic exist for the subscription to attach to. This resource allows you to
automatically place messages sent to SNS topics in SQS queues, send them as
HTTP(S) POST requests to a given endpoint, send SMS messages, or notify
devices / applications. The most likely use case for Terraform users will
probably be SQS queues. ~> NOTE: If SNS topic and SQS queue are in different
AWS regions it is important to place the "aws_sns_topic_subscription" into
the terraform configuration of the region with the SQS queue. If
"aws_sns_topic_subscription" is placed in the terraform configuration of the
region with the SNS topic terraform will fail to create the subscription. ~>
NOTE: Setup of cross-account subscriptions from SNS topics to SQS queues
requires Terraform to have access to BOTH accounts. ~> NOTE: If SNS topic
and SQS queue are in different AWS accounts but the same region it is
important to place the "aws_sns_topic_subscription" into the terraform
configuration of the account with the SQS queue. If
"aws_sns_topic_subscription" is placed in the terraform configuration of the
account with the SNS topic terraform creates the subscriptions but does not
keep state and tries to re-create the subscription at every apply. ~> NOTE:
If SNS topic and SQS queue are in different AWS accounts and different AWS
regions it is important to recognize that the subscription needs to be
initiated from the account with the SQS queue but in the region of the SNS
topic.
-}
data SnsTopicSubscriptionResource = SnsTopicSubscriptionResource {
      _confirmation_timeout_in_minutes :: !(TF.Argument "confirmation_timeout_in_minutes" Text)
    {- ^ (Optional) Integer indicating number of minutes to wait in retying mode for fetching subscription arn before marking it as failure. Only applicable for http and https protocols (default is 1 minute). -}
    , _endpoint :: !(TF.Argument "endpoint" Text)
    {- ^ (Required) The endpoint to send data to, the contents will vary with the protocol. (see below for more information) -}
    , _endpoint_auto_confirms :: !(TF.Argument "endpoint_auto_confirms" Text)
    {- ^ (Optional) Boolean indicating whether the end point is capable of <http://docs.aws.amazon.com/sns/latest/dg/SendMessageToHttp.html#SendMessageToHttp.prepare> e.g., PagerDuty (default is false) -}
    , _protocol :: !(TF.Argument "protocol" Text)
    {- ^ (Required) The protocol to use. The possible values for this are: @sqs@ , @sms@ , @lambda@ , @application@ . ( @http@ or @https@ are partially supported, see below) ( @email@ is option but unsupported, see below). -}
    , _raw_message_delivery :: !(TF.Argument "raw_message_delivery" Text)
    {- ^ (Optional) Boolean indicating whether or not to enable raw message delivery (the original message is directly passed, not wrapped in JSON with the original message in the message property) (default is false). -}
    , _topic_arn :: !(TF.Argument "topic_arn" Text)
    {- ^ (Required) The ARN of the SNS topic to subscribe to -}
    } deriving (Show, Eq)

instance TF.ToHCL SnsTopicSubscriptionResource where
    toHCL SnsTopicSubscriptionResource{..} = TF.block $ catMaybes
        [ TF.argument _confirmation_timeout_in_minutes
        , TF.argument _endpoint
        , TF.argument _endpoint_auto_confirms
        , TF.argument _protocol
        , TF.argument _raw_message_delivery
        , TF.argument _topic_arn
        ]

instance HasConfirmationTimeoutInMinutes SnsTopicSubscriptionResource Text where
    confirmationTimeoutInMinutes =
        lens (_confirmation_timeout_in_minutes :: SnsTopicSubscriptionResource -> TF.Argument "confirmation_timeout_in_minutes" Text)
             (\s a -> s { _confirmation_timeout_in_minutes = a } :: SnsTopicSubscriptionResource)

instance HasEndpoint SnsTopicSubscriptionResource Text where
    endpoint =
        lens (_endpoint :: SnsTopicSubscriptionResource -> TF.Argument "endpoint" Text)
             (\s a -> s { _endpoint = a } :: SnsTopicSubscriptionResource)

instance HasEndpointAutoConfirms SnsTopicSubscriptionResource Text where
    endpointAutoConfirms =
        lens (_endpoint_auto_confirms :: SnsTopicSubscriptionResource -> TF.Argument "endpoint_auto_confirms" Text)
             (\s a -> s { _endpoint_auto_confirms = a } :: SnsTopicSubscriptionResource)

instance HasProtocol SnsTopicSubscriptionResource Text where
    protocol =
        lens (_protocol :: SnsTopicSubscriptionResource -> TF.Argument "protocol" Text)
             (\s a -> s { _protocol = a } :: SnsTopicSubscriptionResource)

instance HasRawMessageDelivery SnsTopicSubscriptionResource Text where
    rawMessageDelivery =
        lens (_raw_message_delivery :: SnsTopicSubscriptionResource -> TF.Argument "raw_message_delivery" Text)
             (\s a -> s { _raw_message_delivery = a } :: SnsTopicSubscriptionResource)

instance HasTopicArn SnsTopicSubscriptionResource Text where
    topicArn =
        lens (_topic_arn :: SnsTopicSubscriptionResource -> TF.Argument "topic_arn" Text)
             (\s a -> s { _topic_arn = a } :: SnsTopicSubscriptionResource)

snsTopicSubscriptionResource :: TF.Resource TF.AWS SnsTopicSubscriptionResource
snsTopicSubscriptionResource =
    TF.newResource "aws_sns_topic_subscription" $
        SnsTopicSubscriptionResource {
            _confirmation_timeout_in_minutes = TF.Nil
            , _endpoint = TF.Nil
            , _endpoint_auto_confirms = TF.Nil
            , _protocol = TF.Nil
            , _raw_message_delivery = TF.Nil
            , _topic_arn = TF.Nil
            }

{- | The @aws_spot_datafeed_subscription@ AWS resource.

-> Note: There is only a single subscription allowed per account. To help
you understand the charges for your Spot instances, Amazon EC2 provides a
data feed that describes your Spot instance usage and pricing. This data
feed is sent to an Amazon S3 bucket that you specify when you subscribe to
the data feed.
-}
data SpotDatafeedSubscriptionResource = SpotDatafeedSubscriptionResource {
      _bucket :: !(TF.Argument "bucket" Text)
    {- ^ (Required) The Amazon S3 bucket in which to store the Spot instance data feed. -}
    , _prefix :: !(TF.Argument "prefix" Text)
    {- ^ (Optional) Path of folder inside bucket to place spot pricing data. -}
    } deriving (Show, Eq)

instance TF.ToHCL SpotDatafeedSubscriptionResource where
    toHCL SpotDatafeedSubscriptionResource{..} = TF.block $ catMaybes
        [ TF.argument _bucket
        , TF.argument _prefix
        ]

instance HasBucket SpotDatafeedSubscriptionResource Text where
    bucket =
        lens (_bucket :: SpotDatafeedSubscriptionResource -> TF.Argument "bucket" Text)
             (\s a -> s { _bucket = a } :: SpotDatafeedSubscriptionResource)

instance HasPrefix SpotDatafeedSubscriptionResource Text where
    prefix =
        lens (_prefix :: SpotDatafeedSubscriptionResource -> TF.Argument "prefix" Text)
             (\s a -> s { _prefix = a } :: SpotDatafeedSubscriptionResource)

spotDatafeedSubscriptionResource :: TF.Resource TF.AWS SpotDatafeedSubscriptionResource
spotDatafeedSubscriptionResource =
    TF.newResource "aws_spot_datafeed_subscription" $
        SpotDatafeedSubscriptionResource {
            _bucket = TF.Nil
            , _prefix = TF.Nil
            }

{- | The @aws_spot_fleet_request@ AWS resource.

Provides an EC2 Spot Fleet Request resource. This allows a fleet of Spot
instances to be requested on the Spot market.
-}
data SpotFleetRequestResource = SpotFleetRequestResource {
      _allocation_strategy :: !(TF.Argument "allocation_strategy" Text)
    {- ^ - Indicates how to allocate the target capacity across the Spot pools specified by the Spot fleet request. The default is lowestPrice. -}
    , _excess_capacity_termination_policy :: !(TF.Argument "excess_capacity_termination_policy" Text)
    {- ^ - Indicates whether running Spot instances should be terminated if the target capacity of the Spot fleet request is decreased below the current size of the Spot fleet. -}
    , _iam_fleet_role :: !(TF.Argument "iam_fleet_role" Text)
    {- ^ (Required) Grants the Spot fleet permission to terminate Spot instances on your behalf when you cancel its Spot fleet request using CancelSpotFleetRequests or when the Spot fleet request expires, if you set terminateInstancesWithExpiration. -}
    , _instance_interruption_behavior :: !(TF.Argument "instance_interruption_behavior" Text)
    {- ^ (Optional) Indicates whether a Spot instance stops or terminates when it is interrupted. Default is @terminate@ . -}
    , _launch_specification :: !(TF.Argument "launch_specification" Text)
    {- ^ - Used to define the launch configuration of the spot-fleet request. Can be specified multiple times to define different bids across different markets and instance types. -}
    , _replace_unhealthy_instances :: !(TF.Argument "replace_unhealthy_instances" Text)
    {- ^ (Optional) Indicates whether Spot fleet should replace unhealthy instances. Default @false@ . -}
    , _spot_price :: !(TF.Argument "spot_price" Text)
    {- ^ (Required) The bid price per unit hour. -}
    , _target_capacity :: !(TF.Argument "target_capacity" Text)
    {- ^ - The number of units to request. You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O. -}
    , _terminate_instances_with_expiration :: !(TF.Argument "terminate_instances_with_expiration" Text)
    {- ^ - Indicates whether running Spot instances should be terminated when the Spot fleet request expires. -}
    , _valid_until :: !(TF.Argument "valid_until" Text)
    {- ^ - The end date and time of the request, in UTC ISO8601 format (for example, YYYY-MM-DDTHH:MM:SSZ). At this point, no new Spot instance requests are placed or enabled to fulfill the request. Defaults to 24 hours. -}
    , _wait_for_fulfillment :: !(TF.Argument "wait_for_fulfillment" Text)
    {- ^ (Optional; Default: false) If set, Terraform will wait for the Spot Request to be fulfilled, and will throw an error if the timeout of 10m is reached. -}
    } deriving (Show, Eq)

instance TF.ToHCL SpotFleetRequestResource where
    toHCL SpotFleetRequestResource{..} = TF.block $ catMaybes
        [ TF.argument _allocation_strategy
        , TF.argument _excess_capacity_termination_policy
        , TF.argument _iam_fleet_role
        , TF.argument _instance_interruption_behavior
        , TF.argument _launch_specification
        , TF.argument _replace_unhealthy_instances
        , TF.argument _spot_price
        , TF.argument _target_capacity
        , TF.argument _terminate_instances_with_expiration
        , TF.argument _valid_until
        , TF.argument _wait_for_fulfillment
        ]

instance HasAllocationStrategy SpotFleetRequestResource Text where
    allocationStrategy =
        lens (_allocation_strategy :: SpotFleetRequestResource -> TF.Argument "allocation_strategy" Text)
             (\s a -> s { _allocation_strategy = a } :: SpotFleetRequestResource)

instance HasExcessCapacityTerminationPolicy SpotFleetRequestResource Text where
    excessCapacityTerminationPolicy =
        lens (_excess_capacity_termination_policy :: SpotFleetRequestResource -> TF.Argument "excess_capacity_termination_policy" Text)
             (\s a -> s { _excess_capacity_termination_policy = a } :: SpotFleetRequestResource)

instance HasIamFleetRole SpotFleetRequestResource Text where
    iamFleetRole =
        lens (_iam_fleet_role :: SpotFleetRequestResource -> TF.Argument "iam_fleet_role" Text)
             (\s a -> s { _iam_fleet_role = a } :: SpotFleetRequestResource)

instance HasInstanceInterruptionBehavior SpotFleetRequestResource Text where
    instanceInterruptionBehavior =
        lens (_instance_interruption_behavior :: SpotFleetRequestResource -> TF.Argument "instance_interruption_behavior" Text)
             (\s a -> s { _instance_interruption_behavior = a } :: SpotFleetRequestResource)

instance HasLaunchSpecification SpotFleetRequestResource Text where
    launchSpecification =
        lens (_launch_specification :: SpotFleetRequestResource -> TF.Argument "launch_specification" Text)
             (\s a -> s { _launch_specification = a } :: SpotFleetRequestResource)

instance HasReplaceUnhealthyInstances SpotFleetRequestResource Text where
    replaceUnhealthyInstances =
        lens (_replace_unhealthy_instances :: SpotFleetRequestResource -> TF.Argument "replace_unhealthy_instances" Text)
             (\s a -> s { _replace_unhealthy_instances = a } :: SpotFleetRequestResource)

instance HasSpotPrice SpotFleetRequestResource Text where
    spotPrice =
        lens (_spot_price :: SpotFleetRequestResource -> TF.Argument "spot_price" Text)
             (\s a -> s { _spot_price = a } :: SpotFleetRequestResource)

instance HasTargetCapacity SpotFleetRequestResource Text where
    targetCapacity =
        lens (_target_capacity :: SpotFleetRequestResource -> TF.Argument "target_capacity" Text)
             (\s a -> s { _target_capacity = a } :: SpotFleetRequestResource)

instance HasTerminateInstancesWithExpiration SpotFleetRequestResource Text where
    terminateInstancesWithExpiration =
        lens (_terminate_instances_with_expiration :: SpotFleetRequestResource -> TF.Argument "terminate_instances_with_expiration" Text)
             (\s a -> s { _terminate_instances_with_expiration = a } :: SpotFleetRequestResource)

instance HasValidUntil SpotFleetRequestResource Text where
    validUntil =
        lens (_valid_until :: SpotFleetRequestResource -> TF.Argument "valid_until" Text)
             (\s a -> s { _valid_until = a } :: SpotFleetRequestResource)

instance HasWaitForFulfillment SpotFleetRequestResource Text where
    waitForFulfillment =
        lens (_wait_for_fulfillment :: SpotFleetRequestResource -> TF.Argument "wait_for_fulfillment" Text)
             (\s a -> s { _wait_for_fulfillment = a } :: SpotFleetRequestResource)

spotFleetRequestResource :: TF.Resource TF.AWS SpotFleetRequestResource
spotFleetRequestResource =
    TF.newResource "aws_spot_fleet_request" $
        SpotFleetRequestResource {
            _allocation_strategy = TF.Nil
            , _excess_capacity_termination_policy = TF.Nil
            , _iam_fleet_role = TF.Nil
            , _instance_interruption_behavior = TF.Nil
            , _launch_specification = TF.Nil
            , _replace_unhealthy_instances = TF.Nil
            , _spot_price = TF.Nil
            , _target_capacity = TF.Nil
            , _terminate_instances_with_expiration = TF.Nil
            , _valid_until = TF.Nil
            , _wait_for_fulfillment = TF.Nil
            }

{- | The @aws_spot_instance_request@ AWS resource.

Provides an EC2 Spot Instance Request resource. This allows instances to be
requested on the spot market. Terraform always creates Spot Instance
Requests with a @persistent@ type, which means that for the duration of
their lifetime, AWS will launch an instance with the configured details if
and when the spot market will accept the requested price. On destruction,
Terraform will make an attempt to terminate the associated Spot Instance if
there is one present. ~> NOTE: Because their behavior depends on the live
status of the spot market, Spot Instance Requests have a unique lifecycle
that makes them behave differently than other Terraform resources. Most
importantly: there is no guarantee that a Spot Instance exists to fulfill
the request at any given point in time. See the
<https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-spot-instances.html>
for more information.
-}
data SpotInstanceRequestResource = SpotInstanceRequestResource {
      _block_duration_minutes :: !(TF.Argument "block_duration_minutes" Text)
    {- ^ (Optional) The required duration for the Spot instances, in minutes. This value must be a multiple of 60 (60, 120, 180, 240, 300, or 360). The duration period starts as soon as your Spot instance receives its instance ID. At the end of the duration period, Amazon EC2 marks the Spot instance for termination and provides a Spot instance termination notice, which gives the instance a two-minute warning before it terminates. Note that you can't specify an Availability Zone group or a launch group if you specify a duration. -}
    , _instance_interruption_behavior :: !(TF.Argument "instance_interruption_behavior" Text)
    {- ^ (Optional) Indicates whether a Spot instance stops or terminates when it is interrupted. Default is @terminate@ as this is the current AWS behaviour. -}
    , _launch_group :: !(TF.Argument "launch_group" Text)
    {- ^ (Optional) A launch group is a group of spot instances that launch together and terminate together. If left empty instances are launched and terminated individually. -}
    , _spot_price :: !(TF.Argument "spot_price" Text)
    {- ^ (Required) The price to request on the spot market. -}
    , _spot_type :: !(TF.Argument "spot_type" Text)
    {- ^ (Optional; Default: "persistent") If set to "one-time", after the instance is terminated, the spot request will be closed. Also, Terraform can't manage one-time spot requests, just launch them. -}
    , _wait_for_fulfillment :: !(TF.Argument "wait_for_fulfillment" Text)
    {- ^ (Optional; Default: false) If set, Terraform will wait for the Spot Request to be fulfilled, and will throw an error if the timeout of 10m is reached. -}
    } deriving (Show, Eq)

instance TF.ToHCL SpotInstanceRequestResource where
    toHCL SpotInstanceRequestResource{..} = TF.block $ catMaybes
        [ TF.argument _block_duration_minutes
        , TF.argument _instance_interruption_behavior
        , TF.argument _launch_group
        , TF.argument _spot_price
        , TF.argument _spot_type
        , TF.argument _wait_for_fulfillment
        ]

instance HasBlockDurationMinutes SpotInstanceRequestResource Text where
    blockDurationMinutes =
        lens (_block_duration_minutes :: SpotInstanceRequestResource -> TF.Argument "block_duration_minutes" Text)
             (\s a -> s { _block_duration_minutes = a } :: SpotInstanceRequestResource)

instance HasInstanceInterruptionBehavior SpotInstanceRequestResource Text where
    instanceInterruptionBehavior =
        lens (_instance_interruption_behavior :: SpotInstanceRequestResource -> TF.Argument "instance_interruption_behavior" Text)
             (\s a -> s { _instance_interruption_behavior = a } :: SpotInstanceRequestResource)

instance HasLaunchGroup SpotInstanceRequestResource Text where
    launchGroup =
        lens (_launch_group :: SpotInstanceRequestResource -> TF.Argument "launch_group" Text)
             (\s a -> s { _launch_group = a } :: SpotInstanceRequestResource)

instance HasSpotPrice SpotInstanceRequestResource Text where
    spotPrice =
        lens (_spot_price :: SpotInstanceRequestResource -> TF.Argument "spot_price" Text)
             (\s a -> s { _spot_price = a } :: SpotInstanceRequestResource)

instance HasSpotType SpotInstanceRequestResource Text where
    spotType =
        lens (_spot_type :: SpotInstanceRequestResource -> TF.Argument "spot_type" Text)
             (\s a -> s { _spot_type = a } :: SpotInstanceRequestResource)

instance HasWaitForFulfillment SpotInstanceRequestResource Text where
    waitForFulfillment =
        lens (_wait_for_fulfillment :: SpotInstanceRequestResource -> TF.Argument "wait_for_fulfillment" Text)
             (\s a -> s { _wait_for_fulfillment = a } :: SpotInstanceRequestResource)

spotInstanceRequestResource :: TF.Resource TF.AWS SpotInstanceRequestResource
spotInstanceRequestResource =
    TF.newResource "aws_spot_instance_request" $
        SpotInstanceRequestResource {
            _block_duration_minutes = TF.Nil
            , _instance_interruption_behavior = TF.Nil
            , _launch_group = TF.Nil
            , _spot_price = TF.Nil
            , _spot_type = TF.Nil
            , _wait_for_fulfillment = TF.Nil
            }

{- | The @aws_sqs_queue_policy@ AWS resource.

Allows you to set a policy of an SQS Queue while referencing ARN of the
queue within the policy.
-}
data SqsQueuePolicyResource = SqsQueuePolicyResource {
      _policy :: !(TF.Argument "policy" Text)
    {- ^ (Required) The JSON policy for the SQS queue -}
    , _queue_url :: !(TF.Argument "queue_url" Text)
    {- ^ (Required) The URL of the SQS Queue to which to attach the policy -}
    } deriving (Show, Eq)

instance TF.ToHCL SqsQueuePolicyResource where
    toHCL SqsQueuePolicyResource{..} = TF.block $ catMaybes
        [ TF.argument _policy
        , TF.argument _queue_url
        ]

instance HasPolicy SqsQueuePolicyResource Text where
    policy =
        lens (_policy :: SqsQueuePolicyResource -> TF.Argument "policy" Text)
             (\s a -> s { _policy = a } :: SqsQueuePolicyResource)

instance HasQueueUrl SqsQueuePolicyResource Text where
    queueUrl =
        lens (_queue_url :: SqsQueuePolicyResource -> TF.Argument "queue_url" Text)
             (\s a -> s { _queue_url = a } :: SqsQueuePolicyResource)

sqsQueuePolicyResource :: TF.Resource TF.AWS SqsQueuePolicyResource
sqsQueuePolicyResource =
    TF.newResource "aws_sqs_queue_policy" $
        SqsQueuePolicyResource {
            _policy = TF.Nil
            , _queue_url = TF.Nil
            }

{- | The @aws_sqs_queue@ AWS resource.


-}
data SqsQueueResource = SqsQueueResource {
      _content_based_deduplication :: !(TF.Argument "content_based_deduplication" Text)
    {- ^ (Optional) Enables content-based deduplication for FIFO queues. For more information, see the <http://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/FIFO-queues.html#FIFO-queues-exactly-once-processing> -}
    , _delay_seconds :: !(TF.Argument "delay_seconds" Text)
    {- ^ (Optional) The time in seconds that the delivery of all messages in the queue will be delayed. An integer from 0 to 900 (15 minutes). The default for this attribute is 0 seconds. -}
    , _fifo_queue :: !(TF.Argument "fifo_queue" Text)
    {- ^ (Optional) Boolean designating a FIFO queue. If not set, it defaults to @false@ making it standard. -}
    , _kms_data_key_reuse_period_seconds :: !(TF.Argument "kms_data_key_reuse_period_seconds" Text)
    {- ^ (Optional) The length of time, in seconds, for which Amazon SQS can reuse a data key to encrypt or decrypt messages before calling AWS KMS again. An integer representing seconds, between 60 seconds (1 minute) and 86,400 seconds (24 hours). The default is 300 (5 minutes). -}
    , _kms_master_key_id :: !(TF.Argument "kms_master_key_id" Text)
    {- ^ (Optional) The ID of an AWS-managed customer master key (CMK) for Amazon SQS or a custom CMK. For more information, see <http://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-server-side-encryption.html#sqs-sse-key-terms> . -}
    , _max_message_size :: !(TF.Argument "max_message_size" Text)
    {- ^ (Optional) The limit of how many bytes a message can contain before Amazon SQS rejects it. An integer from 1024 bytes (1 KiB) up to 262144 bytes (256 KiB). The default for this attribute is 262144 (256 KiB). -}
    , _message_retention_seconds :: !(TF.Argument "message_retention_seconds" Text)
    {- ^ (Optional) The number of seconds Amazon SQS retains a message. Integer representing seconds, from 60 (1 minute) to 1209600 (14 days). The default for this attribute is 345600 (4 days). -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Optional) This is the human-readable name of the queue. If omitted, Terraform will assign a random name. -}
    , _name_prefix :: !(TF.Argument "name_prefix" Text)
    {- ^ (Optional) Creates a unique name beginning with the specified prefix. Conflicts with @name@ . -}
    , _policy :: !(TF.Argument "policy" Text)
    {- ^ (Optional) The JSON policy for the SQS queue -}
    , _receive_wait_time_seconds :: !(TF.Argument "receive_wait_time_seconds" Text)
    {- ^ (Optional) The time for which a ReceiveMessage call will wait for a message to arrive (long polling) before returning. An integer from 0 to 20 (seconds). The default for this attribute is 0, meaning that the call will return immediately. -}
    , _redrive_policy :: !(TF.Argument "redrive_policy" Text)
    {- ^ (Optional) The JSON policy to set up the Dead Letter Queue, see <https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/SQSDeadLetterQueue.html> . Note: when specifying @maxReceiveCount@ , you must specify it as an integer ( @5@ ), and not a string ( @"5"@ ). -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the queue. -}
    , _visibility_timeout_seconds :: !(TF.Argument "visibility_timeout_seconds" Text)
    {- ^ (Optional) The visibility timeout for the queue. An integer from 0 to 43200 (12 hours). The default for this attribute is 30. For more information about visibility timeout, see <https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/AboutVT.html> . -}
    } deriving (Show, Eq)

instance TF.ToHCL SqsQueueResource where
    toHCL SqsQueueResource{..} = TF.block $ catMaybes
        [ TF.argument _content_based_deduplication
        , TF.argument _delay_seconds
        , TF.argument _fifo_queue
        , TF.argument _kms_data_key_reuse_period_seconds
        , TF.argument _kms_master_key_id
        , TF.argument _max_message_size
        , TF.argument _message_retention_seconds
        , TF.argument _name
        , TF.argument _name_prefix
        , TF.argument _policy
        , TF.argument _receive_wait_time_seconds
        , TF.argument _redrive_policy
        , TF.argument _tags
        , TF.argument _visibility_timeout_seconds
        ]

instance HasContentBasedDeduplication SqsQueueResource Text where
    contentBasedDeduplication =
        lens (_content_based_deduplication :: SqsQueueResource -> TF.Argument "content_based_deduplication" Text)
             (\s a -> s { _content_based_deduplication = a } :: SqsQueueResource)

instance HasDelaySeconds SqsQueueResource Text where
    delaySeconds =
        lens (_delay_seconds :: SqsQueueResource -> TF.Argument "delay_seconds" Text)
             (\s a -> s { _delay_seconds = a } :: SqsQueueResource)

instance HasFifoQueue SqsQueueResource Text where
    fifoQueue =
        lens (_fifo_queue :: SqsQueueResource -> TF.Argument "fifo_queue" Text)
             (\s a -> s { _fifo_queue = a } :: SqsQueueResource)

instance HasKmsDataKeyReusePeriodSeconds SqsQueueResource Text where
    kmsDataKeyReusePeriodSeconds =
        lens (_kms_data_key_reuse_period_seconds :: SqsQueueResource -> TF.Argument "kms_data_key_reuse_period_seconds" Text)
             (\s a -> s { _kms_data_key_reuse_period_seconds = a } :: SqsQueueResource)

instance HasKmsMasterKeyId SqsQueueResource Text where
    kmsMasterKeyId =
        lens (_kms_master_key_id :: SqsQueueResource -> TF.Argument "kms_master_key_id" Text)
             (\s a -> s { _kms_master_key_id = a } :: SqsQueueResource)

instance HasMaxMessageSize SqsQueueResource Text where
    maxMessageSize =
        lens (_max_message_size :: SqsQueueResource -> TF.Argument "max_message_size" Text)
             (\s a -> s { _max_message_size = a } :: SqsQueueResource)

instance HasMessageRetentionSeconds SqsQueueResource Text where
    messageRetentionSeconds =
        lens (_message_retention_seconds :: SqsQueueResource -> TF.Argument "message_retention_seconds" Text)
             (\s a -> s { _message_retention_seconds = a } :: SqsQueueResource)

instance HasName SqsQueueResource Text where
    name =
        lens (_name :: SqsQueueResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: SqsQueueResource)

instance HasNamePrefix SqsQueueResource Text where
    namePrefix =
        lens (_name_prefix :: SqsQueueResource -> TF.Argument "name_prefix" Text)
             (\s a -> s { _name_prefix = a } :: SqsQueueResource)

instance HasPolicy SqsQueueResource Text where
    policy =
        lens (_policy :: SqsQueueResource -> TF.Argument "policy" Text)
             (\s a -> s { _policy = a } :: SqsQueueResource)

instance HasReceiveWaitTimeSeconds SqsQueueResource Text where
    receiveWaitTimeSeconds =
        lens (_receive_wait_time_seconds :: SqsQueueResource -> TF.Argument "receive_wait_time_seconds" Text)
             (\s a -> s { _receive_wait_time_seconds = a } :: SqsQueueResource)

instance HasRedrivePolicy SqsQueueResource Text where
    redrivePolicy =
        lens (_redrive_policy :: SqsQueueResource -> TF.Argument "redrive_policy" Text)
             (\s a -> s { _redrive_policy = a } :: SqsQueueResource)

instance HasTags SqsQueueResource TF.Tags where
    tags =
        lens (_tags :: SqsQueueResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: SqsQueueResource)

instance HasVisibilityTimeoutSeconds SqsQueueResource Text where
    visibilityTimeoutSeconds =
        lens (_visibility_timeout_seconds :: SqsQueueResource -> TF.Argument "visibility_timeout_seconds" Text)
             (\s a -> s { _visibility_timeout_seconds = a } :: SqsQueueResource)

instance HasComputedArn SqsQueueResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

instance HasComputedId SqsQueueResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

sqsQueueResource :: TF.Resource TF.AWS SqsQueueResource
sqsQueueResource =
    TF.newResource "aws_sqs_queue" $
        SqsQueueResource {
            _content_based_deduplication = TF.Nil
            , _delay_seconds = TF.Nil
            , _fifo_queue = TF.Nil
            , _kms_data_key_reuse_period_seconds = TF.Nil
            , _kms_master_key_id = TF.Nil
            , _max_message_size = TF.Nil
            , _message_retention_seconds = TF.Nil
            , _name = TF.Nil
            , _name_prefix = TF.Nil
            , _policy = TF.Nil
            , _receive_wait_time_seconds = TF.Nil
            , _redrive_policy = TF.Nil
            , _tags = TF.Nil
            , _visibility_timeout_seconds = TF.Nil
            }

{- | The @aws_ssm_activation@ AWS resource.

Registers an on-premises server or virtual machine with Amazon EC2 so that
it can be managed using Run Command.
-}
data SsmActivationResource = SsmActivationResource {
      _description :: !(TF.Argument "description" Text)
    {- ^ (Optional) The description of the resource that you want to register. -}
    , _expiration_date :: !(TF.Argument "expiration_date" Text)
    {- ^ (Optional) The date by which this activation request should expire. The default value is 24 hours. -}
    , _iam_role :: !(TF.Argument "iam_role" Text)
    {- ^ (Required) The IAM Role to attach to the managed instance. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Optional) The default name of the registerd managed instance. -}
    , _registration_limit :: !(TF.Argument "registration_limit" Text)
    {- ^ (Optional) The maximum number of managed instances you want to register. The default value is 1 instance. -}
    } deriving (Show, Eq)

instance TF.ToHCL SsmActivationResource where
    toHCL SsmActivationResource{..} = TF.block $ catMaybes
        [ TF.argument _description
        , TF.argument _expiration_date
        , TF.argument _iam_role
        , TF.argument _name
        , TF.argument _registration_limit
        ]

instance HasDescription SsmActivationResource Text where
    description =
        lens (_description :: SsmActivationResource -> TF.Argument "description" Text)
             (\s a -> s { _description = a } :: SsmActivationResource)

instance HasExpirationDate SsmActivationResource Text where
    expirationDate =
        lens (_expiration_date :: SsmActivationResource -> TF.Argument "expiration_date" Text)
             (\s a -> s { _expiration_date = a } :: SsmActivationResource)

instance HasIamRole SsmActivationResource Text where
    iamRole =
        lens (_iam_role :: SsmActivationResource -> TF.Argument "iam_role" Text)
             (\s a -> s { _iam_role = a } :: SsmActivationResource)

instance HasName SsmActivationResource Text where
    name =
        lens (_name :: SsmActivationResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: SsmActivationResource)

instance HasRegistrationLimit SsmActivationResource Text where
    registrationLimit =
        lens (_registration_limit :: SsmActivationResource -> TF.Argument "registration_limit" Text)
             (\s a -> s { _registration_limit = a } :: SsmActivationResource)

instance HasComputedActivationCode SsmActivationResource Text where
    computedActivationCode =
        to (\_  -> TF.Compute "activation_code")

instance HasComputedDescription SsmActivationResource Text where
    computedDescription =
        to (\_  -> TF.Compute "description")

instance HasComputedExpirationDate SsmActivationResource Text where
    computedExpirationDate =
        to (\_  -> TF.Compute "expiration_date")

instance HasComputedExpired SsmActivationResource Text where
    computedExpired =
        to (\_  -> TF.Compute "expired")

instance HasComputedIamRole SsmActivationResource Text where
    computedIamRole =
        to (\_  -> TF.Compute "iam_role")

instance HasComputedName SsmActivationResource Text where
    computedName =
        to (\_  -> TF.Compute "name")

instance HasComputedRegistrationCount SsmActivationResource Text where
    computedRegistrationCount =
        to (\_  -> TF.Compute "registration_count")

instance HasComputedRegistrationLimit SsmActivationResource Text where
    computedRegistrationLimit =
        to (\_  -> TF.Compute "registration_limit")

ssmActivationResource :: TF.Resource TF.AWS SsmActivationResource
ssmActivationResource =
    TF.newResource "aws_ssm_activation" $
        SsmActivationResource {
            _description = TF.Nil
            , _expiration_date = TF.Nil
            , _iam_role = TF.Nil
            , _name = TF.Nil
            , _registration_limit = TF.Nil
            }

{- | The @aws_ssm_association@ AWS resource.

Associates an SSM Document to an instance or EC2 tag.
-}
data SsmAssociationResource = SsmAssociationResource {
      _association_name :: !(TF.Argument "association_name" Text)
    {- ^ (Optional) The descriptive name for the association. -}
    , _document_version :: !(TF.Argument "document_version" Text)
    {- ^ (Optional) The document version you want to associate with the target(s). Can be a specific version or the default version. -}
    , _instance_id :: !(TF.Argument "instance_id" Text)
    {- ^ (Optional) The instance ID to apply an SSM document to. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the SSM document to apply. -}
    , _output_location :: !(TF.Argument "output_location" Text)
    {- ^ (Optional) An output location block. Output Location is documented below. -}
    , _parameters :: !(TF.Argument "parameters" Text)
    {- ^ (Optional) A block of arbitrary string parameters to pass to the SSM document. -}
    , _schedule_expression :: !(TF.Argument "schedule_expression" Text)
    {- ^ (Optional) A cron expression when the association will be applied to the target(s). -}
    , _targets :: !(TF.Argument "targets" Text)
    {- ^ (Optional) A block containing the targets of the SSM association. Targets are documented below. AWS currently supports a maximum of 5 targets. -}
    } deriving (Show, Eq)

instance TF.ToHCL SsmAssociationResource where
    toHCL SsmAssociationResource{..} = TF.block $ catMaybes
        [ TF.argument _association_name
        , TF.argument _document_version
        , TF.argument _instance_id
        , TF.argument _name
        , TF.argument _output_location
        , TF.argument _parameters
        , TF.argument _schedule_expression
        , TF.argument _targets
        ]

instance HasAssociationName SsmAssociationResource Text where
    associationName =
        lens (_association_name :: SsmAssociationResource -> TF.Argument "association_name" Text)
             (\s a -> s { _association_name = a } :: SsmAssociationResource)

instance HasDocumentVersion SsmAssociationResource Text where
    documentVersion =
        lens (_document_version :: SsmAssociationResource -> TF.Argument "document_version" Text)
             (\s a -> s { _document_version = a } :: SsmAssociationResource)

instance HasInstanceId SsmAssociationResource Text where
    instanceId =
        lens (_instance_id :: SsmAssociationResource -> TF.Argument "instance_id" Text)
             (\s a -> s { _instance_id = a } :: SsmAssociationResource)

instance HasName SsmAssociationResource Text where
    name =
        lens (_name :: SsmAssociationResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: SsmAssociationResource)

instance HasOutputLocation SsmAssociationResource Text where
    outputLocation =
        lens (_output_location :: SsmAssociationResource -> TF.Argument "output_location" Text)
             (\s a -> s { _output_location = a } :: SsmAssociationResource)

instance HasParameters SsmAssociationResource Text where
    parameters =
        lens (_parameters :: SsmAssociationResource -> TF.Argument "parameters" Text)
             (\s a -> s { _parameters = a } :: SsmAssociationResource)

instance HasScheduleExpression SsmAssociationResource Text where
    scheduleExpression =
        lens (_schedule_expression :: SsmAssociationResource -> TF.Argument "schedule_expression" Text)
             (\s a -> s { _schedule_expression = a } :: SsmAssociationResource)

instance HasTargets SsmAssociationResource Text where
    targets =
        lens (_targets :: SsmAssociationResource -> TF.Argument "targets" Text)
             (\s a -> s { _targets = a } :: SsmAssociationResource)

instance HasComputedInstanceIds SsmAssociationResource Text where
    computedInstanceIds =
        to (\_  -> TF.Compute "instance_ids")

instance HasComputedName SsmAssociationResource Text where
    computedName =
        to (\_  -> TF.Compute "name")

instance HasComputedParameters SsmAssociationResource Text where
    computedParameters =
        to (\_  -> TF.Compute "parameters")

ssmAssociationResource :: TF.Resource TF.AWS SsmAssociationResource
ssmAssociationResource =
    TF.newResource "aws_ssm_association" $
        SsmAssociationResource {
            _association_name = TF.Nil
            , _document_version = TF.Nil
            , _instance_id = TF.Nil
            , _name = TF.Nil
            , _output_location = TF.Nil
            , _parameters = TF.Nil
            , _schedule_expression = TF.Nil
            , _targets = TF.Nil
            }

{- | The @aws_ssm_document@ AWS resource.

Provides an SSM Document resource ~> NOTE on updating SSM documents: Only
documents with a schema version of 2.0 or greater can update their content
once created, see
<http://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-ssm-docs.html#document-schemas-features>
. To update a document with an older schema version you must recreate the
resource.
-}
data SsmDocumentResource = SsmDocumentResource {
      _content :: !(TF.Argument "content" Text)
    {- ^ (Required) The json content of the document. -}
    , _document_type :: !(TF.Argument "document_type" Text)
    {- ^ (Required) The type of the document. Valid document types include: @Command@ , @Policy@ and @Automation@ -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the document. -}
    , _permissions :: !(TF.Argument "permissions" Text)
    {- ^ (Optional) Additional Permissions to attach to the document. See <#permissions> below for details. -}
    } deriving (Show, Eq)

instance TF.ToHCL SsmDocumentResource where
    toHCL SsmDocumentResource{..} = TF.block $ catMaybes
        [ TF.argument _content
        , TF.argument _document_type
        , TF.argument _name
        , TF.argument _permissions
        ]

instance HasContent SsmDocumentResource Text where
    content =
        lens (_content :: SsmDocumentResource -> TF.Argument "content" Text)
             (\s a -> s { _content = a } :: SsmDocumentResource)

instance HasDocumentType SsmDocumentResource Text where
    documentType =
        lens (_document_type :: SsmDocumentResource -> TF.Argument "document_type" Text)
             (\s a -> s { _document_type = a } :: SsmDocumentResource)

instance HasName SsmDocumentResource Text where
    name =
        lens (_name :: SsmDocumentResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: SsmDocumentResource)

instance HasPermissions SsmDocumentResource Text where
    permissions =
        lens (_permissions :: SsmDocumentResource -> TF.Argument "permissions" Text)
             (\s a -> s { _permissions = a } :: SsmDocumentResource)

instance HasComputedContent SsmDocumentResource Text where
    computedContent =
        to (\_  -> TF.Compute "content")

instance HasComputedCreatedDate SsmDocumentResource Text where
    computedCreatedDate =
        to (\_  -> TF.Compute "created_date")

instance HasComputedDefaultVersion SsmDocumentResource Text where
    computedDefaultVersion =
        to (\_  -> TF.Compute "default_version")

instance HasComputedDescription SsmDocumentResource Text where
    computedDescription =
        to (\_  -> TF.Compute "description")

instance HasComputedDocumentType SsmDocumentResource Text where
    computedDocumentType =
        to (\_  -> TF.Compute "document_type")

instance HasComputedHash SsmDocumentResource Text where
    computedHash =
        to (\_  -> TF.Compute "hash")

instance HasComputedHashType SsmDocumentResource Text where
    computedHashType =
        to (\_  -> TF.Compute "hash_type")

instance HasComputedLatestVersion SsmDocumentResource Text where
    computedLatestVersion =
        to (\_  -> TF.Compute "latest_version")

instance HasComputedName SsmDocumentResource Text where
    computedName =
        to (\_  -> TF.Compute "name")

instance HasComputedOwner SsmDocumentResource Text where
    computedOwner =
        to (\_  -> TF.Compute "owner")

instance HasComputedParameter SsmDocumentResource Text where
    computedParameter =
        to (\_  -> TF.Compute "parameter")

instance HasComputedPermissions SsmDocumentResource Text where
    computedPermissions =
        to (\_  -> TF.Compute "permissions")

instance HasComputedPlatformTypes SsmDocumentResource Text where
    computedPlatformTypes =
        to (\_  -> TF.Compute "platform_types")

instance HasComputedSchemaVersion SsmDocumentResource Text where
    computedSchemaVersion =
        to (\_  -> TF.Compute "schema_version")

instance HasComputedStatus SsmDocumentResource Text where
    computedStatus =
        to (\_  -> TF.Compute "status")

ssmDocumentResource :: TF.Resource TF.AWS SsmDocumentResource
ssmDocumentResource =
    TF.newResource "aws_ssm_document" $
        SsmDocumentResource {
            _content = TF.Nil
            , _document_type = TF.Nil
            , _name = TF.Nil
            , _permissions = TF.Nil
            }

{- | The @aws_ssm_maintenance_window@ AWS resource.

Provides an SSM Maintenance Window resource
-}
data SsmMaintenanceWindowResource = SsmMaintenanceWindowResource {
      _allow_unassociated_targets :: !(TF.Argument "allow_unassociated_targets" Text)
    {- ^ (Optional) Whether targets must be registered with the Maintenance Window before tasks can be defined for those targets. -}
    , _cutoff :: !(TF.Argument "cutoff" Text)
    {- ^ (Required) The number of hours before the end of the Maintenance Window that Systems Manager stops scheduling new tasks for execution. -}
    , _duration :: !(TF.Argument "duration" Text)
    {- ^ (Required) The duration of the Maintenance Window in hours. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the maintenance window. -}
    , _schedule :: !(TF.Argument "schedule" Text)
    {- ^ (Required) The schedule of the Maintenance Window in the form of a <https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-maintenance-cron.html> or rate expression. -}
    } deriving (Show, Eq)

instance TF.ToHCL SsmMaintenanceWindowResource where
    toHCL SsmMaintenanceWindowResource{..} = TF.block $ catMaybes
        [ TF.argument _allow_unassociated_targets
        , TF.argument _cutoff
        , TF.argument _duration
        , TF.argument _name
        , TF.argument _schedule
        ]

instance HasAllowUnassociatedTargets SsmMaintenanceWindowResource Text where
    allowUnassociatedTargets =
        lens (_allow_unassociated_targets :: SsmMaintenanceWindowResource -> TF.Argument "allow_unassociated_targets" Text)
             (\s a -> s { _allow_unassociated_targets = a } :: SsmMaintenanceWindowResource)

instance HasCutoff SsmMaintenanceWindowResource Text where
    cutoff =
        lens (_cutoff :: SsmMaintenanceWindowResource -> TF.Argument "cutoff" Text)
             (\s a -> s { _cutoff = a } :: SsmMaintenanceWindowResource)

instance HasDuration SsmMaintenanceWindowResource Text where
    duration =
        lens (_duration :: SsmMaintenanceWindowResource -> TF.Argument "duration" Text)
             (\s a -> s { _duration = a } :: SsmMaintenanceWindowResource)

instance HasName SsmMaintenanceWindowResource Text where
    name =
        lens (_name :: SsmMaintenanceWindowResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: SsmMaintenanceWindowResource)

instance HasSchedule SsmMaintenanceWindowResource Text where
    schedule =
        lens (_schedule :: SsmMaintenanceWindowResource -> TF.Argument "schedule" Text)
             (\s a -> s { _schedule = a } :: SsmMaintenanceWindowResource)

instance HasComputedId SsmMaintenanceWindowResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

ssmMaintenanceWindowResource :: TF.Resource TF.AWS SsmMaintenanceWindowResource
ssmMaintenanceWindowResource =
    TF.newResource "aws_ssm_maintenance_window" $
        SsmMaintenanceWindowResource {
            _allow_unassociated_targets = TF.Nil
            , _cutoff = TF.Nil
            , _duration = TF.Nil
            , _name = TF.Nil
            , _schedule = TF.Nil
            }

{- | The @aws_ssm_maintenance_window_target@ AWS resource.

Provides an SSM Maintenance Window Target resource
-}
data SsmMaintenanceWindowTargetResource = SsmMaintenanceWindowTargetResource {
      _owner_information :: !(TF.Argument "owner_information" Text)
    {- ^ (Optional) User-provided value that will be included in any CloudWatch events raised while running tasks for these targets in this Maintenance Window. -}
    , _resource_type :: !(TF.Argument "resource_type" Text)
    {- ^ (Required) The type of target being registered with the Maintenance Window. Possible values @INSTANCE@ . -}
    , _targets :: !(TF.Argument "targets" Text)
    {- ^ (Required) The targets (either instances or tags). Instances are specified using Key=instanceids,Values=instanceid1,instanceid2. Tags are specified using Key=tag name,Values=tag value. -}
    , _window_id :: !(TF.Argument "window_id" Text)
    {- ^ (Required) The Id of the maintenance window to register the target with. -}
    } deriving (Show, Eq)

instance TF.ToHCL SsmMaintenanceWindowTargetResource where
    toHCL SsmMaintenanceWindowTargetResource{..} = TF.block $ catMaybes
        [ TF.argument _owner_information
        , TF.argument _resource_type
        , TF.argument _targets
        , TF.argument _window_id
        ]

instance HasOwnerInformation SsmMaintenanceWindowTargetResource Text where
    ownerInformation =
        lens (_owner_information :: SsmMaintenanceWindowTargetResource -> TF.Argument "owner_information" Text)
             (\s a -> s { _owner_information = a } :: SsmMaintenanceWindowTargetResource)

instance HasResourceType SsmMaintenanceWindowTargetResource Text where
    resourceType =
        lens (_resource_type :: SsmMaintenanceWindowTargetResource -> TF.Argument "resource_type" Text)
             (\s a -> s { _resource_type = a } :: SsmMaintenanceWindowTargetResource)

instance HasTargets SsmMaintenanceWindowTargetResource Text where
    targets =
        lens (_targets :: SsmMaintenanceWindowTargetResource -> TF.Argument "targets" Text)
             (\s a -> s { _targets = a } :: SsmMaintenanceWindowTargetResource)

instance HasWindowId SsmMaintenanceWindowTargetResource Text where
    windowId =
        lens (_window_id :: SsmMaintenanceWindowTargetResource -> TF.Argument "window_id" Text)
             (\s a -> s { _window_id = a } :: SsmMaintenanceWindowTargetResource)

instance HasComputedId SsmMaintenanceWindowTargetResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

ssmMaintenanceWindowTargetResource :: TF.Resource TF.AWS SsmMaintenanceWindowTargetResource
ssmMaintenanceWindowTargetResource =
    TF.newResource "aws_ssm_maintenance_window_target" $
        SsmMaintenanceWindowTargetResource {
            _owner_information = TF.Nil
            , _resource_type = TF.Nil
            , _targets = TF.Nil
            , _window_id = TF.Nil
            }

{- | The @aws_ssm_maintenance_window_task@ AWS resource.

Provides an SSM Maintenance Window Task resource
-}
data SsmMaintenanceWindowTaskResource = SsmMaintenanceWindowTaskResource {
      _logging_info :: !(TF.Argument "logging_info" Text)
    {- ^ (Optional) A structure containing information about an Amazon S3 bucket to write instance-level logs to. Documented below. -}
    , _max_concurrency :: !(TF.Argument "max_concurrency" Text)
    {- ^ (Required) The maximum number of targets this task can be run for in parallel. -}
    , _max_errors :: !(TF.Argument "max_errors" Text)
    {- ^ (Required) The maximum number of errors allowed before this task stops being scheduled. -}
    , _priority :: !(TF.Argument "priority" Text)
    {- ^ (Optional) The priority of the task in the Maintenance Window, the lower the number the higher the priority. Tasks in a Maintenance Window are scheduled in priority order with tasks that have the same priority scheduled in parallel. -}
    , _service_role_arn :: !(TF.Argument "service_role_arn" Text)
    {- ^ (Required) The role that should be assumed when executing the task. -}
    , _targets :: !(TF.Argument "targets" Text)
    {- ^ (Required) The targets (either instances or window target ids). Instances are specified using Key=InstanceIds,Values=instanceid1,instanceid2. Window target ids are specified using Key=WindowTargetIds,Values=window target id1, window target id2. -}
    , _task_arn :: !(TF.Argument "task_arn" Text)
    {- ^ (Required) The ARN of the task to execute. -}
    , _task_parameters :: !(TF.Argument "task_parameters" Text)
    {- ^ (Optional) A structure containing information about parameters required by the particular @task_arn@ . Documented below. -}
    , _task_type :: !(TF.Argument "task_type" Text)
    {- ^ (Required) The type of task being registered. The only allowed value is @RUN_COMMAND@ . -}
    , _window_id :: !(TF.Argument "window_id" Text)
    {- ^ (Required) The Id of the maintenance window to register the task with. -}
    } deriving (Show, Eq)

instance TF.ToHCL SsmMaintenanceWindowTaskResource where
    toHCL SsmMaintenanceWindowTaskResource{..} = TF.block $ catMaybes
        [ TF.argument _logging_info
        , TF.argument _max_concurrency
        , TF.argument _max_errors
        , TF.argument _priority
        , TF.argument _service_role_arn
        , TF.argument _targets
        , TF.argument _task_arn
        , TF.argument _task_parameters
        , TF.argument _task_type
        , TF.argument _window_id
        ]

instance HasLoggingInfo SsmMaintenanceWindowTaskResource Text where
    loggingInfo =
        lens (_logging_info :: SsmMaintenanceWindowTaskResource -> TF.Argument "logging_info" Text)
             (\s a -> s { _logging_info = a } :: SsmMaintenanceWindowTaskResource)

instance HasMaxConcurrency SsmMaintenanceWindowTaskResource Text where
    maxConcurrency =
        lens (_max_concurrency :: SsmMaintenanceWindowTaskResource -> TF.Argument "max_concurrency" Text)
             (\s a -> s { _max_concurrency = a } :: SsmMaintenanceWindowTaskResource)

instance HasMaxErrors SsmMaintenanceWindowTaskResource Text where
    maxErrors =
        lens (_max_errors :: SsmMaintenanceWindowTaskResource -> TF.Argument "max_errors" Text)
             (\s a -> s { _max_errors = a } :: SsmMaintenanceWindowTaskResource)

instance HasPriority SsmMaintenanceWindowTaskResource Text where
    priority =
        lens (_priority :: SsmMaintenanceWindowTaskResource -> TF.Argument "priority" Text)
             (\s a -> s { _priority = a } :: SsmMaintenanceWindowTaskResource)

instance HasServiceRoleArn SsmMaintenanceWindowTaskResource Text where
    serviceRoleArn =
        lens (_service_role_arn :: SsmMaintenanceWindowTaskResource -> TF.Argument "service_role_arn" Text)
             (\s a -> s { _service_role_arn = a } :: SsmMaintenanceWindowTaskResource)

instance HasTargets SsmMaintenanceWindowTaskResource Text where
    targets =
        lens (_targets :: SsmMaintenanceWindowTaskResource -> TF.Argument "targets" Text)
             (\s a -> s { _targets = a } :: SsmMaintenanceWindowTaskResource)

instance HasTaskArn SsmMaintenanceWindowTaskResource Text where
    taskArn =
        lens (_task_arn :: SsmMaintenanceWindowTaskResource -> TF.Argument "task_arn" Text)
             (\s a -> s { _task_arn = a } :: SsmMaintenanceWindowTaskResource)

instance HasTaskParameters SsmMaintenanceWindowTaskResource Text where
    taskParameters =
        lens (_task_parameters :: SsmMaintenanceWindowTaskResource -> TF.Argument "task_parameters" Text)
             (\s a -> s { _task_parameters = a } :: SsmMaintenanceWindowTaskResource)

instance HasTaskType SsmMaintenanceWindowTaskResource Text where
    taskType =
        lens (_task_type :: SsmMaintenanceWindowTaskResource -> TF.Argument "task_type" Text)
             (\s a -> s { _task_type = a } :: SsmMaintenanceWindowTaskResource)

instance HasWindowId SsmMaintenanceWindowTaskResource Text where
    windowId =
        lens (_window_id :: SsmMaintenanceWindowTaskResource -> TF.Argument "window_id" Text)
             (\s a -> s { _window_id = a } :: SsmMaintenanceWindowTaskResource)

instance HasComputedId SsmMaintenanceWindowTaskResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

ssmMaintenanceWindowTaskResource :: TF.Resource TF.AWS SsmMaintenanceWindowTaskResource
ssmMaintenanceWindowTaskResource =
    TF.newResource "aws_ssm_maintenance_window_task" $
        SsmMaintenanceWindowTaskResource {
            _logging_info = TF.Nil
            , _max_concurrency = TF.Nil
            , _max_errors = TF.Nil
            , _priority = TF.Nil
            , _service_role_arn = TF.Nil
            , _targets = TF.Nil
            , _task_arn = TF.Nil
            , _task_parameters = TF.Nil
            , _task_type = TF.Nil
            , _window_id = TF.Nil
            }

{- | The @aws_ssm_parameter@ AWS resource.

Provides an SSM Parameter resource.
-}
data SsmParameterResource = SsmParameterResource {
      _key_id :: !(TF.Argument "key_id" Text)
    {- ^ (Optional) The KMS key id or arn for encrypting a SecureString. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the parameter. -}
    , _overwrite :: !(TF.Argument "overwrite" Text)
    {- ^ (Optional) Overwrite an existing parameter. If not specified, will default to @false@ . -}
    , _type' :: !(TF.Argument "type" Text)
    {- ^ (Required) The type of the parameter. Valid types are @String@ , @StringList@ and @SecureString@ . -}
    , _value :: !(TF.Argument "value" Text)
    {- ^ (Required) The value of the parameter. -}
    } deriving (Show, Eq)

instance TF.ToHCL SsmParameterResource where
    toHCL SsmParameterResource{..} = TF.block $ catMaybes
        [ TF.argument _key_id
        , TF.argument _name
        , TF.argument _overwrite
        , TF.argument _type'
        , TF.argument _value
        ]

instance HasKeyId SsmParameterResource Text where
    keyId =
        lens (_key_id :: SsmParameterResource -> TF.Argument "key_id" Text)
             (\s a -> s { _key_id = a } :: SsmParameterResource)

instance HasName SsmParameterResource Text where
    name =
        lens (_name :: SsmParameterResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: SsmParameterResource)

instance HasOverwrite SsmParameterResource Text where
    overwrite =
        lens (_overwrite :: SsmParameterResource -> TF.Argument "overwrite" Text)
             (\s a -> s { _overwrite = a } :: SsmParameterResource)

instance HasType' SsmParameterResource Text where
    type' =
        lens (_type' :: SsmParameterResource -> TF.Argument "type" Text)
             (\s a -> s { _type' = a } :: SsmParameterResource)

instance HasValue SsmParameterResource Text where
    value =
        lens (_value :: SsmParameterResource -> TF.Argument "value" Text)
             (\s a -> s { _value = a } :: SsmParameterResource)

instance HasComputedArn SsmParameterResource Text where
    computedArn =
        to (\_  -> TF.Compute "arn")

instance HasComputedName SsmParameterResource Text where
    computedName =
        to (\_  -> TF.Compute "name")

instance HasComputedType' SsmParameterResource Text where
    computedType' =
        to (\_  -> TF.Compute "type")

instance HasComputedValue SsmParameterResource Text where
    computedValue =
        to (\_  -> TF.Compute "value")

ssmParameterResource :: TF.Resource TF.AWS SsmParameterResource
ssmParameterResource =
    TF.newResource "aws_ssm_parameter" $
        SsmParameterResource {
            _key_id = TF.Nil
            , _name = TF.Nil
            , _overwrite = TF.Nil
            , _type' = TF.Nil
            , _value = TF.Nil
            }

{- | The @aws_ssm_patch_baseline@ AWS resource.

Provides an SSM Patch Baseline resource ~> NOTE on Patch Baselines: The
@approved_patches@ and @approval_rule@ are both marked as optional fields,
but the Patch Baseline requires that at least one of them is specified.
-}
data SsmPatchBaselineResource = SsmPatchBaselineResource {
      _approval_rule :: !(TF.Argument "approval_rule" Text)
    {- ^ (Optional) A set of rules used to include patches in the baseline. up to 10 approval rules can be specified. Each approval_rule block requires the fields documented below. -}
    , _approved_patches :: !(TF.Argument "approved_patches" Text)
    {- ^ (Optional) A list of explicitly approved patches for the baseline. -}
    , _approved_patches_compliance_level :: !(TF.Argument "approved_patches_compliance_level" Text)
    {- ^ (Optional) Defines the compliance level for approved patches. This means that if an approved patch is reported as missing, this is the severity of the compliance violation. Valid compliance levels include the following: @CRITICAL@ , @HIGH@ , @MEDIUM@ , @LOW@ , @INFORMATIONAL@ , @UNSPECIFIED@ . The default value is @UNSPECIFIED@ . -}
    , _description :: !(TF.Argument "description" Text)
    {- ^ (Optional) The description of the patch baseline. -}
    , _global_filter :: !(TF.Argument "global_filter" Text)
    {- ^ (Optional) A set of global filters used to exclude patches from the baseline. Up to 4 global filters can be specified using Key/Value pairs. Valid Keys are @PRODUCT | CLASSIFICATION | MSRC_SEVERITY | PATCH_ID@ . -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the patch baseline. -}
    , _operating_system :: !(TF.Argument "operating_system" Text)
    {- ^ (Optional) Defines the operating system the patch baseline applies to. Supported operating systems include @WINDOWS@ , @AMAZON_LINUX@ , @UBUNTU@ and @REDHAT_ENTERPRISE_LINUX@ . The Default value is @WINDOWS@ . -}
    , _rejected_patches :: !(TF.Argument "rejected_patches" Text)
    {- ^ (Optional) A list of rejected patches. -}
    } deriving (Show, Eq)

instance TF.ToHCL SsmPatchBaselineResource where
    toHCL SsmPatchBaselineResource{..} = TF.block $ catMaybes
        [ TF.argument _approval_rule
        , TF.argument _approved_patches
        , TF.argument _approved_patches_compliance_level
        , TF.argument _description
        , TF.argument _global_filter
        , TF.argument _name
        , TF.argument _operating_system
        , TF.argument _rejected_patches
        ]

instance HasApprovalRule SsmPatchBaselineResource Text where
    approvalRule =
        lens (_approval_rule :: SsmPatchBaselineResource -> TF.Argument "approval_rule" Text)
             (\s a -> s { _approval_rule = a } :: SsmPatchBaselineResource)

instance HasApprovedPatches SsmPatchBaselineResource Text where
    approvedPatches =
        lens (_approved_patches :: SsmPatchBaselineResource -> TF.Argument "approved_patches" Text)
             (\s a -> s { _approved_patches = a } :: SsmPatchBaselineResource)

instance HasApprovedPatchesComplianceLevel SsmPatchBaselineResource Text where
    approvedPatchesComplianceLevel =
        lens (_approved_patches_compliance_level :: SsmPatchBaselineResource -> TF.Argument "approved_patches_compliance_level" Text)
             (\s a -> s { _approved_patches_compliance_level = a } :: SsmPatchBaselineResource)

instance HasDescription SsmPatchBaselineResource Text where
    description =
        lens (_description :: SsmPatchBaselineResource -> TF.Argument "description" Text)
             (\s a -> s { _description = a } :: SsmPatchBaselineResource)

instance HasGlobalFilter SsmPatchBaselineResource Text where
    globalFilter =
        lens (_global_filter :: SsmPatchBaselineResource -> TF.Argument "global_filter" Text)
             (\s a -> s { _global_filter = a } :: SsmPatchBaselineResource)

instance HasName SsmPatchBaselineResource Text where
    name =
        lens (_name :: SsmPatchBaselineResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: SsmPatchBaselineResource)

instance HasOperatingSystem SsmPatchBaselineResource Text where
    operatingSystem =
        lens (_operating_system :: SsmPatchBaselineResource -> TF.Argument "operating_system" Text)
             (\s a -> s { _operating_system = a } :: SsmPatchBaselineResource)

instance HasRejectedPatches SsmPatchBaselineResource Text where
    rejectedPatches =
        lens (_rejected_patches :: SsmPatchBaselineResource -> TF.Argument "rejected_patches" Text)
             (\s a -> s { _rejected_patches = a } :: SsmPatchBaselineResource)

instance HasComputedId SsmPatchBaselineResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

ssmPatchBaselineResource :: TF.Resource TF.AWS SsmPatchBaselineResource
ssmPatchBaselineResource =
    TF.newResource "aws_ssm_patch_baseline" $
        SsmPatchBaselineResource {
            _approval_rule = TF.Nil
            , _approved_patches = TF.Nil
            , _approved_patches_compliance_level = TF.Nil
            , _description = TF.Nil
            , _global_filter = TF.Nil
            , _name = TF.Nil
            , _operating_system = TF.Nil
            , _rejected_patches = TF.Nil
            }

{- | The @aws_ssm_patch_group@ AWS resource.

Provides an SSM Patch Group resource
-}
data SsmPatchGroupResource = SsmPatchGroupResource {
      _baseline_id :: !(TF.Argument "baseline_id" Text)
    {- ^ (Required) The ID of the patch baseline to register the patch group with. -}
    , _patch_group :: !(TF.Argument "patch_group" Text)
    {- ^ (Required) The name of the patch group that should be registered with the patch baseline. -}
    } deriving (Show, Eq)

instance TF.ToHCL SsmPatchGroupResource where
    toHCL SsmPatchGroupResource{..} = TF.block $ catMaybes
        [ TF.argument _baseline_id
        , TF.argument _patch_group
        ]

instance HasBaselineId SsmPatchGroupResource Text where
    baselineId =
        lens (_baseline_id :: SsmPatchGroupResource -> TF.Argument "baseline_id" Text)
             (\s a -> s { _baseline_id = a } :: SsmPatchGroupResource)

instance HasPatchGroup SsmPatchGroupResource Text where
    patchGroup =
        lens (_patch_group :: SsmPatchGroupResource -> TF.Argument "patch_group" Text)
             (\s a -> s { _patch_group = a } :: SsmPatchGroupResource)

instance HasComputedId SsmPatchGroupResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

ssmPatchGroupResource :: TF.Resource TF.AWS SsmPatchGroupResource
ssmPatchGroupResource =
    TF.newResource "aws_ssm_patch_group" $
        SsmPatchGroupResource {
            _baseline_id = TF.Nil
            , _patch_group = TF.Nil
            }

{- | The @sfn_state_machine@ AWS resource.

Provides a Step Function State Machine resource
-}
data StateMachineResource = StateMachineResource {
      _definition :: !(TF.Argument "definition" Text)
    {- ^ (Required) The Amazon States Language definition of the state machine. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name of the state machine. -}
    , _role_arn :: !(TF.Argument "role_arn" Text)
    {- ^ (Required) The Amazon Resource Name (ARN) of the IAM role to use for this state machine. -}
    } deriving (Show, Eq)

instance TF.ToHCL StateMachineResource where
    toHCL StateMachineResource{..} = TF.block $ catMaybes
        [ TF.argument _definition
        , TF.argument _name
        , TF.argument _role_arn
        ]

instance HasDefinition StateMachineResource Text where
    definition =
        lens (_definition :: StateMachineResource -> TF.Argument "definition" Text)
             (\s a -> s { _definition = a } :: StateMachineResource)

instance HasName StateMachineResource Text where
    name =
        lens (_name :: StateMachineResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: StateMachineResource)

instance HasRoleArn StateMachineResource Text where
    roleArn =
        lens (_role_arn :: StateMachineResource -> TF.Argument "role_arn" Text)
             (\s a -> s { _role_arn = a } :: StateMachineResource)

instance HasComputedCreationDate StateMachineResource Text where
    computedCreationDate =
        to (\_  -> TF.Compute "creation_date")

instance HasComputedId StateMachineResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedStatus StateMachineResource Text where
    computedStatus =
        to (\_  -> TF.Compute "status")

stateMachineResource :: TF.Resource TF.AWS StateMachineResource
stateMachineResource =
    TF.newResource "sfn_state_machine" $
        StateMachineResource {
            _definition = TF.Nil
            , _name = TF.Nil
            , _role_arn = TF.Nil
            }

{- | The @aws_subnet@ AWS resource.

Provides an VPC subnet resource.
-}
data SubnetResource = SubnetResource {
      _assign_ipv6_address_on_creation :: !(TF.Argument "assign_ipv6_address_on_creation" Text)
    {- ^ (Optional) Specify true to indicate that network interfaces created in the specified subnet should be assigned an IPv6 address. Default is @false@ -}
    , _availability_zone :: !(TF.Argument "availability_zone" TF.Zone)
    {- ^ (Optional) The AZ for the subnet. -}
    , _cidr_block :: !(TF.Argument "cidr_block" TF.CIDR)
    {- ^ (Required) The CIDR block for the subnet. -}
    , _ipv6_cidr_block :: !(TF.Argument "ipv6_cidr_block" TF.CIDR)
    {- ^ (Optional) The IPv6 network range for the subnet, in CIDR notation. The subnet size must use a /64 prefix length. -}
    , _map_public_ip_on_launch :: !(TF.Argument "map_public_ip_on_launch" Text)
    {- ^ -  (Optional) Specify true to indicate that instances launched into the subnet should be assigned a public IP address. Default is @false@ . -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    , _vpc_id :: !(TF.Argument "vpc_id" Text)
    {- ^ (Required) The VPC ID. -}
    } deriving (Show, Eq)

instance TF.ToHCL SubnetResource where
    toHCL SubnetResource{..} = TF.block $ catMaybes
        [ TF.argument _assign_ipv6_address_on_creation
        , TF.argument _availability_zone
        , TF.argument _cidr_block
        , TF.argument _ipv6_cidr_block
        , TF.argument _map_public_ip_on_launch
        , TF.argument _tags
        , TF.argument _vpc_id
        ]

instance HasAssignIpv6AddressOnCreation SubnetResource Text where
    assignIpv6AddressOnCreation =
        lens (_assign_ipv6_address_on_creation :: SubnetResource -> TF.Argument "assign_ipv6_address_on_creation" Text)
             (\s a -> s { _assign_ipv6_address_on_creation = a } :: SubnetResource)

instance HasAvailabilityZone SubnetResource TF.Zone where
    availabilityZone =
        lens (_availability_zone :: SubnetResource -> TF.Argument "availability_zone" TF.Zone)
             (\s a -> s { _availability_zone = a } :: SubnetResource)

instance HasCidrBlock SubnetResource TF.CIDR where
    cidrBlock =
        lens (_cidr_block :: SubnetResource -> TF.Argument "cidr_block" TF.CIDR)
             (\s a -> s { _cidr_block = a } :: SubnetResource)

instance HasIpv6CidrBlock SubnetResource TF.CIDR where
    ipv6CidrBlock =
        lens (_ipv6_cidr_block :: SubnetResource -> TF.Argument "ipv6_cidr_block" TF.CIDR)
             (\s a -> s { _ipv6_cidr_block = a } :: SubnetResource)

instance HasMapPublicIpOnLaunch SubnetResource Text where
    mapPublicIpOnLaunch =
        lens (_map_public_ip_on_launch :: SubnetResource -> TF.Argument "map_public_ip_on_launch" Text)
             (\s a -> s { _map_public_ip_on_launch = a } :: SubnetResource)

instance HasTags SubnetResource TF.Tags where
    tags =
        lens (_tags :: SubnetResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: SubnetResource)

instance HasVpcId SubnetResource Text where
    vpcId =
        lens (_vpc_id :: SubnetResource -> TF.Argument "vpc_id" Text)
             (\s a -> s { _vpc_id = a } :: SubnetResource)

instance HasComputedAvailabilityZone SubnetResource TF.Zone where
    computedAvailabilityZone =
        to (\_  -> TF.Compute "availability_zone")

instance HasComputedCidrBlock SubnetResource TF.CIDR where
    computedCidrBlock =
        to (\_  -> TF.Compute "cidr_block")

instance HasComputedId SubnetResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedIpv6AssociationId SubnetResource Text where
    computedIpv6AssociationId =
        to (\_  -> TF.Compute "ipv6_association_id")

instance HasComputedIpv6CidrBlock SubnetResource TF.CIDR where
    computedIpv6CidrBlock =
        to (\_  -> TF.Compute "ipv6_cidr_block")

instance HasComputedVpcId SubnetResource Text where
    computedVpcId =
        to (\_  -> TF.Compute "vpc_id")

subnetResource :: TF.Resource TF.AWS SubnetResource
subnetResource =
    TF.newResource "aws_subnet" $
        SubnetResource {
            _assign_ipv6_address_on_creation = TF.Nil
            , _availability_zone = TF.Nil
            , _cidr_block = TF.Nil
            , _ipv6_cidr_block = TF.Nil
            , _map_public_ip_on_launch = TF.Nil
            , _tags = TF.Nil
            , _vpc_id = TF.Nil
            }

{- | The @aws_volume_attachment@ AWS resource.

Provides an AWS EBS Volume Attachment as a top level resource, to attach and
detach volumes from AWS Instances. ~> NOTE on EBS block devices: If you use
@ebs_block_device@ on an @aws_instance@ , Terraform will assume management
over the full set of non-root EBS block devices for the instance, and treats
additional block devices as drift. For this reason, @ebs_block_device@
cannot be mixed with external @aws_ebs_volume@ + @aws_ebs_volume_attachment@
resources for a given instance.
-}
data VolumeAttachmentResource = VolumeAttachmentResource {
      _device_name :: !(TF.Argument "device_name" Text)
    {- ^ (Required) The device name to expose to the instance (for example, @/dev/sdh@ or @xvdh@ ) -}
    , _force_detach :: !(TF.Argument "force_detach" Text)
    {- ^ (Optional, Boolean) Set to @true@ if you want to force the volume to detach. Useful if previous attempts failed, but use this option only as a last resort, as this can result in data loss . See <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-detaching-volume.html> for more information. -}
    , _instance_id :: !(TF.Argument "instance_id" Text)
    {- ^ (Required) ID of the Instance to attach to -}
    , _skip_destroy :: !(TF.Argument "skip_destroy" Text)
    {- ^ (Optional, Boolean) Set this to true if you do not wish to detach the volume from the instance to which it is attached at destroy time, and instead just remove the attachment from Terraform state. This is useful when destroying an instance which has volumes created by some other means attached. -}
    , _volume_id :: !(TF.Argument "volume_id" Text)
    {- ^ (Required) ID of the Volume to be attached -}
    } deriving (Show, Eq)

instance TF.ToHCL VolumeAttachmentResource where
    toHCL VolumeAttachmentResource{..} = TF.block $ catMaybes
        [ TF.argument _device_name
        , TF.argument _force_detach
        , TF.argument _instance_id
        , TF.argument _skip_destroy
        , TF.argument _volume_id
        ]

instance HasDeviceName VolumeAttachmentResource Text where
    deviceName =
        lens (_device_name :: VolumeAttachmentResource -> TF.Argument "device_name" Text)
             (\s a -> s { _device_name = a } :: VolumeAttachmentResource)

instance HasForceDetach VolumeAttachmentResource Text where
    forceDetach =
        lens (_force_detach :: VolumeAttachmentResource -> TF.Argument "force_detach" Text)
             (\s a -> s { _force_detach = a } :: VolumeAttachmentResource)

instance HasInstanceId VolumeAttachmentResource Text where
    instanceId =
        lens (_instance_id :: VolumeAttachmentResource -> TF.Argument "instance_id" Text)
             (\s a -> s { _instance_id = a } :: VolumeAttachmentResource)

instance HasSkipDestroy VolumeAttachmentResource Text where
    skipDestroy =
        lens (_skip_destroy :: VolumeAttachmentResource -> TF.Argument "skip_destroy" Text)
             (\s a -> s { _skip_destroy = a } :: VolumeAttachmentResource)

instance HasVolumeId VolumeAttachmentResource Text where
    volumeId =
        lens (_volume_id :: VolumeAttachmentResource -> TF.Argument "volume_id" Text)
             (\s a -> s { _volume_id = a } :: VolumeAttachmentResource)

instance HasComputedDeviceName VolumeAttachmentResource Text where
    computedDeviceName =
        to (\_  -> TF.Compute "device_name")

instance HasComputedInstanceId VolumeAttachmentResource Text where
    computedInstanceId =
        to (\_  -> TF.Compute "instance_id")

instance HasComputedVolumeId VolumeAttachmentResource Text where
    computedVolumeId =
        to (\_  -> TF.Compute "volume_id")

volumeAttachmentResource :: TF.Resource TF.AWS VolumeAttachmentResource
volumeAttachmentResource =
    TF.newResource "aws_volume_attachment" $
        VolumeAttachmentResource {
            _device_name = TF.Nil
            , _force_detach = TF.Nil
            , _instance_id = TF.Nil
            , _skip_destroy = TF.Nil
            , _volume_id = TF.Nil
            }

{- | The @aws_vpc_dhcp_options_association@ AWS resource.

Provides a VPC DHCP Options Association resource.
-}
data VpcDhcpOptionsAssociationResource = VpcDhcpOptionsAssociationResource {
      _dhcp_options_id :: !(TF.Argument "dhcp_options_id" Text)
    {- ^ (Required) The ID of the DHCP Options Set to associate to the VPC. -}
    , _vpc_id :: !(TF.Argument "vpc_id" Text)
    {- ^ (Required) The ID of the VPC to which we would like to associate a DHCP Options Set. -}
    } deriving (Show, Eq)

instance TF.ToHCL VpcDhcpOptionsAssociationResource where
    toHCL VpcDhcpOptionsAssociationResource{..} = TF.block $ catMaybes
        [ TF.argument _dhcp_options_id
        , TF.argument _vpc_id
        ]

instance HasDhcpOptionsId VpcDhcpOptionsAssociationResource Text where
    dhcpOptionsId =
        lens (_dhcp_options_id :: VpcDhcpOptionsAssociationResource -> TF.Argument "dhcp_options_id" Text)
             (\s a -> s { _dhcp_options_id = a } :: VpcDhcpOptionsAssociationResource)

instance HasVpcId VpcDhcpOptionsAssociationResource Text where
    vpcId =
        lens (_vpc_id :: VpcDhcpOptionsAssociationResource -> TF.Argument "vpc_id" Text)
             (\s a -> s { _vpc_id = a } :: VpcDhcpOptionsAssociationResource)

vpcDhcpOptionsAssociationResource :: TF.Resource TF.AWS VpcDhcpOptionsAssociationResource
vpcDhcpOptionsAssociationResource =
    TF.newResource "aws_vpc_dhcp_options_association" $
        VpcDhcpOptionsAssociationResource {
            _dhcp_options_id = TF.Nil
            , _vpc_id = TF.Nil
            }

{- | The @aws_vpc_dhcp_options@ AWS resource.

Provides a VPC DHCP Options resource.
-}
data VpcDhcpOptionsResource = VpcDhcpOptionsResource {
      _domain_name :: !(TF.Argument "domain_name" Text)
    {- ^ (Optional) the suffix domain name to use by default when resolving non Fully Qualified Domain Names. In other words, this is what ends up being the @search@ value in the @/etc/resolv.conf@ file. -}
    , _domain_name_servers :: !(TF.Argument "domain_name_servers" Text)
    {- ^ (Optional) List of name servers to configure in @/etc/resolv.conf@ . If you want to use the default AWS nameservers you should set this to @AmazonProvidedDNS@ . -}
    , _netbios_name_servers :: !(TF.Argument "netbios_name_servers" Text)
    {- ^ (Optional) List of NETBIOS name servers. -}
    , _netbios_node_type :: !(TF.Argument "netbios_node_type" Text)
    {- ^ (Optional) The NetBIOS node type (1, 2, 4, or 8). AWS recommends to specify 2 since broadcast and multicast are not supported in their network. For more information about these node types, see <http://www.ietf.org/rfc/rfc2132.txt> . -}
    , _ntp_servers :: !(TF.Argument "ntp_servers" Text)
    {- ^ (Optional) List of NTP servers to configure. -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    } deriving (Show, Eq)

instance TF.ToHCL VpcDhcpOptionsResource where
    toHCL VpcDhcpOptionsResource{..} = TF.block $ catMaybes
        [ TF.argument _domain_name
        , TF.argument _domain_name_servers
        , TF.argument _netbios_name_servers
        , TF.argument _netbios_node_type
        , TF.argument _ntp_servers
        , TF.argument _tags
        ]

instance HasDomainName VpcDhcpOptionsResource Text where
    domainName =
        lens (_domain_name :: VpcDhcpOptionsResource -> TF.Argument "domain_name" Text)
             (\s a -> s { _domain_name = a } :: VpcDhcpOptionsResource)

instance HasDomainNameServers VpcDhcpOptionsResource Text where
    domainNameServers =
        lens (_domain_name_servers :: VpcDhcpOptionsResource -> TF.Argument "domain_name_servers" Text)
             (\s a -> s { _domain_name_servers = a } :: VpcDhcpOptionsResource)

instance HasNetbiosNameServers VpcDhcpOptionsResource Text where
    netbiosNameServers =
        lens (_netbios_name_servers :: VpcDhcpOptionsResource -> TF.Argument "netbios_name_servers" Text)
             (\s a -> s { _netbios_name_servers = a } :: VpcDhcpOptionsResource)

instance HasNetbiosNodeType VpcDhcpOptionsResource Text where
    netbiosNodeType =
        lens (_netbios_node_type :: VpcDhcpOptionsResource -> TF.Argument "netbios_node_type" Text)
             (\s a -> s { _netbios_node_type = a } :: VpcDhcpOptionsResource)

instance HasNtpServers VpcDhcpOptionsResource Text where
    ntpServers =
        lens (_ntp_servers :: VpcDhcpOptionsResource -> TF.Argument "ntp_servers" Text)
             (\s a -> s { _ntp_servers = a } :: VpcDhcpOptionsResource)

instance HasTags VpcDhcpOptionsResource TF.Tags where
    tags =
        lens (_tags :: VpcDhcpOptionsResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: VpcDhcpOptionsResource)

vpcDhcpOptionsResource :: TF.Resource TF.AWS VpcDhcpOptionsResource
vpcDhcpOptionsResource =
    TF.newResource "aws_vpc_dhcp_options" $
        VpcDhcpOptionsResource {
            _domain_name = TF.Nil
            , _domain_name_servers = TF.Nil
            , _netbios_name_servers = TF.Nil
            , _netbios_node_type = TF.Nil
            , _ntp_servers = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_vpc_endpoint@ AWS resource.

Provides a VPC Endpoint resource. ~> NOTE on VPC Endpoints and VPC Endpoint
Route Table Associations: Terraform provides both a standalone
<vpc_endpoint_route_table_association.html> (an association between a VPC
endpoint and a single @route_table_id@ ) and a VPC Endpoint resource with a
@route_table_ids@ attribute. Do not use the same route table ID in both a
VPC Endpoint resource and a VPC Endpoint Route Table Association resource.
Doing so will cause a conflict of associations and will overwrite the
association.
-}
data VpcEndpointResource = VpcEndpointResource {
      _policy :: !(TF.Argument "policy" Text)
    {- ^ (Optional) A policy to attach to the endpoint that controls access to the service. -}
    , _route_table_ids :: !(TF.Argument "route_table_ids" Text)
    {- ^ (Optional) One or more route table IDs. -}
    , _service_name :: !(TF.Argument "service_name" Text)
    {- ^ (Required) The AWS service name, in the form @com.amazonaws.region.service@ . -}
    , _vpc_id :: !(TF.Argument "vpc_id" Text)
    {- ^ (Required) The ID of the VPC in which the endpoint will be used. -}
    } deriving (Show, Eq)

instance TF.ToHCL VpcEndpointResource where
    toHCL VpcEndpointResource{..} = TF.block $ catMaybes
        [ TF.argument _policy
        , TF.argument _route_table_ids
        , TF.argument _service_name
        , TF.argument _vpc_id
        ]

instance HasPolicy VpcEndpointResource Text where
    policy =
        lens (_policy :: VpcEndpointResource -> TF.Argument "policy" Text)
             (\s a -> s { _policy = a } :: VpcEndpointResource)

instance HasRouteTableIds VpcEndpointResource Text where
    routeTableIds =
        lens (_route_table_ids :: VpcEndpointResource -> TF.Argument "route_table_ids" Text)
             (\s a -> s { _route_table_ids = a } :: VpcEndpointResource)

instance HasServiceName VpcEndpointResource Text where
    serviceName =
        lens (_service_name :: VpcEndpointResource -> TF.Argument "service_name" Text)
             (\s a -> s { _service_name = a } :: VpcEndpointResource)

instance HasVpcId VpcEndpointResource Text where
    vpcId =
        lens (_vpc_id :: VpcEndpointResource -> TF.Argument "vpc_id" Text)
             (\s a -> s { _vpc_id = a } :: VpcEndpointResource)

instance HasComputedCidrBlocks VpcEndpointResource Text where
    computedCidrBlocks =
        to (\_  -> TF.Compute "cidr_blocks")

instance HasComputedId VpcEndpointResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedPrefixListId VpcEndpointResource Text where
    computedPrefixListId =
        to (\_  -> TF.Compute "prefix_list_id")

vpcEndpointResource :: TF.Resource TF.AWS VpcEndpointResource
vpcEndpointResource =
    TF.newResource "aws_vpc_endpoint" $
        VpcEndpointResource {
            _policy = TF.Nil
            , _route_table_ids = TF.Nil
            , _service_name = TF.Nil
            , _vpc_id = TF.Nil
            }

{- | The @aws_vpc_endpoint_route_table_association@ AWS resource.

Provides a resource to create an association between a VPC endpoint and
routing table. ~> NOTE on VPC Endpoints and VPC Endpoint Route Table
Associations: Terraform provides both a standalone VPC Endpoint Route Table
Association (an association between a VPC endpoint and a single
@route_table_id@ ) and a <vpc_endpoint.html> resource with a
@route_table_ids@ attribute. Do not use the same route table ID in both a
VPC Endpoint resource and a VPC Endpoint Route Table Association resource.
Doing so will cause a conflict of associations and will overwrite the
association.
-}
data VpcEndpointRouteTableAssociationResource = VpcEndpointRouteTableAssociationResource {
      _route_table_id :: !(TF.Argument "route_table_id" Text)
    {- ^ (Required) The ID of the routing table to be associated with the VPC endpoint. -}
    , _vpc_endpoint_id :: !(TF.Argument "vpc_endpoint_id" Text)
    {- ^ (Required) The ID of the VPC endpoint with which the routing table will be associated. -}
    } deriving (Show, Eq)

instance TF.ToHCL VpcEndpointRouteTableAssociationResource where
    toHCL VpcEndpointRouteTableAssociationResource{..} = TF.block $ catMaybes
        [ TF.argument _route_table_id
        , TF.argument _vpc_endpoint_id
        ]

instance HasRouteTableId VpcEndpointRouteTableAssociationResource Text where
    routeTableId =
        lens (_route_table_id :: VpcEndpointRouteTableAssociationResource -> TF.Argument "route_table_id" Text)
             (\s a -> s { _route_table_id = a } :: VpcEndpointRouteTableAssociationResource)

instance HasVpcEndpointId VpcEndpointRouteTableAssociationResource Text where
    vpcEndpointId =
        lens (_vpc_endpoint_id :: VpcEndpointRouteTableAssociationResource -> TF.Argument "vpc_endpoint_id" Text)
             (\s a -> s { _vpc_endpoint_id = a } :: VpcEndpointRouteTableAssociationResource)

instance HasComputedId VpcEndpointRouteTableAssociationResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

vpcEndpointRouteTableAssociationResource :: TF.Resource TF.AWS VpcEndpointRouteTableAssociationResource
vpcEndpointRouteTableAssociationResource =
    TF.newResource "aws_vpc_endpoint_route_table_association" $
        VpcEndpointRouteTableAssociationResource {
            _route_table_id = TF.Nil
            , _vpc_endpoint_id = TF.Nil
            }

{- | The @aws_vpc_peering_connection_accepter@ AWS resource.

Provides a resource to manage the accepter's side of a VPC Peering
Connection. When a cross-account (requester's AWS account differs from the
accepter's AWS account) or an inter-region VPC Peering Connection is
created, a VPC Peering Connection resource is automatically created in the
accepter's account. The requester can use the @aws_vpc_peering_connection@
resource to manage its side of the connection and the accepter can use the
@aws_vpc_peering_connection_accepter@ resource to "adopt" its side of the
connection into management.
-}
data VpcPeeringConnectionAccepterResource = VpcPeeringConnectionAccepterResource {
      _auto_accept :: !(TF.Argument "auto_accept" Text)
    {- ^ (Optional) Whether or not to accept the peering request. Defaults to @false@ . -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    , _vpc_peering_connection_id :: !(TF.Argument "vpc_peering_connection_id" Text)
    {- ^ (Required) The VPC Peering Connection ID to manage. -}
    } deriving (Show, Eq)

instance TF.ToHCL VpcPeeringConnectionAccepterResource where
    toHCL VpcPeeringConnectionAccepterResource{..} = TF.block $ catMaybes
        [ TF.argument _auto_accept
        , TF.argument _tags
        , TF.argument _vpc_peering_connection_id
        ]

instance HasAutoAccept VpcPeeringConnectionAccepterResource Text where
    autoAccept =
        lens (_auto_accept :: VpcPeeringConnectionAccepterResource -> TF.Argument "auto_accept" Text)
             (\s a -> s { _auto_accept = a } :: VpcPeeringConnectionAccepterResource)

instance HasTags VpcPeeringConnectionAccepterResource TF.Tags where
    tags =
        lens (_tags :: VpcPeeringConnectionAccepterResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: VpcPeeringConnectionAccepterResource)

instance HasVpcPeeringConnectionId VpcPeeringConnectionAccepterResource Text where
    vpcPeeringConnectionId =
        lens (_vpc_peering_connection_id :: VpcPeeringConnectionAccepterResource -> TF.Argument "vpc_peering_connection_id" Text)
             (\s a -> s { _vpc_peering_connection_id = a } :: VpcPeeringConnectionAccepterResource)

vpcPeeringConnectionAccepterResource :: TF.Resource TF.AWS VpcPeeringConnectionAccepterResource
vpcPeeringConnectionAccepterResource =
    TF.newResource "aws_vpc_peering_connection_accepter" $
        VpcPeeringConnectionAccepterResource {
            _auto_accept = TF.Nil
            , _tags = TF.Nil
            , _vpc_peering_connection_id = TF.Nil
            }

{- | The @aws_vpc_peering_connection@ AWS resource.

Provides a resource to manage a VPC Peering Connection resource. -> Note:
For cross-account (requester's AWS account differs from the accepter's AWS
account) or inter-region VPC Peering Connections use the
@aws_vpc_peering_connection@ resource to manage the requester's side of the
connection and use the @aws_vpc_peering_connection_accepter@ resource to
manage the accepter's side of the connection.
-}
data VpcPeeringConnectionResource = VpcPeeringConnectionResource {
      _accepter :: !(TF.Argument "accepter" Text)
    {- ^ (Optional) - An optional configuration block that allows for [VPC Peering Connection] (http://docs.aws.amazon.com/AmazonVPC/latest/PeeringGuide) options to be set for the VPC that accepts the peering connection (a maximum of one). -}
    , _auto_accept :: !(TF.Argument "auto_accept" Text)
    {- ^ (Optional) Accept the peering (both VPCs need to be in the same AWS account). -}
    , _peer_owner_id :: !(TF.Argument "peer_owner_id" Text)
    {- ^ (Optional) The AWS account ID of the owner of the peer VPC. Defaults to the account ID the </docs/providers/aws/index.html> is currently connected to. -}
    , _peer_region :: !(TF.Argument "peer_region" TF.Region)
    {- ^ (Optional) The region of the accepter VPC of the [VPC Peering Connection]. @auto_accept@ must be @false@ , and use the @aws_vpc_peering_connection_accepter@ to manage the accepter side. -}
    , _peer_vpc_id :: !(TF.Argument "peer_vpc_id" Text)
    {- ^ (Required) The ID of the VPC with which you are creating the VPC Peering Connection. -}
    , _requester :: !(TF.Argument "requester" Text)
    {- ^ (Optional) - A optional configuration block that allows for [VPC Peering Connection] (http://docs.aws.amazon.com/AmazonVPC/latest/PeeringGuide) options to be set for the VPC that requests the peering connection (a maximum of one). -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    , _vpc_id :: !(TF.Argument "vpc_id" Text)
    {- ^ (Required) The ID of the requester VPC. -}
    } deriving (Show, Eq)

instance TF.ToHCL VpcPeeringConnectionResource where
    toHCL VpcPeeringConnectionResource{..} = TF.block $ catMaybes
        [ TF.argument _accepter
        , TF.argument _auto_accept
        , TF.argument _peer_owner_id
        , TF.argument _peer_region
        , TF.argument _peer_vpc_id
        , TF.argument _requester
        , TF.argument _tags
        , TF.argument _vpc_id
        ]

instance HasAccepter VpcPeeringConnectionResource Text where
    accepter =
        lens (_accepter :: VpcPeeringConnectionResource -> TF.Argument "accepter" Text)
             (\s a -> s { _accepter = a } :: VpcPeeringConnectionResource)

instance HasAutoAccept VpcPeeringConnectionResource Text where
    autoAccept =
        lens (_auto_accept :: VpcPeeringConnectionResource -> TF.Argument "auto_accept" Text)
             (\s a -> s { _auto_accept = a } :: VpcPeeringConnectionResource)

instance HasPeerOwnerId VpcPeeringConnectionResource Text where
    peerOwnerId =
        lens (_peer_owner_id :: VpcPeeringConnectionResource -> TF.Argument "peer_owner_id" Text)
             (\s a -> s { _peer_owner_id = a } :: VpcPeeringConnectionResource)

instance HasPeerRegion VpcPeeringConnectionResource TF.Region where
    peerRegion =
        lens (_peer_region :: VpcPeeringConnectionResource -> TF.Argument "peer_region" TF.Region)
             (\s a -> s { _peer_region = a } :: VpcPeeringConnectionResource)

instance HasPeerVpcId VpcPeeringConnectionResource Text where
    peerVpcId =
        lens (_peer_vpc_id :: VpcPeeringConnectionResource -> TF.Argument "peer_vpc_id" Text)
             (\s a -> s { _peer_vpc_id = a } :: VpcPeeringConnectionResource)

instance HasRequester VpcPeeringConnectionResource Text where
    requester =
        lens (_requester :: VpcPeeringConnectionResource -> TF.Argument "requester" Text)
             (\s a -> s { _requester = a } :: VpcPeeringConnectionResource)

instance HasTags VpcPeeringConnectionResource TF.Tags where
    tags =
        lens (_tags :: VpcPeeringConnectionResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: VpcPeeringConnectionResource)

instance HasVpcId VpcPeeringConnectionResource Text where
    vpcId =
        lens (_vpc_id :: VpcPeeringConnectionResource -> TF.Argument "vpc_id" Text)
             (\s a -> s { _vpc_id = a } :: VpcPeeringConnectionResource)

vpcPeeringConnectionResource :: TF.Resource TF.AWS VpcPeeringConnectionResource
vpcPeeringConnectionResource =
    TF.newResource "aws_vpc_peering_connection" $
        VpcPeeringConnectionResource {
            _accepter = TF.Nil
            , _auto_accept = TF.Nil
            , _peer_owner_id = TF.Nil
            , _peer_region = TF.Nil
            , _peer_vpc_id = TF.Nil
            , _requester = TF.Nil
            , _tags = TF.Nil
            , _vpc_id = TF.Nil
            }

{- | The @aws_vpc@ AWS resource.

Provides an VPC resource.
-}
data VpcResource = VpcResource {
      _assign_generated_ipv6_cidr_block :: !(TF.Argument "assign_generated_ipv6_cidr_block" TF.CIDR)
    {- ^ (Optional) Requests an Amazon-provided IPv6 CIDR block with a /56 prefix length for the VPC. You cannot specify the range of IP addresses, or the size of the CIDR block. Default is @false@ . -}
    , _cidr_block :: !(TF.Argument "cidr_block" TF.CIDR)
    {- ^ (Required) The CIDR block for the VPC. -}
    , _enable_classiclink :: !(TF.Argument "enable_classiclink" TF.Bool)
    {- ^ (Optional) A boolean flag to enable/disable ClassicLink for the VPC. Only valid in regions and accounts that support EC2 Classic. See the <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/vpc-classiclink.html> for more information. Defaults false. -}
    , _enable_classiclink_dns_support :: !(TF.Argument "enable_classiclink_dns_support" TF.Bool)
    {- ^ (Optional) A boolean flag to enable/disable ClassicLink DNS Support for the VPC. Only valid in regions and accounts that support EC2 Classic. -}
    , _enable_dns_hostnames :: !(TF.Argument "enable_dns_hostnames" TF.Bool)
    {- ^ (Optional) A boolean flag to enable/disable DNS hostnames in the VPC. Defaults false. -}
    , _enable_dns_support :: !(TF.Argument "enable_dns_support" TF.Bool)
    {- ^ (Optional) A boolean flag to enable/disable DNS support in the VPC. Defaults true. -}
    , _instance_tenancy :: !(TF.Argument "instance_tenancy" Text)
    {- ^ (Optional) A tenancy option for instances launched into the VPC -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    } deriving (Show, Eq)

instance TF.ToHCL VpcResource where
    toHCL VpcResource{..} = TF.block $ catMaybes
        [ TF.argument _assign_generated_ipv6_cidr_block
        , TF.argument _cidr_block
        , TF.argument _enable_classiclink
        , TF.argument _enable_classiclink_dns_support
        , TF.argument _enable_dns_hostnames
        , TF.argument _enable_dns_support
        , TF.argument _instance_tenancy
        , TF.argument _tags
        ]

instance HasAssignGeneratedIpv6CidrBlock VpcResource TF.CIDR where
    assignGeneratedIpv6CidrBlock =
        lens (_assign_generated_ipv6_cidr_block :: VpcResource -> TF.Argument "assign_generated_ipv6_cidr_block" TF.CIDR)
             (\s a -> s { _assign_generated_ipv6_cidr_block = a } :: VpcResource)

instance HasCidrBlock VpcResource TF.CIDR where
    cidrBlock =
        lens (_cidr_block :: VpcResource -> TF.Argument "cidr_block" TF.CIDR)
             (\s a -> s { _cidr_block = a } :: VpcResource)

instance HasEnableClassiclink VpcResource TF.Bool where
    enableClassiclink =
        lens (_enable_classiclink :: VpcResource -> TF.Argument "enable_classiclink" TF.Bool)
             (\s a -> s { _enable_classiclink = a } :: VpcResource)

instance HasEnableClassiclinkDnsSupport VpcResource TF.Bool where
    enableClassiclinkDnsSupport =
        lens (_enable_classiclink_dns_support :: VpcResource -> TF.Argument "enable_classiclink_dns_support" TF.Bool)
             (\s a -> s { _enable_classiclink_dns_support = a } :: VpcResource)

instance HasEnableDnsHostnames VpcResource TF.Bool where
    enableDnsHostnames =
        lens (_enable_dns_hostnames :: VpcResource -> TF.Argument "enable_dns_hostnames" TF.Bool)
             (\s a -> s { _enable_dns_hostnames = a } :: VpcResource)

instance HasEnableDnsSupport VpcResource TF.Bool where
    enableDnsSupport =
        lens (_enable_dns_support :: VpcResource -> TF.Argument "enable_dns_support" TF.Bool)
             (\s a -> s { _enable_dns_support = a } :: VpcResource)

instance HasInstanceTenancy VpcResource Text where
    instanceTenancy =
        lens (_instance_tenancy :: VpcResource -> TF.Argument "instance_tenancy" Text)
             (\s a -> s { _instance_tenancy = a } :: VpcResource)

instance HasTags VpcResource TF.Tags where
    tags =
        lens (_tags :: VpcResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: VpcResource)

instance HasComputedCidrBlock VpcResource TF.CIDR where
    computedCidrBlock =
        to (\_  -> TF.Compute "cidr_block")

instance HasComputedDefaultNetworkAclId VpcResource Text where
    computedDefaultNetworkAclId =
        to (\_  -> TF.Compute "default_network_acl_id")

instance HasComputedDefaultRouteTableId VpcResource Text where
    computedDefaultRouteTableId =
        to (\_  -> TF.Compute "default_route_table_id")

instance HasComputedDefaultSecurityGroupId VpcResource Text where
    computedDefaultSecurityGroupId =
        to (\_  -> TF.Compute "default_security_group_id")

instance HasComputedEnableClassiclink VpcResource TF.Bool where
    computedEnableClassiclink =
        to (\_  -> TF.Compute "enable_classiclink")

instance HasComputedEnableDnsHostnames VpcResource TF.Bool where
    computedEnableDnsHostnames =
        to (\_  -> TF.Compute "enable_dns_hostnames")

instance HasComputedEnableDnsSupport VpcResource TF.Bool where
    computedEnableDnsSupport =
        to (\_  -> TF.Compute "enable_dns_support")

instance HasComputedId VpcResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedInstanceTenancy VpcResource Text where
    computedInstanceTenancy =
        to (\_  -> TF.Compute "instance_tenancy")

instance HasComputedIpv6AssociationId VpcResource Text where
    computedIpv6AssociationId =
        to (\_  -> TF.Compute "ipv6_association_id")

instance HasComputedIpv6CidrBlock VpcResource TF.CIDR where
    computedIpv6CidrBlock =
        to (\_  -> TF.Compute "ipv6_cidr_block")

instance HasComputedMainRouteTableId VpcResource Text where
    computedMainRouteTableId =
        to (\_  -> TF.Compute "main_route_table_id")

vpcResource :: TF.Resource TF.AWS VpcResource
vpcResource =
    TF.newResource "aws_vpc" $
        VpcResource {
            _assign_generated_ipv6_cidr_block = TF.Nil
            , _cidr_block = TF.Nil
            , _enable_classiclink = TF.Nil
            , _enable_classiclink_dns_support = TF.Nil
            , _enable_dns_hostnames = TF.Nil
            , _enable_dns_support = TF.Nil
            , _instance_tenancy = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_vpn_connection@ AWS resource.

Provides a VPN connection connected to a VPC. These objects can be connected
to customer gateways, and allow you to establish tunnels between your
network and the VPC. ~> Note: All arguments including
@tunnel1_preshared_key@ and @tunnel2_preshared_key@ will be stored in the
raw state as plain-text. </docs/state/sensitive-data.html> .
-}
data VpnConnectionResource = VpnConnectionResource {
      _customer_gateway_id :: !(TF.Argument "customer_gateway_id" Text)
    {- ^ (Required) The ID of the customer gateway. -}
    , _static_routes_only :: !(TF.Argument "static_routes_only" Text)
    {- ^ (Optional, Default @false@ ) Whether the VPN connection uses static routes exclusively. Static routes must be used for devices that don't support BGP. -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) Tags to apply to the connection. -}
    , _type' :: !(TF.Argument "type" Text)
    {- ^ (Required) The type of VPN connection. The only type AWS supports at this time is "ipsec.1". -}
    , _vpn_gateway_id :: !(TF.Argument "vpn_gateway_id" Text)
    {- ^ (Required) The ID of the virtual private gateway. -}
    } deriving (Show, Eq)

instance TF.ToHCL VpnConnectionResource where
    toHCL VpnConnectionResource{..} = TF.block $ catMaybes
        [ TF.argument _customer_gateway_id
        , TF.argument _static_routes_only
        , TF.argument _tags
        , TF.argument _type'
        , TF.argument _vpn_gateway_id
        ]

instance HasCustomerGatewayId VpnConnectionResource Text where
    customerGatewayId =
        lens (_customer_gateway_id :: VpnConnectionResource -> TF.Argument "customer_gateway_id" Text)
             (\s a -> s { _customer_gateway_id = a } :: VpnConnectionResource)

instance HasStaticRoutesOnly VpnConnectionResource Text where
    staticRoutesOnly =
        lens (_static_routes_only :: VpnConnectionResource -> TF.Argument "static_routes_only" Text)
             (\s a -> s { _static_routes_only = a } :: VpnConnectionResource)

instance HasTags VpnConnectionResource TF.Tags where
    tags =
        lens (_tags :: VpnConnectionResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: VpnConnectionResource)

instance HasType' VpnConnectionResource Text where
    type' =
        lens (_type' :: VpnConnectionResource -> TF.Argument "type" Text)
             (\s a -> s { _type' = a } :: VpnConnectionResource)

instance HasVpnGatewayId VpnConnectionResource Text where
    vpnGatewayId =
        lens (_vpn_gateway_id :: VpnConnectionResource -> TF.Argument "vpn_gateway_id" Text)
             (\s a -> s { _vpn_gateway_id = a } :: VpnConnectionResource)

instance HasComputedCustomerGatewayConfiguration VpnConnectionResource Text where
    computedCustomerGatewayConfiguration =
        to (\_  -> TF.Compute "customer_gateway_configuration")

instance HasComputedCustomerGatewayId VpnConnectionResource Text where
    computedCustomerGatewayId =
        to (\_  -> TF.Compute "customer_gateway_id")

instance HasComputedId VpnConnectionResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

instance HasComputedStaticRoutesOnly VpnConnectionResource Text where
    computedStaticRoutesOnly =
        to (\_  -> TF.Compute "static_routes_only")

instance HasComputedTags VpnConnectionResource TF.Tags where
    computedTags =
        to (\_  -> TF.Compute "tags")

instance HasComputedTunnel1Address VpnConnectionResource Text where
    computedTunnel1Address =
        to (\_  -> TF.Compute "tunnel1_address")

instance HasComputedTunnel1BgpAsn VpnConnectionResource Text where
    computedTunnel1BgpAsn =
        to (\_  -> TF.Compute "tunnel1_bgp_asn")

instance HasComputedTunnel1BgpHoldtime VpnConnectionResource Text where
    computedTunnel1BgpHoldtime =
        to (\_  -> TF.Compute "tunnel1_bgp_holdtime")

instance HasComputedTunnel1CgwInsideAddress VpnConnectionResource Text where
    computedTunnel1CgwInsideAddress =
        to (\_  -> TF.Compute "tunnel1_cgw_inside_address")

instance HasComputedTunnel1PresharedKey VpnConnectionResource Text where
    computedTunnel1PresharedKey =
        to (\_  -> TF.Compute "tunnel1_preshared_key")

instance HasComputedTunnel1VgwInsideAddress VpnConnectionResource Text where
    computedTunnel1VgwInsideAddress =
        to (\_  -> TF.Compute "tunnel1_vgw_inside_address")

instance HasComputedTunnel2Address VpnConnectionResource Text where
    computedTunnel2Address =
        to (\_  -> TF.Compute "tunnel2_address")

instance HasComputedTunnel2BgpAsn VpnConnectionResource Text where
    computedTunnel2BgpAsn =
        to (\_  -> TF.Compute "tunnel2_bgp_asn")

instance HasComputedTunnel2BgpHoldtime VpnConnectionResource Text where
    computedTunnel2BgpHoldtime =
        to (\_  -> TF.Compute "tunnel2_bgp_holdtime")

instance HasComputedTunnel2CgwInsideAddress VpnConnectionResource Text where
    computedTunnel2CgwInsideAddress =
        to (\_  -> TF.Compute "tunnel2_cgw_inside_address")

instance HasComputedTunnel2PresharedKey VpnConnectionResource Text where
    computedTunnel2PresharedKey =
        to (\_  -> TF.Compute "tunnel2_preshared_key")

instance HasComputedTunnel2VgwInsideAddress VpnConnectionResource Text where
    computedTunnel2VgwInsideAddress =
        to (\_  -> TF.Compute "tunnel2_vgw_inside_address")

instance HasComputedType' VpnConnectionResource Text where
    computedType' =
        to (\_  -> TF.Compute "type")

instance HasComputedVpnGatewayId VpnConnectionResource Text where
    computedVpnGatewayId =
        to (\_  -> TF.Compute "vpn_gateway_id")

vpnConnectionResource :: TF.Resource TF.AWS VpnConnectionResource
vpnConnectionResource =
    TF.newResource "aws_vpn_connection" $
        VpnConnectionResource {
            _customer_gateway_id = TF.Nil
            , _static_routes_only = TF.Nil
            , _tags = TF.Nil
            , _type' = TF.Nil
            , _vpn_gateway_id = TF.Nil
            }

{- | The @aws_vpn_connection_route@ AWS resource.

Provides a static route between a VPN connection and a customer gateway.
-}
data VpnConnectionRouteResource = VpnConnectionRouteResource {
      _destination_cidr_block :: !(TF.Argument "destination_cidr_block" TF.CIDR)
    {- ^ (Required) The CIDR block associated with the local subnet of the customer network. -}
    , _vpn_connection_id :: !(TF.Argument "vpn_connection_id" Text)
    {- ^ (Required) The ID of the VPN connection. -}
    } deriving (Show, Eq)

instance TF.ToHCL VpnConnectionRouteResource where
    toHCL VpnConnectionRouteResource{..} = TF.block $ catMaybes
        [ TF.argument _destination_cidr_block
        , TF.argument _vpn_connection_id
        ]

instance HasDestinationCidrBlock VpnConnectionRouteResource TF.CIDR where
    destinationCidrBlock =
        lens (_destination_cidr_block :: VpnConnectionRouteResource -> TF.Argument "destination_cidr_block" TF.CIDR)
             (\s a -> s { _destination_cidr_block = a } :: VpnConnectionRouteResource)

instance HasVpnConnectionId VpnConnectionRouteResource Text where
    vpnConnectionId =
        lens (_vpn_connection_id :: VpnConnectionRouteResource -> TF.Argument "vpn_connection_id" Text)
             (\s a -> s { _vpn_connection_id = a } :: VpnConnectionRouteResource)

instance HasComputedDestinationCidrBlock VpnConnectionRouteResource TF.CIDR where
    computedDestinationCidrBlock =
        to (\_  -> TF.Compute "destination_cidr_block")

instance HasComputedVpnConnectionId VpnConnectionRouteResource Text where
    computedVpnConnectionId =
        to (\_  -> TF.Compute "vpn_connection_id")

vpnConnectionRouteResource :: TF.Resource TF.AWS VpnConnectionRouteResource
vpnConnectionRouteResource =
    TF.newResource "aws_vpn_connection_route" $
        VpnConnectionRouteResource {
            _destination_cidr_block = TF.Nil
            , _vpn_connection_id = TF.Nil
            }

{- | The @aws_vpn_gateway_attachment@ AWS resource.

Provides a Virtual Private Gateway attachment resource, allowing for an
existing hardware VPN gateway to be attached and/or detached from a VPC. ->
Note: The <vpn_gateway.html> resource can also automatically attach the
Virtual Private Gateway it creates to an existing VPC by setting the
<vpn_gateway.html#vpc_id> attribute accordingly.
-}
data VpnGatewayAttachmentResource = VpnGatewayAttachmentResource {
      _vpc_id :: !(TF.Argument "vpc_id" Text)
    {- ^ (Required) The ID of the VPC. -}
    , _vpn_gateway_id :: !(TF.Argument "vpn_gateway_id" Text)
    {- ^ (Required) The ID of the Virtual Private Gateway. -}
    } deriving (Show, Eq)

instance TF.ToHCL VpnGatewayAttachmentResource where
    toHCL VpnGatewayAttachmentResource{..} = TF.block $ catMaybes
        [ TF.argument _vpc_id
        , TF.argument _vpn_gateway_id
        ]

instance HasVpcId VpnGatewayAttachmentResource Text where
    vpcId =
        lens (_vpc_id :: VpnGatewayAttachmentResource -> TF.Argument "vpc_id" Text)
             (\s a -> s { _vpc_id = a } :: VpnGatewayAttachmentResource)

instance HasVpnGatewayId VpnGatewayAttachmentResource Text where
    vpnGatewayId =
        lens (_vpn_gateway_id :: VpnGatewayAttachmentResource -> TF.Argument "vpn_gateway_id" Text)
             (\s a -> s { _vpn_gateway_id = a } :: VpnGatewayAttachmentResource)

instance HasComputedVpcId VpnGatewayAttachmentResource Text where
    computedVpcId =
        to (\_  -> TF.Compute "vpc_id")

instance HasComputedVpnGatewayId VpnGatewayAttachmentResource Text where
    computedVpnGatewayId =
        to (\_  -> TF.Compute "vpn_gateway_id")

vpnGatewayAttachmentResource :: TF.Resource TF.AWS VpnGatewayAttachmentResource
vpnGatewayAttachmentResource =
    TF.newResource "aws_vpn_gateway_attachment" $
        VpnGatewayAttachmentResource {
            _vpc_id = TF.Nil
            , _vpn_gateway_id = TF.Nil
            }

{- | The @aws_vpn_gateway@ AWS resource.

Provides a resource to create a VPC VPN Gateway.
-}
data VpnGatewayResource = VpnGatewayResource {
      _availability_zone :: !(TF.Argument "availability_zone" TF.Zone)
    {- ^ (Optional) The Availability Zone for the virtual private gateway. -}
    , _tags :: !(TF.Argument "tags" TF.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    , _vpc_id :: !(TF.Argument "vpc_id" Text)
    {- ^ (Optional) The VPC ID to create in. -}
    } deriving (Show, Eq)

instance TF.ToHCL VpnGatewayResource where
    toHCL VpnGatewayResource{..} = TF.block $ catMaybes
        [ TF.argument _availability_zone
        , TF.argument _tags
        , TF.argument _vpc_id
        ]

instance HasAvailabilityZone VpnGatewayResource TF.Zone where
    availabilityZone =
        lens (_availability_zone :: VpnGatewayResource -> TF.Argument "availability_zone" TF.Zone)
             (\s a -> s { _availability_zone = a } :: VpnGatewayResource)

instance HasTags VpnGatewayResource TF.Tags where
    tags =
        lens (_tags :: VpnGatewayResource -> TF.Argument "tags" TF.Tags)
             (\s a -> s { _tags = a } :: VpnGatewayResource)

instance HasVpcId VpnGatewayResource Text where
    vpcId =
        lens (_vpc_id :: VpnGatewayResource -> TF.Argument "vpc_id" Text)
             (\s a -> s { _vpc_id = a } :: VpnGatewayResource)

instance HasComputedId VpnGatewayResource Text where
    computedId =
        to (\_  -> TF.Compute "id")

vpnGatewayResource :: TF.Resource TF.AWS VpnGatewayResource
vpnGatewayResource =
    TF.newResource "aws_vpn_gateway" $
        VpnGatewayResource {
            _availability_zone = TF.Nil
            , _tags = TF.Nil
            , _vpc_id = TF.Nil
            }

{- | The @aws_vpn_gateway_route_propagation@ AWS resource.

Requests automatic route propagation between a VPN gateway and a route
table. ~> Note: This resource should not be used with a route table that has
the @propagating_vgws@ argument set. If that argument is set, any route
propagation not explicitly listed in its value will be removed.
-}
data VpnGatewayRoutePropagationResource = VpnGatewayRoutePropagationResource {
      _route_table_id :: !(TF.Argument "route_table_id" Text)
    {- ^ - The id of the @aws_route_table@ to propagate routes into. -}
    , _vpn_gateway_id :: !(TF.Argument "vpn_gateway_id" Text)
    {- ^ - The id of the @aws_vpn_gateway@ to propagate routes from. -}
    } deriving (Show, Eq)

instance TF.ToHCL VpnGatewayRoutePropagationResource where
    toHCL VpnGatewayRoutePropagationResource{..} = TF.block $ catMaybes
        [ TF.argument _route_table_id
        , TF.argument _vpn_gateway_id
        ]

instance HasRouteTableId VpnGatewayRoutePropagationResource Text where
    routeTableId =
        lens (_route_table_id :: VpnGatewayRoutePropagationResource -> TF.Argument "route_table_id" Text)
             (\s a -> s { _route_table_id = a } :: VpnGatewayRoutePropagationResource)

instance HasVpnGatewayId VpnGatewayRoutePropagationResource Text where
    vpnGatewayId =
        lens (_vpn_gateway_id :: VpnGatewayRoutePropagationResource -> TF.Argument "vpn_gateway_id" Text)
             (\s a -> s { _vpn_gateway_id = a } :: VpnGatewayRoutePropagationResource)

vpnGatewayRoutePropagationResource :: TF.Resource TF.AWS VpnGatewayRoutePropagationResource
vpnGatewayRoutePropagationResource =
    TF.newResource "aws_vpn_gateway_route_propagation" $
        VpnGatewayRoutePropagationResource {
            _route_table_id = TF.Nil
            , _vpn_gateway_id = TF.Nil
            }

{- | The @aws_waf_byte_match_set@ AWS resource.

Provides a WAF Byte Match Set Resource
-}
data WafByteMatchSetResource = WafByteMatchSetResource {
      _byte_match_tuples :: !(TF.Argument "byte_match_tuples" Text)
    {- ^ - Specifies the bytes (typically a string that corresponds with ASCII characters) that you want to search for in web requests, the location in requests that you want to search, and other settings. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name or description of the Byte Match Set. -}
    } deriving (Show, Eq)

instance TF.ToHCL WafByteMatchSetResource where
    toHCL WafByteMatchSetResource{..} = TF.block $ catMaybes
        [ TF.argument _byte_match_tuples
        , TF.argument _name
        ]

instance HasByteMatchTuples WafByteMatchSetResource Text where
    byteMatchTuples =
        lens (_byte_match_tuples :: WafByteMatchSetResource -> TF.Argument "byte_match_tuples" Text)
             (\s a -> s { _byte_match_tuples = a } :: WafByteMatchSetResource)

instance HasName WafByteMatchSetResource Text where
    name =
        lens (_name :: WafByteMatchSetResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: WafByteMatchSetResource)

wafByteMatchSetResource :: TF.Resource TF.AWS WafByteMatchSetResource
wafByteMatchSetResource =
    TF.newResource "aws_waf_byte_match_set" $
        WafByteMatchSetResource {
            _byte_match_tuples = TF.Nil
            , _name = TF.Nil
            }

{- | The @aws_waf_ipset@ AWS resource.

Provides a WAF IPSet Resource
-}
data WafIpsetResource = WafIpsetResource {
      _ip_set_descriptors :: !(TF.Argument "ip_set_descriptors" Text)
    {- ^ (Optional) Specifies the IP address type (IPV4 or IPV6) and the IP address range (in CIDR format) that web requests originate from. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name or description of the IPSet. -}
    } deriving (Show, Eq)

instance TF.ToHCL WafIpsetResource where
    toHCL WafIpsetResource{..} = TF.block $ catMaybes
        [ TF.argument _ip_set_descriptors
        , TF.argument _name
        ]

instance HasIpSetDescriptors WafIpsetResource Text where
    ipSetDescriptors =
        lens (_ip_set_descriptors :: WafIpsetResource -> TF.Argument "ip_set_descriptors" Text)
             (\s a -> s { _ip_set_descriptors = a } :: WafIpsetResource)

instance HasName WafIpsetResource Text where
    name =
        lens (_name :: WafIpsetResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: WafIpsetResource)

wafIpsetResource :: TF.Resource TF.AWS WafIpsetResource
wafIpsetResource =
    TF.newResource "aws_waf_ipset" $
        WafIpsetResource {
            _ip_set_descriptors = TF.Nil
            , _name = TF.Nil
            }

{- | The @aws_waf_rate_based_rule@ AWS resource.

Provides a WAF Rate Based Rule Resource
-}
data WafRateBasedRuleResource = WafRateBasedRuleResource {
      _metric_name :: !(TF.Argument "metric_name" Text)
    {- ^ (Required) The name or description for the Amazon CloudWatch metric of this rule. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name or description of the rule. -}
    , _predicates :: !(TF.Argument "predicates" Text)
    {- ^ (Optional) One of ByteMatchSet, IPSet, SizeConstraintSet, SqlInjectionMatchSet, or XssMatchSet objects to include in a rule. -}
    , _rate_key :: !(TF.Argument "rate_key" Text)
    {- ^ (Required) Valid value is IP. -}
    , _rate_limit :: !(TF.Argument "rate_limit" Text)
    {- ^ (Required) The maximum number of requests, which have an identical value in the field specified by the RateKey, allowed in a five-minute period. Minimum value is 2000. -}
    } deriving (Show, Eq)

instance TF.ToHCL WafRateBasedRuleResource where
    toHCL WafRateBasedRuleResource{..} = TF.block $ catMaybes
        [ TF.argument _metric_name
        , TF.argument _name
        , TF.argument _predicates
        , TF.argument _rate_key
        , TF.argument _rate_limit
        ]

instance HasMetricName WafRateBasedRuleResource Text where
    metricName =
        lens (_metric_name :: WafRateBasedRuleResource -> TF.Argument "metric_name" Text)
             (\s a -> s { _metric_name = a } :: WafRateBasedRuleResource)

instance HasName WafRateBasedRuleResource Text where
    name =
        lens (_name :: WafRateBasedRuleResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: WafRateBasedRuleResource)

instance HasPredicates WafRateBasedRuleResource Text where
    predicates =
        lens (_predicates :: WafRateBasedRuleResource -> TF.Argument "predicates" Text)
             (\s a -> s { _predicates = a } :: WafRateBasedRuleResource)

instance HasRateKey WafRateBasedRuleResource Text where
    rateKey =
        lens (_rate_key :: WafRateBasedRuleResource -> TF.Argument "rate_key" Text)
             (\s a -> s { _rate_key = a } :: WafRateBasedRuleResource)

instance HasRateLimit WafRateBasedRuleResource Text where
    rateLimit =
        lens (_rate_limit :: WafRateBasedRuleResource -> TF.Argument "rate_limit" Text)
             (\s a -> s { _rate_limit = a } :: WafRateBasedRuleResource)

wafRateBasedRuleResource :: TF.Resource TF.AWS WafRateBasedRuleResource
wafRateBasedRuleResource =
    TF.newResource "aws_waf_rate_based_rule" $
        WafRateBasedRuleResource {
            _metric_name = TF.Nil
            , _name = TF.Nil
            , _predicates = TF.Nil
            , _rate_key = TF.Nil
            , _rate_limit = TF.Nil
            }

{- | The @aws_waf_rule@ AWS resource.

Provides a WAF Rule Resource
-}
data WafRuleResource = WafRuleResource {
      _metric_name :: !(TF.Argument "metric_name" Text)
    {- ^ (Required) The name or description for the Amazon CloudWatch metric of this rule. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name or description of the rule. -}
    , _predicates :: !(TF.Argument "predicates" Text)
    {- ^ (Optional) One of ByteMatchSet, IPSet, SizeConstraintSet, SqlInjectionMatchSet, or XssMatchSet objects to include in a rule. -}
    } deriving (Show, Eq)

instance TF.ToHCL WafRuleResource where
    toHCL WafRuleResource{..} = TF.block $ catMaybes
        [ TF.argument _metric_name
        , TF.argument _name
        , TF.argument _predicates
        ]

instance HasMetricName WafRuleResource Text where
    metricName =
        lens (_metric_name :: WafRuleResource -> TF.Argument "metric_name" Text)
             (\s a -> s { _metric_name = a } :: WafRuleResource)

instance HasName WafRuleResource Text where
    name =
        lens (_name :: WafRuleResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: WafRuleResource)

instance HasPredicates WafRuleResource Text where
    predicates =
        lens (_predicates :: WafRuleResource -> TF.Argument "predicates" Text)
             (\s a -> s { _predicates = a } :: WafRuleResource)

wafRuleResource :: TF.Resource TF.AWS WafRuleResource
wafRuleResource =
    TF.newResource "aws_waf_rule" $
        WafRuleResource {
            _metric_name = TF.Nil
            , _name = TF.Nil
            , _predicates = TF.Nil
            }

{- | The @aws_waf_size_constraint_set@ AWS resource.

Provides a WAF Size Constraint Set Resource
-}
data WafSizeConstraintSetResource = WafSizeConstraintSetResource {
      _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name or description of the Size Constraint Set. -}
    , _size_constraints :: !(TF.Argument "size_constraints" Text)
    {- ^ (Optional) Specifies the parts of web requests that you want to inspect the size of. -}
    } deriving (Show, Eq)

instance TF.ToHCL WafSizeConstraintSetResource where
    toHCL WafSizeConstraintSetResource{..} = TF.block $ catMaybes
        [ TF.argument _name
        , TF.argument _size_constraints
        ]

instance HasName WafSizeConstraintSetResource Text where
    name =
        lens (_name :: WafSizeConstraintSetResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: WafSizeConstraintSetResource)

instance HasSizeConstraints WafSizeConstraintSetResource Text where
    sizeConstraints =
        lens (_size_constraints :: WafSizeConstraintSetResource -> TF.Argument "size_constraints" Text)
             (\s a -> s { _size_constraints = a } :: WafSizeConstraintSetResource)

wafSizeConstraintSetResource :: TF.Resource TF.AWS WafSizeConstraintSetResource
wafSizeConstraintSetResource =
    TF.newResource "aws_waf_size_constraint_set" $
        WafSizeConstraintSetResource {
            _name = TF.Nil
            , _size_constraints = TF.Nil
            }

{- | The @aws_waf_sql_injection_match_set@ AWS resource.

Provides a WAF SQL Injection Match Set Resource
-}
data WafSqlInjectionMatchSetResource = WafSqlInjectionMatchSetResource {
      _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name or description of the SizeConstraintSet. -}
    , _sql_injection_match_tuples :: !(TF.Argument "sql_injection_match_tuples" Text)
    {- ^ (Optional) The parts of web requests that you want AWS WAF to inspect for malicious SQL code and, if you want AWS WAF to inspect a header, the name of the header. -}
    } deriving (Show, Eq)

instance TF.ToHCL WafSqlInjectionMatchSetResource where
    toHCL WafSqlInjectionMatchSetResource{..} = TF.block $ catMaybes
        [ TF.argument _name
        , TF.argument _sql_injection_match_tuples
        ]

instance HasName WafSqlInjectionMatchSetResource Text where
    name =
        lens (_name :: WafSqlInjectionMatchSetResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: WafSqlInjectionMatchSetResource)

instance HasSqlInjectionMatchTuples WafSqlInjectionMatchSetResource Text where
    sqlInjectionMatchTuples =
        lens (_sql_injection_match_tuples :: WafSqlInjectionMatchSetResource -> TF.Argument "sql_injection_match_tuples" Text)
             (\s a -> s { _sql_injection_match_tuples = a } :: WafSqlInjectionMatchSetResource)

wafSqlInjectionMatchSetResource :: TF.Resource TF.AWS WafSqlInjectionMatchSetResource
wafSqlInjectionMatchSetResource =
    TF.newResource "aws_waf_sql_injection_match_set" $
        WafSqlInjectionMatchSetResource {
            _name = TF.Nil
            , _sql_injection_match_tuples = TF.Nil
            }

{- | The @aws_waf_web_acl@ AWS resource.

Provides a WAF Web ACL Resource
-}
data WafWebAclResource = WafWebAclResource {
      _default_action :: !(TF.Argument "default_action" Text)
    {- ^ (Required) The action that you want AWS WAF to take when a request doesn't match the criteria in any of the rules that are associated with the web ACL. -}
    , _metric_name :: !(TF.Argument "metric_name" Text)
    {- ^ (Required) The name or description for the Amazon CloudWatch metric of this web ACL. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name or description of the web ACL. -}
    , _rules :: !(TF.Argument "rules" Text)
    {- ^ (Required) The rules to associate with the web ACL and the settings for each rule. -}
    } deriving (Show, Eq)

instance TF.ToHCL WafWebAclResource where
    toHCL WafWebAclResource{..} = TF.block $ catMaybes
        [ TF.argument _default_action
        , TF.argument _metric_name
        , TF.argument _name
        , TF.argument _rules
        ]

instance HasDefaultAction WafWebAclResource Text where
    defaultAction =
        lens (_default_action :: WafWebAclResource -> TF.Argument "default_action" Text)
             (\s a -> s { _default_action = a } :: WafWebAclResource)

instance HasMetricName WafWebAclResource Text where
    metricName =
        lens (_metric_name :: WafWebAclResource -> TF.Argument "metric_name" Text)
             (\s a -> s { _metric_name = a } :: WafWebAclResource)

instance HasName WafWebAclResource Text where
    name =
        lens (_name :: WafWebAclResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: WafWebAclResource)

instance HasRules WafWebAclResource Text where
    rules =
        lens (_rules :: WafWebAclResource -> TF.Argument "rules" Text)
             (\s a -> s { _rules = a } :: WafWebAclResource)

wafWebAclResource :: TF.Resource TF.AWS WafWebAclResource
wafWebAclResource =
    TF.newResource "aws_waf_web_acl" $
        WafWebAclResource {
            _default_action = TF.Nil
            , _metric_name = TF.Nil
            , _name = TF.Nil
            , _rules = TF.Nil
            }

{- | The @aws_waf_xss_match_set@ AWS resource.

Provides a WAF XSS Match Set Resource
-}
data WafXssMatchSetResource = WafXssMatchSetResource {
      _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name or description of the SizeConstraintSet. -}
    , _xss_match_tuples :: !(TF.Argument "xss_match_tuples" Text)
    {- ^ (Optional) The parts of web requests that you want to inspect for cross-site scripting attacks. -}
    } deriving (Show, Eq)

instance TF.ToHCL WafXssMatchSetResource where
    toHCL WafXssMatchSetResource{..} = TF.block $ catMaybes
        [ TF.argument _name
        , TF.argument _xss_match_tuples
        ]

instance HasName WafXssMatchSetResource Text where
    name =
        lens (_name :: WafXssMatchSetResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: WafXssMatchSetResource)

instance HasXssMatchTuples WafXssMatchSetResource Text where
    xssMatchTuples =
        lens (_xss_match_tuples :: WafXssMatchSetResource -> TF.Argument "xss_match_tuples" Text)
             (\s a -> s { _xss_match_tuples = a } :: WafXssMatchSetResource)

wafXssMatchSetResource :: TF.Resource TF.AWS WafXssMatchSetResource
wafXssMatchSetResource =
    TF.newResource "aws_waf_xss_match_set" $
        WafXssMatchSetResource {
            _name = TF.Nil
            , _xss_match_tuples = TF.Nil
            }

{- | The @aws_wafregional_byte_match_set@ AWS resource.

Provides a WAF Regional Byte Match Set Resource for use with Application
Load Balancer.
-}
data WafregionalByteMatchSetResource = WafregionalByteMatchSetResource {
      _byte_match_tuple :: !(TF.Argument "byte_match_tuple" Text)
    {- ^ (Optional)Settings for the ByteMatchSet, such as the bytes (typically a string that corresponds with ASCII characters) that you want AWS WAF to search for in web requests. ByteMatchTuple documented below. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name or description of the ByteMatchSet. -}
    } deriving (Show, Eq)

instance TF.ToHCL WafregionalByteMatchSetResource where
    toHCL WafregionalByteMatchSetResource{..} = TF.block $ catMaybes
        [ TF.argument _byte_match_tuple
        , TF.argument _name
        ]

instance HasByteMatchTuple WafregionalByteMatchSetResource Text where
    byteMatchTuple =
        lens (_byte_match_tuple :: WafregionalByteMatchSetResource -> TF.Argument "byte_match_tuple" Text)
             (\s a -> s { _byte_match_tuple = a } :: WafregionalByteMatchSetResource)

instance HasName WafregionalByteMatchSetResource Text where
    name =
        lens (_name :: WafregionalByteMatchSetResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: WafregionalByteMatchSetResource)

wafregionalByteMatchSetResource :: TF.Resource TF.AWS WafregionalByteMatchSetResource
wafregionalByteMatchSetResource =
    TF.newResource "aws_wafregional_byte_match_set" $
        WafregionalByteMatchSetResource {
            _byte_match_tuple = TF.Nil
            , _name = TF.Nil
            }

{- | The @aws_wafregional_ipset@ AWS resource.

Provides a WAF Regional IPSet Resource for use with Application Load
Balancer.
-}
data WafregionalIpsetResource = WafregionalIpsetResource {
      _ip_set_descriptor :: !(TF.Argument "ip_set_descriptor" Text)
    {- ^ (Optional) The IP address type and IP address range (in CIDR notation) from which web requests originate. -}
    , _name :: !(TF.Argument "name" Text)
    {- ^ (Required) The name or description of the IPSet. -}
    } deriving (Show, Eq)

instance TF.ToHCL WafregionalIpsetResource where
    toHCL WafregionalIpsetResource{..} = TF.block $ catMaybes
        [ TF.argument _ip_set_descriptor
        , TF.argument _name
        ]

instance HasIpSetDescriptor WafregionalIpsetResource Text where
    ipSetDescriptor =
        lens (_ip_set_descriptor :: WafregionalIpsetResource -> TF.Argument "ip_set_descriptor" Text)
             (\s a -> s { _ip_set_descriptor = a } :: WafregionalIpsetResource)

instance HasName WafregionalIpsetResource Text where
    name =
        lens (_name :: WafregionalIpsetResource -> TF.Argument "name" Text)
             (\s a -> s { _name = a } :: WafregionalIpsetResource)

wafregionalIpsetResource :: TF.Resource TF.AWS WafregionalIpsetResource
wafregionalIpsetResource =
    TF.newResource "aws_wafregional_ipset" $
        WafregionalIpsetResource {
            _ip_set_descriptor = TF.Nil
            , _name = TF.Nil
            }

class HasAccelerationStatus s a | s -> a where
    accelerationStatus :: Lens' s (TF.Argument "acceleration_status" a)

instance HasAccelerationStatus s a => HasAccelerationStatus (TF.Resource p s) a where
    accelerationStatus = TF.configuration . accelerationStatus

class HasAccepter s a | s -> a where
    accepter :: Lens' s (TF.Argument "accepter" a)

instance HasAccepter s a => HasAccepter (TF.Resource p s) a where
    accepter = TF.configuration . accepter

class HasAccessLogs s a | s -> a where
    accessLogs :: Lens' s (TF.Argument "access_logs" a)

instance HasAccessLogs s a => HasAccessLogs (TF.Resource p s) a where
    accessLogs = TF.configuration . accessLogs

class HasAccessPolicies s a | s -> a where
    accessPolicies :: Lens' s (TF.Argument "access_policies" a)

instance HasAccessPolicies s a => HasAccessPolicies (TF.Resource p s) a where
    accessPolicies = TF.configuration . accessPolicies

class HasAccessPolicy s a | s -> a where
    accessPolicy :: Lens' s (TF.Argument "access_policy" a)

instance HasAccessPolicy s a => HasAccessPolicy (TF.Resource p s) a where
    accessPolicy = TF.configuration . accessPolicy

class HasAccountAlias s a | s -> a where
    accountAlias :: Lens' s (TF.Argument "account_alias" a)

instance HasAccountAlias s a => HasAccountAlias (TF.Resource p s) a where
    accountAlias = TF.configuration . accountAlias

class HasAccountId s a | s -> a where
    accountId :: Lens' s (TF.Argument "account_id" a)

instance HasAccountId s a => HasAccountId (TF.Resource p s) a where
    accountId = TF.configuration . accountId

class HasAcl s a | s -> a where
    acl :: Lens' s (TF.Argument "acl" a)

instance HasAcl s a => HasAcl (TF.Resource p s) a where
    acl = TF.configuration . acl

class HasAction s a | s -> a where
    action :: Lens' s (TF.Argument "action" a)

instance HasAction s a => HasAction (TF.Resource p s) a where
    action = TF.configuration . action

class HasActionsEnabled s a | s -> a where
    actionsEnabled :: Lens' s (TF.Argument "actions_enabled" a)

instance HasActionsEnabled s a => HasActionsEnabled (TF.Resource p s) a where
    actionsEnabled = TF.configuration . actionsEnabled

class HasActive s a | s -> a where
    active :: Lens' s (TF.Argument "active" a)

instance HasActive s a => HasActive (TF.Resource p s) a where
    active = TF.configuration . active

class HasAddHeaderAction s a | s -> a where
    addHeaderAction :: Lens' s (TF.Argument "add_header_action" a)

instance HasAddHeaderAction s a => HasAddHeaderAction (TF.Resource p s) a where
    addHeaderAction = TF.configuration . addHeaderAction

class HasAdjustmentType s a | s -> a where
    adjustmentType :: Lens' s (TF.Argument "adjustment_type" a)

instance HasAdjustmentType s a => HasAdjustmentType (TF.Resource p s) a where
    adjustmentType = TF.configuration . adjustmentType

class HasAdminCreateUserConfig s a | s -> a where
    adminCreateUserConfig :: Lens' s (TF.Argument "admin_create_user_config" a)

instance HasAdminCreateUserConfig s a => HasAdminCreateUserConfig (TF.Resource p s) a where
    adminCreateUserConfig = TF.configuration . adminCreateUserConfig

class HasAdvancedOptions s a | s -> a where
    advancedOptions :: Lens' s (TF.Argument "advanced_options" a)

instance HasAdvancedOptions s a => HasAdvancedOptions (TF.Resource p s) a where
    advancedOptions = TF.configuration . advancedOptions

class HasAfter s a | s -> a where
    after :: Lens' s (TF.Argument "after" a)

instance HasAfter s a => HasAfter (TF.Resource p s) a where
    after = TF.configuration . after

class HasAgentVersion s a | s -> a where
    agentVersion :: Lens' s (TF.Argument "agent_version" a)

instance HasAgentVersion s a => HasAgentVersion (TF.Resource p s) a where
    agentVersion = TF.configuration . agentVersion

class HasAlarmActions s a | s -> a where
    alarmActions :: Lens' s (TF.Argument "alarm_actions" a)

instance HasAlarmActions s a => HasAlarmActions (TF.Resource p s) a where
    alarmActions = TF.configuration . alarmActions

class HasAlarmConfiguration s a | s -> a where
    alarmConfiguration :: Lens' s (TF.Argument "alarm_configuration" a)

instance HasAlarmConfiguration s a => HasAlarmConfiguration (TF.Resource p s) a where
    alarmConfiguration = TF.configuration . alarmConfiguration

class HasAlarmDescription s a | s -> a where
    alarmDescription :: Lens' s (TF.Argument "alarm_description" a)

instance HasAlarmDescription s a => HasAlarmDescription (TF.Resource p s) a where
    alarmDescription = TF.configuration . alarmDescription

class HasAlarmName s a | s -> a where
    alarmName :: Lens' s (TF.Argument "alarm_name" a)

instance HasAlarmName s a => HasAlarmName (TF.Resource p s) a where
    alarmName = TF.configuration . alarmName

class HasAlbTargetGroupArn s a | s -> a where
    albTargetGroupArn :: Lens' s (TF.Argument "alb_target_group_arn" a)

instance HasAlbTargetGroupArn s a => HasAlbTargetGroupArn (TF.Resource p s) a where
    albTargetGroupArn = TF.configuration . albTargetGroupArn

class HasAlias s a | s -> a where
    alias :: Lens' s (TF.Argument "alias" a)

instance HasAlias s a => HasAlias (TF.Resource p s) a where
    alias = TF.configuration . alias

class HasAliasAttributes s a | s -> a where
    aliasAttributes :: Lens' s (TF.Argument "alias_attributes" a)

instance HasAliasAttributes s a => HasAliasAttributes (TF.Resource p s) a where
    aliasAttributes = TF.configuration . aliasAttributes

class HasAliases s a | s -> a where
    aliases :: Lens' s (TF.Argument "aliases" a)

instance HasAliases s a => HasAliases (TF.Resource p s) a where
    aliases = TF.configuration . aliases

class HasAllocatedMemory s a | s -> a where
    allocatedMemory :: Lens' s (TF.Argument "allocated_memory" a)

instance HasAllocatedMemory s a => HasAllocatedMemory (TF.Resource p s) a where
    allocatedMemory = TF.configuration . allocatedMemory

class HasAllocatedStorage s a | s -> a where
    allocatedStorage :: Lens' s (TF.Argument "allocated_storage" a)

instance HasAllocatedStorage s a => HasAllocatedStorage (TF.Resource p s) a where
    allocatedStorage = TF.configuration . allocatedStorage

class HasAllocationId s a | s -> a where
    allocationId :: Lens' s (TF.Argument "allocation_id" a)

instance HasAllocationId s a => HasAllocationId (TF.Resource p s) a where
    allocationId = TF.configuration . allocationId

class HasAllocationStrategy s a | s -> a where
    allocationStrategy :: Lens' s (TF.Argument "allocation_strategy" a)

instance HasAllocationStrategy s a => HasAllocationStrategy (TF.Resource p s) a where
    allocationStrategy = TF.configuration . allocationStrategy

class HasAllowMajorVersionUpgrade s a | s -> a where
    allowMajorVersionUpgrade :: Lens' s (TF.Argument "allow_major_version_upgrade" a)

instance HasAllowMajorVersionUpgrade s a => HasAllowMajorVersionUpgrade (TF.Resource p s) a where
    allowMajorVersionUpgrade = TF.configuration . allowMajorVersionUpgrade

class HasAllowReassociation s a | s -> a where
    allowReassociation :: Lens' s (TF.Argument "allow_reassociation" a)

instance HasAllowReassociation s a => HasAllowReassociation (TF.Resource p s) a where
    allowReassociation = TF.configuration . allowReassociation

class HasAllowSelfManagement s a | s -> a where
    allowSelfManagement :: Lens' s (TF.Argument "allow_self_management" a)

instance HasAllowSelfManagement s a => HasAllowSelfManagement (TF.Resource p s) a where
    allowSelfManagement = TF.configuration . allowSelfManagement

class HasAllowSsh s a | s -> a where
    allowSsh :: Lens' s (TF.Argument "allow_ssh" a)

instance HasAllowSsh s a => HasAllowSsh (TF.Resource p s) a where
    allowSsh = TF.configuration . allowSsh

class HasAllowSudo s a | s -> a where
    allowSudo :: Lens' s (TF.Argument "allow_sudo" a)

instance HasAllowSudo s a => HasAllowSudo (TF.Resource p s) a where
    allowSudo = TF.configuration . allowSudo

class HasAllowUnassociatedTargets s a | s -> a where
    allowUnassociatedTargets :: Lens' s (TF.Argument "allow_unassociated_targets" a)

instance HasAllowUnassociatedTargets s a => HasAllowUnassociatedTargets (TF.Resource p s) a where
    allowUnassociatedTargets = TF.configuration . allowUnassociatedTargets

class HasAllowUnauthenticatedIdentities s a | s -> a where
    allowUnauthenticatedIdentities :: Lens' s (TF.Argument "allow_unauthenticated_identities" a)

instance HasAllowUnauthenticatedIdentities s a => HasAllowUnauthenticatedIdentities (TF.Resource p s) a where
    allowUnauthenticatedIdentities = TF.configuration . allowUnauthenticatedIdentities

class HasAllowUsersToChangePassword s a | s -> a where
    allowUsersToChangePassword :: Lens' s (TF.Argument "allow_users_to_change_password" a)

instance HasAllowUsersToChangePassword s a => HasAllowUsersToChangePassword (TF.Resource p s) a where
    allowUsersToChangePassword = TF.configuration . allowUsersToChangePassword

class HasAllowVersionUpgrade s a | s -> a where
    allowVersionUpgrade :: Lens' s (TF.Argument "allow_version_upgrade" a)

instance HasAllowVersionUpgrade s a => HasAllowVersionUpgrade (TF.Resource p s) a where
    allowVersionUpgrade = TF.configuration . allowVersionUpgrade

class HasAllowedOauthFlows s a | s -> a where
    allowedOauthFlows :: Lens' s (TF.Argument "allowed_oauth_flows" a)

instance HasAllowedOauthFlows s a => HasAllowedOauthFlows (TF.Resource p s) a where
    allowedOauthFlows = TF.configuration . allowedOauthFlows

class HasAllowedOauthFlowsUserPoolClient s a | s -> a where
    allowedOauthFlowsUserPoolClient :: Lens' s (TF.Argument "allowed_oauth_flows_user_pool_client" a)

instance HasAllowedOauthFlowsUserPoolClient s a => HasAllowedOauthFlowsUserPoolClient (TF.Resource p s) a where
    allowedOauthFlowsUserPoolClient = TF.configuration . allowedOauthFlowsUserPoolClient

class HasAllowedOauthScopes s a | s -> a where
    allowedOauthScopes :: Lens' s (TF.Argument "allowed_oauth_scopes" a)

instance HasAllowedOauthScopes s a => HasAllowedOauthScopes (TF.Resource p s) a where
    allowedOauthScopes = TF.configuration . allowedOauthScopes

class HasAmi s a | s -> a where
    ami :: Lens' s (TF.Argument "ami" a)

instance HasAmi s a => HasAmi (TF.Resource p s) a where
    ami = TF.configuration . ami

class HasAmiId s a | s -> a where
    amiId :: Lens' s (TF.Argument "ami_id" a)

instance HasAmiId s a => HasAmiId (TF.Resource p s) a where
    amiId = TF.configuration . amiId

class HasApiId s a | s -> a where
    apiId :: Lens' s (TF.Argument "api_id" a)

instance HasApiId s a => HasApiId (TF.Resource p s) a where
    apiId = TF.configuration . apiId

class HasApiKeyRequired s a | s -> a where
    apiKeyRequired :: Lens' s (TF.Argument "api_key_required" a)

instance HasApiKeyRequired s a => HasApiKeyRequired (TF.Resource p s) a where
    apiKeyRequired = TF.configuration . apiKeyRequired

class HasApiStages s a | s -> a where
    apiStages :: Lens' s (TF.Argument "api_stages" a)

instance HasApiStages s a => HasApiStages (TF.Resource p s) a where
    apiStages = TF.configuration . apiStages

class HasAppName s a | s -> a where
    appName :: Lens' s (TF.Argument "app_name" a)

instance HasAppName s a => HasAppName (TF.Resource p s) a where
    appName = TF.configuration . appName

class HasAppServer s a | s -> a where
    appServer :: Lens' s (TF.Argument "app_server" a)

instance HasAppServer s a => HasAppServer (TF.Resource p s) a where
    appServer = TF.configuration . appServer

class HasAppServerVersion s a | s -> a where
    appServerVersion :: Lens' s (TF.Argument "app_server_version" a)

instance HasAppServerVersion s a => HasAppServerVersion (TF.Resource p s) a where
    appServerVersion = TF.configuration . appServerVersion

class HasAppSource s a | s -> a where
    appSource :: Lens' s (TF.Argument "app_source" a)

instance HasAppSource s a => HasAppSource (TF.Resource p s) a where
    appSource = TF.configuration . appSource

class HasApplication s a | s -> a where
    application :: Lens' s (TF.Argument "application" a)

instance HasApplication s a => HasApplication (TF.Resource p s) a where
    application = TF.configuration . application

class HasApplications s a | s -> a where
    applications :: Lens' s (TF.Argument "applications" a)

instance HasApplications s a => HasApplications (TF.Resource p s) a where
    applications = TF.configuration . applications

class HasApplyImmediately s a | s -> a where
    applyImmediately :: Lens' s (TF.Argument "apply_immediately" a)

instance HasApplyImmediately s a => HasApplyImmediately (TF.Resource p s) a where
    applyImmediately = TF.configuration . applyImmediately

class HasApprovalRule s a | s -> a where
    approvalRule :: Lens' s (TF.Argument "approval_rule" a)

instance HasApprovalRule s a => HasApprovalRule (TF.Resource p s) a where
    approvalRule = TF.configuration . approvalRule

class HasApprovedPatches s a | s -> a where
    approvedPatches :: Lens' s (TF.Argument "approved_patches" a)

instance HasApprovedPatches s a => HasApprovedPatches (TF.Resource p s) a where
    approvedPatches = TF.configuration . approvedPatches

class HasApprovedPatchesComplianceLevel s a | s -> a where
    approvedPatchesComplianceLevel :: Lens' s (TF.Argument "approved_patches_compliance_level" a)

instance HasApprovedPatchesComplianceLevel s a => HasApprovedPatchesComplianceLevel (TF.Resource p s) a where
    approvedPatchesComplianceLevel = TF.configuration . approvedPatchesComplianceLevel

class HasArchitecture s a | s -> a where
    architecture :: Lens' s (TF.Argument "architecture" a)

instance HasArchitecture s a => HasArchitecture (TF.Resource p s) a where
    architecture = TF.configuration . architecture

class HasArn s a | s -> a where
    arn :: Lens' s (TF.Argument "arn" a)

instance HasArn s a => HasArn (TF.Resource p s) a where
    arn = TF.configuration . arn

class HasArtifactStore s a | s -> a where
    artifactStore :: Lens' s (TF.Argument "artifact_store" a)

instance HasArtifactStore s a => HasArtifactStore (TF.Resource p s) a where
    artifactStore = TF.configuration . artifactStore

class HasArtifacts s a | s -> a where
    artifacts :: Lens' s (TF.Argument "artifacts" a)

instance HasArtifacts s a => HasArtifacts (TF.Resource p s) a where
    artifacts = TF.configuration . artifacts

class HasAssignGeneratedIpv6CidrBlock s a | s -> a where
    assignGeneratedIpv6CidrBlock :: Lens' s (TF.Argument "assign_generated_ipv6_cidr_block" a)

instance HasAssignGeneratedIpv6CidrBlock s a => HasAssignGeneratedIpv6CidrBlock (TF.Resource p s) a where
    assignGeneratedIpv6CidrBlock = TF.configuration . assignGeneratedIpv6CidrBlock

class HasAssignIpv6AddressOnCreation s a | s -> a where
    assignIpv6AddressOnCreation :: Lens' s (TF.Argument "assign_ipv6_address_on_creation" a)

instance HasAssignIpv6AddressOnCreation s a => HasAssignIpv6AddressOnCreation (TF.Resource p s) a where
    assignIpv6AddressOnCreation = TF.configuration . assignIpv6AddressOnCreation

class HasAssociatePublicIpAddress s a | s -> a where
    associatePublicIpAddress :: Lens' s (TF.Argument "associate_public_ip_address" a)

instance HasAssociatePublicIpAddress s a => HasAssociatePublicIpAddress (TF.Resource p s) a where
    associatePublicIpAddress = TF.configuration . associatePublicIpAddress

class HasAssociateWithPrivateIp s a | s -> a where
    associateWithPrivateIp :: Lens' s (TF.Argument "associate_with_private_ip" a)

instance HasAssociateWithPrivateIp s a => HasAssociateWithPrivateIp (TF.Resource p s) a where
    associateWithPrivateIp = TF.configuration . associateWithPrivateIp

class HasAssociationName s a | s -> a where
    associationName :: Lens' s (TF.Argument "association_name" a)

instance HasAssociationName s a => HasAssociationName (TF.Resource p s) a where
    associationName = TF.configuration . associationName

class HasAssumeRolePolicy s a | s -> a where
    assumeRolePolicy :: Lens' s (TF.Argument "assume_role_policy" a)

instance HasAssumeRolePolicy s a => HasAssumeRolePolicy (TF.Resource p s) a where
    assumeRolePolicy = TF.configuration . assumeRolePolicy

class HasAtRestEncryptionEnabled s a | s -> a where
    atRestEncryptionEnabled :: Lens' s (TF.Argument "at_rest_encryption_enabled" a)

instance HasAtRestEncryptionEnabled s a => HasAtRestEncryptionEnabled (TF.Resource p s) a where
    atRestEncryptionEnabled = TF.configuration . atRestEncryptionEnabled

class HasAttachment s a | s -> a where
    attachment :: Lens' s (TF.Argument "attachment" a)

instance HasAttachment s a => HasAttachment (TF.Resource p s) a where
    attachment = TF.configuration . attachment

class HasAttribute s a | s -> a where
    attribute :: Lens' s (TF.Argument "attribute" a)

instance HasAttribute s a => HasAttribute (TF.Resource p s) a where
    attribute = TF.configuration . attribute

class HasAudio s a | s -> a where
    audio :: Lens' s (TF.Argument "audio" a)

instance HasAudio s a => HasAudio (TF.Resource p s) a where
    audio = TF.configuration . audio

class HasAudioCodecOptions s a | s -> a where
    audioCodecOptions :: Lens' s (TF.Argument "audio_codec_options" a)

instance HasAudioCodecOptions s a => HasAudioCodecOptions (TF.Resource p s) a where
    audioCodecOptions = TF.configuration . audioCodecOptions

class HasAuthToken s a | s -> a where
    authToken :: Lens' s (TF.Argument "auth_token" a)

instance HasAuthToken s a => HasAuthToken (TF.Resource p s) a where
    authToken = TF.configuration . authToken

class HasAuthorization s a | s -> a where
    authorization :: Lens' s (TF.Argument "authorization" a)

instance HasAuthorization s a => HasAuthorization (TF.Resource p s) a where
    authorization = TF.configuration . authorization

class HasAuthorizerCredentials s a | s -> a where
    authorizerCredentials :: Lens' s (TF.Argument "authorizer_credentials" a)

instance HasAuthorizerCredentials s a => HasAuthorizerCredentials (TF.Resource p s) a where
    authorizerCredentials = TF.configuration . authorizerCredentials

class HasAuthorizerId s a | s -> a where
    authorizerId :: Lens' s (TF.Argument "authorizer_id" a)

instance HasAuthorizerId s a => HasAuthorizerId (TF.Resource p s) a where
    authorizerId = TF.configuration . authorizerId

class HasAuthorizerResultTtlInSeconds s a | s -> a where
    authorizerResultTtlInSeconds :: Lens' s (TF.Argument "authorizer_result_ttl_in_seconds" a)

instance HasAuthorizerResultTtlInSeconds s a => HasAuthorizerResultTtlInSeconds (TF.Resource p s) a where
    authorizerResultTtlInSeconds = TF.configuration . authorizerResultTtlInSeconds

class HasAuthorizerUri s a | s -> a where
    authorizerUri :: Lens' s (TF.Argument "authorizer_uri" a)

instance HasAuthorizerUri s a => HasAuthorizerUri (TF.Resource p s) a where
    authorizerUri = TF.configuration . authorizerUri

class HasAutoAccept s a | s -> a where
    autoAccept :: Lens' s (TF.Argument "auto_accept" a)

instance HasAutoAccept s a => HasAutoAccept (TF.Resource p s) a where
    autoAccept = TF.configuration . autoAccept

class HasAutoAssignElasticIps s a | s -> a where
    autoAssignElasticIps :: Lens' s (TF.Argument "auto_assign_elastic_ips" a)

instance HasAutoAssignElasticIps s a => HasAutoAssignElasticIps (TF.Resource p s) a where
    autoAssignElasticIps = TF.configuration . autoAssignElasticIps

class HasAutoAssignPublicIps s a | s -> a where
    autoAssignPublicIps :: Lens' s (TF.Argument "auto_assign_public_ips" a)

instance HasAutoAssignPublicIps s a => HasAutoAssignPublicIps (TF.Resource p s) a where
    autoAssignPublicIps = TF.configuration . autoAssignPublicIps

class HasAutoBundleOnDeploy s a | s -> a where
    autoBundleOnDeploy :: Lens' s (TF.Argument "auto_bundle_on_deploy" a)

instance HasAutoBundleOnDeploy s a => HasAutoBundleOnDeploy (TF.Resource p s) a where
    autoBundleOnDeploy = TF.configuration . autoBundleOnDeploy

class HasAutoHealing s a | s -> a where
    autoHealing :: Lens' s (TF.Argument "auto_healing" a)

instance HasAutoHealing s a => HasAutoHealing (TF.Resource p s) a where
    autoHealing = TF.configuration . autoHealing

class HasAutoMinorVersionUpgrade s a | s -> a where
    autoMinorVersionUpgrade :: Lens' s (TF.Argument "auto_minor_version_upgrade" a)

instance HasAutoMinorVersionUpgrade s a => HasAutoMinorVersionUpgrade (TF.Resource p s) a where
    autoMinorVersionUpgrade = TF.configuration . autoMinorVersionUpgrade

class HasAutoRollbackConfiguration s a | s -> a where
    autoRollbackConfiguration :: Lens' s (TF.Argument "auto_rollback_configuration" a)

instance HasAutoRollbackConfiguration s a => HasAutoRollbackConfiguration (TF.Resource p s) a where
    autoRollbackConfiguration = TF.configuration . autoRollbackConfiguration

class HasAutoScalingType s a | s -> a where
    autoScalingType :: Lens' s (TF.Argument "auto_scaling_type" a)

instance HasAutoScalingType s a => HasAutoScalingType (TF.Resource p s) a where
    autoScalingType = TF.configuration . autoScalingType

class HasAutoVerifiedAttributes s a | s -> a where
    autoVerifiedAttributes :: Lens' s (TF.Argument "auto_verified_attributes" a)

instance HasAutoVerifiedAttributes s a => HasAutoVerifiedAttributes (TF.Resource p s) a where
    autoVerifiedAttributes = TF.configuration . autoVerifiedAttributes

class HasAutomatedSnapshotRetentionPeriod s a | s -> a where
    automatedSnapshotRetentionPeriod :: Lens' s (TF.Argument "automated_snapshot_retention_period" a)

instance HasAutomatedSnapshotRetentionPeriod s a => HasAutomatedSnapshotRetentionPeriod (TF.Resource p s) a where
    automatedSnapshotRetentionPeriod = TF.configuration . automatedSnapshotRetentionPeriod

class HasAutomaticFailoverEnabled s a | s -> a where
    automaticFailoverEnabled :: Lens' s (TF.Argument "automatic_failover_enabled" a)

instance HasAutomaticFailoverEnabled s a => HasAutomaticFailoverEnabled (TF.Resource p s) a where
    automaticFailoverEnabled = TF.configuration . automaticFailoverEnabled

class HasAutoscalingGroupName s a | s -> a where
    autoscalingGroupName :: Lens' s (TF.Argument "autoscaling_group_name" a)

instance HasAutoscalingGroupName s a => HasAutoscalingGroupName (TF.Resource p s) a where
    autoscalingGroupName = TF.configuration . autoscalingGroupName

class HasAutoscalingGroups s a | s -> a where
    autoscalingGroups :: Lens' s (TF.Argument "autoscaling_groups" a)

instance HasAutoscalingGroups s a => HasAutoscalingGroups (TF.Resource p s) a where
    autoscalingGroups = TF.configuration . autoscalingGroups

class HasAutoscalingRole s a | s -> a where
    autoscalingRole :: Lens' s (TF.Argument "autoscaling_role" a)

instance HasAutoscalingRole s a => HasAutoscalingRole (TF.Resource p s) a where
    autoscalingRole = TF.configuration . autoscalingRole

class HasAvailabilityZone s a | s -> a where
    availabilityZone :: Lens' s (TF.Argument "availability_zone" a)

instance HasAvailabilityZone s a => HasAvailabilityZone (TF.Resource p s) a where
    availabilityZone = TF.configuration . availabilityZone

class HasAvailabilityZones s a | s -> a where
    availabilityZones :: Lens' s (TF.Argument "availability_zones" a)

instance HasAvailabilityZones s a => HasAvailabilityZones (TF.Resource p s) a where
    availabilityZones = TF.configuration . availabilityZones

class HasAwsFlowRubySettings s a | s -> a where
    awsFlowRubySettings :: Lens' s (TF.Argument "aws_flow_ruby_settings" a)

instance HasAwsFlowRubySettings s a => HasAwsFlowRubySettings (TF.Resource p s) a where
    awsFlowRubySettings = TF.configuration . awsFlowRubySettings

class HasAwsKmsKeyArn s a | s -> a where
    awsKmsKeyArn :: Lens' s (TF.Argument "aws_kms_key_arn" a)

instance HasAwsKmsKeyArn s a => HasAwsKmsKeyArn (TF.Resource p s) a where
    awsKmsKeyArn = TF.configuration . awsKmsKeyArn

class HasAzMode s a | s -> a where
    azMode :: Lens' s (TF.Argument "az_mode" a)

instance HasAzMode s a => HasAzMode (TF.Resource p s) a where
    azMode = TF.configuration . azMode

class HasBackupRetentionPeriod s a | s -> a where
    backupRetentionPeriod :: Lens' s (TF.Argument "backup_retention_period" a)

instance HasBackupRetentionPeriod s a => HasBackupRetentionPeriod (TF.Resource p s) a where
    backupRetentionPeriod = TF.configuration . backupRetentionPeriod

class HasBackupWindow s a | s -> a where
    backupWindow :: Lens' s (TF.Argument "backup_window" a)

instance HasBackupWindow s a => HasBackupWindow (TF.Resource p s) a where
    backupWindow = TF.configuration . backupWindow

class HasBandwidth s a | s -> a where
    bandwidth :: Lens' s (TF.Argument "bandwidth" a)

instance HasBandwidth s a => HasBandwidth (TF.Resource p s) a where
    bandwidth = TF.configuration . bandwidth

class HasBasePath s a | s -> a where
    basePath :: Lens' s (TF.Argument "base_path" a)

instance HasBasePath s a => HasBasePath (TF.Resource p s) a where
    basePath = TF.configuration . basePath

class HasBaselineId s a | s -> a where
    baselineId :: Lens' s (TF.Argument "baseline_id" a)

instance HasBaselineId s a => HasBaselineId (TF.Resource p s) a where
    baselineId = TF.configuration . baselineId

class HasBatchSize s a | s -> a where
    batchSize :: Lens' s (TF.Argument "batch_size" a)

instance HasBatchSize s a => HasBatchSize (TF.Resource p s) a where
    batchSize = TF.configuration . batchSize

class HasBerkshelfVersion s a | s -> a where
    berkshelfVersion :: Lens' s (TF.Argument "berkshelf_version" a)

instance HasBerkshelfVersion s a => HasBerkshelfVersion (TF.Resource p s) a where
    berkshelfVersion = TF.configuration . berkshelfVersion

class HasBgpAsn s a | s -> a where
    bgpAsn :: Lens' s (TF.Argument "bgp_asn" a)

instance HasBgpAsn s a => HasBgpAsn (TF.Resource p s) a where
    bgpAsn = TF.configuration . bgpAsn

class HasBinaryMediaTypes s a | s -> a where
    binaryMediaTypes :: Lens' s (TF.Argument "binary_media_types" a)

instance HasBinaryMediaTypes s a => HasBinaryMediaTypes (TF.Resource p s) a where
    binaryMediaTypes = TF.configuration . binaryMediaTypes

class HasBlockDurationMinutes s a | s -> a where
    blockDurationMinutes :: Lens' s (TF.Argument "block_duration_minutes" a)

instance HasBlockDurationMinutes s a => HasBlockDurationMinutes (TF.Resource p s) a where
    blockDurationMinutes = TF.configuration . blockDurationMinutes

class HasBlueGreenDeploymentConfig s a | s -> a where
    blueGreenDeploymentConfig :: Lens' s (TF.Argument "blue_green_deployment_config" a)

instance HasBlueGreenDeploymentConfig s a => HasBlueGreenDeploymentConfig (TF.Resource p s) a where
    blueGreenDeploymentConfig = TF.configuration . blueGreenDeploymentConfig

class HasBlueprintId s a | s -> a where
    blueprintId :: Lens' s (TF.Argument "blueprint_id" a)

instance HasBlueprintId s a => HasBlueprintId (TF.Resource p s) a where
    blueprintId = TF.configuration . blueprintId

class HasBody s a | s -> a where
    body :: Lens' s (TF.Argument "body" a)

instance HasBody s a => HasBody (TF.Resource p s) a where
    body = TF.configuration . body

class HasBootstrapAction s a | s -> a where
    bootstrapAction :: Lens' s (TF.Argument "bootstrap_action" a)

instance HasBootstrapAction s a => HasBootstrapAction (TF.Resource p s) a where
    bootstrapAction = TF.configuration . bootstrapAction

class HasBounceAction s a | s -> a where
    bounceAction :: Lens' s (TF.Argument "bounce_action" a)

instance HasBounceAction s a => HasBounceAction (TF.Resource p s) a where
    bounceAction = TF.configuration . bounceAction

class HasBranches s a | s -> a where
    branches :: Lens' s (TF.Argument "branches" a)

instance HasBranches s a => HasBranches (TF.Resource p s) a where
    branches = TF.configuration . branches

class HasBrokerName s a | s -> a where
    brokerName :: Lens' s (TF.Argument "broker_name" a)

instance HasBrokerName s a => HasBrokerName (TF.Resource p s) a where
    brokerName = TF.configuration . brokerName

class HasBucket s a | s -> a where
    bucket :: Lens' s (TF.Argument "bucket" a)

instance HasBucket s a => HasBucket (TF.Resource p s) a where
    bucket = TF.configuration . bucket

class HasBucketPrefix s a | s -> a where
    bucketPrefix :: Lens' s (TF.Argument "bucket_prefix" a)

instance HasBucketPrefix s a => HasBucketPrefix (TF.Resource p s) a where
    bucketPrefix = TF.configuration . bucketPrefix

class HasBuildTimeout s a | s -> a where
    buildTimeout :: Lens' s (TF.Argument "build_timeout" a)

instance HasBuildTimeout s a => HasBuildTimeout (TF.Resource p s) a where
    buildTimeout = TF.configuration . buildTimeout

class HasBundleId s a | s -> a where
    bundleId :: Lens' s (TF.Argument "bundle_id" a)

instance HasBundleId s a => HasBundleId (TF.Resource p s) a where
    bundleId = TF.configuration . bundleId

class HasBundlerVersion s a | s -> a where
    bundlerVersion :: Lens' s (TF.Argument "bundler_version" a)

instance HasBundlerVersion s a => HasBundlerVersion (TF.Resource p s) a where
    bundlerVersion = TF.configuration . bundlerVersion

class HasByteMatchTuple s a | s -> a where
    byteMatchTuple :: Lens' s (TF.Argument "byte_match_tuple" a)

instance HasByteMatchTuple s a => HasByteMatchTuple (TF.Resource p s) a where
    byteMatchTuple = TF.configuration . byteMatchTuple

class HasByteMatchTuples s a | s -> a where
    byteMatchTuples :: Lens' s (TF.Argument "byte_match_tuples" a)

instance HasByteMatchTuples s a => HasByteMatchTuples (TF.Resource p s) a where
    byteMatchTuples = TF.configuration . byteMatchTuples

class HasCacheBehavior s a | s -> a where
    cacheBehavior :: Lens' s (TF.Argument "cache_behavior" a)

instance HasCacheBehavior s a => HasCacheBehavior (TF.Resource p s) a where
    cacheBehavior = TF.configuration . cacheBehavior

class HasCacheClusterEnabled s a | s -> a where
    cacheClusterEnabled :: Lens' s (TF.Argument "cache_cluster_enabled" a)

instance HasCacheClusterEnabled s a => HasCacheClusterEnabled (TF.Resource p s) a where
    cacheClusterEnabled = TF.configuration . cacheClusterEnabled

class HasCacheClusterSize s a | s -> a where
    cacheClusterSize :: Lens' s (TF.Argument "cache_cluster_size" a)

instance HasCacheClusterSize s a => HasCacheClusterSize (TF.Resource p s) a where
    cacheClusterSize = TF.configuration . cacheClusterSize

class HasCacheControl s a | s -> a where
    cacheControl :: Lens' s (TF.Argument "cache_control" a)

instance HasCacheControl s a => HasCacheControl (TF.Resource p s) a where
    cacheControl = TF.configuration . cacheControl

class HasCacheKeyNamespace s a | s -> a where
    cacheKeyNamespace :: Lens' s (TF.Argument "cache_key_namespace" a)

instance HasCacheKeyNamespace s a => HasCacheKeyNamespace (TF.Resource p s) a where
    cacheKeyNamespace = TF.configuration . cacheKeyNamespace

class HasCacheKeyParameters s a | s -> a where
    cacheKeyParameters :: Lens' s (TF.Argument "cache_key_parameters" a)

instance HasCacheKeyParameters s a => HasCacheKeyParameters (TF.Resource p s) a where
    cacheKeyParameters = TF.configuration . cacheKeyParameters

class HasCallbackUrls s a | s -> a where
    callbackUrls :: Lens' s (TF.Argument "callback_urls" a)

instance HasCallbackUrls s a => HasCallbackUrls (TF.Resource p s) a where
    callbackUrls = TF.configuration . callbackUrls

class HasCapabilities s a | s -> a where
    capabilities :: Lens' s (TF.Argument "capabilities" a)

instance HasCapabilities s a => HasCapabilities (TF.Resource p s) a where
    capabilities = TF.configuration . capabilities

class HasCatalogId s a | s -> a where
    catalogId :: Lens' s (TF.Argument "catalog_id" a)

instance HasCatalogId s a => HasCatalogId (TF.Resource p s) a where
    catalogId = TF.configuration . catalogId

class HasCdcStartTime s a | s -> a where
    cdcStartTime :: Lens' s (TF.Argument "cdc_start_time" a)

instance HasCdcStartTime s a => HasCdcStartTime (TF.Resource p s) a where
    cdcStartTime = TF.configuration . cdcStartTime

class HasCertificateArn s a | s -> a where
    certificateArn :: Lens' s (TF.Argument "certificate_arn" a)

instance HasCertificateArn s a => HasCertificateArn (TF.Resource p s) a where
    certificateArn = TF.configuration . certificateArn

class HasCertificateBody s a | s -> a where
    certificateBody :: Lens' s (TF.Argument "certificate_body" a)

instance HasCertificateBody s a => HasCertificateBody (TF.Resource p s) a where
    certificateBody = TF.configuration . certificateBody

class HasCertificateChain s a | s -> a where
    certificateChain :: Lens' s (TF.Argument "certificate_chain" a)

instance HasCertificateChain s a => HasCertificateChain (TF.Resource p s) a where
    certificateChain = TF.configuration . certificateChain

class HasCertificateId s a | s -> a where
    certificateId :: Lens' s (TF.Argument "certificate_id" a)

instance HasCertificateId s a => HasCertificateId (TF.Resource p s) a where
    certificateId = TF.configuration . certificateId

class HasCertificateName s a | s -> a where
    certificateName :: Lens' s (TF.Argument "certificate_name" a)

instance HasCertificateName s a => HasCertificateName (TF.Resource p s) a where
    certificateName = TF.configuration . certificateName

class HasCertificatePem s a | s -> a where
    certificatePem :: Lens' s (TF.Argument "certificate_pem" a)

instance HasCertificatePem s a => HasCertificatePem (TF.Resource p s) a where
    certificatePem = TF.configuration . certificatePem

class HasCertificatePrivateKey s a | s -> a where
    certificatePrivateKey :: Lens' s (TF.Argument "certificate_private_key" a)

instance HasCertificatePrivateKey s a => HasCertificatePrivateKey (TF.Resource p s) a where
    certificatePrivateKey = TF.configuration . certificatePrivateKey

class HasCertificateWallet s a | s -> a where
    certificateWallet :: Lens' s (TF.Argument "certificate_wallet" a)

instance HasCertificateWallet s a => HasCertificateWallet (TF.Resource p s) a where
    certificateWallet = TF.configuration . certificateWallet

class HasCharacterSetName s a | s -> a where
    characterSetName :: Lens' s (TF.Argument "character_set_name" a)

instance HasCharacterSetName s a => HasCharacterSetName (TF.Resource p s) a where
    characterSetName = TF.configuration . characterSetName

class HasChildHealthThreshold s a | s -> a where
    childHealthThreshold :: Lens' s (TF.Argument "child_health_threshold" a)

instance HasChildHealthThreshold s a => HasChildHealthThreshold (TF.Resource p s) a where
    childHealthThreshold = TF.configuration . childHealthThreshold

class HasChildHealthchecks s a | s -> a where
    childHealthchecks :: Lens' s (TF.Argument "child_healthchecks" a)

instance HasChildHealthchecks s a => HasChildHealthchecks (TF.Resource p s) a where
    childHealthchecks = TF.configuration . childHealthchecks

class HasCidr s a | s -> a where
    cidr :: Lens' s (TF.Argument "cidr" a)

instance HasCidr s a => HasCidr (TF.Resource p s) a where
    cidr = TF.configuration . cidr

class HasCidrBlock s a | s -> a where
    cidrBlock :: Lens' s (TF.Argument "cidr_block" a)

instance HasCidrBlock s a => HasCidrBlock (TF.Resource p s) a where
    cidrBlock = TF.configuration . cidrBlock

class HasCidrBlocks s a | s -> a where
    cidrBlocks :: Lens' s (TF.Argument "cidr_blocks" a)

instance HasCidrBlocks s a => HasCidrBlocks (TF.Resource p s) a where
    cidrBlocks = TF.configuration . cidrBlocks

class HasClientCertificateId s a | s -> a where
    clientCertificateId :: Lens' s (TF.Argument "client_certificate_id" a)

instance HasClientCertificateId s a => HasClientCertificateId (TF.Resource p s) a where
    clientCertificateId = TF.configuration . clientCertificateId

class HasClientIdList s a | s -> a where
    clientIdList :: Lens' s (TF.Argument "client_id_list" a)

instance HasClientIdList s a => HasClientIdList (TF.Resource p s) a where
    clientIdList = TF.configuration . clientIdList

class HasCloudWatchLogsGroupArn s a | s -> a where
    cloudWatchLogsGroupArn :: Lens' s (TF.Argument "cloud_watch_logs_group_arn" a)

instance HasCloudWatchLogsGroupArn s a => HasCloudWatchLogsGroupArn (TF.Resource p s) a where
    cloudWatchLogsGroupArn = TF.configuration . cloudWatchLogsGroupArn

class HasCloudWatchLogsRoleArn s a | s -> a where
    cloudWatchLogsRoleArn :: Lens' s (TF.Argument "cloud_watch_logs_role_arn" a)

instance HasCloudWatchLogsRoleArn s a => HasCloudWatchLogsRoleArn (TF.Resource p s) a where
    cloudWatchLogsRoleArn = TF.configuration . cloudWatchLogsRoleArn

class HasCloudwatchAlarmName s a | s -> a where
    cloudwatchAlarmName :: Lens' s (TF.Argument "cloudwatch_alarm_name" a)

instance HasCloudwatchAlarmName s a => HasCloudwatchAlarmName (TF.Resource p s) a where
    cloudwatchAlarmName = TF.configuration . cloudwatchAlarmName

class HasCloudwatchAlarmRegion s a | s -> a where
    cloudwatchAlarmRegion :: Lens' s (TF.Argument "cloudwatch_alarm_region" a)

instance HasCloudwatchAlarmRegion s a => HasCloudwatchAlarmRegion (TF.Resource p s) a where
    cloudwatchAlarmRegion = TF.configuration . cloudwatchAlarmRegion

class HasCloudwatchDestination s a | s -> a where
    cloudwatchDestination :: Lens' s (TF.Argument "cloudwatch_destination" a)

instance HasCloudwatchDestination s a => HasCloudwatchDestination (TF.Resource p s) a where
    cloudwatchDestination = TF.configuration . cloudwatchDestination

class HasCloudwatchLogGroupArn s a | s -> a where
    cloudwatchLogGroupArn :: Lens' s (TF.Argument "cloudwatch_log_group_arn" a)

instance HasCloudwatchLogGroupArn s a => HasCloudwatchLogGroupArn (TF.Resource p s) a where
    cloudwatchLogGroupArn = TF.configuration . cloudwatchLogGroupArn

class HasCloudwatchRoleArn s a | s -> a where
    cloudwatchRoleArn :: Lens' s (TF.Argument "cloudwatch_role_arn" a)

instance HasCloudwatchRoleArn s a => HasCloudwatchRoleArn (TF.Resource p s) a where
    cloudwatchRoleArn = TF.configuration . cloudwatchRoleArn

class HasCluster s a | s -> a where
    cluster :: Lens' s (TF.Argument "cluster" a)

instance HasCluster s a => HasCluster (TF.Resource p s) a where
    cluster = TF.configuration . cluster

class HasClusterConfig s a | s -> a where
    clusterConfig :: Lens' s (TF.Argument "cluster_config" a)

instance HasClusterConfig s a => HasClusterConfig (TF.Resource p s) a where
    clusterConfig = TF.configuration . clusterConfig

class HasClusterId s a | s -> a where
    clusterId :: Lens' s (TF.Argument "cluster_id" a)

instance HasClusterId s a => HasClusterId (TF.Resource p s) a where
    clusterId = TF.configuration . clusterId

class HasClusterIdentifier s a | s -> a where
    clusterIdentifier :: Lens' s (TF.Argument "cluster_identifier" a)

instance HasClusterIdentifier s a => HasClusterIdentifier (TF.Resource p s) a where
    clusterIdentifier = TF.configuration . clusterIdentifier

class HasClusterIdentifierPrefix s a | s -> a where
    clusterIdentifierPrefix :: Lens' s (TF.Argument "cluster_identifier_prefix" a)

instance HasClusterIdentifierPrefix s a => HasClusterIdentifierPrefix (TF.Resource p s) a where
    clusterIdentifierPrefix = TF.configuration . clusterIdentifierPrefix

class HasClusterMode s a | s -> a where
    clusterMode :: Lens' s (TF.Argument "cluster_mode" a)

instance HasClusterMode s a => HasClusterMode (TF.Resource p s) a where
    clusterMode = TF.configuration . clusterMode

class HasClusterParameterGroupName s a | s -> a where
    clusterParameterGroupName :: Lens' s (TF.Argument "cluster_parameter_group_name" a)

instance HasClusterParameterGroupName s a => HasClusterParameterGroupName (TF.Resource p s) a where
    clusterParameterGroupName = TF.configuration . clusterParameterGroupName

class HasClusterSecurityGroups s a | s -> a where
    clusterSecurityGroups :: Lens' s (TF.Argument "cluster_security_groups" a)

instance HasClusterSecurityGroups s a => HasClusterSecurityGroups (TF.Resource p s) a where
    clusterSecurityGroups = TF.configuration . clusterSecurityGroups

class HasClusterSubnetGroupName s a | s -> a where
    clusterSubnetGroupName :: Lens' s (TF.Argument "cluster_subnet_group_name" a)

instance HasClusterSubnetGroupName s a => HasClusterSubnetGroupName (TF.Resource p s) a where
    clusterSubnetGroupName = TF.configuration . clusterSubnetGroupName

class HasClusterType s a | s -> a where
    clusterType :: Lens' s (TF.Argument "cluster_type" a)

instance HasClusterType s a => HasClusterType (TF.Resource p s) a where
    clusterType = TF.configuration . clusterType

class HasClusterVersion s a | s -> a where
    clusterVersion :: Lens' s (TF.Argument "cluster_version" a)

instance HasClusterVersion s a => HasClusterVersion (TF.Resource p s) a where
    clusterVersion = TF.configuration . clusterVersion

class HasCnamePrefix s a | s -> a where
    cnamePrefix :: Lens' s (TF.Argument "cname_prefix" a)

instance HasCnamePrefix s a => HasCnamePrefix (TF.Resource p s) a where
    cnamePrefix = TF.configuration . cnamePrefix

class HasCognitoIdentityProviders s a | s -> a where
    cognitoIdentityProviders :: Lens' s (TF.Argument "cognito_identity_providers" a)

instance HasCognitoIdentityProviders s a => HasCognitoIdentityProviders (TF.Resource p s) a where
    cognitoIdentityProviders = TF.configuration . cognitoIdentityProviders

class HasColor s a | s -> a where
    color :: Lens' s (TF.Argument "color" a)

instance HasColor s a => HasColor (TF.Resource p s) a where
    color = TF.configuration . color

class HasComment s a | s -> a where
    comment :: Lens' s (TF.Argument "comment" a)

instance HasComment s a => HasComment (TF.Resource p s) a where
    comment = TF.configuration . comment

class HasComparisonOperator s a | s -> a where
    comparisonOperator :: Lens' s (TF.Argument "comparison_operator" a)

instance HasComparisonOperator s a => HasComparisonOperator (TF.Resource p s) a where
    comparisonOperator = TF.configuration . comparisonOperator

class HasComputeEnvironmentName s a | s -> a where
    computeEnvironmentName :: Lens' s (TF.Argument "compute_environment_name" a)

instance HasComputeEnvironmentName s a => HasComputeEnvironmentName (TF.Resource p s) a where
    computeEnvironmentName = TF.configuration . computeEnvironmentName

class HasComputeEnvironments s a | s -> a where
    computeEnvironments :: Lens' s (TF.Argument "compute_environments" a)

instance HasComputeEnvironments s a => HasComputeEnvironments (TF.Resource p s) a where
    computeEnvironments = TF.configuration . computeEnvironments

class HasComputeResources s a | s -> a where
    computeResources :: Lens' s (TF.Argument "compute_resources" a)

instance HasComputeResources s a => HasComputeResources (TF.Resource p s) a where
    computeResources = TF.configuration . computeResources

class HasCondition s a | s -> a where
    condition :: Lens' s (TF.Argument "condition" a)

instance HasCondition s a => HasCondition (TF.Resource p s) a where
    condition = TF.configuration . condition

class HasConfiguration s a | s -> a where
    configuration :: Lens' s (TF.Argument "configuration" a)

instance HasConfiguration s a => HasConfiguration (TF.Resource p s) a where
    configuration = TF.configuration . configuration

class HasConfigurationManagerName s a | s -> a where
    configurationManagerName :: Lens' s (TF.Argument "configuration_manager_name" a)

instance HasConfigurationManagerName s a => HasConfigurationManagerName (TF.Resource p s) a where
    configurationManagerName = TF.configuration . configurationManagerName

class HasConfigurationManagerVersion s a | s -> a where
    configurationManagerVersion :: Lens' s (TF.Argument "configuration_manager_version" a)

instance HasConfigurationManagerVersion s a => HasConfigurationManagerVersion (TF.Resource p s) a where
    configurationManagerVersion = TF.configuration . configurationManagerVersion

class HasConfigurationSetName s a | s -> a where
    configurationSetName :: Lens' s (TF.Argument "configuration_set_name" a)

instance HasConfigurationSetName s a => HasConfigurationSetName (TF.Resource p s) a where
    configurationSetName = TF.configuration . configurationSetName

class HasConfigurations s a | s -> a where
    configurations :: Lens' s (TF.Argument "configurations" a)

instance HasConfigurations s a => HasConfigurations (TF.Resource p s) a where
    configurations = TF.configuration . configurations

class HasConfirmationTimeoutInMinutes s a | s -> a where
    confirmationTimeoutInMinutes :: Lens' s (TF.Argument "confirmation_timeout_in_minutes" a)

instance HasConfirmationTimeoutInMinutes s a => HasConfirmationTimeoutInMinutes (TF.Resource p s) a where
    confirmationTimeoutInMinutes = TF.configuration . confirmationTimeoutInMinutes

class HasConnectSettings s a | s -> a where
    connectSettings :: Lens' s (TF.Argument "connect_settings" a)

instance HasConnectSettings s a => HasConnectSettings (TF.Resource p s) a where
    connectSettings = TF.configuration . connectSettings

class HasConnectionDraining s a | s -> a where
    connectionDraining :: Lens' s (TF.Argument "connection_draining" a)

instance HasConnectionDraining s a => HasConnectionDraining (TF.Resource p s) a where
    connectionDraining = TF.configuration . connectionDraining

class HasConnectionDrainingTimeout s a | s -> a where
    connectionDrainingTimeout :: Lens' s (TF.Argument "connection_draining_timeout" a)

instance HasConnectionDrainingTimeout s a => HasConnectionDrainingTimeout (TF.Resource p s) a where
    connectionDrainingTimeout = TF.configuration . connectionDrainingTimeout

class HasConnectionId s a | s -> a where
    connectionId :: Lens' s (TF.Argument "connection_id" a)

instance HasConnectionId s a => HasConnectionId (TF.Resource p s) a where
    connectionId = TF.configuration . connectionId

class HasConnectionsBandwidth s a | s -> a where
    connectionsBandwidth :: Lens' s (TF.Argument "connections_bandwidth" a)

instance HasConnectionsBandwidth s a => HasConnectionsBandwidth (TF.Resource p s) a where
    connectionsBandwidth = TF.configuration . connectionsBandwidth

class HasContainer s a | s -> a where
    container :: Lens' s (TF.Argument "container" a)

instance HasContainer s a => HasContainer (TF.Resource p s) a where
    container = TF.configuration . container

class HasContainerDefinitions s a | s -> a where
    containerDefinitions :: Lens' s (TF.Argument "container_definitions" a)

instance HasContainerDefinitions s a => HasContainerDefinitions (TF.Resource p s) a where
    containerDefinitions = TF.configuration . containerDefinitions

class HasContainerProperties s a | s -> a where
    containerProperties :: Lens' s (TF.Argument "container_properties" a)

instance HasContainerProperties s a => HasContainerProperties (TF.Resource p s) a where
    containerProperties = TF.configuration . containerProperties

class HasContent s a | s -> a where
    content :: Lens' s (TF.Argument "content" a)

instance HasContent s a => HasContent (TF.Resource p s) a where
    content = TF.configuration . content

class HasContentBasedDeduplication s a | s -> a where
    contentBasedDeduplication :: Lens' s (TF.Argument "content_based_deduplication" a)

instance HasContentBasedDeduplication s a => HasContentBasedDeduplication (TF.Resource p s) a where
    contentBasedDeduplication = TF.configuration . contentBasedDeduplication

class HasContentConfig s a | s -> a where
    contentConfig :: Lens' s (TF.Argument "content_config" a)

instance HasContentConfig s a => HasContentConfig (TF.Resource p s) a where
    contentConfig = TF.configuration . contentConfig

class HasContentConfigPermissions s a | s -> a where
    contentConfigPermissions :: Lens' s (TF.Argument "content_config_permissions" a)

instance HasContentConfigPermissions s a => HasContentConfigPermissions (TF.Resource p s) a where
    contentConfigPermissions = TF.configuration . contentConfigPermissions

class HasContentDisposition s a | s -> a where
    contentDisposition :: Lens' s (TF.Argument "content_disposition" a)

instance HasContentDisposition s a => HasContentDisposition (TF.Resource p s) a where
    contentDisposition = TF.configuration . contentDisposition

class HasContentEncoding s a | s -> a where
    contentEncoding :: Lens' s (TF.Argument "content_encoding" a)

instance HasContentEncoding s a => HasContentEncoding (TF.Resource p s) a where
    contentEncoding = TF.configuration . contentEncoding

class HasContentHandling s a | s -> a where
    contentHandling :: Lens' s (TF.Argument "content_handling" a)

instance HasContentHandling s a => HasContentHandling (TF.Resource p s) a where
    contentHandling = TF.configuration . contentHandling

class HasContentLanguage s a | s -> a where
    contentLanguage :: Lens' s (TF.Argument "content_language" a)

instance HasContentLanguage s a => HasContentLanguage (TF.Resource p s) a where
    contentLanguage = TF.configuration . contentLanguage

class HasContentType s a | s -> a where
    contentType :: Lens' s (TF.Argument "content_type" a)

instance HasContentType s a => HasContentType (TF.Resource p s) a where
    contentType = TF.configuration . contentType

class HasCookieExpirationPeriod s a | s -> a where
    cookieExpirationPeriod :: Lens' s (TF.Argument "cookie_expiration_period" a)

instance HasCookieExpirationPeriod s a => HasCookieExpirationPeriod (TF.Resource p s) a where
    cookieExpirationPeriod = TF.configuration . cookieExpirationPeriod

class HasCookieName s a | s -> a where
    cookieName :: Lens' s (TF.Argument "cookie_name" a)

instance HasCookieName s a => HasCookieName (TF.Resource p s) a where
    cookieName = TF.configuration . cookieName

class HasCopyTagsToSnapshot s a | s -> a where
    copyTagsToSnapshot :: Lens' s (TF.Argument "copy_tags_to_snapshot" a)

instance HasCopyTagsToSnapshot s a => HasCopyTagsToSnapshot (TF.Resource p s) a where
    copyTagsToSnapshot = TF.configuration . copyTagsToSnapshot

class HasCoreInstanceCount s a | s -> a where
    coreInstanceCount :: Lens' s (TF.Argument "core_instance_count" a)

instance HasCoreInstanceCount s a => HasCoreInstanceCount (TF.Resource p s) a where
    coreInstanceCount = TF.configuration . coreInstanceCount

class HasCoreInstanceType s a | s -> a where
    coreInstanceType :: Lens' s (TF.Argument "core_instance_type" a)

instance HasCoreInstanceType s a => HasCoreInstanceType (TF.Resource p s) a where
    coreInstanceType = TF.configuration . coreInstanceType

class HasCorsRule s a | s -> a where
    corsRule :: Lens' s (TF.Argument "cors_rule" a)

instance HasCorsRule s a => HasCorsRule (TF.Resource p s) a where
    corsRule = TF.configuration . corsRule

class HasCreationToken s a | s -> a where
    creationToken :: Lens' s (TF.Argument "creation_token" a)

instance HasCreationToken s a => HasCreationToken (TF.Resource p s) a where
    creationToken = TF.configuration . creationToken

class HasCredentials s a | s -> a where
    credentials :: Lens' s (TF.Argument "credentials" a)

instance HasCredentials s a => HasCredentials (TF.Resource p s) a where
    credentials = TF.configuration . credentials

class HasCrossZoneLoadBalancing s a | s -> a where
    crossZoneLoadBalancing :: Lens' s (TF.Argument "cross_zone_load_balancing" a)

instance HasCrossZoneLoadBalancing s a => HasCrossZoneLoadBalancing (TF.Resource p s) a where
    crossZoneLoadBalancing = TF.configuration . crossZoneLoadBalancing

class HasCsr s a | s -> a where
    csr :: Lens' s (TF.Argument "csr" a)

instance HasCsr s a => HasCsr (TF.Resource p s) a where
    csr = TF.configuration . csr

class HasCustomCookbooksSource s a | s -> a where
    customCookbooksSource :: Lens' s (TF.Argument "custom_cookbooks_source" a)

instance HasCustomCookbooksSource s a => HasCustomCookbooksSource (TF.Resource p s) a where
    customCookbooksSource = TF.configuration . customCookbooksSource

class HasCustomData s a | s -> a where
    customData :: Lens' s (TF.Argument "custom_data" a)

instance HasCustomData s a => HasCustomData (TF.Resource p s) a where
    customData = TF.configuration . customData

class HasCustomErrorResponse s a | s -> a where
    customErrorResponse :: Lens' s (TF.Argument "custom_error_response" a)

instance HasCustomErrorResponse s a => HasCustomErrorResponse (TF.Resource p s) a where
    customErrorResponse = TF.configuration . customErrorResponse

class HasCustomInstanceProfileArn s a | s -> a where
    customInstanceProfileArn :: Lens' s (TF.Argument "custom_instance_profile_arn" a)

instance HasCustomInstanceProfileArn s a => HasCustomInstanceProfileArn (TF.Resource p s) a where
    customInstanceProfileArn = TF.configuration . customInstanceProfileArn

class HasCustomJson s a | s -> a where
    customJson :: Lens' s (TF.Argument "custom_json" a)

instance HasCustomJson s a => HasCustomJson (TF.Resource p s) a where
    customJson = TF.configuration . customJson

class HasCustomSecurityGroupIds s a | s -> a where
    customSecurityGroupIds :: Lens' s (TF.Argument "custom_security_group_ids" a)

instance HasCustomSecurityGroupIds s a => HasCustomSecurityGroupIds (TF.Resource p s) a where
    customSecurityGroupIds = TF.configuration . customSecurityGroupIds

class HasCustomerGatewayId s a | s -> a where
    customerGatewayId :: Lens' s (TF.Argument "customer_gateway_id" a)

instance HasCustomerGatewayId s a => HasCustomerGatewayId (TF.Resource p s) a where
    customerGatewayId = TF.configuration . customerGatewayId

class HasCutoff s a | s -> a where
    cutoff :: Lens' s (TF.Argument "cutoff" a)

instance HasCutoff s a => HasCutoff (TF.Resource p s) a where
    cutoff = TF.configuration . cutoff

class HasDashboardBody s a | s -> a where
    dashboardBody :: Lens' s (TF.Argument "dashboard_body" a)

instance HasDashboardBody s a => HasDashboardBody (TF.Resource p s) a where
    dashboardBody = TF.configuration . dashboardBody

class HasDashboardName s a | s -> a where
    dashboardName :: Lens' s (TF.Argument "dashboard_name" a)

instance HasDashboardName s a => HasDashboardName (TF.Resource p s) a where
    dashboardName = TF.configuration . dashboardName

class HasData' s a | s -> a where
    data' :: Lens' s (TF.Argument "data" a)

instance HasData' s a => HasData' (TF.Resource p s) a where
    data' = TF.configuration . data'

class HasDataSourceArn s a | s -> a where
    dataSourceArn :: Lens' s (TF.Argument "data_source_arn" a)

instance HasDataSourceArn s a => HasDataSourceArn (TF.Resource p s) a where
    dataSourceArn = TF.configuration . dataSourceArn

class HasDataSourceDatabaseName s a | s -> a where
    dataSourceDatabaseName :: Lens' s (TF.Argument "data_source_database_name" a)

instance HasDataSourceDatabaseName s a => HasDataSourceDatabaseName (TF.Resource p s) a where
    dataSourceDatabaseName = TF.configuration . dataSourceDatabaseName

class HasDataSourceType s a | s -> a where
    dataSourceType :: Lens' s (TF.Argument "data_source_type" a)

instance HasDataSourceType s a => HasDataSourceType (TF.Resource p s) a where
    dataSourceType = TF.configuration . dataSourceType

class HasDatabase s a | s -> a where
    database :: Lens' s (TF.Argument "database" a)

instance HasDatabase s a => HasDatabase (TF.Resource p s) a where
    database = TF.configuration . database

class HasDatabaseName s a | s -> a where
    databaseName :: Lens' s (TF.Argument "database_name" a)

instance HasDatabaseName s a => HasDatabaseName (TF.Resource p s) a where
    databaseName = TF.configuration . databaseName

class HasDatapointsToAlarm s a | s -> a where
    datapointsToAlarm :: Lens' s (TF.Argument "datapoints_to_alarm" a)

instance HasDatapointsToAlarm s a => HasDatapointsToAlarm (TF.Resource p s) a where
    datapointsToAlarm = TF.configuration . datapointsToAlarm

class HasDbClusterParameterGroupName s a | s -> a where
    dbClusterParameterGroupName :: Lens' s (TF.Argument "db_cluster_parameter_group_name" a)

instance HasDbClusterParameterGroupName s a => HasDbClusterParameterGroupName (TF.Resource p s) a where
    dbClusterParameterGroupName = TF.configuration . dbClusterParameterGroupName

class HasDbInstanceIdentifier s a | s -> a where
    dbInstanceIdentifier :: Lens' s (TF.Argument "db_instance_identifier" a)

instance HasDbInstanceIdentifier s a => HasDbInstanceIdentifier (TF.Resource p s) a where
    dbInstanceIdentifier = TF.configuration . dbInstanceIdentifier

class HasDbParameterGroupName s a | s -> a where
    dbParameterGroupName :: Lens' s (TF.Argument "db_parameter_group_name" a)

instance HasDbParameterGroupName s a => HasDbParameterGroupName (TF.Resource p s) a where
    dbParameterGroupName = TF.configuration . dbParameterGroupName

class HasDbPassword s a | s -> a where
    dbPassword :: Lens' s (TF.Argument "db_password" a)

instance HasDbPassword s a => HasDbPassword (TF.Resource p s) a where
    dbPassword = TF.configuration . dbPassword

class HasDbSnapshotIdentifier s a | s -> a where
    dbSnapshotIdentifier :: Lens' s (TF.Argument "db_snapshot_identifier" a)

instance HasDbSnapshotIdentifier s a => HasDbSnapshotIdentifier (TF.Resource p s) a where
    dbSnapshotIdentifier = TF.configuration . dbSnapshotIdentifier

class HasDbSubnetGroupName s a | s -> a where
    dbSubnetGroupName :: Lens' s (TF.Argument "db_subnet_group_name" a)

instance HasDbSubnetGroupName s a => HasDbSubnetGroupName (TF.Resource p s) a where
    dbSubnetGroupName = TF.configuration . dbSubnetGroupName

class HasDbUser s a | s -> a where
    dbUser :: Lens' s (TF.Argument "db_user" a)

instance HasDbUser s a => HasDbUser (TF.Resource p s) a where
    dbUser = TF.configuration . dbUser

class HasDeadLetterConfig s a | s -> a where
    deadLetterConfig :: Lens' s (TF.Argument "dead_letter_config" a)

instance HasDeadLetterConfig s a => HasDeadLetterConfig (TF.Resource p s) a where
    deadLetterConfig = TF.configuration . deadLetterConfig

class HasDefaultAction s a | s -> a where
    defaultAction :: Lens' s (TF.Argument "default_action" a)

instance HasDefaultAction s a => HasDefaultAction (TF.Resource p s) a where
    defaultAction = TF.configuration . defaultAction

class HasDefaultAvailabilityZone s a | s -> a where
    defaultAvailabilityZone :: Lens' s (TF.Argument "default_availability_zone" a)

instance HasDefaultAvailabilityZone s a => HasDefaultAvailabilityZone (TF.Resource p s) a where
    defaultAvailabilityZone = TF.configuration . defaultAvailabilityZone

class HasDefaultBranch s a | s -> a where
    defaultBranch :: Lens' s (TF.Argument "default_branch" a)

instance HasDefaultBranch s a => HasDefaultBranch (TF.Resource p s) a where
    defaultBranch = TF.configuration . defaultBranch

class HasDefaultCacheBehavior s a | s -> a where
    defaultCacheBehavior :: Lens' s (TF.Argument "default_cache_behavior" a)

instance HasDefaultCacheBehavior s a => HasDefaultCacheBehavior (TF.Resource p s) a where
    defaultCacheBehavior = TF.configuration . defaultCacheBehavior

class HasDefaultCooldown s a | s -> a where
    defaultCooldown :: Lens' s (TF.Argument "default_cooldown" a)

instance HasDefaultCooldown s a => HasDefaultCooldown (TF.Resource p s) a where
    defaultCooldown = TF.configuration . defaultCooldown

class HasDefaultInstanceProfileArn s a | s -> a where
    defaultInstanceProfileArn :: Lens' s (TF.Argument "default_instance_profile_arn" a)

instance HasDefaultInstanceProfileArn s a => HasDefaultInstanceProfileArn (TF.Resource p s) a where
    defaultInstanceProfileArn = TF.configuration . defaultInstanceProfileArn

class HasDefaultNetworkAclId s a | s -> a where
    defaultNetworkAclId :: Lens' s (TF.Argument "default_network_acl_id" a)

instance HasDefaultNetworkAclId s a => HasDefaultNetworkAclId (TF.Resource p s) a where
    defaultNetworkAclId = TF.configuration . defaultNetworkAclId

class HasDefaultOs s a | s -> a where
    defaultOs :: Lens' s (TF.Argument "default_os" a)

instance HasDefaultOs s a => HasDefaultOs (TF.Resource p s) a where
    defaultOs = TF.configuration . defaultOs

class HasDefaultRedirectUri s a | s -> a where
    defaultRedirectUri :: Lens' s (TF.Argument "default_redirect_uri" a)

instance HasDefaultRedirectUri s a => HasDefaultRedirectUri (TF.Resource p s) a where
    defaultRedirectUri = TF.configuration . defaultRedirectUri

class HasDefaultResult s a | s -> a where
    defaultResult :: Lens' s (TF.Argument "default_result" a)

instance HasDefaultResult s a => HasDefaultResult (TF.Resource p s) a where
    defaultResult = TF.configuration . defaultResult

class HasDefaultRootDeviceType s a | s -> a where
    defaultRootDeviceType :: Lens' s (TF.Argument "default_root_device_type" a)

instance HasDefaultRootDeviceType s a => HasDefaultRootDeviceType (TF.Resource p s) a where
    defaultRootDeviceType = TF.configuration . defaultRootDeviceType

class HasDefaultRootObject s a | s -> a where
    defaultRootObject :: Lens' s (TF.Argument "default_root_object" a)

instance HasDefaultRootObject s a => HasDefaultRootObject (TF.Resource p s) a where
    defaultRootObject = TF.configuration . defaultRootObject

class HasDefaultRouteTableId s a | s -> a where
    defaultRouteTableId :: Lens' s (TF.Argument "default_route_table_id" a)

instance HasDefaultRouteTableId s a => HasDefaultRouteTableId (TF.Resource p s) a where
    defaultRouteTableId = TF.configuration . defaultRouteTableId

class HasDefaultSshKeyName s a | s -> a where
    defaultSshKeyName :: Lens' s (TF.Argument "default_ssh_key_name" a)

instance HasDefaultSshKeyName s a => HasDefaultSshKeyName (TF.Resource p s) a where
    defaultSshKeyName = TF.configuration . defaultSshKeyName

class HasDefaultSubnetId s a | s -> a where
    defaultSubnetId :: Lens' s (TF.Argument "default_subnet_id" a)

instance HasDefaultSubnetId s a => HasDefaultSubnetId (TF.Resource p s) a where
    defaultSubnetId = TF.configuration . defaultSubnetId

class HasDefinition s a | s -> a where
    definition :: Lens' s (TF.Argument "definition" a)

instance HasDefinition s a => HasDefinition (TF.Resource p s) a where
    definition = TF.configuration . definition

class HasDelaySeconds s a | s -> a where
    delaySeconds :: Lens' s (TF.Argument "delay_seconds" a)

instance HasDelaySeconds s a => HasDelaySeconds (TF.Resource p s) a where
    delaySeconds = TF.configuration . delaySeconds

class HasDelegationSetId s a | s -> a where
    delegationSetId :: Lens' s (TF.Argument "delegation_set_id" a)

instance HasDelegationSetId s a => HasDelegationSetId (TF.Resource p s) a where
    delegationSetId = TF.configuration . delegationSetId

class HasDeletionWindowInDays s a | s -> a where
    deletionWindowInDays :: Lens' s (TF.Argument "deletion_window_in_days" a)

instance HasDeletionWindowInDays s a => HasDeletionWindowInDays (TF.Resource p s) a where
    deletionWindowInDays = TF.configuration . deletionWindowInDays

class HasDeliveryPolicy s a | s -> a where
    deliveryPolicy :: Lens' s (TF.Argument "delivery_policy" a)

instance HasDeliveryPolicy s a => HasDeliveryPolicy (TF.Resource p s) a where
    deliveryPolicy = TF.configuration . deliveryPolicy

class HasDeploymentConfigName s a | s -> a where
    deploymentConfigName :: Lens' s (TF.Argument "deployment_config_name" a)

instance HasDeploymentConfigName s a => HasDeploymentConfigName (TF.Resource p s) a where
    deploymentConfigName = TF.configuration . deploymentConfigName

class HasDeploymentGroupName s a | s -> a where
    deploymentGroupName :: Lens' s (TF.Argument "deployment_group_name" a)

instance HasDeploymentGroupName s a => HasDeploymentGroupName (TF.Resource p s) a where
    deploymentGroupName = TF.configuration . deploymentGroupName

class HasDeploymentId s a | s -> a where
    deploymentId :: Lens' s (TF.Argument "deployment_id" a)

instance HasDeploymentId s a => HasDeploymentId (TF.Resource p s) a where
    deploymentId = TF.configuration . deploymentId

class HasDeploymentMaximumPercent s a | s -> a where
    deploymentMaximumPercent :: Lens' s (TF.Argument "deployment_maximum_percent" a)

instance HasDeploymentMaximumPercent s a => HasDeploymentMaximumPercent (TF.Resource p s) a where
    deploymentMaximumPercent = TF.configuration . deploymentMaximumPercent

class HasDeploymentMinimumHealthyPercent s a | s -> a where
    deploymentMinimumHealthyPercent :: Lens' s (TF.Argument "deployment_minimum_healthy_percent" a)

instance HasDeploymentMinimumHealthyPercent s a => HasDeploymentMinimumHealthyPercent (TF.Resource p s) a where
    deploymentMinimumHealthyPercent = TF.configuration . deploymentMinimumHealthyPercent

class HasDeploymentMode s a | s -> a where
    deploymentMode :: Lens' s (TF.Argument "deployment_mode" a)

instance HasDeploymentMode s a => HasDeploymentMode (TF.Resource p s) a where
    deploymentMode = TF.configuration . deploymentMode

class HasDeploymentStyle s a | s -> a where
    deploymentStyle :: Lens' s (TF.Argument "deployment_style" a)

instance HasDeploymentStyle s a => HasDeploymentStyle (TF.Resource p s) a where
    deploymentStyle = TF.configuration . deploymentStyle

class HasDeregistrationDelay s a | s -> a where
    deregistrationDelay :: Lens' s (TF.Argument "deregistration_delay" a)

instance HasDeregistrationDelay s a => HasDeregistrationDelay (TF.Resource p s) a where
    deregistrationDelay = TF.configuration . deregistrationDelay

class HasDescription s a | s -> a where
    description :: Lens' s (TF.Argument "description" a)

instance HasDescription s a => HasDescription (TF.Resource p s) a where
    description = TF.configuration . description

class HasDesiredCapacity s a | s -> a where
    desiredCapacity :: Lens' s (TF.Argument "desired_capacity" a)

instance HasDesiredCapacity s a => HasDesiredCapacity (TF.Resource p s) a where
    desiredCapacity = TF.configuration . desiredCapacity

class HasDesiredCount s a | s -> a where
    desiredCount :: Lens' s (TF.Argument "desired_count" a)

instance HasDesiredCount s a => HasDesiredCount (TF.Resource p s) a where
    desiredCount = TF.configuration . desiredCount

class HasDestination s a | s -> a where
    destination :: Lens' s (TF.Argument "destination" a)

instance HasDestination s a => HasDestination (TF.Resource p s) a where
    destination = TF.configuration . destination

class HasDestinationArn s a | s -> a where
    destinationArn :: Lens' s (TF.Argument "destination_arn" a)

instance HasDestinationArn s a => HasDestinationArn (TF.Resource p s) a where
    destinationArn = TF.configuration . destinationArn

class HasDestinationCidrBlock s a | s -> a where
    destinationCidrBlock :: Lens' s (TF.Argument "destination_cidr_block" a)

instance HasDestinationCidrBlock s a => HasDestinationCidrBlock (TF.Resource p s) a where
    destinationCidrBlock = TF.configuration . destinationCidrBlock

class HasDestinationIpv6CidrBlock s a | s -> a where
    destinationIpv6CidrBlock :: Lens' s (TF.Argument "destination_ipv6_cidr_block" a)

instance HasDestinationIpv6CidrBlock s a => HasDestinationIpv6CidrBlock (TF.Resource p s) a where
    destinationIpv6CidrBlock = TF.configuration . destinationIpv6CidrBlock

class HasDestinationName s a | s -> a where
    destinationName :: Lens' s (TF.Argument "destination_name" a)

instance HasDestinationName s a => HasDestinationName (TF.Resource p s) a where
    destinationName = TF.configuration . destinationName

class HasDetectorId s a | s -> a where
    detectorId :: Lens' s (TF.Argument "detector_id" a)

instance HasDetectorId s a => HasDetectorId (TF.Resource p s) a where
    detectorId = TF.configuration . detectorId

class HasDeveloperProviderName s a | s -> a where
    developerProviderName :: Lens' s (TF.Argument "developer_provider_name" a)

instance HasDeveloperProviderName s a => HasDeveloperProviderName (TF.Resource p s) a where
    developerProviderName = TF.configuration . developerProviderName

class HasDeviceConfiguration s a | s -> a where
    deviceConfiguration :: Lens' s (TF.Argument "device_configuration" a)

instance HasDeviceConfiguration s a => HasDeviceConfiguration (TF.Resource p s) a where
    deviceConfiguration = TF.configuration . deviceConfiguration

class HasDeviceIndex s a | s -> a where
    deviceIndex :: Lens' s (TF.Argument "device_index" a)

instance HasDeviceIndex s a => HasDeviceIndex (TF.Resource p s) a where
    deviceIndex = TF.configuration . deviceIndex

class HasDeviceName s a | s -> a where
    deviceName :: Lens' s (TF.Argument "device_name" a)

instance HasDeviceName s a => HasDeviceName (TF.Resource p s) a where
    deviceName = TF.configuration . deviceName

class HasDhcpOptionsId s a | s -> a where
    dhcpOptionsId :: Lens' s (TF.Argument "dhcp_options_id" a)

instance HasDhcpOptionsId s a => HasDhcpOptionsId (TF.Resource p s) a where
    dhcpOptionsId = TF.configuration . dhcpOptionsId

class HasDimensions s a | s -> a where
    dimensions :: Lens' s (TF.Argument "dimensions" a)

instance HasDimensions s a => HasDimensions (TF.Resource p s) a where
    dimensions = TF.configuration . dimensions

class HasDisableApiTermination s a | s -> a where
    disableApiTermination :: Lens' s (TF.Argument "disable_api_termination" a)

instance HasDisableApiTermination s a => HasDisableApiTermination (TF.Resource p s) a where
    disableApiTermination = TF.configuration . disableApiTermination

class HasDisableRollback s a | s -> a where
    disableRollback :: Lens' s (TF.Argument "disable_rollback" a)

instance HasDisableRollback s a => HasDisableRollback (TF.Resource p s) a where
    disableRollback = TF.configuration . disableRollback

class HasDisplayName s a | s -> a where
    displayName :: Lens' s (TF.Argument "display_name" a)

instance HasDisplayName s a => HasDisplayName (TF.Resource p s) a where
    displayName = TF.configuration . displayName

class HasDnsConfig s a | s -> a where
    dnsConfig :: Lens' s (TF.Argument "dns_config" a)

instance HasDnsConfig s a => HasDnsConfig (TF.Resource p s) a where
    dnsConfig = TF.configuration . dnsConfig

class HasDocumentRoot s a | s -> a where
    documentRoot :: Lens' s (TF.Argument "document_root" a)

instance HasDocumentRoot s a => HasDocumentRoot (TF.Resource p s) a where
    documentRoot = TF.configuration . documentRoot

class HasDocumentType s a | s -> a where
    documentType :: Lens' s (TF.Argument "document_type" a)

instance HasDocumentType s a => HasDocumentType (TF.Resource p s) a where
    documentType = TF.configuration . documentType

class HasDocumentVersion s a | s -> a where
    documentVersion :: Lens' s (TF.Argument "document_version" a)

instance HasDocumentVersion s a => HasDocumentVersion (TF.Resource p s) a where
    documentVersion = TF.configuration . documentVersion

class HasDocumentationVersion s a | s -> a where
    documentationVersion :: Lens' s (TF.Argument "documentation_version" a)

instance HasDocumentationVersion s a => HasDocumentationVersion (TF.Resource p s) a where
    documentationVersion = TF.configuration . documentationVersion

class HasDomain s a | s -> a where
    domain :: Lens' s (TF.Argument "domain" a)

instance HasDomain s a => HasDomain (TF.Resource p s) a where
    domain = TF.configuration . domain

class HasDomainName s a | s -> a where
    domainName :: Lens' s (TF.Argument "domain_name" a)

instance HasDomainName s a => HasDomainName (TF.Resource p s) a where
    domainName = TF.configuration . domainName

class HasDomainNameServers s a | s -> a where
    domainNameServers :: Lens' s (TF.Argument "domain_name_servers" a)

instance HasDomainNameServers s a => HasDomainNameServers (TF.Resource p s) a where
    domainNameServers = TF.configuration . domainNameServers

class HasDomains s a | s -> a where
    domains :: Lens' s (TF.Argument "domains" a)

instance HasDomains s a => HasDomains (TF.Resource p s) a where
    domains = TF.configuration . domains

class HasDrainElbOnShutdown s a | s -> a where
    drainElbOnShutdown :: Lens' s (TF.Argument "drain_elb_on_shutdown" a)

instance HasDrainElbOnShutdown s a => HasDrainElbOnShutdown (TF.Resource p s) a where
    drainElbOnShutdown = TF.configuration . drainElbOnShutdown

class HasDuration s a | s -> a where
    duration :: Lens' s (TF.Argument "duration" a)

instance HasDuration s a => HasDuration (TF.Resource p s) a where
    duration = TF.configuration . duration

class HasEbsBlockDevice s a | s -> a where
    ebsBlockDevice :: Lens' s (TF.Argument "ebs_block_device" a)

instance HasEbsBlockDevice s a => HasEbsBlockDevice (TF.Resource p s) a where
    ebsBlockDevice = TF.configuration . ebsBlockDevice

class HasEbsConfig s a | s -> a where
    ebsConfig :: Lens' s (TF.Argument "ebs_config" a)

instance HasEbsConfig s a => HasEbsConfig (TF.Resource p s) a where
    ebsConfig = TF.configuration . ebsConfig

class HasEbsOptimized s a | s -> a where
    ebsOptimized :: Lens' s (TF.Argument "ebs_optimized" a)

instance HasEbsOptimized s a => HasEbsOptimized (TF.Resource p s) a where
    ebsOptimized = TF.configuration . ebsOptimized

class HasEbsOptions s a | s -> a where
    ebsOptions :: Lens' s (TF.Argument "ebs_options" a)

instance HasEbsOptions s a => HasEbsOptions (TF.Resource p s) a where
    ebsOptions = TF.configuration . ebsOptions

class HasEbsRootVolumeSize s a | s -> a where
    ebsRootVolumeSize :: Lens' s (TF.Argument "ebs_root_volume_size" a)

instance HasEbsRootVolumeSize s a => HasEbsRootVolumeSize (TF.Resource p s) a where
    ebsRootVolumeSize = TF.configuration . ebsRootVolumeSize

class HasEbsVolume s a | s -> a where
    ebsVolume :: Lens' s (TF.Argument "ebs_volume" a)

instance HasEbsVolume s a => HasEbsVolume (TF.Resource p s) a where
    ebsVolume = TF.configuration . ebsVolume

class HasEc2Attributes s a | s -> a where
    ec2Attributes :: Lens' s (TF.Argument "ec2_attributes" a)

instance HasEc2Attributes s a => HasEc2Attributes (TF.Resource p s) a where
    ec2Attributes = TF.configuration . ec2Attributes

class HasEc2TagFilter s a | s -> a where
    ec2TagFilter :: Lens' s (TF.Argument "ec2_tag_filter" a)

instance HasEc2TagFilter s a => HasEc2TagFilter (TF.Resource p s) a where
    ec2TagFilter = TF.configuration . ec2TagFilter

class HasEcsTarget s a | s -> a where
    ecsTarget :: Lens' s (TF.Argument "ecs_target" a)

instance HasEcsTarget s a => HasEcsTarget (TF.Resource p s) a where
    ecsTarget = TF.configuration . ecsTarget

class HasEgress s a | s -> a where
    egress :: Lens' s (TF.Argument "egress" a)

instance HasEgress s a => HasEgress (TF.Resource p s) a where
    egress = TF.configuration . egress

class HasEgressOnlyGatewayId s a | s -> a where
    egressOnlyGatewayId :: Lens' s (TF.Argument "egress_only_gateway_id" a)

instance HasEgressOnlyGatewayId s a => HasEgressOnlyGatewayId (TF.Resource p s) a where
    egressOnlyGatewayId = TF.configuration . egressOnlyGatewayId

class HasElasticIp s a | s -> a where
    elasticIp :: Lens' s (TF.Argument "elastic_ip" a)

instance HasElasticIp s a => HasElasticIp (TF.Resource p s) a where
    elasticIp = TF.configuration . elasticIp

class HasElasticLoadBalancer s a | s -> a where
    elasticLoadBalancer :: Lens' s (TF.Argument "elastic_load_balancer" a)

instance HasElasticLoadBalancer s a => HasElasticLoadBalancer (TF.Resource p s) a where
    elasticLoadBalancer = TF.configuration . elasticLoadBalancer

class HasElasticsearchVersion s a | s -> a where
    elasticsearchVersion :: Lens' s (TF.Argument "elasticsearch_version" a)

instance HasElasticsearchVersion s a => HasElasticsearchVersion (TF.Resource p s) a where
    elasticsearchVersion = TF.configuration . elasticsearchVersion

class HasElb s a | s -> a where
    elb :: Lens' s (TF.Argument "elb" a)

instance HasElb s a => HasElb (TF.Resource p s) a where
    elb = TF.configuration . elb

class HasEmail s a | s -> a where
    email :: Lens' s (TF.Argument "email" a)

instance HasEmail s a => HasEmail (TF.Resource p s) a where
    email = TF.configuration . email

class HasEmailConfiguration s a | s -> a where
    emailConfiguration :: Lens' s (TF.Argument "email_configuration" a)

instance HasEmailConfiguration s a => HasEmailConfiguration (TF.Resource p s) a where
    emailConfiguration = TF.configuration . emailConfiguration

class HasEmailVerificationMessage s a | s -> a where
    emailVerificationMessage :: Lens' s (TF.Argument "email_verification_message" a)

instance HasEmailVerificationMessage s a => HasEmailVerificationMessage (TF.Resource p s) a where
    emailVerificationMessage = TF.configuration . emailVerificationMessage

class HasEmailVerificationSubject s a | s -> a where
    emailVerificationSubject :: Lens' s (TF.Argument "email_verification_subject" a)

instance HasEmailVerificationSubject s a => HasEmailVerificationSubject (TF.Resource p s) a where
    emailVerificationSubject = TF.configuration . emailVerificationSubject

class HasEnable s a | s -> a where
    enable :: Lens' s (TF.Argument "enable" a)

instance HasEnable s a => HasEnable (TF.Resource p s) a where
    enable = TF.configuration . enable

class HasEnableClassiclink s a | s -> a where
    enableClassiclink :: Lens' s (TF.Argument "enable_classiclink" a)

instance HasEnableClassiclink s a => HasEnableClassiclink (TF.Resource p s) a where
    enableClassiclink = TF.configuration . enableClassiclink

class HasEnableClassiclinkDnsSupport s a | s -> a where
    enableClassiclinkDnsSupport :: Lens' s (TF.Argument "enable_classiclink_dns_support" a)

instance HasEnableClassiclinkDnsSupport s a => HasEnableClassiclinkDnsSupport (TF.Resource p s) a where
    enableClassiclinkDnsSupport = TF.configuration . enableClassiclinkDnsSupport

class HasEnableDeletionProtection s a | s -> a where
    enableDeletionProtection :: Lens' s (TF.Argument "enable_deletion_protection" a)

instance HasEnableDeletionProtection s a => HasEnableDeletionProtection (TF.Resource p s) a where
    enableDeletionProtection = TF.configuration . enableDeletionProtection

class HasEnableDnsHostnames s a | s -> a where
    enableDnsHostnames :: Lens' s (TF.Argument "enable_dns_hostnames" a)

instance HasEnableDnsHostnames s a => HasEnableDnsHostnames (TF.Resource p s) a where
    enableDnsHostnames = TF.configuration . enableDnsHostnames

class HasEnableDnsSupport s a | s -> a where
    enableDnsSupport :: Lens' s (TF.Argument "enable_dns_support" a)

instance HasEnableDnsSupport s a => HasEnableDnsSupport (TF.Resource p s) a where
    enableDnsSupport = TF.configuration . enableDnsSupport

class HasEnableKeyRotation s a | s -> a where
    enableKeyRotation :: Lens' s (TF.Argument "enable_key_rotation" a)

instance HasEnableKeyRotation s a => HasEnableKeyRotation (TF.Resource p s) a where
    enableKeyRotation = TF.configuration . enableKeyRotation

class HasEnableLogFileValidation s a | s -> a where
    enableLogFileValidation :: Lens' s (TF.Argument "enable_log_file_validation" a)

instance HasEnableLogFileValidation s a => HasEnableLogFileValidation (TF.Resource p s) a where
    enableLogFileValidation = TF.configuration . enableLogFileValidation

class HasEnableLogging s a | s -> a where
    enableLogging :: Lens' s (TF.Argument "enable_logging" a)

instance HasEnableLogging s a => HasEnableLogging (TF.Resource p s) a where
    enableLogging = TF.configuration . enableLogging

class HasEnableMonitoring s a | s -> a where
    enableMonitoring :: Lens' s (TF.Argument "enable_monitoring" a)

instance HasEnableMonitoring s a => HasEnableMonitoring (TF.Resource p s) a where
    enableMonitoring = TF.configuration . enableMonitoring

class HasEnableSni s a | s -> a where
    enableSni :: Lens' s (TF.Argument "enable_sni" a)

instance HasEnableSni s a => HasEnableSni (TF.Resource p s) a where
    enableSni = TF.configuration . enableSni

class HasEnableSsl s a | s -> a where
    enableSsl :: Lens' s (TF.Argument "enable_ssl" a)

instance HasEnableSsl s a => HasEnableSsl (TF.Resource p s) a where
    enableSsl = TF.configuration . enableSsl

class HasEnableSso s a | s -> a where
    enableSso :: Lens' s (TF.Argument "enable_sso" a)

instance HasEnableSso s a => HasEnableSso (TF.Resource p s) a where
    enableSso = TF.configuration . enableSso

class HasEnabled s a | s -> a where
    enabled :: Lens' s (TF.Argument "enabled" a)

instance HasEnabled s a => HasEnabled (TF.Resource p s) a where
    enabled = TF.configuration . enabled

class HasEnabledMetrics s a | s -> a where
    enabledMetrics :: Lens' s (TF.Argument "enabled_metrics" a)

instance HasEnabledMetrics s a => HasEnabledMetrics (TF.Resource p s) a where
    enabledMetrics = TF.configuration . enabledMetrics

class HasEncoding s a | s -> a where
    encoding :: Lens' s (TF.Argument "encoding" a)

instance HasEncoding s a => HasEncoding (TF.Resource p s) a where
    encoding = TF.configuration . encoding

class HasEncryptAtRest s a | s -> a where
    encryptAtRest :: Lens' s (TF.Argument "encrypt_at_rest" a)

instance HasEncryptAtRest s a => HasEncryptAtRest (TF.Resource p s) a where
    encryptAtRest = TF.configuration . encryptAtRest

class HasEncrypted s a | s -> a where
    encrypted :: Lens' s (TF.Argument "encrypted" a)

instance HasEncrypted s a => HasEncrypted (TF.Resource p s) a where
    encrypted = TF.configuration . encrypted

class HasEncryptionKey s a | s -> a where
    encryptionKey :: Lens' s (TF.Argument "encryption_key" a)

instance HasEncryptionKey s a => HasEncryptionKey (TF.Resource p s) a where
    encryptionKey = TF.configuration . encryptionKey

class HasEncryptionType s a | s -> a where
    encryptionType :: Lens' s (TF.Argument "encryption_type" a)

instance HasEncryptionType s a => HasEncryptionType (TF.Resource p s) a where
    encryptionType = TF.configuration . encryptionType

class HasEndTime s a | s -> a where
    endTime :: Lens' s (TF.Argument "end_time" a)

instance HasEndTime s a => HasEndTime (TF.Resource p s) a where
    endTime = TF.configuration . endTime

class HasEndpoint s a | s -> a where
    endpoint :: Lens' s (TF.Argument "endpoint" a)

instance HasEndpoint s a => HasEndpoint (TF.Resource p s) a where
    endpoint = TF.configuration . endpoint

class HasEndpointAutoConfirms s a | s -> a where
    endpointAutoConfirms :: Lens' s (TF.Argument "endpoint_auto_confirms" a)

instance HasEndpointAutoConfirms s a => HasEndpointAutoConfirms (TF.Resource p s) a where
    endpointAutoConfirms = TF.configuration . endpointAutoConfirms

class HasEndpointId s a | s -> a where
    endpointId :: Lens' s (TF.Argument "endpoint_id" a)

instance HasEndpointId s a => HasEndpointId (TF.Resource p s) a where
    endpointId = TF.configuration . endpointId

class HasEndpointType s a | s -> a where
    endpointType :: Lens' s (TF.Argument "endpoint_type" a)

instance HasEndpointType s a => HasEndpointType (TF.Resource p s) a where
    endpointType = TF.configuration . endpointType

class HasEngine s a | s -> a where
    engine :: Lens' s (TF.Argument "engine" a)

instance HasEngine s a => HasEngine (TF.Resource p s) a where
    engine = TF.configuration . engine

class HasEngineName s a | s -> a where
    engineName :: Lens' s (TF.Argument "engine_name" a)

instance HasEngineName s a => HasEngineName (TF.Resource p s) a where
    engineName = TF.configuration . engineName

class HasEngineType s a | s -> a where
    engineType :: Lens' s (TF.Argument "engine_type" a)

instance HasEngineType s a => HasEngineType (TF.Resource p s) a where
    engineType = TF.configuration . engineType

class HasEngineVersion s a | s -> a where
    engineVersion :: Lens' s (TF.Argument "engine_version" a)

instance HasEngineVersion s a => HasEngineVersion (TF.Resource p s) a where
    engineVersion = TF.configuration . engineVersion

class HasEnhancedVpcRouting s a | s -> a where
    enhancedVpcRouting :: Lens' s (TF.Argument "enhanced_vpc_routing" a)

instance HasEnhancedVpcRouting s a => HasEnhancedVpcRouting (TF.Resource p s) a where
    enhancedVpcRouting = TF.configuration . enhancedVpcRouting

class HasEniId s a | s -> a where
    eniId :: Lens' s (TF.Argument "eni_id" a)

instance HasEniId s a => HasEniId (TF.Resource p s) a where
    eniId = TF.configuration . eniId

class HasEnvironment s a | s -> a where
    environment :: Lens' s (TF.Argument "environment" a)

instance HasEnvironment s a => HasEnvironment (TF.Resource p s) a where
    environment = TF.configuration . environment

class HasEnvironmentId s a | s -> a where
    environmentId :: Lens' s (TF.Argument "environment_id" a)

instance HasEnvironmentId s a => HasEnvironmentId (TF.Resource p s) a where
    environmentId = TF.configuration . environmentId

class HasEphemeralBlockDevice s a | s -> a where
    ephemeralBlockDevice :: Lens' s (TF.Argument "ephemeral_block_device" a)

instance HasEphemeralBlockDevice s a => HasEphemeralBlockDevice (TF.Resource p s) a where
    ephemeralBlockDevice = TF.configuration . ephemeralBlockDevice

class HasEtag s a | s -> a where
    etag :: Lens' s (TF.Argument "etag" a)

instance HasEtag s a => HasEtag (TF.Resource p s) a where
    etag = TF.configuration . etag

class HasEvaluateLowSampleCountPercentiles s a | s -> a where
    evaluateLowSampleCountPercentiles :: Lens' s (TF.Argument "evaluate_low_sample_count_percentiles" a)

instance HasEvaluateLowSampleCountPercentiles s a => HasEvaluateLowSampleCountPercentiles (TF.Resource p s) a where
    evaluateLowSampleCountPercentiles = TF.configuration . evaluateLowSampleCountPercentiles

class HasEvaluationPeriods s a | s -> a where
    evaluationPeriods :: Lens' s (TF.Argument "evaluation_periods" a)

instance HasEvaluationPeriods s a => HasEvaluationPeriods (TF.Resource p s) a where
    evaluationPeriods = TF.configuration . evaluationPeriods

class HasEventCategories s a | s -> a where
    eventCategories :: Lens' s (TF.Argument "event_categories" a)

instance HasEventCategories s a => HasEventCategories (TF.Resource p s) a where
    eventCategories = TF.configuration . eventCategories

class HasEventPattern s a | s -> a where
    eventPattern :: Lens' s (TF.Argument "event_pattern" a)

instance HasEventPattern s a => HasEventPattern (TF.Resource p s) a where
    eventPattern = TF.configuration . eventPattern

class HasEventSourceArn s a | s -> a where
    eventSourceArn :: Lens' s (TF.Argument "event_source_arn" a)

instance HasEventSourceArn s a => HasEventSourceArn (TF.Resource p s) a where
    eventSourceArn = TF.configuration . eventSourceArn

class HasEvents s a | s -> a where
    events :: Lens' s (TF.Argument "events" a)

instance HasEvents s a => HasEvents (TF.Resource p s) a where
    events = TF.configuration . events

class HasExcessCapacityTerminationPolicy s a | s -> a where
    excessCapacityTerminationPolicy :: Lens' s (TF.Argument "excess_capacity_termination_policy" a)

instance HasExcessCapacityTerminationPolicy s a => HasExcessCapacityTerminationPolicy (TF.Resource p s) a where
    excessCapacityTerminationPolicy = TF.configuration . excessCapacityTerminationPolicy

class HasExpirationDate s a | s -> a where
    expirationDate :: Lens' s (TF.Argument "expiration_date" a)

instance HasExpirationDate s a => HasExpirationDate (TF.Resource p s) a where
    expirationDate = TF.configuration . expirationDate

class HasExplicitAuthFlows s a | s -> a where
    explicitAuthFlows :: Lens' s (TF.Argument "explicit_auth_flows" a)

instance HasExplicitAuthFlows s a => HasExplicitAuthFlows (TF.Resource p s) a where
    explicitAuthFlows = TF.configuration . explicitAuthFlows

class HasExtendedS3Configuration s a | s -> a where
    extendedS3Configuration :: Lens' s (TF.Argument "extended_s3_configuration" a)

instance HasExtendedS3Configuration s a => HasExtendedS3Configuration (TF.Resource p s) a where
    extendedS3Configuration = TF.configuration . extendedS3Configuration

class HasExtendedStatistic s a | s -> a where
    extendedStatistic :: Lens' s (TF.Argument "extended_statistic" a)

instance HasExtendedStatistic s a => HasExtendedStatistic (TF.Resource p s) a where
    extendedStatistic = TF.configuration . extendedStatistic

class HasExtraConnectionAttributes s a | s -> a where
    extraConnectionAttributes :: Lens' s (TF.Argument "extra_connection_attributes" a)

instance HasExtraConnectionAttributes s a => HasExtraConnectionAttributes (TF.Resource p s) a where
    extraConnectionAttributes = TF.configuration . extraConnectionAttributes

class HasFailoverRoutingPolicy s a | s -> a where
    failoverRoutingPolicy :: Lens' s (TF.Argument "failover_routing_policy" a)

instance HasFailoverRoutingPolicy s a => HasFailoverRoutingPolicy (TF.Resource p s) a where
    failoverRoutingPolicy = TF.configuration . failoverRoutingPolicy

class HasFailureThreshold s a | s -> a where
    failureThreshold :: Lens' s (TF.Argument "failure_threshold" a)

instance HasFailureThreshold s a => HasFailureThreshold (TF.Resource p s) a where
    failureThreshold = TF.configuration . failureThreshold

class HasFamily' s a | s -> a where
    family' :: Lens' s (TF.Argument "family" a)

instance HasFamily' s a => HasFamily' (TF.Resource p s) a where
    family' = TF.configuration . family'

class HasFifoQueue s a | s -> a where
    fifoQueue :: Lens' s (TF.Argument "fifo_queue" a)

instance HasFifoQueue s a => HasFifoQueue (TF.Resource p s) a where
    fifoQueue = TF.configuration . fifoQueue

class HasFileSystemId s a | s -> a where
    fileSystemId :: Lens' s (TF.Argument "file_system_id" a)

instance HasFileSystemId s a => HasFileSystemId (TF.Resource p s) a where
    fileSystemId = TF.configuration . fileSystemId

class HasFilename s a | s -> a where
    filename :: Lens' s (TF.Argument "filename" a)

instance HasFilename s a => HasFilename (TF.Resource p s) a where
    filename = TF.configuration . filename

class HasFilterPattern s a | s -> a where
    filterPattern :: Lens' s (TF.Argument "filter_pattern" a)

instance HasFilterPattern s a => HasFilterPattern (TF.Resource p s) a where
    filterPattern = TF.configuration . filterPattern

class HasFinalSnapshotIdentifier s a | s -> a where
    finalSnapshotIdentifier :: Lens' s (TF.Argument "final_snapshot_identifier" a)

instance HasFinalSnapshotIdentifier s a => HasFinalSnapshotIdentifier (TF.Resource p s) a where
    finalSnapshotIdentifier = TF.configuration . finalSnapshotIdentifier

class HasForceDelete s a | s -> a where
    forceDelete :: Lens' s (TF.Argument "force_delete" a)

instance HasForceDelete s a => HasForceDelete (TF.Resource p s) a where
    forceDelete = TF.configuration . forceDelete

class HasForceDestroy s a | s -> a where
    forceDestroy :: Lens' s (TF.Argument "force_destroy" a)

instance HasForceDestroy s a => HasForceDestroy (TF.Resource p s) a where
    forceDestroy = TF.configuration . forceDestroy

class HasForceDetach s a | s -> a where
    forceDetach :: Lens' s (TF.Argument "force_detach" a)

instance HasForceDetach s a => HasForceDetach (TF.Resource p s) a where
    forceDetach = TF.configuration . forceDetach

class HasFqdn s a | s -> a where
    fqdn :: Lens' s (TF.Argument "fqdn" a)

instance HasFqdn s a => HasFqdn (TF.Resource p s) a where
    fqdn = TF.configuration . fqdn

class HasFromPort s a | s -> a where
    fromPort :: Lens' s (TF.Argument "from_port" a)

instance HasFromPort s a => HasFromPort (TF.Resource p s) a where
    fromPort = TF.configuration . fromPort

class HasFunctionName s a | s -> a where
    functionName :: Lens' s (TF.Argument "function_name" a)

instance HasFunctionName s a => HasFunctionName (TF.Resource p s) a where
    functionName = TF.configuration . functionName

class HasFunctionVersion s a | s -> a where
    functionVersion :: Lens' s (TF.Argument "function_version" a)

instance HasFunctionVersion s a => HasFunctionVersion (TF.Resource p s) a where
    functionVersion = TF.configuration . functionVersion

class HasGatewayId s a | s -> a where
    gatewayId :: Lens' s (TF.Argument "gateway_id" a)

instance HasGatewayId s a => HasGatewayId (TF.Resource p s) a where
    gatewayId = TF.configuration . gatewayId

class HasGenerateSecret s a | s -> a where
    generateSecret :: Lens' s (TF.Argument "generate_secret" a)

instance HasGenerateSecret s a => HasGenerateSecret (TF.Resource p s) a where
    generateSecret = TF.configuration . generateSecret

class HasGeolocationRoutingPolicy s a | s -> a where
    geolocationRoutingPolicy :: Lens' s (TF.Argument "geolocation_routing_policy" a)

instance HasGeolocationRoutingPolicy s a => HasGeolocationRoutingPolicy (TF.Resource p s) a where
    geolocationRoutingPolicy = TF.configuration . geolocationRoutingPolicy

class HasGlobalFilter s a | s -> a where
    globalFilter :: Lens' s (TF.Argument "global_filter" a)

instance HasGlobalFilter s a => HasGlobalFilter (TF.Resource p s) a where
    globalFilter = TF.configuration . globalFilter

class HasGlobalSecondaryIndex s a | s -> a where
    globalSecondaryIndex :: Lens' s (TF.Argument "global_secondary_index" a)

instance HasGlobalSecondaryIndex s a => HasGlobalSecondaryIndex (TF.Resource p s) a where
    globalSecondaryIndex = TF.configuration . globalSecondaryIndex

class HasGroup s a | s -> a where
    group :: Lens' s (TF.Argument "group" a)

instance HasGroup s a => HasGroup (TF.Resource p s) a where
    group = TF.configuration . group

class HasGroupNames s a | s -> a where
    groupNames :: Lens' s (TF.Argument "group_names" a)

instance HasGroupNames s a => HasGroupNames (TF.Resource p s) a where
    groupNames = TF.configuration . groupNames

class HasGroups s a | s -> a where
    groups :: Lens' s (TF.Argument "groups" a)

instance HasGroups s a => HasGroups (TF.Resource p s) a where
    groups = TF.configuration . groups

class HasHandler s a | s -> a where
    handler :: Lens' s (TF.Argument "handler" a)

instance HasHandler s a => HasHandler (TF.Resource p s) a where
    handler = TF.configuration . handler

class HasHardExpiry s a | s -> a where
    hardExpiry :: Lens' s (TF.Argument "hard_expiry" a)

instance HasHardExpiry s a => HasHardExpiry (TF.Resource p s) a where
    hardExpiry = TF.configuration . hardExpiry

class HasHashKey s a | s -> a where
    hashKey :: Lens' s (TF.Argument "hash_key" a)

instance HasHashKey s a => HasHashKey (TF.Resource p s) a where
    hashKey = TF.configuration . hashKey

class HasHealthCheck s a | s -> a where
    healthCheck :: Lens' s (TF.Argument "health_check" a)

instance HasHealthCheck s a => HasHealthCheck (TF.Resource p s) a where
    healthCheck = TF.configuration . healthCheck

class HasHealthCheckConfig s a | s -> a where
    healthCheckConfig :: Lens' s (TF.Argument "health_check_config" a)

instance HasHealthCheckConfig s a => HasHealthCheckConfig (TF.Resource p s) a where
    healthCheckConfig = TF.configuration . healthCheckConfig

class HasHealthCheckGracePeriod s a | s -> a where
    healthCheckGracePeriod :: Lens' s (TF.Argument "health_check_grace_period" a)

instance HasHealthCheckGracePeriod s a => HasHealthCheckGracePeriod (TF.Resource p s) a where
    healthCheckGracePeriod = TF.configuration . healthCheckGracePeriod

class HasHealthCheckGracePeriodSeconds s a | s -> a where
    healthCheckGracePeriodSeconds :: Lens' s (TF.Argument "health_check_grace_period_seconds" a)

instance HasHealthCheckGracePeriodSeconds s a => HasHealthCheckGracePeriodSeconds (TF.Resource p s) a where
    healthCheckGracePeriodSeconds = TF.configuration . healthCheckGracePeriodSeconds

class HasHealthCheckId s a | s -> a where
    healthCheckId :: Lens' s (TF.Argument "health_check_id" a)

instance HasHealthCheckId s a => HasHealthCheckId (TF.Resource p s) a where
    healthCheckId = TF.configuration . healthCheckId

class HasHealthCheckType s a | s -> a where
    healthCheckType :: Lens' s (TF.Argument "health_check_type" a)

instance HasHealthCheckType s a => HasHealthCheckType (TF.Resource p s) a where
    healthCheckType = TF.configuration . healthCheckType

class HasHealthcheckMethod s a | s -> a where
    healthcheckMethod :: Lens' s (TF.Argument "healthcheck_method" a)

instance HasHealthcheckMethod s a => HasHealthcheckMethod (TF.Resource p s) a where
    healthcheckMethod = TF.configuration . healthcheckMethod

class HasHealthcheckUrl s a | s -> a where
    healthcheckUrl :: Lens' s (TF.Argument "healthcheck_url" a)

instance HasHealthcheckUrl s a => HasHealthcheckUrl (TF.Resource p s) a where
    healthcheckUrl = TF.configuration . healthcheckUrl

class HasHeartbeatTimeout s a | s -> a where
    heartbeatTimeout :: Lens' s (TF.Argument "heartbeat_timeout" a)

instance HasHeartbeatTimeout s a => HasHeartbeatTimeout (TF.Resource p s) a where
    heartbeatTimeout = TF.configuration . heartbeatTimeout

class HasHostInstanceType s a | s -> a where
    hostInstanceType :: Lens' s (TF.Argument "host_instance_type" a)

instance HasHostInstanceType s a => HasHostInstanceType (TF.Resource p s) a where
    hostInstanceType = TF.configuration . hostInstanceType

class HasHostname s a | s -> a where
    hostname :: Lens' s (TF.Argument "hostname" a)

instance HasHostname s a => HasHostname (TF.Resource p s) a where
    hostname = TF.configuration . hostname

class HasHostnameTheme s a | s -> a where
    hostnameTheme :: Lens' s (TF.Argument "hostname_theme" a)

instance HasHostnameTheme s a => HasHostnameTheme (TF.Resource p s) a where
    hostnameTheme = TF.configuration . hostnameTheme

class HasHtml s a | s -> a where
    html :: Lens' s (TF.Argument "html" a)

instance HasHtml s a => HasHtml (TF.Resource p s) a where
    html = TF.configuration . html

class HasHttpMethod s a | s -> a where
    httpMethod :: Lens' s (TF.Argument "http_method" a)

instance HasHttpMethod s a => HasHttpMethod (TF.Resource p s) a where
    httpMethod = TF.configuration . httpMethod

class HasHttpVersion s a | s -> a where
    httpVersion :: Lens' s (TF.Argument "http_version" a)

instance HasHttpVersion s a => HasHttpVersion (TF.Resource p s) a where
    httpVersion = TF.configuration . httpVersion

class HasIamDatabaseAuthenticationEnabled s a | s -> a where
    iamDatabaseAuthenticationEnabled :: Lens' s (TF.Argument "iam_database_authentication_enabled" a)

instance HasIamDatabaseAuthenticationEnabled s a => HasIamDatabaseAuthenticationEnabled (TF.Resource p s) a where
    iamDatabaseAuthenticationEnabled = TF.configuration . iamDatabaseAuthenticationEnabled

class HasIamFleetRole s a | s -> a where
    iamFleetRole :: Lens' s (TF.Argument "iam_fleet_role" a)

instance HasIamFleetRole s a => HasIamFleetRole (TF.Resource p s) a where
    iamFleetRole = TF.configuration . iamFleetRole

class HasIamInstanceProfile s a | s -> a where
    iamInstanceProfile :: Lens' s (TF.Argument "iam_instance_profile" a)

instance HasIamInstanceProfile s a => HasIamInstanceProfile (TF.Resource p s) a where
    iamInstanceProfile = TF.configuration . iamInstanceProfile

class HasIamRole s a | s -> a where
    iamRole :: Lens' s (TF.Argument "iam_role" a)

instance HasIamRole s a => HasIamRole (TF.Resource p s) a where
    iamRole = TF.configuration . iamRole

class HasIamRoleArn s a | s -> a where
    iamRoleArn :: Lens' s (TF.Argument "iam_role_arn" a)

instance HasIamRoleArn s a => HasIamRoleArn (TF.Resource p s) a where
    iamRoleArn = TF.configuration . iamRoleArn

class HasIamRoles s a | s -> a where
    iamRoles :: Lens' s (TF.Argument "iam_roles" a)

instance HasIamRoles s a => HasIamRoles (TF.Resource p s) a where
    iamRoles = TF.configuration . iamRoles

class HasIcmpCode s a | s -> a where
    icmpCode :: Lens' s (TF.Argument "icmp_code" a)

instance HasIcmpCode s a => HasIcmpCode (TF.Resource p s) a where
    icmpCode = TF.configuration . icmpCode

class HasIcmpType s a | s -> a where
    icmpType :: Lens' s (TF.Argument "icmp_type" a)

instance HasIcmpType s a => HasIcmpType (TF.Resource p s) a where
    icmpType = TF.configuration . icmpType

class HasIdentifier s a | s -> a where
    identifier :: Lens' s (TF.Argument "identifier" a)

instance HasIdentifier s a => HasIdentifier (TF.Resource p s) a where
    identifier = TF.configuration . identifier

class HasIdentifierPrefix s a | s -> a where
    identifierPrefix :: Lens' s (TF.Argument "identifier_prefix" a)

instance HasIdentifierPrefix s a => HasIdentifierPrefix (TF.Resource p s) a where
    identifierPrefix = TF.configuration . identifierPrefix

class HasIdentityPoolId s a | s -> a where
    identityPoolId :: Lens' s (TF.Argument "identity_pool_id" a)

instance HasIdentityPoolId s a => HasIdentityPoolId (TF.Resource p s) a where
    identityPoolId = TF.configuration . identityPoolId

class HasIdentityPoolName s a | s -> a where
    identityPoolName :: Lens' s (TF.Argument "identity_pool_name" a)

instance HasIdentityPoolName s a => HasIdentityPoolName (TF.Resource p s) a where
    identityPoolName = TF.configuration . identityPoolName

class HasIdentitySource s a | s -> a where
    identitySource :: Lens' s (TF.Argument "identity_source" a)

instance HasIdentitySource s a => HasIdentitySource (TF.Resource p s) a where
    identitySource = TF.configuration . identitySource

class HasIdentityValidationExpression s a | s -> a where
    identityValidationExpression :: Lens' s (TF.Argument "identity_validation_expression" a)

instance HasIdentityValidationExpression s a => HasIdentityValidationExpression (TF.Resource p s) a where
    identityValidationExpression = TF.configuration . identityValidationExpression

class HasIdleTimeout s a | s -> a where
    idleTimeout :: Lens' s (TF.Argument "idle_timeout" a)

instance HasIdleTimeout s a => HasIdleTimeout (TF.Resource p s) a where
    idleTimeout = TF.configuration . idleTimeout

class HasImageId s a | s -> a where
    imageId :: Lens' s (TF.Argument "image_id" a)

instance HasImageId s a => HasImageId (TF.Resource p s) a where
    imageId = TF.configuration . imageId

class HasIncludeGlobalServiceEvents s a | s -> a where
    includeGlobalServiceEvents :: Lens' s (TF.Argument "include_global_service_events" a)

instance HasIncludeGlobalServiceEvents s a => HasIncludeGlobalServiceEvents (TF.Resource p s) a where
    includeGlobalServiceEvents = TF.configuration . includeGlobalServiceEvents

class HasIngress s a | s -> a where
    ingress :: Lens' s (TF.Argument "ingress" a)

instance HasIngress s a => HasIngress (TF.Resource p s) a where
    ingress = TF.configuration . ingress

class HasInitialLifecycleHook s a | s -> a where
    initialLifecycleHook :: Lens' s (TF.Argument "initial_lifecycle_hook" a)

instance HasInitialLifecycleHook s a => HasInitialLifecycleHook (TF.Resource p s) a where
    initialLifecycleHook = TF.configuration . initialLifecycleHook

class HasInput s a | s -> a where
    input :: Lens' s (TF.Argument "input" a)

instance HasInput s a => HasInput (TF.Resource p s) a where
    input = TF.configuration . input

class HasInputBucket s a | s -> a where
    inputBucket :: Lens' s (TF.Argument "input_bucket" a)

instance HasInputBucket s a => HasInputBucket (TF.Resource p s) a where
    inputBucket = TF.configuration . inputBucket

class HasInputParameters s a | s -> a where
    inputParameters :: Lens' s (TF.Argument "input_parameters" a)

instance HasInputParameters s a => HasInputParameters (TF.Resource p s) a where
    inputParameters = TF.configuration . inputParameters

class HasInputPath s a | s -> a where
    inputPath :: Lens' s (TF.Argument "input_path" a)

instance HasInputPath s a => HasInputPath (TF.Resource p s) a where
    inputPath = TF.configuration . inputPath

class HasInputTransformer s a | s -> a where
    inputTransformer :: Lens' s (TF.Argument "input_transformer" a)

instance HasInputTransformer s a => HasInputTransformer (TF.Resource p s) a where
    inputTransformer = TF.configuration . inputTransformer

class HasInstallUpdatesOnBoot s a | s -> a where
    installUpdatesOnBoot :: Lens' s (TF.Argument "install_updates_on_boot" a)

instance HasInstallUpdatesOnBoot s a => HasInstallUpdatesOnBoot (TF.Resource p s) a where
    installUpdatesOnBoot = TF.configuration . installUpdatesOnBoot

class HasInstance' s a | s -> a where
    instance' :: Lens' s (TF.Argument "instance" a)

instance HasInstance' s a => HasInstance' (TF.Resource p s) a where
    instance' = TF.configuration . instance'

class HasInstanceClass s a | s -> a where
    instanceClass :: Lens' s (TF.Argument "instance_class" a)

instance HasInstanceClass s a => HasInstanceClass (TF.Resource p s) a where
    instanceClass = TF.configuration . instanceClass

class HasInstanceCount s a | s -> a where
    instanceCount :: Lens' s (TF.Argument "instance_count" a)

instance HasInstanceCount s a => HasInstanceCount (TF.Resource p s) a where
    instanceCount = TF.configuration . instanceCount

class HasInstanceGroup s a | s -> a where
    instanceGroup :: Lens' s (TF.Argument "instance_group" a)

instance HasInstanceGroup s a => HasInstanceGroup (TF.Resource p s) a where
    instanceGroup = TF.configuration . instanceGroup

class HasInstanceId s a | s -> a where
    instanceId :: Lens' s (TF.Argument "instance_id" a)

instance HasInstanceId s a => HasInstanceId (TF.Resource p s) a where
    instanceId = TF.configuration . instanceId

class HasInstanceInitiatedShutdownBehavior s a | s -> a where
    instanceInitiatedShutdownBehavior :: Lens' s (TF.Argument "instance_initiated_shutdown_behavior" a)

instance HasInstanceInitiatedShutdownBehavior s a => HasInstanceInitiatedShutdownBehavior (TF.Resource p s) a where
    instanceInitiatedShutdownBehavior = TF.configuration . instanceInitiatedShutdownBehavior

class HasInstanceInterruptionBehavior s a | s -> a where
    instanceInterruptionBehavior :: Lens' s (TF.Argument "instance_interruption_behavior" a)

instance HasInstanceInterruptionBehavior s a => HasInstanceInterruptionBehavior (TF.Resource p s) a where
    instanceInterruptionBehavior = TF.configuration . instanceInterruptionBehavior

class HasInstanceName s a | s -> a where
    instanceName :: Lens' s (TF.Argument "instance_name" a)

instance HasInstanceName s a => HasInstanceName (TF.Resource p s) a where
    instanceName = TF.configuration . instanceName

class HasInstancePort s a | s -> a where
    instancePort :: Lens' s (TF.Argument "instance_port" a)

instance HasInstancePort s a => HasInstancePort (TF.Resource p s) a where
    instancePort = TF.configuration . instancePort

class HasInstancePorts s a | s -> a where
    instancePorts :: Lens' s (TF.Argument "instance_ports" a)

instance HasInstancePorts s a => HasInstancePorts (TF.Resource p s) a where
    instancePorts = TF.configuration . instancePorts

class HasInstanceShutdownTimeout s a | s -> a where
    instanceShutdownTimeout :: Lens' s (TF.Argument "instance_shutdown_timeout" a)

instance HasInstanceShutdownTimeout s a => HasInstanceShutdownTimeout (TF.Resource p s) a where
    instanceShutdownTimeout = TF.configuration . instanceShutdownTimeout

class HasInstanceTenancy s a | s -> a where
    instanceTenancy :: Lens' s (TF.Argument "instance_tenancy" a)

instance HasInstanceTenancy s a => HasInstanceTenancy (TF.Resource p s) a where
    instanceTenancy = TF.configuration . instanceTenancy

class HasInstanceType s a | s -> a where
    instanceType :: Lens' s (TF.Argument "instance_type" a)

instance HasInstanceType s a => HasInstanceType (TF.Resource p s) a where
    instanceType = TF.configuration . instanceType

class HasInstances s a | s -> a where
    instances :: Lens' s (TF.Argument "instances" a)

instance HasInstances s a => HasInstances (TF.Resource p s) a where
    instances = TF.configuration . instances

class HasInsufficientDataActions s a | s -> a where
    insufficientDataActions :: Lens' s (TF.Argument "insufficient_data_actions" a)

instance HasInsufficientDataActions s a => HasInsufficientDataActions (TF.Resource p s) a where
    insufficientDataActions = TF.configuration . insufficientDataActions

class HasInsufficientDataHealthStatus s a | s -> a where
    insufficientDataHealthStatus :: Lens' s (TF.Argument "insufficient_data_health_status" a)

instance HasInsufficientDataHealthStatus s a => HasInsufficientDataHealthStatus (TF.Resource p s) a where
    insufficientDataHealthStatus = TF.configuration . insufficientDataHealthStatus

class HasIntegrationHttpMethod s a | s -> a where
    integrationHttpMethod :: Lens' s (TF.Argument "integration_http_method" a)

instance HasIntegrationHttpMethod s a => HasIntegrationHttpMethod (TF.Resource p s) a where
    integrationHttpMethod = TF.configuration . integrationHttpMethod

class HasInternal s a | s -> a where
    internal :: Lens' s (TF.Argument "internal" a)

instance HasInternal s a => HasInternal (TF.Resource p s) a where
    internal = TF.configuration . internal

class HasInvertHealthcheck s a | s -> a where
    invertHealthcheck :: Lens' s (TF.Argument "invert_healthcheck" a)

instance HasInvertHealthcheck s a => HasInvertHealthcheck (TF.Resource p s) a where
    invertHealthcheck = TF.configuration . invertHealthcheck

class HasIops s a | s -> a where
    iops :: Lens' s (TF.Argument "iops" a)

instance HasIops s a => HasIops (TF.Resource p s) a where
    iops = TF.configuration . iops

class HasIpAddress s a | s -> a where
    ipAddress :: Lens' s (TF.Argument "ip_address" a)

instance HasIpAddress s a => HasIpAddress (TF.Resource p s) a where
    ipAddress = TF.configuration . ipAddress

class HasIpAddressType s a | s -> a where
    ipAddressType :: Lens' s (TF.Argument "ip_address_type" a)

instance HasIpAddressType s a => HasIpAddressType (TF.Resource p s) a where
    ipAddressType = TF.configuration . ipAddressType

class HasIpSetDescriptor s a | s -> a where
    ipSetDescriptor :: Lens' s (TF.Argument "ip_set_descriptor" a)

instance HasIpSetDescriptor s a => HasIpSetDescriptor (TF.Resource p s) a where
    ipSetDescriptor = TF.configuration . ipSetDescriptor

class HasIpSetDescriptors s a | s -> a where
    ipSetDescriptors :: Lens' s (TF.Argument "ip_set_descriptors" a)

instance HasIpSetDescriptors s a => HasIpSetDescriptors (TF.Resource p s) a where
    ipSetDescriptors = TF.configuration . ipSetDescriptors

class HasIpv6AddressCount s a | s -> a where
    ipv6AddressCount :: Lens' s (TF.Argument "ipv6_address_count" a)

instance HasIpv6AddressCount s a => HasIpv6AddressCount (TF.Resource p s) a where
    ipv6AddressCount = TF.configuration . ipv6AddressCount

class HasIpv6Addresses s a | s -> a where
    ipv6Addresses :: Lens' s (TF.Argument "ipv6_addresses" a)

instance HasIpv6Addresses s a => HasIpv6Addresses (TF.Resource p s) a where
    ipv6Addresses = TF.configuration . ipv6Addresses

class HasIpv6CidrBlock s a | s -> a where
    ipv6CidrBlock :: Lens' s (TF.Argument "ipv6_cidr_block" a)

instance HasIpv6CidrBlock s a => HasIpv6CidrBlock (TF.Resource p s) a where
    ipv6CidrBlock = TF.configuration . ipv6CidrBlock

class HasIpv6CidrBlocks s a | s -> a where
    ipv6CidrBlocks :: Lens' s (TF.Argument "ipv6_cidr_blocks" a)

instance HasIpv6CidrBlocks s a => HasIpv6CidrBlocks (TF.Resource p s) a where
    ipv6CidrBlocks = TF.configuration . ipv6CidrBlocks

class HasIsEnabled s a | s -> a where
    isEnabled :: Lens' s (TF.Argument "is_enabled" a)

instance HasIsEnabled s a => HasIsEnabled (TF.Resource p s) a where
    isEnabled = TF.configuration . isEnabled

class HasIsIpv6Enabled s a | s -> a where
    isIpv6Enabled :: Lens' s (TF.Argument "is_ipv6_enabled" a)

instance HasIsIpv6Enabled s a => HasIsIpv6Enabled (TF.Resource p s) a where
    isIpv6Enabled = TF.configuration . isIpv6Enabled

class HasIsMultiRegionTrail s a | s -> a where
    isMultiRegionTrail :: Lens' s (TF.Argument "is_multi_region_trail" a)

instance HasIsMultiRegionTrail s a => HasIsMultiRegionTrail (TF.Resource p s) a where
    isMultiRegionTrail = TF.configuration . isMultiRegionTrail

class HasJvmOptions s a | s -> a where
    jvmOptions :: Lens' s (TF.Argument "jvm_options" a)

instance HasJvmOptions s a => HasJvmOptions (TF.Resource p s) a where
    jvmOptions = TF.configuration . jvmOptions

class HasJvmType s a | s -> a where
    jvmType :: Lens' s (TF.Argument "jvm_type" a)

instance HasJvmType s a => HasJvmType (TF.Resource p s) a where
    jvmType = TF.configuration . jvmType

class HasJvmVersion s a | s -> a where
    jvmVersion :: Lens' s (TF.Argument "jvm_version" a)

instance HasJvmVersion s a => HasJvmVersion (TF.Resource p s) a where
    jvmVersion = TF.configuration . jvmVersion

class HasKeepJobFlowAliveWhenNoSteps s a | s -> a where
    keepJobFlowAliveWhenNoSteps :: Lens' s (TF.Argument "keep_job_flow_alive_when_no_steps" a)

instance HasKeepJobFlowAliveWhenNoSteps s a => HasKeepJobFlowAliveWhenNoSteps (TF.Resource p s) a where
    keepJobFlowAliveWhenNoSteps = TF.configuration . keepJobFlowAliveWhenNoSteps

class HasKey s a | s -> a where
    key :: Lens' s (TF.Argument "key" a)

instance HasKey s a => HasKey (TF.Resource p s) a where
    key = TF.configuration . key

class HasKeyId s a | s -> a where
    keyId :: Lens' s (TF.Argument "key_id" a)

instance HasKeyId s a => HasKeyId (TF.Resource p s) a where
    keyId = TF.configuration . keyId

class HasKeyName s a | s -> a where
    keyName :: Lens' s (TF.Argument "key_name" a)

instance HasKeyName s a => HasKeyName (TF.Resource p s) a where
    keyName = TF.configuration . keyName

class HasKeyNamePrefix s a | s -> a where
    keyNamePrefix :: Lens' s (TF.Argument "key_name_prefix" a)

instance HasKeyNamePrefix s a => HasKeyNamePrefix (TF.Resource p s) a where
    keyNamePrefix = TF.configuration . keyNamePrefix

class HasKeyPairName s a | s -> a where
    keyPairName :: Lens' s (TF.Argument "key_pair_name" a)

instance HasKeyPairName s a => HasKeyPairName (TF.Resource p s) a where
    keyPairName = TF.configuration . keyPairName

class HasKeyType s a | s -> a where
    keyType :: Lens' s (TF.Argument "key_type" a)

instance HasKeyType s a => HasKeyType (TF.Resource p s) a where
    keyType = TF.configuration . keyType

class HasKeyUsage s a | s -> a where
    keyUsage :: Lens' s (TF.Argument "key_usage" a)

instance HasKeyUsage s a => HasKeyUsage (TF.Resource p s) a where
    keyUsage = TF.configuration . keyUsage

class HasKinesisDestination s a | s -> a where
    kinesisDestination :: Lens' s (TF.Argument "kinesis_destination" a)

instance HasKinesisDestination s a => HasKinesisDestination (TF.Resource p s) a where
    kinesisDestination = TF.configuration . kinesisDestination

class HasKinesisSourceConfiguration s a | s -> a where
    kinesisSourceConfiguration :: Lens' s (TF.Argument "kinesis_source_configuration" a)

instance HasKinesisSourceConfiguration s a => HasKinesisSourceConfiguration (TF.Resource p s) a where
    kinesisSourceConfiguration = TF.configuration . kinesisSourceConfiguration

class HasKmsDataKeyReusePeriodSeconds s a | s -> a where
    kmsDataKeyReusePeriodSeconds :: Lens' s (TF.Argument "kms_data_key_reuse_period_seconds" a)

instance HasKmsDataKeyReusePeriodSeconds s a => HasKmsDataKeyReusePeriodSeconds (TF.Resource p s) a where
    kmsDataKeyReusePeriodSeconds = TF.configuration . kmsDataKeyReusePeriodSeconds

class HasKmsKeyArn s a | s -> a where
    kmsKeyArn :: Lens' s (TF.Argument "kms_key_arn" a)

instance HasKmsKeyArn s a => HasKmsKeyArn (TF.Resource p s) a where
    kmsKeyArn = TF.configuration . kmsKeyArn

class HasKmsKeyId s a | s -> a where
    kmsKeyId :: Lens' s (TF.Argument "kms_key_id" a)

instance HasKmsKeyId s a => HasKmsKeyId (TF.Resource p s) a where
    kmsKeyId = TF.configuration . kmsKeyId

class HasKmsMasterKeyId s a | s -> a where
    kmsMasterKeyId :: Lens' s (TF.Argument "kms_master_key_id" a)

instance HasKmsMasterKeyId s a => HasKmsMasterKeyId (TF.Resource p s) a where
    kmsMasterKeyId = TF.configuration . kmsMasterKeyId

class HasLagId s a | s -> a where
    lagId :: Lens' s (TF.Argument "lag_id" a)

instance HasLagId s a => HasLagId (TF.Resource p s) a where
    lagId = TF.configuration . lagId

class HasLambdaAction s a | s -> a where
    lambdaAction :: Lens' s (TF.Argument "lambda_action" a)

instance HasLambdaAction s a => HasLambdaAction (TF.Resource p s) a where
    lambdaAction = TF.configuration . lambdaAction

class HasLambdaConfig s a | s -> a where
    lambdaConfig :: Lens' s (TF.Argument "lambda_config" a)

instance HasLambdaConfig s a => HasLambdaConfig (TF.Resource p s) a where
    lambdaConfig = TF.configuration . lambdaConfig

class HasLambdaFunction s a | s -> a where
    lambdaFunction :: Lens' s (TF.Argument "lambda_function" a)

instance HasLambdaFunction s a => HasLambdaFunction (TF.Resource p s) a where
    lambdaFunction = TF.configuration . lambdaFunction

class HasLatencyRoutingPolicy s a | s -> a where
    latencyRoutingPolicy :: Lens' s (TF.Argument "latency_routing_policy" a)

instance HasLatencyRoutingPolicy s a => HasLatencyRoutingPolicy (TF.Resource p s) a where
    latencyRoutingPolicy = TF.configuration . latencyRoutingPolicy

class HasLaunchConfiguration s a | s -> a where
    launchConfiguration :: Lens' s (TF.Argument "launch_configuration" a)

instance HasLaunchConfiguration s a => HasLaunchConfiguration (TF.Resource p s) a where
    launchConfiguration = TF.configuration . launchConfiguration

class HasLaunchGroup s a | s -> a where
    launchGroup :: Lens' s (TF.Argument "launch_group" a)

instance HasLaunchGroup s a => HasLaunchGroup (TF.Resource p s) a where
    launchGroup = TF.configuration . launchGroup

class HasLaunchSpecification s a | s -> a where
    launchSpecification :: Lens' s (TF.Argument "launch_specification" a)

instance HasLaunchSpecification s a => HasLaunchSpecification (TF.Resource p s) a where
    launchSpecification = TF.configuration . launchSpecification

class HasLaunchType s a | s -> a where
    launchType :: Lens' s (TF.Argument "launch_type" a)

instance HasLaunchType s a => HasLaunchType (TF.Resource p s) a where
    launchType = TF.configuration . launchType

class HasLayerIds s a | s -> a where
    layerIds :: Lens' s (TF.Argument "layer_ids" a)

instance HasLayerIds s a => HasLayerIds (TF.Resource p s) a where
    layerIds = TF.configuration . layerIds

class HasLbPort s a | s -> a where
    lbPort :: Lens' s (TF.Argument "lb_port" a)

instance HasLbPort s a => HasLbPort (TF.Resource p s) a where
    lbPort = TF.configuration . lbPort

class HasLevel s a | s -> a where
    level :: Lens' s (TF.Argument "level" a)

instance HasLevel s a => HasLevel (TF.Resource p s) a where
    level = TF.configuration . level

class HasLicenseModel s a | s -> a where
    licenseModel :: Lens' s (TF.Argument "license_model" a)

instance HasLicenseModel s a => HasLicenseModel (TF.Resource p s) a where
    licenseModel = TF.configuration . licenseModel

class HasLifecycleRule s a | s -> a where
    lifecycleRule :: Lens' s (TF.Argument "lifecycle_rule" a)

instance HasLifecycleRule s a => HasLifecycleRule (TF.Resource p s) a where
    lifecycleRule = TF.configuration . lifecycleRule

class HasLifecycleTransition s a | s -> a where
    lifecycleTransition :: Lens' s (TF.Argument "lifecycle_transition" a)

instance HasLifecycleTransition s a => HasLifecycleTransition (TF.Resource p s) a where
    lifecycleTransition = TF.configuration . lifecycleTransition

class HasListener s a | s -> a where
    listener :: Lens' s (TF.Argument "listener" a)

instance HasListener s a => HasListener (TF.Resource p s) a where
    listener = TF.configuration . listener

class HasListenerArn s a | s -> a where
    listenerArn :: Lens' s (TF.Argument "listener_arn" a)

instance HasListenerArn s a => HasListenerArn (TF.Resource p s) a where
    listenerArn = TF.configuration . listenerArn

class HasLoadBalancer s a | s -> a where
    loadBalancer :: Lens' s (TF.Argument "load_balancer" a)

instance HasLoadBalancer s a => HasLoadBalancer (TF.Resource p s) a where
    loadBalancer = TF.configuration . loadBalancer

class HasLoadBalancerArn s a | s -> a where
    loadBalancerArn :: Lens' s (TF.Argument "load_balancer_arn" a)

instance HasLoadBalancerArn s a => HasLoadBalancerArn (TF.Resource p s) a where
    loadBalancerArn = TF.configuration . loadBalancerArn

class HasLoadBalancerInfo s a | s -> a where
    loadBalancerInfo :: Lens' s (TF.Argument "load_balancer_info" a)

instance HasLoadBalancerInfo s a => HasLoadBalancerInfo (TF.Resource p s) a where
    loadBalancerInfo = TF.configuration . loadBalancerInfo

class HasLoadBalancerName s a | s -> a where
    loadBalancerName :: Lens' s (TF.Argument "load_balancer_name" a)

instance HasLoadBalancerName s a => HasLoadBalancerName (TF.Resource p s) a where
    loadBalancerName = TF.configuration . loadBalancerName

class HasLoadBalancerPort s a | s -> a where
    loadBalancerPort :: Lens' s (TF.Argument "load_balancer_port" a)

instance HasLoadBalancerPort s a => HasLoadBalancerPort (TF.Resource p s) a where
    loadBalancerPort = TF.configuration . loadBalancerPort

class HasLoadBalancerType s a | s -> a where
    loadBalancerType :: Lens' s (TF.Argument "load_balancer_type" a)

instance HasLoadBalancerType s a => HasLoadBalancerType (TF.Resource p s) a where
    loadBalancerType = TF.configuration . loadBalancerType

class HasLoadBalancers s a | s -> a where
    loadBalancers :: Lens' s (TF.Argument "load_balancers" a)

instance HasLoadBalancers s a => HasLoadBalancers (TF.Resource p s) a where
    loadBalancers = TF.configuration . loadBalancers

class HasLocalSecondaryIndex s a | s -> a where
    localSecondaryIndex :: Lens' s (TF.Argument "local_secondary_index" a)

instance HasLocalSecondaryIndex s a => HasLocalSecondaryIndex (TF.Resource p s) a where
    localSecondaryIndex = TF.configuration . localSecondaryIndex

class HasLocation s a | s -> a where
    location :: Lens' s (TF.Argument "location" a)

instance HasLocation s a => HasLocation (TF.Resource p s) a where
    location = TF.configuration . location

class HasLocationUri s a | s -> a where
    locationUri :: Lens' s (TF.Argument "location_uri" a)

instance HasLocationUri s a => HasLocationUri (TF.Resource p s) a where
    locationUri = TF.configuration . locationUri

class HasLogGroupName s a | s -> a where
    logGroupName :: Lens' s (TF.Argument "log_group_name" a)

instance HasLogGroupName s a => HasLogGroupName (TF.Resource p s) a where
    logGroupName = TF.configuration . logGroupName

class HasLogPublishingOptions s a | s -> a where
    logPublishingOptions :: Lens' s (TF.Argument "log_publishing_options" a)

instance HasLogPublishingOptions s a => HasLogPublishingOptions (TF.Resource p s) a where
    logPublishingOptions = TF.configuration . logPublishingOptions

class HasLogUri s a | s -> a where
    logUri :: Lens' s (TF.Argument "log_uri" a)

instance HasLogUri s a => HasLogUri (TF.Resource p s) a where
    logUri = TF.configuration . logUri

class HasLogging s a | s -> a where
    logging :: Lens' s (TF.Argument "logging" a)

instance HasLogging s a => HasLogging (TF.Resource p s) a where
    logging = TF.configuration . logging

class HasLoggingConfig s a | s -> a where
    loggingConfig :: Lens' s (TF.Argument "logging_config" a)

instance HasLoggingConfig s a => HasLoggingConfig (TF.Resource p s) a where
    loggingConfig = TF.configuration . loggingConfig

class HasLoggingInfo s a | s -> a where
    loggingInfo :: Lens' s (TF.Argument "logging_info" a)

instance HasLoggingInfo s a => HasLoggingInfo (TF.Resource p s) a where
    loggingInfo = TF.configuration . loggingInfo

class HasLogoutUrls s a | s -> a where
    logoutUrls :: Lens' s (TF.Argument "logout_urls" a)

instance HasLogoutUrls s a => HasLogoutUrls (TF.Resource p s) a where
    logoutUrls = TF.configuration . logoutUrls

class HasMaintenanceWindow s a | s -> a where
    maintenanceWindow :: Lens' s (TF.Argument "maintenance_window" a)

instance HasMaintenanceWindow s a => HasMaintenanceWindow (TF.Resource p s) a where
    maintenanceWindow = TF.configuration . maintenanceWindow

class HasMaintenanceWindowStartTime s a | s -> a where
    maintenanceWindowStartTime :: Lens' s (TF.Argument "maintenance_window_start_time" a)

instance HasMaintenanceWindowStartTime s a => HasMaintenanceWindowStartTime (TF.Resource p s) a where
    maintenanceWindowStartTime = TF.configuration . maintenanceWindowStartTime

class HasMajorEngineVersion s a | s -> a where
    majorEngineVersion :: Lens' s (TF.Argument "major_engine_version" a)

instance HasMajorEngineVersion s a => HasMajorEngineVersion (TF.Resource p s) a where
    majorEngineVersion = TF.configuration . majorEngineVersion

class HasManageBerkshelf s a | s -> a where
    manageBerkshelf :: Lens' s (TF.Argument "manage_berkshelf" a)

instance HasManageBerkshelf s a => HasManageBerkshelf (TF.Resource p s) a where
    manageBerkshelf = TF.configuration . manageBerkshelf

class HasManageBundler s a | s -> a where
    manageBundler :: Lens' s (TF.Argument "manage_bundler" a)

instance HasManageBundler s a => HasManageBundler (TF.Resource p s) a where
    manageBundler = TF.configuration . manageBundler

class HasMapPublicIpOnLaunch s a | s -> a where
    mapPublicIpOnLaunch :: Lens' s (TF.Argument "map_public_ip_on_launch" a)

instance HasMapPublicIpOnLaunch s a => HasMapPublicIpOnLaunch (TF.Resource p s) a where
    mapPublicIpOnLaunch = TF.configuration . mapPublicIpOnLaunch

class HasMasterInstanceType s a | s -> a where
    masterInstanceType :: Lens' s (TF.Argument "master_instance_type" a)

instance HasMasterInstanceType s a => HasMasterInstanceType (TF.Resource p s) a where
    masterInstanceType = TF.configuration . masterInstanceType

class HasMasterPassword s a | s -> a where
    masterPassword :: Lens' s (TF.Argument "master_password" a)

instance HasMasterPassword s a => HasMasterPassword (TF.Resource p s) a where
    masterPassword = TF.configuration . masterPassword

class HasMasterUsername s a | s -> a where
    masterUsername :: Lens' s (TF.Argument "master_username" a)

instance HasMasterUsername s a => HasMasterUsername (TF.Resource p s) a where
    masterUsername = TF.configuration . masterUsername

class HasMatchingTypes s a | s -> a where
    matchingTypes :: Lens' s (TF.Argument "matching_types" a)

instance HasMatchingTypes s a => HasMatchingTypes (TF.Resource p s) a where
    matchingTypes = TF.configuration . matchingTypes

class HasMaxCapacity s a | s -> a where
    maxCapacity :: Lens' s (TF.Argument "max_capacity" a)

instance HasMaxCapacity s a => HasMaxCapacity (TF.Resource p s) a where
    maxCapacity = TF.configuration . maxCapacity

class HasMaxConcurrency s a | s -> a where
    maxConcurrency :: Lens' s (TF.Argument "max_concurrency" a)

instance HasMaxConcurrency s a => HasMaxConcurrency (TF.Resource p s) a where
    maxConcurrency = TF.configuration . maxConcurrency

class HasMaxErrors s a | s -> a where
    maxErrors :: Lens' s (TF.Argument "max_errors" a)

instance HasMaxErrors s a => HasMaxErrors (TF.Resource p s) a where
    maxErrors = TF.configuration . maxErrors

class HasMaxMessageSize s a | s -> a where
    maxMessageSize :: Lens' s (TF.Argument "max_message_size" a)

instance HasMaxMessageSize s a => HasMaxMessageSize (TF.Resource p s) a where
    maxMessageSize = TF.configuration . maxMessageSize

class HasMaxPasswordAge s a | s -> a where
    maxPasswordAge :: Lens' s (TF.Argument "max_password_age" a)

instance HasMaxPasswordAge s a => HasMaxPasswordAge (TF.Resource p s) a where
    maxPasswordAge = TF.configuration . maxPasswordAge

class HasMaxSize s a | s -> a where
    maxSize :: Lens' s (TF.Argument "max_size" a)

instance HasMaxSize s a => HasMaxSize (TF.Resource p s) a where
    maxSize = TF.configuration . maxSize

class HasMaximumExecutionFrequency s a | s -> a where
    maximumExecutionFrequency :: Lens' s (TF.Argument "maximum_execution_frequency" a)

instance HasMaximumExecutionFrequency s a => HasMaximumExecutionFrequency (TF.Resource p s) a where
    maximumExecutionFrequency = TF.configuration . maximumExecutionFrequency

class HasMeasureLatency s a | s -> a where
    measureLatency :: Lens' s (TF.Argument "measure_latency" a)

instance HasMeasureLatency s a => HasMeasureLatency (TF.Resource p s) a where
    measureLatency = TF.configuration . measureLatency

class HasMemorySize s a | s -> a where
    memorySize :: Lens' s (TF.Argument "memory_size" a)

instance HasMemorySize s a => HasMemorySize (TF.Resource p s) a where
    memorySize = TF.configuration . memorySize

class HasMessageRetentionSeconds s a | s -> a where
    messageRetentionSeconds :: Lens' s (TF.Argument "message_retention_seconds" a)

instance HasMessageRetentionSeconds s a => HasMessageRetentionSeconds (TF.Resource p s) a where
    messageRetentionSeconds = TF.configuration . messageRetentionSeconds

class HasMethodPath s a | s -> a where
    methodPath :: Lens' s (TF.Argument "method_path" a)

instance HasMethodPath s a => HasMethodPath (TF.Resource p s) a where
    methodPath = TF.configuration . methodPath

class HasMetricName s a | s -> a where
    metricName :: Lens' s (TF.Argument "metric_name" a)

instance HasMetricName s a => HasMetricName (TF.Resource p s) a where
    metricName = TF.configuration . metricName

class HasMetricTransformation s a | s -> a where
    metricTransformation :: Lens' s (TF.Argument "metric_transformation" a)

instance HasMetricTransformation s a => HasMetricTransformation (TF.Resource p s) a where
    metricTransformation = TF.configuration . metricTransformation

class HasMetricsGranularity s a | s -> a where
    metricsGranularity :: Lens' s (TF.Argument "metrics_granularity" a)

instance HasMetricsGranularity s a => HasMetricsGranularity (TF.Resource p s) a where
    metricsGranularity = TF.configuration . metricsGranularity

class HasMfaConfiguration s a | s -> a where
    mfaConfiguration :: Lens' s (TF.Argument "mfa_configuration" a)

instance HasMfaConfiguration s a => HasMfaConfiguration (TF.Resource p s) a where
    mfaConfiguration = TF.configuration . mfaConfiguration

class HasMigrationType s a | s -> a where
    migrationType :: Lens' s (TF.Argument "migration_type" a)

instance HasMigrationType s a => HasMigrationType (TF.Resource p s) a where
    migrationType = TF.configuration . migrationType

class HasMinCapacity s a | s -> a where
    minCapacity :: Lens' s (TF.Argument "min_capacity" a)

instance HasMinCapacity s a => HasMinCapacity (TF.Resource p s) a where
    minCapacity = TF.configuration . minCapacity

class HasMinElbCapacity s a | s -> a where
    minElbCapacity :: Lens' s (TF.Argument "min_elb_capacity" a)

instance HasMinElbCapacity s a => HasMinElbCapacity (TF.Resource p s) a where
    minElbCapacity = TF.configuration . minElbCapacity

class HasMinSize s a | s -> a where
    minSize :: Lens' s (TF.Argument "min_size" a)

instance HasMinSize s a => HasMinSize (TF.Resource p s) a where
    minSize = TF.configuration . minSize

class HasMinimumHealthyHosts s a | s -> a where
    minimumHealthyHosts :: Lens' s (TF.Argument "minimum_healthy_hosts" a)

instance HasMinimumHealthyHosts s a => HasMinimumHealthyHosts (TF.Resource p s) a where
    minimumHealthyHosts = TF.configuration . minimumHealthyHosts

class HasMinimumPasswordLength s a | s -> a where
    minimumPasswordLength :: Lens' s (TF.Argument "minimum_password_length" a)

instance HasMinimumPasswordLength s a => HasMinimumPasswordLength (TF.Resource p s) a where
    minimumPasswordLength = TF.configuration . minimumPasswordLength

class HasMonitoring s a | s -> a where
    monitoring :: Lens' s (TF.Argument "monitoring" a)

instance HasMonitoring s a => HasMonitoring (TF.Resource p s) a where
    monitoring = TF.configuration . monitoring

class HasMonitoringInterval s a | s -> a where
    monitoringInterval :: Lens' s (TF.Argument "monitoring_interval" a)

instance HasMonitoringInterval s a => HasMonitoringInterval (TF.Resource p s) a where
    monitoringInterval = TF.configuration . monitoringInterval

class HasMonitoringRoleArn s a | s -> a where
    monitoringRoleArn :: Lens' s (TF.Argument "monitoring_role_arn" a)

instance HasMonitoringRoleArn s a => HasMonitoringRoleArn (TF.Resource p s) a where
    monitoringRoleArn = TF.configuration . monitoringRoleArn

class HasMultiAz s a | s -> a where
    multiAz :: Lens' s (TF.Argument "multi_az" a)

instance HasMultiAz s a => HasMultiAz (TF.Resource p s) a where
    multiAz = TF.configuration . multiAz

class HasMultivalueAnswerRoutingPolicy s a | s -> a where
    multivalueAnswerRoutingPolicy :: Lens' s (TF.Argument "multivalue_answer_routing_policy" a)

instance HasMultivalueAnswerRoutingPolicy s a => HasMultivalueAnswerRoutingPolicy (TF.Resource p s) a where
    multivalueAnswerRoutingPolicy = TF.configuration . multivalueAnswerRoutingPolicy

class HasName s a | s -> a where
    name :: Lens' s (TF.Argument "name" a)

instance HasName s a => HasName (TF.Resource p s) a where
    name = TF.configuration . name

class HasNamePrefix s a | s -> a where
    namePrefix :: Lens' s (TF.Argument "name_prefix" a)

instance HasNamePrefix s a => HasNamePrefix (TF.Resource p s) a where
    namePrefix = TF.configuration . namePrefix

class HasNamespace s a | s -> a where
    namespace :: Lens' s (TF.Argument "namespace" a)

instance HasNamespace s a => HasNamespace (TF.Resource p s) a where
    namespace = TF.configuration . namespace

class HasNatGatewayId s a | s -> a where
    natGatewayId :: Lens' s (TF.Argument "nat_gateway_id" a)

instance HasNatGatewayId s a => HasNatGatewayId (TF.Resource p s) a where
    natGatewayId = TF.configuration . natGatewayId

class HasNetbiosNameServers s a | s -> a where
    netbiosNameServers :: Lens' s (TF.Argument "netbios_name_servers" a)

instance HasNetbiosNameServers s a => HasNetbiosNameServers (TF.Resource p s) a where
    netbiosNameServers = TF.configuration . netbiosNameServers

class HasNetbiosNodeType s a | s -> a where
    netbiosNodeType :: Lens' s (TF.Argument "netbios_node_type" a)

instance HasNetbiosNodeType s a => HasNetbiosNodeType (TF.Resource p s) a where
    netbiosNodeType = TF.configuration . netbiosNodeType

class HasNetworkAclId s a | s -> a where
    networkAclId :: Lens' s (TF.Argument "network_acl_id" a)

instance HasNetworkAclId s a => HasNetworkAclId (TF.Resource p s) a where
    networkAclId = TF.configuration . networkAclId

class HasNetworkConfiguration s a | s -> a where
    networkConfiguration :: Lens' s (TF.Argument "network_configuration" a)

instance HasNetworkConfiguration s a => HasNetworkConfiguration (TF.Resource p s) a where
    networkConfiguration = TF.configuration . networkConfiguration

class HasNetworkInterface s a | s -> a where
    networkInterface :: Lens' s (TF.Argument "network_interface" a)

instance HasNetworkInterface s a => HasNetworkInterface (TF.Resource p s) a where
    networkInterface = TF.configuration . networkInterface

class HasNetworkInterfaceId s a | s -> a where
    networkInterfaceId :: Lens' s (TF.Argument "network_interface_id" a)

instance HasNetworkInterfaceId s a => HasNetworkInterfaceId (TF.Resource p s) a where
    networkInterfaceId = TF.configuration . networkInterfaceId

class HasNodeType s a | s -> a where
    nodeType :: Lens' s (TF.Argument "node_type" a)

instance HasNodeType s a => HasNodeType (TF.Resource p s) a where
    nodeType = TF.configuration . nodeType

class HasNodejsVersion s a | s -> a where
    nodejsVersion :: Lens' s (TF.Argument "nodejs_version" a)

instance HasNodejsVersion s a => HasNodejsVersion (TF.Resource p s) a where
    nodejsVersion = TF.configuration . nodejsVersion

class HasNotification s a | s -> a where
    notification :: Lens' s (TF.Argument "notification" a)

instance HasNotification s a => HasNotification (TF.Resource p s) a where
    notification = TF.configuration . notification

class HasNotificationArns s a | s -> a where
    notificationArns :: Lens' s (TF.Argument "notification_arns" a)

instance HasNotificationArns s a => HasNotificationArns (TF.Resource p s) a where
    notificationArns = TF.configuration . notificationArns

class HasNotificationMetadata s a | s -> a where
    notificationMetadata :: Lens' s (TF.Argument "notification_metadata" a)

instance HasNotificationMetadata s a => HasNotificationMetadata (TF.Resource p s) a where
    notificationMetadata = TF.configuration . notificationMetadata

class HasNotificationTargetArn s a | s -> a where
    notificationTargetArn :: Lens' s (TF.Argument "notification_target_arn" a)

instance HasNotificationTargetArn s a => HasNotificationTargetArn (TF.Resource p s) a where
    notificationTargetArn = TF.configuration . notificationTargetArn

class HasNotificationTopicArn s a | s -> a where
    notificationTopicArn :: Lens' s (TF.Argument "notification_topic_arn" a)

instance HasNotificationTopicArn s a => HasNotificationTopicArn (TF.Resource p s) a where
    notificationTopicArn = TF.configuration . notificationTopicArn

class HasNotifications s a | s -> a where
    notifications :: Lens' s (TF.Argument "notifications" a)

instance HasNotifications s a => HasNotifications (TF.Resource p s) a where
    notifications = TF.configuration . notifications

class HasNtpServers s a | s -> a where
    ntpServers :: Lens' s (TF.Argument "ntp_servers" a)

instance HasNtpServers s a => HasNtpServers (TF.Resource p s) a where
    ntpServers = TF.configuration . ntpServers

class HasNumCacheNodes s a | s -> a where
    numCacheNodes :: Lens' s (TF.Argument "num_cache_nodes" a)

instance HasNumCacheNodes s a => HasNumCacheNodes (TF.Resource p s) a where
    numCacheNodes = TF.configuration . numCacheNodes

class HasNumberCacheClusters s a | s -> a where
    numberCacheClusters :: Lens' s (TF.Argument "number_cache_clusters" a)

instance HasNumberCacheClusters s a => HasNumberCacheClusters (TF.Resource p s) a where
    numberCacheClusters = TF.configuration . numberCacheClusters

class HasNumberOfConnections s a | s -> a where
    numberOfConnections :: Lens' s (TF.Argument "number_of_connections" a)

instance HasNumberOfConnections s a => HasNumberOfConnections (TF.Resource p s) a where
    numberOfConnections = TF.configuration . numberOfConnections

class HasNumberOfNodes s a | s -> a where
    numberOfNodes :: Lens' s (TF.Argument "number_of_nodes" a)

instance HasNumberOfNodes s a => HasNumberOfNodes (TF.Resource p s) a where
    numberOfNodes = TF.configuration . numberOfNodes

class HasOkActions s a | s -> a where
    okActions :: Lens' s (TF.Argument "ok_actions" a)

instance HasOkActions s a => HasOkActions (TF.Resource p s) a where
    okActions = TF.configuration . okActions

class HasOnFailure s a | s -> a where
    onFailure :: Lens' s (TF.Argument "on_failure" a)

instance HasOnFailure s a => HasOnFailure (TF.Resource p s) a where
    onFailure = TF.configuration . onFailure

class HasOnPremisesInstanceTagFilter s a | s -> a where
    onPremisesInstanceTagFilter :: Lens' s (TF.Argument "on_premises_instance_tag_filter" a)

instance HasOnPremisesInstanceTagFilter s a => HasOnPremisesInstanceTagFilter (TF.Resource p s) a where
    onPremisesInstanceTagFilter = TF.configuration . onPremisesInstanceTagFilter

class HasOpenidConnectProviderArns s a | s -> a where
    openidConnectProviderArns :: Lens' s (TF.Argument "openid_connect_provider_arns" a)

instance HasOpenidConnectProviderArns s a => HasOpenidConnectProviderArns (TF.Resource p s) a where
    openidConnectProviderArns = TF.configuration . openidConnectProviderArns

class HasOperatingSystem s a | s -> a where
    operatingSystem :: Lens' s (TF.Argument "operating_system" a)

instance HasOperatingSystem s a => HasOperatingSystem (TF.Resource p s) a where
    operatingSystem = TF.configuration . operatingSystem

class HasOption s a | s -> a where
    option :: Lens' s (TF.Argument "option" a)

instance HasOption s a => HasOption (TF.Resource p s) a where
    option = TF.configuration . option

class HasOptionGroupDescription s a | s -> a where
    optionGroupDescription :: Lens' s (TF.Argument "option_group_description" a)

instance HasOptionGroupDescription s a => HasOptionGroupDescription (TF.Resource p s) a where
    optionGroupDescription = TF.configuration . optionGroupDescription

class HasOptionGroupName s a | s -> a where
    optionGroupName :: Lens' s (TF.Argument "option_group_name" a)

instance HasOptionGroupName s a => HasOptionGroupName (TF.Resource p s) a where
    optionGroupName = TF.configuration . optionGroupName

class HasOrigin s a | s -> a where
    origin :: Lens' s (TF.Argument "origin" a)

instance HasOrigin s a => HasOrigin (TF.Resource p s) a where
    origin = TF.configuration . origin

class HasOs s a | s -> a where
    os :: Lens' s (TF.Argument "os" a)

instance HasOs s a => HasOs (TF.Resource p s) a where
    os = TF.configuration . os

class HasOutputBucket s a | s -> a where
    outputBucket :: Lens' s (TF.Argument "output_bucket" a)

instance HasOutputBucket s a => HasOutputBucket (TF.Resource p s) a where
    outputBucket = TF.configuration . outputBucket

class HasOutputLocation s a | s -> a where
    outputLocation :: Lens' s (TF.Argument "output_location" a)

instance HasOutputLocation s a => HasOutputLocation (TF.Resource p s) a where
    outputLocation = TF.configuration . outputLocation

class HasOverwrite s a | s -> a where
    overwrite :: Lens' s (TF.Argument "overwrite" a)

instance HasOverwrite s a => HasOverwrite (TF.Resource p s) a where
    overwrite = TF.configuration . overwrite

class HasOwnerAccount s a | s -> a where
    ownerAccount :: Lens' s (TF.Argument "owner_account" a)

instance HasOwnerAccount s a => HasOwnerAccount (TF.Resource p s) a where
    ownerAccount = TF.configuration . ownerAccount

class HasOwnerInformation s a | s -> a where
    ownerInformation :: Lens' s (TF.Argument "owner_information" a)

instance HasOwnerInformation s a => HasOwnerInformation (TF.Resource p s) a where
    ownerInformation = TF.configuration . ownerInformation

class HasParameter s a | s -> a where
    parameter :: Lens' s (TF.Argument "parameter" a)

instance HasParameter s a => HasParameter (TF.Resource p s) a where
    parameter = TF.configuration . parameter

class HasParameterGroupName s a | s -> a where
    parameterGroupName :: Lens' s (TF.Argument "parameter_group_name" a)

instance HasParameterGroupName s a => HasParameterGroupName (TF.Resource p s) a where
    parameterGroupName = TF.configuration . parameterGroupName

class HasParameters s a | s -> a where
    parameters :: Lens' s (TF.Argument "parameters" a)

instance HasParameters s a => HasParameters (TF.Resource p s) a where
    parameters = TF.configuration . parameters

class HasParentId s a | s -> a where
    parentId :: Lens' s (TF.Argument "parent_id" a)

instance HasParentId s a => HasParentId (TF.Resource p s) a where
    parentId = TF.configuration . parentId

class HasPassengerVersion s a | s -> a where
    passengerVersion :: Lens' s (TF.Argument "passenger_version" a)

instance HasPassengerVersion s a => HasPassengerVersion (TF.Resource p s) a where
    passengerVersion = TF.configuration . passengerVersion

class HasPassthroughBehavior s a | s -> a where
    passthroughBehavior :: Lens' s (TF.Argument "passthrough_behavior" a)

instance HasPassthroughBehavior s a => HasPassthroughBehavior (TF.Resource p s) a where
    passthroughBehavior = TF.configuration . passthroughBehavior

class HasPassword s a | s -> a where
    password :: Lens' s (TF.Argument "password" a)

instance HasPassword s a => HasPassword (TF.Resource p s) a where
    password = TF.configuration . password

class HasPasswordLength s a | s -> a where
    passwordLength :: Lens' s (TF.Argument "password_length" a)

instance HasPasswordLength s a => HasPasswordLength (TF.Resource p s) a where
    passwordLength = TF.configuration . passwordLength

class HasPasswordPolicy s a | s -> a where
    passwordPolicy :: Lens' s (TF.Argument "password_policy" a)

instance HasPasswordPolicy s a => HasPasswordPolicy (TF.Resource p s) a where
    passwordPolicy = TF.configuration . passwordPolicy

class HasPasswordResetRequired s a | s -> a where
    passwordResetRequired :: Lens' s (TF.Argument "password_reset_required" a)

instance HasPasswordResetRequired s a => HasPasswordResetRequired (TF.Resource p s) a where
    passwordResetRequired = TF.configuration . passwordResetRequired

class HasPasswordReusePrevention s a | s -> a where
    passwordReusePrevention :: Lens' s (TF.Argument "password_reuse_prevention" a)

instance HasPasswordReusePrevention s a => HasPasswordReusePrevention (TF.Resource p s) a where
    passwordReusePrevention = TF.configuration . passwordReusePrevention

class HasPatchGroup s a | s -> a where
    patchGroup :: Lens' s (TF.Argument "patch_group" a)

instance HasPatchGroup s a => HasPatchGroup (TF.Resource p s) a where
    patchGroup = TF.configuration . patchGroup

class HasPath s a | s -> a where
    path :: Lens' s (TF.Argument "path" a)

instance HasPath s a => HasPath (TF.Resource p s) a where
    path = TF.configuration . path

class HasPathPart s a | s -> a where
    pathPart :: Lens' s (TF.Argument "path_part" a)

instance HasPathPart s a => HasPathPart (TF.Resource p s) a where
    pathPart = TF.configuration . pathPart

class HasPattern s a | s -> a where
    pattern :: Lens' s (TF.Argument "pattern" a)

instance HasPattern s a => HasPattern (TF.Resource p s) a where
    pattern = TF.configuration . pattern

class HasPeerOwnerId s a | s -> a where
    peerOwnerId :: Lens' s (TF.Argument "peer_owner_id" a)

instance HasPeerOwnerId s a => HasPeerOwnerId (TF.Resource p s) a where
    peerOwnerId = TF.configuration . peerOwnerId

class HasPeerRegion s a | s -> a where
    peerRegion :: Lens' s (TF.Argument "peer_region" a)

instance HasPeerRegion s a => HasPeerRegion (TF.Resource p s) a where
    peerRegion = TF.configuration . peerRegion

class HasPeerVpcId s a | s -> a where
    peerVpcId :: Lens' s (TF.Argument "peer_vpc_id" a)

instance HasPeerVpcId s a => HasPeerVpcId (TF.Resource p s) a where
    peerVpcId = TF.configuration . peerVpcId

class HasPerformanceInsightsEnabled s a | s -> a where
    performanceInsightsEnabled :: Lens' s (TF.Argument "performance_insights_enabled" a)

instance HasPerformanceInsightsEnabled s a => HasPerformanceInsightsEnabled (TF.Resource p s) a where
    performanceInsightsEnabled = TF.configuration . performanceInsightsEnabled

class HasPerformanceInsightsKmsKeyId s a | s -> a where
    performanceInsightsKmsKeyId :: Lens' s (TF.Argument "performance_insights_kms_key_id" a)

instance HasPerformanceInsightsKmsKeyId s a => HasPerformanceInsightsKmsKeyId (TF.Resource p s) a where
    performanceInsightsKmsKeyId = TF.configuration . performanceInsightsKmsKeyId

class HasPerformanceMode s a | s -> a where
    performanceMode :: Lens' s (TF.Argument "performance_mode" a)

instance HasPerformanceMode s a => HasPerformanceMode (TF.Resource p s) a where
    performanceMode = TF.configuration . performanceMode

class HasPeriod s a | s -> a where
    period :: Lens' s (TF.Argument "period" a)

instance HasPeriod s a => HasPeriod (TF.Resource p s) a where
    period = TF.configuration . period

class HasPermissions s a | s -> a where
    permissions :: Lens' s (TF.Argument "permissions" a)

instance HasPermissions s a => HasPermissions (TF.Resource p s) a where
    permissions = TF.configuration . permissions

class HasPgpKey s a | s -> a where
    pgpKey :: Lens' s (TF.Argument "pgp_key" a)

instance HasPgpKey s a => HasPgpKey (TF.Resource p s) a where
    pgpKey = TF.configuration . pgpKey

class HasPlacementConstraints s a | s -> a where
    placementConstraints :: Lens' s (TF.Argument "placement_constraints" a)

instance HasPlacementConstraints s a => HasPlacementConstraints (TF.Resource p s) a where
    placementConstraints = TF.configuration . placementConstraints

class HasPlacementGroup s a | s -> a where
    placementGroup :: Lens' s (TF.Argument "placement_group" a)

instance HasPlacementGroup s a => HasPlacementGroup (TF.Resource p s) a where
    placementGroup = TF.configuration . placementGroup

class HasPlacementStrategy s a | s -> a where
    placementStrategy :: Lens' s (TF.Argument "placement_strategy" a)

instance HasPlacementStrategy s a => HasPlacementStrategy (TF.Resource p s) a where
    placementStrategy = TF.configuration . placementStrategy

class HasPlacementTenancy s a | s -> a where
    placementTenancy :: Lens' s (TF.Argument "placement_tenancy" a)

instance HasPlacementTenancy s a => HasPlacementTenancy (TF.Resource p s) a where
    placementTenancy = TF.configuration . placementTenancy

class HasPolicy s a | s -> a where
    policy :: Lens' s (TF.Argument "policy" a)

instance HasPolicy s a => HasPolicy (TF.Resource p s) a where
    policy = TF.configuration . policy

class HasPolicyArn s a | s -> a where
    policyArn :: Lens' s (TF.Argument "policy_arn" a)

instance HasPolicyArn s a => HasPolicyArn (TF.Resource p s) a where
    policyArn = TF.configuration . policyArn

class HasPolicyAttribute s a | s -> a where
    policyAttribute :: Lens' s (TF.Argument "policy_attribute" a)

instance HasPolicyAttribute s a => HasPolicyAttribute (TF.Resource p s) a where
    policyAttribute = TF.configuration . policyAttribute

class HasPolicyBody s a | s -> a where
    policyBody :: Lens' s (TF.Argument "policy_body" a)

instance HasPolicyBody s a => HasPolicyBody (TF.Resource p s) a where
    policyBody = TF.configuration . policyBody

class HasPolicyDocument s a | s -> a where
    policyDocument :: Lens' s (TF.Argument "policy_document" a)

instance HasPolicyDocument s a => HasPolicyDocument (TF.Resource p s) a where
    policyDocument = TF.configuration . policyDocument

class HasPolicyName s a | s -> a where
    policyName :: Lens' s (TF.Argument "policy_name" a)

instance HasPolicyName s a => HasPolicyName (TF.Resource p s) a where
    policyName = TF.configuration . policyName

class HasPolicyNames s a | s -> a where
    policyNames :: Lens' s (TF.Argument "policy_names" a)

instance HasPolicyNames s a => HasPolicyNames (TF.Resource p s) a where
    policyNames = TF.configuration . policyNames

class HasPolicyType s a | s -> a where
    policyType :: Lens' s (TF.Argument "policy_type" a)

instance HasPolicyType s a => HasPolicyType (TF.Resource p s) a where
    policyType = TF.configuration . policyType

class HasPolicyTypeName s a | s -> a where
    policyTypeName :: Lens' s (TF.Argument "policy_type_name" a)

instance HasPolicyTypeName s a => HasPolicyTypeName (TF.Resource p s) a where
    policyTypeName = TF.configuration . policyTypeName

class HasPolicyUrl s a | s -> a where
    policyUrl :: Lens' s (TF.Argument "policy_url" a)

instance HasPolicyUrl s a => HasPolicyUrl (TF.Resource p s) a where
    policyUrl = TF.configuration . policyUrl

class HasPollInterval s a | s -> a where
    pollInterval :: Lens' s (TF.Argument "poll_interval" a)

instance HasPollInterval s a => HasPollInterval (TF.Resource p s) a where
    pollInterval = TF.configuration . pollInterval

class HasPort s a | s -> a where
    port :: Lens' s (TF.Argument "port" a)

instance HasPort s a => HasPort (TF.Resource p s) a where
    port = TF.configuration . port

class HasPredicates s a | s -> a where
    predicates :: Lens' s (TF.Argument "predicates" a)

instance HasPredicates s a => HasPredicates (TF.Resource p s) a where
    predicates = TF.configuration . predicates

class HasPreferredBackupWindow s a | s -> a where
    preferredBackupWindow :: Lens' s (TF.Argument "preferred_backup_window" a)

instance HasPreferredBackupWindow s a => HasPreferredBackupWindow (TF.Resource p s) a where
    preferredBackupWindow = TF.configuration . preferredBackupWindow

class HasPreferredMaintenanceWindow s a | s -> a where
    preferredMaintenanceWindow :: Lens' s (TF.Argument "preferred_maintenance_window" a)

instance HasPreferredMaintenanceWindow s a => HasPreferredMaintenanceWindow (TF.Resource p s) a where
    preferredMaintenanceWindow = TF.configuration . preferredMaintenanceWindow

class HasPrefix s a | s -> a where
    prefix :: Lens' s (TF.Argument "prefix" a)

instance HasPrefix s a => HasPrefix (TF.Resource p s) a where
    prefix = TF.configuration . prefix

class HasPrefixListIds s a | s -> a where
    prefixListIds :: Lens' s (TF.Argument "prefix_list_ids" a)

instance HasPrefixListIds s a => HasPrefixListIds (TF.Resource p s) a where
    prefixListIds = TF.configuration . prefixListIds

class HasPriceClass s a | s -> a where
    priceClass :: Lens' s (TF.Argument "price_class" a)

instance HasPriceClass s a => HasPriceClass (TF.Resource p s) a where
    priceClass = TF.configuration . priceClass

class HasPrincipal s a | s -> a where
    principal :: Lens' s (TF.Argument "principal" a)

instance HasPrincipal s a => HasPrincipal (TF.Resource p s) a where
    principal = TF.configuration . principal

class HasPriority s a | s -> a where
    priority :: Lens' s (TF.Argument "priority" a)

instance HasPriority s a => HasPriority (TF.Resource p s) a where
    priority = TF.configuration . priority

class HasPrivateIp s a | s -> a where
    privateIp :: Lens' s (TF.Argument "private_ip" a)

instance HasPrivateIp s a => HasPrivateIp (TF.Resource p s) a where
    privateIp = TF.configuration . privateIp

class HasPrivateIpAddress s a | s -> a where
    privateIpAddress :: Lens' s (TF.Argument "private_ip_address" a)

instance HasPrivateIpAddress s a => HasPrivateIpAddress (TF.Resource p s) a where
    privateIpAddress = TF.configuration . privateIpAddress

class HasPrivateIps s a | s -> a where
    privateIps :: Lens' s (TF.Argument "private_ips" a)

instance HasPrivateIps s a => HasPrivateIps (TF.Resource p s) a where
    privateIps = TF.configuration . privateIps

class HasPrivateIpsCount s a | s -> a where
    privateIpsCount :: Lens' s (TF.Argument "private_ips_count" a)

instance HasPrivateIpsCount s a => HasPrivateIpsCount (TF.Resource p s) a where
    privateIpsCount = TF.configuration . privateIpsCount

class HasPrivateKey s a | s -> a where
    privateKey :: Lens' s (TF.Argument "private_key" a)

instance HasPrivateKey s a => HasPrivateKey (TF.Resource p s) a where
    privateKey = TF.configuration . privateKey

class HasProductCode s a | s -> a where
    productCode :: Lens' s (TF.Argument "product_code" a)

instance HasProductCode s a => HasProductCode (TF.Resource p s) a where
    productCode = TF.configuration . productCode

class HasPromotionTier s a | s -> a where
    promotionTier :: Lens' s (TF.Argument "promotion_tier" a)

instance HasPromotionTier s a => HasPromotionTier (TF.Resource p s) a where
    promotionTier = TF.configuration . promotionTier

class HasPropagatingVgws s a | s -> a where
    propagatingVgws :: Lens' s (TF.Argument "propagating_vgws" a)

instance HasPropagatingVgws s a => HasPropagatingVgws (TF.Resource p s) a where
    propagatingVgws = TF.configuration . propagatingVgws

class HasProperties s a | s -> a where
    properties :: Lens' s (TF.Argument "properties" a)

instance HasProperties s a => HasProperties (TF.Resource p s) a where
    properties = TF.configuration . properties

class HasProtectFromScaleIn s a | s -> a where
    protectFromScaleIn :: Lens' s (TF.Argument "protect_from_scale_in" a)

instance HasProtectFromScaleIn s a => HasProtectFromScaleIn (TF.Resource p s) a where
    protectFromScaleIn = TF.configuration . protectFromScaleIn

class HasProtocol s a | s -> a where
    protocol :: Lens' s (TF.Argument "protocol" a)

instance HasProtocol s a => HasProtocol (TF.Resource p s) a where
    protocol = TF.configuration . protocol

class HasProviderName s a | s -> a where
    providerName :: Lens' s (TF.Argument "provider_name" a)

instance HasProviderName s a => HasProviderName (TF.Resource p s) a where
    providerName = TF.configuration . providerName

class HasPublicIp s a | s -> a where
    publicIp :: Lens' s (TF.Argument "public_ip" a)

instance HasPublicIp s a => HasPublicIp (TF.Resource p s) a where
    publicIp = TF.configuration . publicIp

class HasPublicKey s a | s -> a where
    publicKey :: Lens' s (TF.Argument "public_key" a)

instance HasPublicKey s a => HasPublicKey (TF.Resource p s) a where
    publicKey = TF.configuration . publicKey

class HasPubliclyAccessible s a | s -> a where
    publiclyAccessible :: Lens' s (TF.Argument "publicly_accessible" a)

instance HasPubliclyAccessible s a => HasPubliclyAccessible (TF.Resource p s) a where
    publiclyAccessible = TF.configuration . publiclyAccessible

class HasPublish s a | s -> a where
    publish :: Lens' s (TF.Argument "publish" a)

instance HasPublish s a => HasPublish (TF.Resource p s) a where
    publish = TF.configuration . publish

class HasQualifier s a | s -> a where
    qualifier :: Lens' s (TF.Argument "qualifier" a)

instance HasQualifier s a => HasQualifier (TF.Resource p s) a where
    qualifier = TF.configuration . qualifier

class HasQuery s a | s -> a where
    query :: Lens' s (TF.Argument "query" a)

instance HasQuery s a => HasQuery (TF.Resource p s) a where
    query = TF.configuration . query

class HasQueue s a | s -> a where
    queue :: Lens' s (TF.Argument "queue" a)

instance HasQueue s a => HasQueue (TF.Resource p s) a where
    queue = TF.configuration . queue

class HasQueueUrl s a | s -> a where
    queueUrl :: Lens' s (TF.Argument "queue_url" a)

instance HasQueueUrl s a => HasQueueUrl (TF.Resource p s) a where
    queueUrl = TF.configuration . queueUrl

class HasQuotaSettings s a | s -> a where
    quotaSettings :: Lens' s (TF.Argument "quota_settings" a)

instance HasQuotaSettings s a => HasQuotaSettings (TF.Resource p s) a where
    quotaSettings = TF.configuration . quotaSettings

class HasRailsEnv s a | s -> a where
    railsEnv :: Lens' s (TF.Argument "rails_env" a)

instance HasRailsEnv s a => HasRailsEnv (TF.Resource p s) a where
    railsEnv = TF.configuration . railsEnv

class HasRangeKey s a | s -> a where
    rangeKey :: Lens' s (TF.Argument "range_key" a)

instance HasRangeKey s a => HasRangeKey (TF.Resource p s) a where
    rangeKey = TF.configuration . rangeKey

class HasRateKey s a | s -> a where
    rateKey :: Lens' s (TF.Argument "rate_key" a)

instance HasRateKey s a => HasRateKey (TF.Resource p s) a where
    rateKey = TF.configuration . rateKey

class HasRateLimit s a | s -> a where
    rateLimit :: Lens' s (TF.Argument "rate_limit" a)

instance HasRateLimit s a => HasRateLimit (TF.Resource p s) a where
    rateLimit = TF.configuration . rateLimit

class HasRawMessageDelivery s a | s -> a where
    rawMessageDelivery :: Lens' s (TF.Argument "raw_message_delivery" a)

instance HasRawMessageDelivery s a => HasRawMessageDelivery (TF.Resource p s) a where
    rawMessageDelivery = TF.configuration . rawMessageDelivery

class HasRdsDbInstanceArn s a | s -> a where
    rdsDbInstanceArn :: Lens' s (TF.Argument "rds_db_instance_arn" a)

instance HasRdsDbInstanceArn s a => HasRdsDbInstanceArn (TF.Resource p s) a where
    rdsDbInstanceArn = TF.configuration . rdsDbInstanceArn

class HasReadAttributes s a | s -> a where
    readAttributes :: Lens' s (TF.Argument "read_attributes" a)

instance HasReadAttributes s a => HasReadAttributes (TF.Resource p s) a where
    readAttributes = TF.configuration . readAttributes

class HasReadCapacity s a | s -> a where
    readCapacity :: Lens' s (TF.Argument "read_capacity" a)

instance HasReadCapacity s a => HasReadCapacity (TF.Resource p s) a where
    readCapacity = TF.configuration . readCapacity

class HasReceiveWaitTimeSeconds s a | s -> a where
    receiveWaitTimeSeconds :: Lens' s (TF.Argument "receive_wait_time_seconds" a)

instance HasReceiveWaitTimeSeconds s a => HasReceiveWaitTimeSeconds (TF.Resource p s) a where
    receiveWaitTimeSeconds = TF.configuration . receiveWaitTimeSeconds

class HasRecipients s a | s -> a where
    recipients :: Lens' s (TF.Argument "recipients" a)

instance HasRecipients s a => HasRecipients (TF.Resource p s) a where
    recipients = TF.configuration . recipients

class HasRecordingGroup s a | s -> a where
    recordingGroup :: Lens' s (TF.Argument "recording_group" a)

instance HasRecordingGroup s a => HasRecordingGroup (TF.Resource p s) a where
    recordingGroup = TF.configuration . recordingGroup

class HasRecords s a | s -> a where
    records :: Lens' s (TF.Argument "records" a)

instance HasRecords s a => HasRecords (TF.Resource p s) a where
    records = TF.configuration . records

class HasRecurrence s a | s -> a where
    recurrence :: Lens' s (TF.Argument "recurrence" a)

instance HasRecurrence s a => HasRecurrence (TF.Resource p s) a where
    recurrence = TF.configuration . recurrence

class HasRedrivePolicy s a | s -> a where
    redrivePolicy :: Lens' s (TF.Argument "redrive_policy" a)

instance HasRedrivePolicy s a => HasRedrivePolicy (TF.Resource p s) a where
    redrivePolicy = TF.configuration . redrivePolicy

class HasRedshiftConfiguration s a | s -> a where
    redshiftConfiguration :: Lens' s (TF.Argument "redshift_configuration" a)

instance HasRedshiftConfiguration s a => HasRedshiftConfiguration (TF.Resource p s) a where
    redshiftConfiguration = TF.configuration . redshiftConfiguration

class HasReferenceName s a | s -> a where
    referenceName :: Lens' s (TF.Argument "reference_name" a)

instance HasReferenceName s a => HasReferenceName (TF.Resource p s) a where
    referenceName = TF.configuration . referenceName

class HasRefreshTokenValidity s a | s -> a where
    refreshTokenValidity :: Lens' s (TF.Argument "refresh_token_validity" a)

instance HasRefreshTokenValidity s a => HasRefreshTokenValidity (TF.Resource p s) a where
    refreshTokenValidity = TF.configuration . refreshTokenValidity

class HasRegion s a | s -> a where
    region :: Lens' s (TF.Argument "region" a)

instance HasRegion s a => HasRegion (TF.Resource p s) a where
    region = TF.configuration . region

class HasRegions s a | s -> a where
    regions :: Lens' s (TF.Argument "regions" a)

instance HasRegions s a => HasRegions (TF.Resource p s) a where
    regions = TF.configuration . regions

class HasRegistrationLimit s a | s -> a where
    registrationLimit :: Lens' s (TF.Argument "registration_limit" a)

instance HasRegistrationLimit s a => HasRegistrationLimit (TF.Resource p s) a where
    registrationLimit = TF.configuration . registrationLimit

class HasRejectedPatches s a | s -> a where
    rejectedPatches :: Lens' s (TF.Argument "rejected_patches" a)

instance HasRejectedPatches s a => HasRejectedPatches (TF.Resource p s) a where
    rejectedPatches = TF.configuration . rejectedPatches

class HasReleaseLabel s a | s -> a where
    releaseLabel :: Lens' s (TF.Argument "release_label" a)

instance HasReleaseLabel s a => HasReleaseLabel (TF.Resource p s) a where
    releaseLabel = TF.configuration . releaseLabel

class HasReplaceUnhealthyInstances s a | s -> a where
    replaceUnhealthyInstances :: Lens' s (TF.Argument "replace_unhealthy_instances" a)

instance HasReplaceUnhealthyInstances s a => HasReplaceUnhealthyInstances (TF.Resource p s) a where
    replaceUnhealthyInstances = TF.configuration . replaceUnhealthyInstances

class HasReplicateSourceDb s a | s -> a where
    replicateSourceDb :: Lens' s (TF.Argument "replicate_source_db" a)

instance HasReplicateSourceDb s a => HasReplicateSourceDb (TF.Resource p s) a where
    replicateSourceDb = TF.configuration . replicateSourceDb

class HasReplicationConfiguration s a | s -> a where
    replicationConfiguration :: Lens' s (TF.Argument "replication_configuration" a)

instance HasReplicationConfiguration s a => HasReplicationConfiguration (TF.Resource p s) a where
    replicationConfiguration = TF.configuration . replicationConfiguration

class HasReplicationGroupDescription s a | s -> a where
    replicationGroupDescription :: Lens' s (TF.Argument "replication_group_description" a)

instance HasReplicationGroupDescription s a => HasReplicationGroupDescription (TF.Resource p s) a where
    replicationGroupDescription = TF.configuration . replicationGroupDescription

class HasReplicationGroupId s a | s -> a where
    replicationGroupId :: Lens' s (TF.Argument "replication_group_id" a)

instance HasReplicationGroupId s a => HasReplicationGroupId (TF.Resource p s) a where
    replicationGroupId = TF.configuration . replicationGroupId

class HasReplicationInstanceArn s a | s -> a where
    replicationInstanceArn :: Lens' s (TF.Argument "replication_instance_arn" a)

instance HasReplicationInstanceArn s a => HasReplicationInstanceArn (TF.Resource p s) a where
    replicationInstanceArn = TF.configuration . replicationInstanceArn

class HasReplicationInstanceClass s a | s -> a where
    replicationInstanceClass :: Lens' s (TF.Argument "replication_instance_class" a)

instance HasReplicationInstanceClass s a => HasReplicationInstanceClass (TF.Resource p s) a where
    replicationInstanceClass = TF.configuration . replicationInstanceClass

class HasReplicationInstanceId s a | s -> a where
    replicationInstanceId :: Lens' s (TF.Argument "replication_instance_id" a)

instance HasReplicationInstanceId s a => HasReplicationInstanceId (TF.Resource p s) a where
    replicationInstanceId = TF.configuration . replicationInstanceId

class HasReplicationSubnetGroupDescription s a | s -> a where
    replicationSubnetGroupDescription :: Lens' s (TF.Argument "replication_subnet_group_description" a)

instance HasReplicationSubnetGroupDescription s a => HasReplicationSubnetGroupDescription (TF.Resource p s) a where
    replicationSubnetGroupDescription = TF.configuration . replicationSubnetGroupDescription

class HasReplicationSubnetGroupId s a | s -> a where
    replicationSubnetGroupId :: Lens' s (TF.Argument "replication_subnet_group_id" a)

instance HasReplicationSubnetGroupId s a => HasReplicationSubnetGroupId (TF.Resource p s) a where
    replicationSubnetGroupId = TF.configuration . replicationSubnetGroupId

class HasReplicationTaskId s a | s -> a where
    replicationTaskId :: Lens' s (TF.Argument "replication_task_id" a)

instance HasReplicationTaskId s a => HasReplicationTaskId (TF.Resource p s) a where
    replicationTaskId = TF.configuration . replicationTaskId

class HasReplicationTaskSettings s a | s -> a where
    replicationTaskSettings :: Lens' s (TF.Argument "replication_task_settings" a)

instance HasReplicationTaskSettings s a => HasReplicationTaskSettings (TF.Resource p s) a where
    replicationTaskSettings = TF.configuration . replicationTaskSettings

class HasRepository s a | s -> a where
    repository :: Lens' s (TF.Argument "repository" a)

instance HasRepository s a => HasRepository (TF.Resource p s) a where
    repository = TF.configuration . repository

class HasRepositoryName s a | s -> a where
    repositoryName :: Lens' s (TF.Argument "repository_name" a)

instance HasRepositoryName s a => HasRepositoryName (TF.Resource p s) a where
    repositoryName = TF.configuration . repositoryName

class HasRequestInterval s a | s -> a where
    requestInterval :: Lens' s (TF.Argument "request_interval" a)

instance HasRequestInterval s a => HasRequestInterval (TF.Resource p s) a where
    requestInterval = TF.configuration . requestInterval

class HasRequestModels s a | s -> a where
    requestModels :: Lens' s (TF.Argument "request_models" a)

instance HasRequestModels s a => HasRequestModels (TF.Resource p s) a where
    requestModels = TF.configuration . requestModels

class HasRequestParameters s a | s -> a where
    requestParameters :: Lens' s (TF.Argument "request_parameters" a)

instance HasRequestParameters s a => HasRequestParameters (TF.Resource p s) a where
    requestParameters = TF.configuration . requestParameters

class HasRequestParametersInJson s a | s -> a where
    requestParametersInJson :: Lens' s (TF.Argument "request_parameters_in_json" a)

instance HasRequestParametersInJson s a => HasRequestParametersInJson (TF.Resource p s) a where
    requestParametersInJson = TF.configuration . requestParametersInJson

class HasRequestPayer s a | s -> a where
    requestPayer :: Lens' s (TF.Argument "request_payer" a)

instance HasRequestPayer s a => HasRequestPayer (TF.Resource p s) a where
    requestPayer = TF.configuration . requestPayer

class HasRequestTemplates s a | s -> a where
    requestTemplates :: Lens' s (TF.Argument "request_templates" a)

instance HasRequestTemplates s a => HasRequestTemplates (TF.Resource p s) a where
    requestTemplates = TF.configuration . requestTemplates

class HasRequestValidatorId s a | s -> a where
    requestValidatorId :: Lens' s (TF.Argument "request_validator_id" a)

instance HasRequestValidatorId s a => HasRequestValidatorId (TF.Resource p s) a where
    requestValidatorId = TF.configuration . requestValidatorId

class HasRequester s a | s -> a where
    requester :: Lens' s (TF.Argument "requester" a)

instance HasRequester s a => HasRequester (TF.Resource p s) a where
    requester = TF.configuration . requester

class HasRequireLowercaseCharacters s a | s -> a where
    requireLowercaseCharacters :: Lens' s (TF.Argument "require_lowercase_characters" a)

instance HasRequireLowercaseCharacters s a => HasRequireLowercaseCharacters (TF.Resource p s) a where
    requireLowercaseCharacters = TF.configuration . requireLowercaseCharacters

class HasRequireNumbers s a | s -> a where
    requireNumbers :: Lens' s (TF.Argument "require_numbers" a)

instance HasRequireNumbers s a => HasRequireNumbers (TF.Resource p s) a where
    requireNumbers = TF.configuration . requireNumbers

class HasRequireSymbols s a | s -> a where
    requireSymbols :: Lens' s (TF.Argument "require_symbols" a)

instance HasRequireSymbols s a => HasRequireSymbols (TF.Resource p s) a where
    requireSymbols = TF.configuration . requireSymbols

class HasRequireUppercaseCharacters s a | s -> a where
    requireUppercaseCharacters :: Lens' s (TF.Argument "require_uppercase_characters" a)

instance HasRequireUppercaseCharacters s a => HasRequireUppercaseCharacters (TF.Resource p s) a where
    requireUppercaseCharacters = TF.configuration . requireUppercaseCharacters

class HasReservedConcurrentExecutions s a | s -> a where
    reservedConcurrentExecutions :: Lens' s (TF.Argument "reserved_concurrent_executions" a)

instance HasReservedConcurrentExecutions s a => HasReservedConcurrentExecutions (TF.Resource p s) a where
    reservedConcurrentExecutions = TF.configuration . reservedConcurrentExecutions

class HasResourceGroupArn s a | s -> a where
    resourceGroupArn :: Lens' s (TF.Argument "resource_group_arn" a)

instance HasResourceGroupArn s a => HasResourceGroupArn (TF.Resource p s) a where
    resourceGroupArn = TF.configuration . resourceGroupArn

class HasResourceId s a | s -> a where
    resourceId :: Lens' s (TF.Argument "resource_id" a)

instance HasResourceId s a => HasResourceId (TF.Resource p s) a where
    resourceId = TF.configuration . resourceId

class HasResourcePath s a | s -> a where
    resourcePath :: Lens' s (TF.Argument "resource_path" a)

instance HasResourcePath s a => HasResourcePath (TF.Resource p s) a where
    resourcePath = TF.configuration . resourcePath

class HasResourceType s a | s -> a where
    resourceType :: Lens' s (TF.Argument "resource_type" a)

instance HasResourceType s a => HasResourceType (TF.Resource p s) a where
    resourceType = TF.configuration . resourceType

class HasResponseModels s a | s -> a where
    responseModels :: Lens' s (TF.Argument "response_models" a)

instance HasResponseModels s a => HasResponseModels (TF.Resource p s) a where
    responseModels = TF.configuration . responseModels

class HasResponseParameters s a | s -> a where
    responseParameters :: Lens' s (TF.Argument "response_parameters" a)

instance HasResponseParameters s a => HasResponseParameters (TF.Resource p s) a where
    responseParameters = TF.configuration . responseParameters

class HasResponseParametersInJson s a | s -> a where
    responseParametersInJson :: Lens' s (TF.Argument "response_parameters_in_json" a)

instance HasResponseParametersInJson s a => HasResponseParametersInJson (TF.Resource p s) a where
    responseParametersInJson = TF.configuration . responseParametersInJson

class HasResponseTemplates s a | s -> a where
    responseTemplates :: Lens' s (TF.Argument "response_templates" a)

instance HasResponseTemplates s a => HasResponseTemplates (TF.Resource p s) a where
    responseTemplates = TF.configuration . responseTemplates

class HasResponseType s a | s -> a where
    responseType :: Lens' s (TF.Argument "response_type" a)

instance HasResponseType s a => HasResponseType (TF.Resource p s) a where
    responseType = TF.configuration . responseType

class HasRestApiId s a | s -> a where
    restApiId :: Lens' s (TF.Argument "rest_api_id" a)

instance HasRestApiId s a => HasRestApiId (TF.Resource p s) a where
    restApiId = TF.configuration . restApiId

class HasRestrictions s a | s -> a where
    restrictions :: Lens' s (TF.Argument "restrictions" a)

instance HasRestrictions s a => HasRestrictions (TF.Resource p s) a where
    restrictions = TF.configuration . restrictions

class HasRetainOnDelete s a | s -> a where
    retainOnDelete :: Lens' s (TF.Argument "retain_on_delete" a)

instance HasRetainOnDelete s a => HasRetainOnDelete (TF.Resource p s) a where
    retainOnDelete = TF.configuration . retainOnDelete

class HasRetentionInDays s a | s -> a where
    retentionInDays :: Lens' s (TF.Argument "retention_in_days" a)

instance HasRetentionInDays s a => HasRetentionInDays (TF.Resource p s) a where
    retentionInDays = TF.configuration . retentionInDays

class HasRetentionPeriod s a | s -> a where
    retentionPeriod :: Lens' s (TF.Argument "retention_period" a)

instance HasRetentionPeriod s a => HasRetentionPeriod (TF.Resource p s) a where
    retentionPeriod = TF.configuration . retentionPeriod

class HasRetryStrategy s a | s -> a where
    retryStrategy :: Lens' s (TF.Argument "retry_strategy" a)

instance HasRetryStrategy s a => HasRetryStrategy (TF.Resource p s) a where
    retryStrategy = TF.configuration . retryStrategy

class HasRevokeRulesOnDelete s a | s -> a where
    revokeRulesOnDelete :: Lens' s (TF.Argument "revoke_rules_on_delete" a)

instance HasRevokeRulesOnDelete s a => HasRevokeRulesOnDelete (TF.Resource p s) a where
    revokeRulesOnDelete = TF.configuration . revokeRulesOnDelete

class HasRole s a | s -> a where
    role :: Lens' s (TF.Argument "role" a)

instance HasRole s a => HasRole (TF.Resource p s) a where
    role = TF.configuration . role

class HasRoleArn s a | s -> a where
    roleArn :: Lens' s (TF.Argument "role_arn" a)

instance HasRoleArn s a => HasRoleArn (TF.Resource p s) a where
    roleArn = TF.configuration . roleArn

class HasRoleMapping s a | s -> a where
    roleMapping :: Lens' s (TF.Argument "role_mapping" a)

instance HasRoleMapping s a => HasRoleMapping (TF.Resource p s) a where
    roleMapping = TF.configuration . roleMapping

class HasRoles s a | s -> a where
    roles :: Lens' s (TF.Argument "roles" a)

instance HasRoles s a => HasRoles (TF.Resource p s) a where
    roles = TF.configuration . roles

class HasRootBlockDevice s a | s -> a where
    rootBlockDevice :: Lens' s (TF.Argument "root_block_device" a)

instance HasRootBlockDevice s a => HasRootBlockDevice (TF.Resource p s) a where
    rootBlockDevice = TF.configuration . rootBlockDevice

class HasRootDeviceName s a | s -> a where
    rootDeviceName :: Lens' s (TF.Argument "root_device_name" a)

instance HasRootDeviceName s a => HasRootDeviceName (TF.Resource p s) a where
    rootDeviceName = TF.configuration . rootDeviceName

class HasRootDeviceType s a | s -> a where
    rootDeviceType :: Lens' s (TF.Argument "root_device_type" a)

instance HasRootDeviceType s a => HasRootDeviceType (TF.Resource p s) a where
    rootDeviceType = TF.configuration . rootDeviceType

class HasRootPassword s a | s -> a where
    rootPassword :: Lens' s (TF.Argument "root_password" a)

instance HasRootPassword s a => HasRootPassword (TF.Resource p s) a where
    rootPassword = TF.configuration . rootPassword

class HasRootPasswordOnAllInstances s a | s -> a where
    rootPasswordOnAllInstances :: Lens' s (TF.Argument "root_password_on_all_instances" a)

instance HasRootPasswordOnAllInstances s a => HasRootPasswordOnAllInstances (TF.Resource p s) a where
    rootPasswordOnAllInstances = TF.configuration . rootPasswordOnAllInstances

class HasRoute s a | s -> a where
    route :: Lens' s (TF.Argument "route" a)

instance HasRoute s a => HasRoute (TF.Resource p s) a where
    route = TF.configuration . route

class HasRouteTableId s a | s -> a where
    routeTableId :: Lens' s (TF.Argument "route_table_id" a)

instance HasRouteTableId s a => HasRouteTableId (TF.Resource p s) a where
    routeTableId = TF.configuration . routeTableId

class HasRouteTableIds s a | s -> a where
    routeTableIds :: Lens' s (TF.Argument "route_table_ids" a)

instance HasRouteTableIds s a => HasRouteTableIds (TF.Resource p s) a where
    routeTableIds = TF.configuration . routeTableIds

class HasRubyVersion s a | s -> a where
    rubyVersion :: Lens' s (TF.Argument "ruby_version" a)

instance HasRubyVersion s a => HasRubyVersion (TF.Resource p s) a where
    rubyVersion = TF.configuration . rubyVersion

class HasRubygemsVersion s a | s -> a where
    rubygemsVersion :: Lens' s (TF.Argument "rubygems_version" a)

instance HasRubygemsVersion s a => HasRubygemsVersion (TF.Resource p s) a where
    rubygemsVersion = TF.configuration . rubygemsVersion

class HasRule s a | s -> a where
    rule :: Lens' s (TF.Argument "rule" a)

instance HasRule s a => HasRule (TF.Resource p s) a where
    rule = TF.configuration . rule

class HasRuleAction s a | s -> a where
    ruleAction :: Lens' s (TF.Argument "rule_action" a)

instance HasRuleAction s a => HasRuleAction (TF.Resource p s) a where
    ruleAction = TF.configuration . ruleAction

class HasRuleNumber s a | s -> a where
    ruleNumber :: Lens' s (TF.Argument "rule_number" a)

instance HasRuleNumber s a => HasRuleNumber (TF.Resource p s) a where
    ruleNumber = TF.configuration . ruleNumber

class HasRuleSetName s a | s -> a where
    ruleSetName :: Lens' s (TF.Argument "rule_set_name" a)

instance HasRuleSetName s a => HasRuleSetName (TF.Resource p s) a where
    ruleSetName = TF.configuration . ruleSetName

class HasRules s a | s -> a where
    rules :: Lens' s (TF.Argument "rules" a)

instance HasRules s a => HasRules (TF.Resource p s) a where
    rules = TF.configuration . rules

class HasRulesPackageArns s a | s -> a where
    rulesPackageArns :: Lens' s (TF.Argument "rules_package_arns" a)

instance HasRulesPackageArns s a => HasRulesPackageArns (TF.Resource p s) a where
    rulesPackageArns = TF.configuration . rulesPackageArns

class HasRunCommandTargets s a | s -> a where
    runCommandTargets :: Lens' s (TF.Argument "run_command_targets" a)

instance HasRunCommandTargets s a => HasRunCommandTargets (TF.Resource p s) a where
    runCommandTargets = TF.configuration . runCommandTargets

class HasRuntime s a | s -> a where
    runtime :: Lens' s (TF.Argument "runtime" a)

instance HasRuntime s a => HasRuntime (TF.Resource p s) a where
    runtime = TF.configuration . runtime

class HasS3Action s a | s -> a where
    s3Action :: Lens' s (TF.Argument "s3_action" a)

instance HasS3Action s a => HasS3Action (TF.Resource p s) a where
    s3Action = TF.configuration . s3Action

class HasS3Bucket s a | s -> a where
    s3Bucket :: Lens' s (TF.Argument "s3_bucket" a)

instance HasS3Bucket s a => HasS3Bucket (TF.Resource p s) a where
    s3Bucket = TF.configuration . s3Bucket

class HasS3BucketName s a | s -> a where
    s3BucketName :: Lens' s (TF.Argument "s3_bucket_name" a)

instance HasS3BucketName s a => HasS3BucketName (TF.Resource p s) a where
    s3BucketName = TF.configuration . s3BucketName

class HasS3Configuration s a | s -> a where
    s3Configuration :: Lens' s (TF.Argument "s3_configuration" a)

instance HasS3Configuration s a => HasS3Configuration (TF.Resource p s) a where
    s3Configuration = TF.configuration . s3Configuration

class HasS3Destination s a | s -> a where
    s3Destination :: Lens' s (TF.Argument "s3_destination" a)

instance HasS3Destination s a => HasS3Destination (TF.Resource p s) a where
    s3Destination = TF.configuration . s3Destination

class HasS3Key s a | s -> a where
    s3Key :: Lens' s (TF.Argument "s3_key" a)

instance HasS3Key s a => HasS3Key (TF.Resource p s) a where
    s3Key = TF.configuration . s3Key

class HasS3KeyPrefix s a | s -> a where
    s3KeyPrefix :: Lens' s (TF.Argument "s3_key_prefix" a)

instance HasS3KeyPrefix s a => HasS3KeyPrefix (TF.Resource p s) a where
    s3KeyPrefix = TF.configuration . s3KeyPrefix

class HasS3ObjectVersion s a | s -> a where
    s3ObjectVersion :: Lens' s (TF.Argument "s3_object_version" a)

instance HasS3ObjectVersion s a => HasS3ObjectVersion (TF.Resource p s) a where
    s3ObjectVersion = TF.configuration . s3ObjectVersion

class HasSamlMetadataDocument s a | s -> a where
    samlMetadataDocument :: Lens' s (TF.Argument "saml_metadata_document" a)

instance HasSamlMetadataDocument s a => HasSamlMetadataDocument (TF.Resource p s) a where
    samlMetadataDocument = TF.configuration . samlMetadataDocument

class HasSamlProviderArns s a | s -> a where
    samlProviderArns :: Lens' s (TF.Argument "saml_provider_arns" a)

instance HasSamlProviderArns s a => HasSamlProviderArns (TF.Resource p s) a where
    samlProviderArns = TF.configuration . samlProviderArns

class HasScalableDimension s a | s -> a where
    scalableDimension :: Lens' s (TF.Argument "scalable_dimension" a)

instance HasScalableDimension s a => HasScalableDimension (TF.Resource p s) a where
    scalableDimension = TF.configuration . scalableDimension

class HasScalableTargetAction s a | s -> a where
    scalableTargetAction :: Lens' s (TF.Argument "scalable_target_action" a)

instance HasScalableTargetAction s a => HasScalableTargetAction (TF.Resource p s) a where
    scalableTargetAction = TF.configuration . scalableTargetAction

class HasScanEnabled s a | s -> a where
    scanEnabled :: Lens' s (TF.Argument "scan_enabled" a)

instance HasScanEnabled s a => HasScanEnabled (TF.Resource p s) a where
    scanEnabled = TF.configuration . scanEnabled

class HasSchedule s a | s -> a where
    schedule :: Lens' s (TF.Argument "schedule" a)

instance HasSchedule s a => HasSchedule (TF.Resource p s) a where
    schedule = TF.configuration . schedule

class HasScheduleExpression s a | s -> a where
    scheduleExpression :: Lens' s (TF.Argument "schedule_expression" a)

instance HasScheduleExpression s a => HasScheduleExpression (TF.Resource p s) a where
    scheduleExpression = TF.configuration . scheduleExpression

class HasScheduledActionName s a | s -> a where
    scheduledActionName :: Lens' s (TF.Argument "scheduled_action_name" a)

instance HasScheduledActionName s a => HasScheduledActionName (TF.Resource p s) a where
    scheduledActionName = TF.configuration . scheduledActionName

class HasSchema s a | s -> a where
    schema :: Lens' s (TF.Argument "schema" a)

instance HasSchema s a => HasSchema (TF.Resource p s) a where
    schema = TF.configuration . schema

class HasScope s a | s -> a where
    scope :: Lens' s (TF.Argument "scope" a)

instance HasScope s a => HasScope (TF.Resource p s) a where
    scope = TF.configuration . scope

class HasSearchString s a | s -> a where
    searchString :: Lens' s (TF.Argument "search_string" a)

instance HasSearchString s a => HasSearchString (TF.Resource p s) a where
    searchString = TF.configuration . searchString

class HasSecurityConfiguration s a | s -> a where
    securityConfiguration :: Lens' s (TF.Argument "security_configuration" a)

instance HasSecurityConfiguration s a => HasSecurityConfiguration (TF.Resource p s) a where
    securityConfiguration = TF.configuration . securityConfiguration

class HasSecurityGroupId s a | s -> a where
    securityGroupId :: Lens' s (TF.Argument "security_group_id" a)

instance HasSecurityGroupId s a => HasSecurityGroupId (TF.Resource p s) a where
    securityGroupId = TF.configuration . securityGroupId

class HasSecurityGroupIds s a | s -> a where
    securityGroupIds :: Lens' s (TF.Argument "security_group_ids" a)

instance HasSecurityGroupIds s a => HasSecurityGroupIds (TF.Resource p s) a where
    securityGroupIds = TF.configuration . securityGroupIds

class HasSecurityGroupNames s a | s -> a where
    securityGroupNames :: Lens' s (TF.Argument "security_group_names" a)

instance HasSecurityGroupNames s a => HasSecurityGroupNames (TF.Resource p s) a where
    securityGroupNames = TF.configuration . securityGroupNames

class HasSecurityGroups s a | s -> a where
    securityGroups :: Lens' s (TF.Argument "security_groups" a)

instance HasSecurityGroups s a => HasSecurityGroups (TF.Resource p s) a where
    securityGroups = TF.configuration . securityGroups

class HasSelectionPattern s a | s -> a where
    selectionPattern :: Lens' s (TF.Argument "selection_pattern" a)

instance HasSelectionPattern s a => HasSelectionPattern (TF.Resource p s) a where
    selectionPattern = TF.configuration . selectionPattern

class HasSelf s a | s -> a where
    self :: Lens' s (TF.Argument "self" a)

instance HasSelf s a => HasSelf (TF.Resource p s) a where
    self = TF.configuration . self

class HasServerName s a | s -> a where
    serverName :: Lens' s (TF.Argument "server_name" a)

instance HasServerName s a => HasServerName (TF.Resource p s) a where
    serverName = TF.configuration . serverName

class HasServerSideEncryption s a | s -> a where
    serverSideEncryption :: Lens' s (TF.Argument "server_side_encryption" a)

instance HasServerSideEncryption s a => HasServerSideEncryption (TF.Resource p s) a where
    serverSideEncryption = TF.configuration . serverSideEncryption

class HasServerSideEncryptionConfiguration s a | s -> a where
    serverSideEncryptionConfiguration :: Lens' s (TF.Argument "server_side_encryption_configuration" a)

instance HasServerSideEncryptionConfiguration s a => HasServerSideEncryptionConfiguration (TF.Resource p s) a where
    serverSideEncryptionConfiguration = TF.configuration . serverSideEncryptionConfiguration

class HasServiceAccessRole s a | s -> a where
    serviceAccessRole :: Lens' s (TF.Argument "service_access_role" a)

instance HasServiceAccessRole s a => HasServiceAccessRole (TF.Resource p s) a where
    serviceAccessRole = TF.configuration . serviceAccessRole

class HasServiceName s a | s -> a where
    serviceName :: Lens' s (TF.Argument "service_name" a)

instance HasServiceName s a => HasServiceName (TF.Resource p s) a where
    serviceName = TF.configuration . serviceName

class HasServiceNamespace s a | s -> a where
    serviceNamespace :: Lens' s (TF.Argument "service_namespace" a)

instance HasServiceNamespace s a => HasServiceNamespace (TF.Resource p s) a where
    serviceNamespace = TF.configuration . serviceNamespace

class HasServiceRole s a | s -> a where
    serviceRole :: Lens' s (TF.Argument "service_role" a)

instance HasServiceRole s a => HasServiceRole (TF.Resource p s) a where
    serviceRole = TF.configuration . serviceRole

class HasServiceRoleArn s a | s -> a where
    serviceRoleArn :: Lens' s (TF.Argument "service_role_arn" a)

instance HasServiceRoleArn s a => HasServiceRoleArn (TF.Resource p s) a where
    serviceRoleArn = TF.configuration . serviceRoleArn

class HasSetIdentifier s a | s -> a where
    setIdentifier :: Lens' s (TF.Argument "set_identifier" a)

instance HasSetIdentifier s a => HasSetIdentifier (TF.Resource p s) a where
    setIdentifier = TF.configuration . setIdentifier

class HasSetting s a | s -> a where
    setting :: Lens' s (TF.Argument "setting" a)

instance HasSetting s a => HasSetting (TF.Resource p s) a where
    setting = TF.configuration . setting

class HasSettings s a | s -> a where
    settings :: Lens' s (TF.Argument "settings" a)

instance HasSettings s a => HasSettings (TF.Resource p s) a where
    settings = TF.configuration . settings

class HasShardCount s a | s -> a where
    shardCount :: Lens' s (TF.Argument "shard_count" a)

instance HasShardCount s a => HasShardCount (TF.Resource p s) a where
    shardCount = TF.configuration . shardCount

class HasShardLevelMetrics s a | s -> a where
    shardLevelMetrics :: Lens' s (TF.Argument "shard_level_metrics" a)

instance HasShardLevelMetrics s a => HasShardLevelMetrics (TF.Resource p s) a where
    shardLevelMetrics = TF.configuration . shardLevelMetrics

class HasShortName s a | s -> a where
    shortName :: Lens' s (TF.Argument "short_name" a)

instance HasShortName s a => HasShortName (TF.Resource p s) a where
    shortName = TF.configuration . shortName

class HasSize s a | s -> a where
    size :: Lens' s (TF.Argument "size" a)

instance HasSize s a => HasSize (TF.Resource p s) a where
    size = TF.configuration . size

class HasSizeConstraints s a | s -> a where
    sizeConstraints :: Lens' s (TF.Argument "size_constraints" a)

instance HasSizeConstraints s a => HasSizeConstraints (TF.Resource p s) a where
    sizeConstraints = TF.configuration . sizeConstraints

class HasSkipDestroy s a | s -> a where
    skipDestroy :: Lens' s (TF.Argument "skip_destroy" a)

instance HasSkipDestroy s a => HasSkipDestroy (TF.Resource p s) a where
    skipDestroy = TF.configuration . skipDestroy

class HasSkipFinalSnapshot s a | s -> a where
    skipFinalSnapshot :: Lens' s (TF.Argument "skip_final_snapshot" a)

instance HasSkipFinalSnapshot s a => HasSkipFinalSnapshot (TF.Resource p s) a where
    skipFinalSnapshot = TF.configuration . skipFinalSnapshot

class HasSmsAuthenticationMessage s a | s -> a where
    smsAuthenticationMessage :: Lens' s (TF.Argument "sms_authentication_message" a)

instance HasSmsAuthenticationMessage s a => HasSmsAuthenticationMessage (TF.Resource p s) a where
    smsAuthenticationMessage = TF.configuration . smsAuthenticationMessage

class HasSmsConfiguration s a | s -> a where
    smsConfiguration :: Lens' s (TF.Argument "sms_configuration" a)

instance HasSmsConfiguration s a => HasSmsConfiguration (TF.Resource p s) a where
    smsConfiguration = TF.configuration . smsConfiguration

class HasSmsVerificationMessage s a | s -> a where
    smsVerificationMessage :: Lens' s (TF.Argument "sms_verification_message" a)

instance HasSmsVerificationMessage s a => HasSmsVerificationMessage (TF.Resource p s) a where
    smsVerificationMessage = TF.configuration . smsVerificationMessage

class HasSnapshotArns s a | s -> a where
    snapshotArns :: Lens' s (TF.Argument "snapshot_arns" a)

instance HasSnapshotArns s a => HasSnapshotArns (TF.Resource p s) a where
    snapshotArns = TF.configuration . snapshotArns

class HasSnapshotClusterIdentifier s a | s -> a where
    snapshotClusterIdentifier :: Lens' s (TF.Argument "snapshot_cluster_identifier" a)

instance HasSnapshotClusterIdentifier s a => HasSnapshotClusterIdentifier (TF.Resource p s) a where
    snapshotClusterIdentifier = TF.configuration . snapshotClusterIdentifier

class HasSnapshotCopy s a | s -> a where
    snapshotCopy :: Lens' s (TF.Argument "snapshot_copy" a)

instance HasSnapshotCopy s a => HasSnapshotCopy (TF.Resource p s) a where
    snapshotCopy = TF.configuration . snapshotCopy

class HasSnapshotDeliveryProperties s a | s -> a where
    snapshotDeliveryProperties :: Lens' s (TF.Argument "snapshot_delivery_properties" a)

instance HasSnapshotDeliveryProperties s a => HasSnapshotDeliveryProperties (TF.Resource p s) a where
    snapshotDeliveryProperties = TF.configuration . snapshotDeliveryProperties

class HasSnapshotId s a | s -> a where
    snapshotId :: Lens' s (TF.Argument "snapshot_id" a)

instance HasSnapshotId s a => HasSnapshotId (TF.Resource p s) a where
    snapshotId = TF.configuration . snapshotId

class HasSnapshotIdentifier s a | s -> a where
    snapshotIdentifier :: Lens' s (TF.Argument "snapshot_identifier" a)

instance HasSnapshotIdentifier s a => HasSnapshotIdentifier (TF.Resource p s) a where
    snapshotIdentifier = TF.configuration . snapshotIdentifier

class HasSnapshotName s a | s -> a where
    snapshotName :: Lens' s (TF.Argument "snapshot_name" a)

instance HasSnapshotName s a => HasSnapshotName (TF.Resource p s) a where
    snapshotName = TF.configuration . snapshotName

class HasSnapshotOptions s a | s -> a where
    snapshotOptions :: Lens' s (TF.Argument "snapshot_options" a)

instance HasSnapshotOptions s a => HasSnapshotOptions (TF.Resource p s) a where
    snapshotOptions = TF.configuration . snapshotOptions

class HasSnapshotRetentionLimit s a | s -> a where
    snapshotRetentionLimit :: Lens' s (TF.Argument "snapshot_retention_limit" a)

instance HasSnapshotRetentionLimit s a => HasSnapshotRetentionLimit (TF.Resource p s) a where
    snapshotRetentionLimit = TF.configuration . snapshotRetentionLimit

class HasSnapshotWindow s a | s -> a where
    snapshotWindow :: Lens' s (TF.Argument "snapshot_window" a)

instance HasSnapshotWindow s a => HasSnapshotWindow (TF.Resource p s) a where
    snapshotWindow = TF.configuration . snapshotWindow

class HasSnapshotWithoutReboot s a | s -> a where
    snapshotWithoutReboot :: Lens' s (TF.Argument "snapshot_without_reboot" a)

instance HasSnapshotWithoutReboot s a => HasSnapshotWithoutReboot (TF.Resource p s) a where
    snapshotWithoutReboot = TF.configuration . snapshotWithoutReboot

class HasSnsAction s a | s -> a where
    snsAction :: Lens' s (TF.Argument "sns_action" a)

instance HasSnsAction s a => HasSnsAction (TF.Resource p s) a where
    snsAction = TF.configuration . snsAction

class HasSnsDestination s a | s -> a where
    snsDestination :: Lens' s (TF.Argument "sns_destination" a)

instance HasSnsDestination s a => HasSnsDestination (TF.Resource p s) a where
    snsDestination = TF.configuration . snsDestination

class HasSnsTopic s a | s -> a where
    snsTopic :: Lens' s (TF.Argument "sns_topic" a)

instance HasSnsTopic s a => HasSnsTopic (TF.Resource p s) a where
    snsTopic = TF.configuration . snsTopic

class HasSnsTopicArn s a | s -> a where
    snsTopicArn :: Lens' s (TF.Argument "sns_topic_arn" a)

instance HasSnsTopicArn s a => HasSnsTopicArn (TF.Resource p s) a where
    snsTopicArn = TF.configuration . snsTopicArn

class HasSnsTopicName s a | s -> a where
    snsTopicName :: Lens' s (TF.Argument "sns_topic_name" a)

instance HasSnsTopicName s a => HasSnsTopicName (TF.Resource p s) a where
    snsTopicName = TF.configuration . snsTopicName

class HasSolutionStackName s a | s -> a where
    solutionStackName :: Lens' s (TF.Argument "solution_stack_name" a)

instance HasSolutionStackName s a => HasSolutionStackName (TF.Resource p s) a where
    solutionStackName = TF.configuration . solutionStackName

class HasSource s a | s -> a where
    source :: Lens' s (TF.Argument "source" a)

instance HasSource s a => HasSource (TF.Resource p s) a where
    source = TF.configuration . source

class HasSourceAccount s a | s -> a where
    sourceAccount :: Lens' s (TF.Argument "source_account" a)

instance HasSourceAccount s a => HasSourceAccount (TF.Resource p s) a where
    sourceAccount = TF.configuration . sourceAccount

class HasSourceAmiId s a | s -> a where
    sourceAmiId :: Lens' s (TF.Argument "source_ami_id" a)

instance HasSourceAmiId s a => HasSourceAmiId (TF.Resource p s) a where
    sourceAmiId = TF.configuration . sourceAmiId

class HasSourceAmiRegion s a | s -> a where
    sourceAmiRegion :: Lens' s (TF.Argument "source_ami_region" a)

instance HasSourceAmiRegion s a => HasSourceAmiRegion (TF.Resource p s) a where
    sourceAmiRegion = TF.configuration . sourceAmiRegion

class HasSourceArn s a | s -> a where
    sourceArn :: Lens' s (TF.Argument "source_arn" a)

instance HasSourceArn s a => HasSourceArn (TF.Resource p s) a where
    sourceArn = TF.configuration . sourceArn

class HasSourceCodeHash s a | s -> a where
    sourceCodeHash :: Lens' s (TF.Argument "source_code_hash" a)

instance HasSourceCodeHash s a => HasSourceCodeHash (TF.Resource p s) a where
    sourceCodeHash = TF.configuration . sourceCodeHash

class HasSourceDestCheck s a | s -> a where
    sourceDestCheck :: Lens' s (TF.Argument "source_dest_check" a)

instance HasSourceDestCheck s a => HasSourceDestCheck (TF.Resource p s) a where
    sourceDestCheck = TF.configuration . sourceDestCheck

class HasSourceEndpointArn s a | s -> a where
    sourceEndpointArn :: Lens' s (TF.Argument "source_endpoint_arn" a)

instance HasSourceEndpointArn s a => HasSourceEndpointArn (TF.Resource p s) a where
    sourceEndpointArn = TF.configuration . sourceEndpointArn

class HasSourceIds s a | s -> a where
    sourceIds :: Lens' s (TF.Argument "source_ids" a)

instance HasSourceIds s a => HasSourceIds (TF.Resource p s) a where
    sourceIds = TF.configuration . sourceIds

class HasSourceInstanceId s a | s -> a where
    sourceInstanceId :: Lens' s (TF.Argument "source_instance_id" a)

instance HasSourceInstanceId s a => HasSourceInstanceId (TF.Resource p s) a where
    sourceInstanceId = TF.configuration . sourceInstanceId

class HasSourceSecurityGroupId s a | s -> a where
    sourceSecurityGroupId :: Lens' s (TF.Argument "source_security_group_id" a)

instance HasSourceSecurityGroupId s a => HasSourceSecurityGroupId (TF.Resource p s) a where
    sourceSecurityGroupId = TF.configuration . sourceSecurityGroupId

class HasSourceType s a | s -> a where
    sourceType :: Lens' s (TF.Argument "source_type" a)

instance HasSourceType s a => HasSourceType (TF.Resource p s) a where
    sourceType = TF.configuration . sourceType

class HasSpotPrice s a | s -> a where
    spotPrice :: Lens' s (TF.Argument "spot_price" a)

instance HasSpotPrice s a => HasSpotPrice (TF.Resource p s) a where
    spotPrice = TF.configuration . spotPrice

class HasSpotType s a | s -> a where
    spotType :: Lens' s (TF.Argument "spot_type" a)

instance HasSpotType s a => HasSpotType (TF.Resource p s) a where
    spotType = TF.configuration . spotType

class HasSqlInjectionMatchTuples s a | s -> a where
    sqlInjectionMatchTuples :: Lens' s (TF.Argument "sql_injection_match_tuples" a)

instance HasSqlInjectionMatchTuples s a => HasSqlInjectionMatchTuples (TF.Resource p s) a where
    sqlInjectionMatchTuples = TF.configuration . sqlInjectionMatchTuples

class HasSshKeyName s a | s -> a where
    sshKeyName :: Lens' s (TF.Argument "ssh_key_name" a)

instance HasSshKeyName s a => HasSshKeyName (TF.Resource p s) a where
    sshKeyName = TF.configuration . sshKeyName

class HasSshPublicKey s a | s -> a where
    sshPublicKey :: Lens' s (TF.Argument "ssh_public_key" a)

instance HasSshPublicKey s a => HasSshPublicKey (TF.Resource p s) a where
    sshPublicKey = TF.configuration . sshPublicKey

class HasSshUsername s a | s -> a where
    sshUsername :: Lens' s (TF.Argument "ssh_username" a)

instance HasSshUsername s a => HasSshUsername (TF.Resource p s) a where
    sshUsername = TF.configuration . sshUsername

class HasSslConfiguration s a | s -> a where
    sslConfiguration :: Lens' s (TF.Argument "ssl_configuration" a)

instance HasSslConfiguration s a => HasSslConfiguration (TF.Resource p s) a where
    sslConfiguration = TF.configuration . sslConfiguration

class HasSslMode s a | s -> a where
    sslMode :: Lens' s (TF.Argument "ssl_mode" a)

instance HasSslMode s a => HasSslMode (TF.Resource p s) a where
    sslMode = TF.configuration . sslMode

class HasSslPolicy s a | s -> a where
    sslPolicy :: Lens' s (TF.Argument "ssl_policy" a)

instance HasSslPolicy s a => HasSslPolicy (TF.Resource p s) a where
    sslPolicy = TF.configuration . sslPolicy

class HasStackId s a | s -> a where
    stackId :: Lens' s (TF.Argument "stack_id" a)

instance HasStackId s a => HasStackId (TF.Resource p s) a where
    stackId = TF.configuration . stackId

class HasStage s a | s -> a where
    stage :: Lens' s (TF.Argument "stage" a)

instance HasStage s a => HasStage (TF.Resource p s) a where
    stage = TF.configuration . stage

class HasStageDescription s a | s -> a where
    stageDescription :: Lens' s (TF.Argument "stage_description" a)

instance HasStageDescription s a => HasStageDescription (TF.Resource p s) a where
    stageDescription = TF.configuration . stageDescription

class HasStageKey s a | s -> a where
    stageKey :: Lens' s (TF.Argument "stage_key" a)

instance HasStageKey s a => HasStageKey (TF.Resource p s) a where
    stageKey = TF.configuration . stageKey

class HasStageName s a | s -> a where
    stageName :: Lens' s (TF.Argument "stage_name" a)

instance HasStageName s a => HasStageName (TF.Resource p s) a where
    stageName = TF.configuration . stageName

class HasStartTime s a | s -> a where
    startTime :: Lens' s (TF.Argument "start_time" a)

instance HasStartTime s a => HasStartTime (TF.Resource p s) a where
    startTime = TF.configuration . startTime

class HasStartingPosition s a | s -> a where
    startingPosition :: Lens' s (TF.Argument "starting_position" a)

instance HasStartingPosition s a => HasStartingPosition (TF.Resource p s) a where
    startingPosition = TF.configuration . startingPosition

class HasState s a | s -> a where
    state :: Lens' s (TF.Argument "state" a)

instance HasState s a => HasState (TF.Resource p s) a where
    state = TF.configuration . state

class HasStatementId s a | s -> a where
    statementId :: Lens' s (TF.Argument "statement_id" a)

instance HasStatementId s a => HasStatementId (TF.Resource p s) a where
    statementId = TF.configuration . statementId

class HasStaticIpName s a | s -> a where
    staticIpName :: Lens' s (TF.Argument "static_ip_name" a)

instance HasStaticIpName s a => HasStaticIpName (TF.Resource p s) a where
    staticIpName = TF.configuration . staticIpName

class HasStaticRoutesOnly s a | s -> a where
    staticRoutesOnly :: Lens' s (TF.Argument "static_routes_only" a)

instance HasStaticRoutesOnly s a => HasStaticRoutesOnly (TF.Resource p s) a where
    staticRoutesOnly = TF.configuration . staticRoutesOnly

class HasStatistic s a | s -> a where
    statistic :: Lens' s (TF.Argument "statistic" a)

instance HasStatistic s a => HasStatistic (TF.Resource p s) a where
    statistic = TF.configuration . statistic

class HasStatsEnabled s a | s -> a where
    statsEnabled :: Lens' s (TF.Argument "stats_enabled" a)

instance HasStatsEnabled s a => HasStatsEnabled (TF.Resource p s) a where
    statsEnabled = TF.configuration . statsEnabled

class HasStatsPassword s a | s -> a where
    statsPassword :: Lens' s (TF.Argument "stats_password" a)

instance HasStatsPassword s a => HasStatsPassword (TF.Resource p s) a where
    statsPassword = TF.configuration . statsPassword

class HasStatsUrl s a | s -> a where
    statsUrl :: Lens' s (TF.Argument "stats_url" a)

instance HasStatsUrl s a => HasStatsUrl (TF.Resource p s) a where
    statsUrl = TF.configuration . statsUrl

class HasStatsUser s a | s -> a where
    statsUser :: Lens' s (TF.Argument "stats_user" a)

instance HasStatsUser s a => HasStatsUser (TF.Resource p s) a where
    statsUser = TF.configuration . statsUser

class HasStatus s a | s -> a where
    status :: Lens' s (TF.Argument "status" a)

instance HasStatus s a => HasStatus (TF.Resource p s) a where
    status = TF.configuration . status

class HasStatusCode s a | s -> a where
    statusCode :: Lens' s (TF.Argument "status_code" a)

instance HasStatusCode s a => HasStatusCode (TF.Resource p s) a where
    statusCode = TF.configuration . statusCode

class HasStepScalingPolicyConfiguration s a | s -> a where
    stepScalingPolicyConfiguration :: Lens' s (TF.Argument "step_scaling_policy_configuration" a)

instance HasStepScalingPolicyConfiguration s a => HasStepScalingPolicyConfiguration (TF.Resource p s) a where
    stepScalingPolicyConfiguration = TF.configuration . stepScalingPolicyConfiguration

class HasStickiness s a | s -> a where
    stickiness :: Lens' s (TF.Argument "stickiness" a)

instance HasStickiness s a => HasStickiness (TF.Resource p s) a where
    stickiness = TF.configuration . stickiness

class HasStopAction s a | s -> a where
    stopAction :: Lens' s (TF.Argument "stop_action" a)

instance HasStopAction s a => HasStopAction (TF.Resource p s) a where
    stopAction = TF.configuration . stopAction

class HasStorageClass s a | s -> a where
    storageClass :: Lens' s (TF.Argument "storage_class" a)

instance HasStorageClass s a => HasStorageClass (TF.Resource p s) a where
    storageClass = TF.configuration . storageClass

class HasStorageEncrypted s a | s -> a where
    storageEncrypted :: Lens' s (TF.Argument "storage_encrypted" a)

instance HasStorageEncrypted s a => HasStorageEncrypted (TF.Resource p s) a where
    storageEncrypted = TF.configuration . storageEncrypted

class HasStorageType s a | s -> a where
    storageType :: Lens' s (TF.Argument "storage_type" a)

instance HasStorageType s a => HasStorageType (TF.Resource p s) a where
    storageType = TF.configuration . storageType

class HasStrategy s a | s -> a where
    strategy :: Lens' s (TF.Argument "strategy" a)

instance HasStrategy s a => HasStrategy (TF.Resource p s) a where
    strategy = TF.configuration . strategy

class HasStreamEnabled s a | s -> a where
    streamEnabled :: Lens' s (TF.Argument "stream_enabled" a)

instance HasStreamEnabled s a => HasStreamEnabled (TF.Resource p s) a where
    streamEnabled = TF.configuration . streamEnabled

class HasStreamViewType s a | s -> a where
    streamViewType :: Lens' s (TF.Argument "stream_view_type" a)

instance HasStreamViewType s a => HasStreamViewType (TF.Resource p s) a where
    streamViewType = TF.configuration . streamViewType

class HasSubject s a | s -> a where
    subject :: Lens' s (TF.Argument "subject" a)

instance HasSubject s a => HasSubject (TF.Resource p s) a where
    subject = TF.configuration . subject

class HasSubnetGroupName s a | s -> a where
    subnetGroupName :: Lens' s (TF.Argument "subnet_group_name" a)

instance HasSubnetGroupName s a => HasSubnetGroupName (TF.Resource p s) a where
    subnetGroupName = TF.configuration . subnetGroupName

class HasSubnetId s a | s -> a where
    subnetId :: Lens' s (TF.Argument "subnet_id" a)

instance HasSubnetId s a => HasSubnetId (TF.Resource p s) a where
    subnetId = TF.configuration . subnetId

class HasSubnetIds s a | s -> a where
    subnetIds :: Lens' s (TF.Argument "subnet_ids" a)

instance HasSubnetIds s a => HasSubnetIds (TF.Resource p s) a where
    subnetIds = TF.configuration . subnetIds

class HasSubnetMapping s a | s -> a where
    subnetMapping :: Lens' s (TF.Argument "subnet_mapping" a)

instance HasSubnetMapping s a => HasSubnetMapping (TF.Resource p s) a where
    subnetMapping = TF.configuration . subnetMapping

class HasSubnets s a | s -> a where
    subnets :: Lens' s (TF.Argument "subnets" a)

instance HasSubnets s a => HasSubnets (TF.Resource p s) a where
    subnets = TF.configuration . subnets

class HasSupportedIdentityProviders s a | s -> a where
    supportedIdentityProviders :: Lens' s (TF.Argument "supported_identity_providers" a)

instance HasSupportedIdentityProviders s a => HasSupportedIdentityProviders (TF.Resource p s) a where
    supportedIdentityProviders = TF.configuration . supportedIdentityProviders

class HasSupportedLoginProviders s a | s -> a where
    supportedLoginProviders :: Lens' s (TF.Argument "supported_login_providers" a)

instance HasSupportedLoginProviders s a => HasSupportedLoginProviders (TF.Resource p s) a where
    supportedLoginProviders = TF.configuration . supportedLoginProviders

class HasSuspendedProcesses s a | s -> a where
    suspendedProcesses :: Lens' s (TF.Argument "suspended_processes" a)

instance HasSuspendedProcesses s a => HasSuspendedProcesses (TF.Resource p s) a where
    suspendedProcesses = TF.configuration . suspendedProcesses

class HasSystemPackages s a | s -> a where
    systemPackages :: Lens' s (TF.Argument "system_packages" a)

instance HasSystemPackages s a => HasSystemPackages (TF.Resource p s) a where
    systemPackages = TF.configuration . systemPackages

class HasTableMappings s a | s -> a where
    tableMappings :: Lens' s (TF.Argument "table_mappings" a)

instance HasTableMappings s a => HasTableMappings (TF.Resource p s) a where
    tableMappings = TF.configuration . tableMappings

class HasTag s a | s -> a where
    tag :: Lens' s (TF.Argument "tag" a)

instance HasTag s a => HasTag (TF.Resource p s) a where
    tag = TF.configuration . tag

class HasTags s a | s -> a where
    tags :: Lens' s (TF.Argument "tags" a)

instance HasTags s a => HasTags (TF.Resource p s) a where
    tags = TF.configuration . tags

class HasTargetArn s a | s -> a where
    targetArn :: Lens' s (TF.Argument "target_arn" a)

instance HasTargetArn s a => HasTargetArn (TF.Resource p s) a where
    targetArn = TF.configuration . targetArn

class HasTargetCapacity s a | s -> a where
    targetCapacity :: Lens' s (TF.Argument "target_capacity" a)

instance HasTargetCapacity s a => HasTargetCapacity (TF.Resource p s) a where
    targetCapacity = TF.configuration . targetCapacity

class HasTargetEndpointArn s a | s -> a where
    targetEndpointArn :: Lens' s (TF.Argument "target_endpoint_arn" a)

instance HasTargetEndpointArn s a => HasTargetEndpointArn (TF.Resource p s) a where
    targetEndpointArn = TF.configuration . targetEndpointArn

class HasTargetGroupArn s a | s -> a where
    targetGroupArn :: Lens' s (TF.Argument "target_group_arn" a)

instance HasTargetGroupArn s a => HasTargetGroupArn (TF.Resource p s) a where
    targetGroupArn = TF.configuration . targetGroupArn

class HasTargetGroupArns s a | s -> a where
    targetGroupArns :: Lens' s (TF.Argument "target_group_arns" a)

instance HasTargetGroupArns s a => HasTargetGroupArns (TF.Resource p s) a where
    targetGroupArns = TF.configuration . targetGroupArns

class HasTargetId s a | s -> a where
    targetId :: Lens' s (TF.Argument "target_id" a)

instance HasTargetId s a => HasTargetId (TF.Resource p s) a where
    targetId = TF.configuration . targetId

class HasTargetKeyId s a | s -> a where
    targetKeyId :: Lens' s (TF.Argument "target_key_id" a)

instance HasTargetKeyId s a => HasTargetKeyId (TF.Resource p s) a where
    targetKeyId = TF.configuration . targetKeyId

class HasTargetTrackingScalingPolicyConfiguration s a | s -> a where
    targetTrackingScalingPolicyConfiguration :: Lens' s (TF.Argument "target_tracking_scaling_policy_configuration" a)

instance HasTargetTrackingScalingPolicyConfiguration s a => HasTargetTrackingScalingPolicyConfiguration (TF.Resource p s) a where
    targetTrackingScalingPolicyConfiguration = TF.configuration . targetTrackingScalingPolicyConfiguration

class HasTargetType s a | s -> a where
    targetType :: Lens' s (TF.Argument "target_type" a)

instance HasTargetType s a => HasTargetType (TF.Resource p s) a where
    targetType = TF.configuration . targetType

class HasTargets s a | s -> a where
    targets :: Lens' s (TF.Argument "targets" a)

instance HasTargets s a => HasTargets (TF.Resource p s) a where
    targets = TF.configuration . targets

class HasTaskArn s a | s -> a where
    taskArn :: Lens' s (TF.Argument "task_arn" a)

instance HasTaskArn s a => HasTaskArn (TF.Resource p s) a where
    taskArn = TF.configuration . taskArn

class HasTaskDefinition s a | s -> a where
    taskDefinition :: Lens' s (TF.Argument "task_definition" a)

instance HasTaskDefinition s a => HasTaskDefinition (TF.Resource p s) a where
    taskDefinition = TF.configuration . taskDefinition

class HasTaskParameters s a | s -> a where
    taskParameters :: Lens' s (TF.Argument "task_parameters" a)

instance HasTaskParameters s a => HasTaskParameters (TF.Resource p s) a where
    taskParameters = TF.configuration . taskParameters

class HasTaskType s a | s -> a where
    taskType :: Lens' s (TF.Argument "task_type" a)

instance HasTaskType s a => HasTaskType (TF.Resource p s) a where
    taskType = TF.configuration . taskType

class HasTemplateBody s a | s -> a where
    templateBody :: Lens' s (TF.Argument "template_body" a)

instance HasTemplateBody s a => HasTemplateBody (TF.Resource p s) a where
    templateBody = TF.configuration . templateBody

class HasTemplateName s a | s -> a where
    templateName :: Lens' s (TF.Argument "template_name" a)

instance HasTemplateName s a => HasTemplateName (TF.Resource p s) a where
    templateName = TF.configuration . templateName

class HasTemplateUrl s a | s -> a where
    templateUrl :: Lens' s (TF.Argument "template_url" a)

instance HasTemplateUrl s a => HasTemplateUrl (TF.Resource p s) a where
    templateUrl = TF.configuration . templateUrl

class HasTenancy s a | s -> a where
    tenancy :: Lens' s (TF.Argument "tenancy" a)

instance HasTenancy s a => HasTenancy (TF.Resource p s) a where
    tenancy = TF.configuration . tenancy

class HasTerminateInstancesWithExpiration s a | s -> a where
    terminateInstancesWithExpiration :: Lens' s (TF.Argument "terminate_instances_with_expiration" a)

instance HasTerminateInstancesWithExpiration s a => HasTerminateInstancesWithExpiration (TF.Resource p s) a where
    terminateInstancesWithExpiration = TF.configuration . terminateInstancesWithExpiration

class HasTerminationPolicies s a | s -> a where
    terminationPolicies :: Lens' s (TF.Argument "termination_policies" a)

instance HasTerminationPolicies s a => HasTerminationPolicies (TF.Resource p s) a where
    terminationPolicies = TF.configuration . terminationPolicies

class HasTerminationProtection s a | s -> a where
    terminationProtection :: Lens' s (TF.Argument "termination_protection" a)

instance HasTerminationProtection s a => HasTerminationProtection (TF.Resource p s) a where
    terminationProtection = TF.configuration . terminationProtection

class HasText s a | s -> a where
    text :: Lens' s (TF.Argument "text" a)

instance HasText s a => HasText (TF.Resource p s) a where
    text = TF.configuration . text

class HasThreshold s a | s -> a where
    threshold :: Lens' s (TF.Argument "threshold" a)

instance HasThreshold s a => HasThreshold (TF.Resource p s) a where
    threshold = TF.configuration . threshold

class HasThrottleSettings s a | s -> a where
    throttleSettings :: Lens' s (TF.Argument "throttle_settings" a)

instance HasThrottleSettings s a => HasThrottleSettings (TF.Resource p s) a where
    throttleSettings = TF.configuration . throttleSettings

class HasThumbnailConfig s a | s -> a where
    thumbnailConfig :: Lens' s (TF.Argument "thumbnail_config" a)

instance HasThumbnailConfig s a => HasThumbnailConfig (TF.Resource p s) a where
    thumbnailConfig = TF.configuration . thumbnailConfig

class HasThumbnailConfigPermissions s a | s -> a where
    thumbnailConfigPermissions :: Lens' s (TF.Argument "thumbnail_config_permissions" a)

instance HasThumbnailConfigPermissions s a => HasThumbnailConfigPermissions (TF.Resource p s) a where
    thumbnailConfigPermissions = TF.configuration . thumbnailConfigPermissions

class HasThumbnails s a | s -> a where
    thumbnails :: Lens' s (TF.Argument "thumbnails" a)

instance HasThumbnails s a => HasThumbnails (TF.Resource p s) a where
    thumbnails = TF.configuration . thumbnails

class HasThumbprintList s a | s -> a where
    thumbprintList :: Lens' s (TF.Argument "thumbprint_list" a)

instance HasThumbprintList s a => HasThumbprintList (TF.Resource p s) a where
    thumbprintList = TF.configuration . thumbprintList

class HasTier s a | s -> a where
    tier :: Lens' s (TF.Argument "tier" a)

instance HasTier s a => HasTier (TF.Resource p s) a where
    tier = TF.configuration . tier

class HasTimeout s a | s -> a where
    timeout :: Lens' s (TF.Argument "timeout" a)

instance HasTimeout s a => HasTimeout (TF.Resource p s) a where
    timeout = TF.configuration . timeout

class HasTimeoutInMinutes s a | s -> a where
    timeoutInMinutes :: Lens' s (TF.Argument "timeout_in_minutes" a)

instance HasTimeoutInMinutes s a => HasTimeoutInMinutes (TF.Resource p s) a where
    timeoutInMinutes = TF.configuration . timeoutInMinutes

class HasTimezone s a | s -> a where
    timezone :: Lens' s (TF.Argument "timezone" a)

instance HasTimezone s a => HasTimezone (TF.Resource p s) a where
    timezone = TF.configuration . timezone

class HasTlsPolicy s a | s -> a where
    tlsPolicy :: Lens' s (TF.Argument "tls_policy" a)

instance HasTlsPolicy s a => HasTlsPolicy (TF.Resource p s) a where
    tlsPolicy = TF.configuration . tlsPolicy

class HasToPort s a | s -> a where
    toPort :: Lens' s (TF.Argument "to_port" a)

instance HasToPort s a => HasToPort (TF.Resource p s) a where
    toPort = TF.configuration . toPort

class HasTopic s a | s -> a where
    topic :: Lens' s (TF.Argument "topic" a)

instance HasTopic s a => HasTopic (TF.Resource p s) a where
    topic = TF.configuration . topic

class HasTopicArn s a | s -> a where
    topicArn :: Lens' s (TF.Argument "topic_arn" a)

instance HasTopicArn s a => HasTopicArn (TF.Resource p s) a where
    topicArn = TF.configuration . topicArn

class HasTrafficType s a | s -> a where
    trafficType :: Lens' s (TF.Argument "traffic_type" a)

instance HasTrafficType s a => HasTrafficType (TF.Resource p s) a where
    trafficType = TF.configuration . trafficType

class HasTransitEncryptionEnabled s a | s -> a where
    transitEncryptionEnabled :: Lens' s (TF.Argument "transit_encryption_enabled" a)

instance HasTransitEncryptionEnabled s a => HasTransitEncryptionEnabled (TF.Resource p s) a where
    transitEncryptionEnabled = TF.configuration . transitEncryptionEnabled

class HasTreatMissingData s a | s -> a where
    treatMissingData :: Lens' s (TF.Argument "treat_missing_data" a)

instance HasTreatMissingData s a => HasTreatMissingData (TF.Resource p s) a where
    treatMissingData = TF.configuration . treatMissingData

class HasTriggerConfiguration s a | s -> a where
    triggerConfiguration :: Lens' s (TF.Argument "trigger_configuration" a)

instance HasTriggerConfiguration s a => HasTriggerConfiguration (TF.Resource p s) a where
    triggerConfiguration = TF.configuration . triggerConfiguration

class HasTtl s a | s -> a where
    ttl :: Lens' s (TF.Argument "ttl" a)

instance HasTtl s a => HasTtl (TF.Resource p s) a where
    ttl = TF.configuration . ttl

class HasType' s a | s -> a where
    type' :: Lens' s (TF.Argument "type" a)

instance HasType' s a => HasType' (TF.Resource p s) a where
    type' = TF.configuration . type'

class HasUnit s a | s -> a where
    unit :: Lens' s (TF.Argument "unit" a)

instance HasUnit s a => HasUnit (TF.Resource p s) a where
    unit = TF.configuration . unit

class HasUri s a | s -> a where
    uri :: Lens' s (TF.Argument "uri" a)

instance HasUri s a => HasUri (TF.Resource p s) a where
    uri = TF.configuration . uri

class HasUrl s a | s -> a where
    url :: Lens' s (TF.Argument "url" a)

instance HasUrl s a => HasUrl (TF.Resource p s) a where
    url = TF.configuration . url

class HasUsagePlanId s a | s -> a where
    usagePlanId :: Lens' s (TF.Argument "usage_plan_id" a)

instance HasUsagePlanId s a => HasUsagePlanId (TF.Resource p s) a where
    usagePlanId = TF.configuration . usagePlanId

class HasUseCustomCookbooks s a | s -> a where
    useCustomCookbooks :: Lens' s (TF.Argument "use_custom_cookbooks" a)

instance HasUseCustomCookbooks s a => HasUseCustomCookbooks (TF.Resource p s) a where
    useCustomCookbooks = TF.configuration . useCustomCookbooks

class HasUseEbsOptimizedInstances s a | s -> a where
    useEbsOptimizedInstances :: Lens' s (TF.Argument "use_ebs_optimized_instances" a)

instance HasUseEbsOptimizedInstances s a => HasUseEbsOptimizedInstances (TF.Resource p s) a where
    useEbsOptimizedInstances = TF.configuration . useEbsOptimizedInstances

class HasUseOpsworksSecurityGroups s a | s -> a where
    useOpsworksSecurityGroups :: Lens' s (TF.Argument "use_opsworks_security_groups" a)

instance HasUseOpsworksSecurityGroups s a => HasUseOpsworksSecurityGroups (TF.Resource p s) a where
    useOpsworksSecurityGroups = TF.configuration . useOpsworksSecurityGroups

class HasUser s a | s -> a where
    user :: Lens' s (TF.Argument "user" a)

instance HasUser s a => HasUser (TF.Resource p s) a where
    user = TF.configuration . user

class HasUserArn s a | s -> a where
    userArn :: Lens' s (TF.Argument "user_arn" a)

instance HasUserArn s a => HasUserArn (TF.Resource p s) a where
    userArn = TF.configuration . userArn

class HasUserData s a | s -> a where
    userData :: Lens' s (TF.Argument "user_data" a)

instance HasUserData s a => HasUserData (TF.Resource p s) a where
    userData = TF.configuration . userData

class HasUserDataBase64 s a | s -> a where
    userDataBase64 :: Lens' s (TF.Argument "user_data_base64" a)

instance HasUserDataBase64 s a => HasUserDataBase64 (TF.Resource p s) a where
    userDataBase64 = TF.configuration . userDataBase64

class HasUserPoolId s a | s -> a where
    userPoolId :: Lens' s (TF.Argument "user_pool_id" a)

instance HasUserPoolId s a => HasUserPoolId (TF.Resource p s) a where
    userPoolId = TF.configuration . userPoolId

class HasUsername s a | s -> a where
    username :: Lens' s (TF.Argument "username" a)

instance HasUsername s a => HasUsername (TF.Resource p s) a where
    username = TF.configuration . username

class HasUsernameAttributes s a | s -> a where
    usernameAttributes :: Lens' s (TF.Argument "username_attributes" a)

instance HasUsernameAttributes s a => HasUsernameAttributes (TF.Resource p s) a where
    usernameAttributes = TF.configuration . usernameAttributes

class HasUsers s a | s -> a where
    users :: Lens' s (TF.Argument "users" a)

instance HasUsers s a => HasUsers (TF.Resource p s) a where
    users = TF.configuration . users

class HasValidUntil s a | s -> a where
    validUntil :: Lens' s (TF.Argument "valid_until" a)

instance HasValidUntil s a => HasValidUntil (TF.Resource p s) a where
    validUntil = TF.configuration . validUntil

class HasValue s a | s -> a where
    value :: Lens' s (TF.Argument "value" a)

instance HasValue s a => HasValue (TF.Resource p s) a where
    value = TF.configuration . value

class HasVariables s a | s -> a where
    variables :: Lens' s (TF.Argument "variables" a)

instance HasVariables s a => HasVariables (TF.Resource p s) a where
    variables = TF.configuration . variables

class HasVerificationMessageTemplate s a | s -> a where
    verificationMessageTemplate :: Lens' s (TF.Argument "verification_message_template" a)

instance HasVerificationMessageTemplate s a => HasVerificationMessageTemplate (TF.Resource p s) a where
    verificationMessageTemplate = TF.configuration . verificationMessageTemplate

class HasVersionLabel s a | s -> a where
    versionLabel :: Lens' s (TF.Argument "version_label" a)

instance HasVersionLabel s a => HasVersionLabel (TF.Resource p s) a where
    versionLabel = TF.configuration . versionLabel

class HasVersioning s a | s -> a where
    versioning :: Lens' s (TF.Argument "versioning" a)

instance HasVersioning s a => HasVersioning (TF.Resource p s) a where
    versioning = TF.configuration . versioning

class HasVideo s a | s -> a where
    video :: Lens' s (TF.Argument "video" a)

instance HasVideo s a => HasVideo (TF.Resource p s) a where
    video = TF.configuration . video

class HasVideoCodecOptions s a | s -> a where
    videoCodecOptions :: Lens' s (TF.Argument "video_codec_options" a)

instance HasVideoCodecOptions s a => HasVideoCodecOptions (TF.Resource p s) a where
    videoCodecOptions = TF.configuration . videoCodecOptions

class HasVideoWatermarks s a | s -> a where
    videoWatermarks :: Lens' s (TF.Argument "video_watermarks" a)

instance HasVideoWatermarks s a => HasVideoWatermarks (TF.Resource p s) a where
    videoWatermarks = TF.configuration . videoWatermarks

class HasViewerCertificate s a | s -> a where
    viewerCertificate :: Lens' s (TF.Argument "viewer_certificate" a)

instance HasViewerCertificate s a => HasViewerCertificate (TF.Resource p s) a where
    viewerCertificate = TF.configuration . viewerCertificate

class HasVirtualizationType s a | s -> a where
    virtualizationType :: Lens' s (TF.Argument "virtualization_type" a)

instance HasVirtualizationType s a => HasVirtualizationType (TF.Resource p s) a where
    virtualizationType = TF.configuration . virtualizationType

class HasVisibilityTimeoutSeconds s a | s -> a where
    visibilityTimeoutSeconds :: Lens' s (TF.Argument "visibility_timeout_seconds" a)

instance HasVisibilityTimeoutSeconds s a => HasVisibilityTimeoutSeconds (TF.Resource p s) a where
    visibilityTimeoutSeconds = TF.configuration . visibilityTimeoutSeconds

class HasVisibleToAllUsers s a | s -> a where
    visibleToAllUsers :: Lens' s (TF.Argument "visible_to_all_users" a)

instance HasVisibleToAllUsers s a => HasVisibleToAllUsers (TF.Resource p s) a where
    visibleToAllUsers = TF.configuration . visibleToAllUsers

class HasVolumeId s a | s -> a where
    volumeId :: Lens' s (TF.Argument "volume_id" a)

instance HasVolumeId s a => HasVolumeId (TF.Resource p s) a where
    volumeId = TF.configuration . volumeId

class HasVolumeTags s a | s -> a where
    volumeTags :: Lens' s (TF.Argument "volume_tags" a)

instance HasVolumeTags s a => HasVolumeTags (TF.Resource p s) a where
    volumeTags = TF.configuration . volumeTags

class HasVpc s a | s -> a where
    vpc :: Lens' s (TF.Argument "vpc" a)

instance HasVpc s a => HasVpc (TF.Resource p s) a where
    vpc = TF.configuration . vpc

class HasVpcClassicLinkId s a | s -> a where
    vpcClassicLinkId :: Lens' s (TF.Argument "vpc_classic_link_id" a)

instance HasVpcClassicLinkId s a => HasVpcClassicLinkId (TF.Resource p s) a where
    vpcClassicLinkId = TF.configuration . vpcClassicLinkId

class HasVpcClassicLinkSecurityGroups s a | s -> a where
    vpcClassicLinkSecurityGroups :: Lens' s (TF.Argument "vpc_classic_link_security_groups" a)

instance HasVpcClassicLinkSecurityGroups s a => HasVpcClassicLinkSecurityGroups (TF.Resource p s) a where
    vpcClassicLinkSecurityGroups = TF.configuration . vpcClassicLinkSecurityGroups

class HasVpcConfig s a | s -> a where
    vpcConfig :: Lens' s (TF.Argument "vpc_config" a)

instance HasVpcConfig s a => HasVpcConfig (TF.Resource p s) a where
    vpcConfig = TF.configuration . vpcConfig

class HasVpcEndpointId s a | s -> a where
    vpcEndpointId :: Lens' s (TF.Argument "vpc_endpoint_id" a)

instance HasVpcEndpointId s a => HasVpcEndpointId (TF.Resource p s) a where
    vpcEndpointId = TF.configuration . vpcEndpointId

class HasVpcId s a | s -> a where
    vpcId :: Lens' s (TF.Argument "vpc_id" a)

instance HasVpcId s a => HasVpcId (TF.Resource p s) a where
    vpcId = TF.configuration . vpcId

class HasVpcOptions s a | s -> a where
    vpcOptions :: Lens' s (TF.Argument "vpc_options" a)

instance HasVpcOptions s a => HasVpcOptions (TF.Resource p s) a where
    vpcOptions = TF.configuration . vpcOptions

class HasVpcPeeringConnectionId s a | s -> a where
    vpcPeeringConnectionId :: Lens' s (TF.Argument "vpc_peering_connection_id" a)

instance HasVpcPeeringConnectionId s a => HasVpcPeeringConnectionId (TF.Resource p s) a where
    vpcPeeringConnectionId = TF.configuration . vpcPeeringConnectionId

class HasVpcRegion s a | s -> a where
    vpcRegion :: Lens' s (TF.Argument "vpc_region" a)

instance HasVpcRegion s a => HasVpcRegion (TF.Resource p s) a where
    vpcRegion = TF.configuration . vpcRegion

class HasVpcSecurityGroupIds s a | s -> a where
    vpcSecurityGroupIds :: Lens' s (TF.Argument "vpc_security_group_ids" a)

instance HasVpcSecurityGroupIds s a => HasVpcSecurityGroupIds (TF.Resource p s) a where
    vpcSecurityGroupIds = TF.configuration . vpcSecurityGroupIds

class HasVpcSettings s a | s -> a where
    vpcSettings :: Lens' s (TF.Argument "vpc_settings" a)

instance HasVpcSettings s a => HasVpcSettings (TF.Resource p s) a where
    vpcSettings = TF.configuration . vpcSettings

class HasVpcZoneIdentifier s a | s -> a where
    vpcZoneIdentifier :: Lens' s (TF.Argument "vpc_zone_identifier" a)

instance HasVpcZoneIdentifier s a => HasVpcZoneIdentifier (TF.Resource p s) a where
    vpcZoneIdentifier = TF.configuration . vpcZoneIdentifier

class HasVpnConnectionId s a | s -> a where
    vpnConnectionId :: Lens' s (TF.Argument "vpn_connection_id" a)

instance HasVpnConnectionId s a => HasVpnConnectionId (TF.Resource p s) a where
    vpnConnectionId = TF.configuration . vpnConnectionId

class HasVpnGatewayId s a | s -> a where
    vpnGatewayId :: Lens' s (TF.Argument "vpn_gateway_id" a)

instance HasVpnGatewayId s a => HasVpnGatewayId (TF.Resource p s) a where
    vpnGatewayId = TF.configuration . vpnGatewayId

class HasWaitForCapacityTimeout s a | s -> a where
    waitForCapacityTimeout :: Lens' s (TF.Argument "wait_for_capacity_timeout" a)

instance HasWaitForCapacityTimeout s a => HasWaitForCapacityTimeout (TF.Resource p s) a where
    waitForCapacityTimeout = TF.configuration . waitForCapacityTimeout

class HasWaitForElbCapacity s a | s -> a where
    waitForElbCapacity :: Lens' s (TF.Argument "wait_for_elb_capacity" a)

instance HasWaitForElbCapacity s a => HasWaitForElbCapacity (TF.Resource p s) a where
    waitForElbCapacity = TF.configuration . waitForElbCapacity

class HasWaitForFulfillment s a | s -> a where
    waitForFulfillment :: Lens' s (TF.Argument "wait_for_fulfillment" a)

instance HasWaitForFulfillment s a => HasWaitForFulfillment (TF.Resource p s) a where
    waitForFulfillment = TF.configuration . waitForFulfillment

class HasWaitForReadyTimeout s a | s -> a where
    waitForReadyTimeout :: Lens' s (TF.Argument "wait_for_ready_timeout" a)

instance HasWaitForReadyTimeout s a => HasWaitForReadyTimeout (TF.Resource p s) a where
    waitForReadyTimeout = TF.configuration . waitForReadyTimeout

class HasWebAclId s a | s -> a where
    webAclId :: Lens' s (TF.Argument "web_acl_id" a)

instance HasWebAclId s a => HasWebAclId (TF.Resource p s) a where
    webAclId = TF.configuration . webAclId

class HasWebsite s a | s -> a where
    website :: Lens' s (TF.Argument "website" a)

instance HasWebsite s a => HasWebsite (TF.Resource p s) a where
    website = TF.configuration . website

class HasWebsiteRedirect s a | s -> a where
    websiteRedirect :: Lens' s (TF.Argument "website_redirect" a)

instance HasWebsiteRedirect s a => HasWebsiteRedirect (TF.Resource p s) a where
    websiteRedirect = TF.configuration . websiteRedirect

class HasWeightedRoutingPolicy s a | s -> a where
    weightedRoutingPolicy :: Lens' s (TF.Argument "weighted_routing_policy" a)

instance HasWeightedRoutingPolicy s a => HasWeightedRoutingPolicy (TF.Resource p s) a where
    weightedRoutingPolicy = TF.configuration . weightedRoutingPolicy

class HasWindowId s a | s -> a where
    windowId :: Lens' s (TF.Argument "window_id" a)

instance HasWindowId s a => HasWindowId (TF.Resource p s) a where
    windowId = TF.configuration . windowId

class HasWorkmailAction s a | s -> a where
    workmailAction :: Lens' s (TF.Argument "workmail_action" a)

instance HasWorkmailAction s a => HasWorkmailAction (TF.Resource p s) a where
    workmailAction = TF.configuration . workmailAction

class HasWriteAttributes s a | s -> a where
    writeAttributes :: Lens' s (TF.Argument "write_attributes" a)

instance HasWriteAttributes s a => HasWriteAttributes (TF.Resource p s) a where
    writeAttributes = TF.configuration . writeAttributes

class HasWriteCapacity s a | s -> a where
    writeCapacity :: Lens' s (TF.Argument "write_capacity" a)

instance HasWriteCapacity s a => HasWriteCapacity (TF.Resource p s) a where
    writeCapacity = TF.configuration . writeCapacity

class HasXssMatchTuples s a | s -> a where
    xssMatchTuples :: Lens' s (TF.Argument "xss_match_tuples" a)

instance HasXssMatchTuples s a => HasXssMatchTuples (TF.Resource p s) a where
    xssMatchTuples = TF.configuration . xssMatchTuples

class HasZoneId s a | s -> a where
    zoneId :: Lens' s (TF.Argument "zone_id" a)

instance HasZoneId s a => HasZoneId (TF.Resource p s) a where
    zoneId = TF.configuration . zoneId

class HasComputedAccessUrl s a | s -> a where
    computedAccessUrl :: forall r. Getting r s (TF.Attribute a)

instance HasComputedAccessUrl s a => HasComputedAccessUrl (TF.Resource p s) a where
    computedAccessUrl = TF.configuration . computedAccessUrl

class HasComputedAccountId s a | s -> a where
    computedAccountId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedAccountId s a => HasComputedAccountId (TF.Resource p s) a where
    computedAccountId = TF.configuration . computedAccountId

class HasComputedActivationCode s a | s -> a where
    computedActivationCode :: forall r. Getting r s (TF.Attribute a)

instance HasComputedActivationCode s a => HasComputedActivationCode (TF.Resource p s) a where
    computedActivationCode = TF.configuration . computedActivationCode

class HasComputedAdjustmentType s a | s -> a where
    computedAdjustmentType :: forall r. Getting r s (TF.Attribute a)

instance HasComputedAdjustmentType s a => HasComputedAdjustmentType (TF.Resource p s) a where
    computedAdjustmentType = TF.configuration . computedAdjustmentType

class HasComputedAllocatedStorage s a | s -> a where
    computedAllocatedStorage :: forall r. Getting r s (TF.Attribute a)

instance HasComputedAllocatedStorage s a => HasComputedAllocatedStorage (TF.Resource p s) a where
    computedAllocatedStorage = TF.configuration . computedAllocatedStorage

class HasComputedAllocationId s a | s -> a where
    computedAllocationId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedAllocationId s a => HasComputedAllocationId (TF.Resource p s) a where
    computedAllocationId = TF.configuration . computedAllocationId

class HasComputedArn s a | s -> a where
    computedArn :: forall r. Getting r s (TF.Attribute a)

instance HasComputedArn s a => HasComputedArn (TF.Resource p s) a where
    computedArn = TF.configuration . computedArn

class HasComputedArnSuffix s a | s -> a where
    computedArnSuffix :: forall r. Getting r s (TF.Attribute a)

instance HasComputedArnSuffix s a => HasComputedArnSuffix (TF.Resource p s) a where
    computedArnSuffix = TF.configuration . computedArnSuffix

class HasComputedAssociateWithPrivateIp s a | s -> a where
    computedAssociateWithPrivateIp :: forall r. Getting r s (TF.Attribute a)

instance HasComputedAssociateWithPrivateIp s a => HasComputedAssociateWithPrivateIp (TF.Resource p s) a where
    computedAssociateWithPrivateIp = TF.configuration . computedAssociateWithPrivateIp

class HasComputedAssociationId s a | s -> a where
    computedAssociationId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedAssociationId s a => HasComputedAssociationId (TF.Resource p s) a where
    computedAssociationId = TF.configuration . computedAssociationId

class HasComputedAttachment s a | s -> a where
    computedAttachment :: forall r. Getting r s (TF.Attribute a)

instance HasComputedAttachment s a => HasComputedAttachment (TF.Resource p s) a where
    computedAttachment = TF.configuration . computedAttachment

class HasComputedAttachmentId s a | s -> a where
    computedAttachmentId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedAttachmentId s a => HasComputedAttachmentId (TF.Resource p s) a where
    computedAttachmentId = TF.configuration . computedAttachmentId

class HasComputedAttribute s a | s -> a where
    computedAttribute :: forall r. Getting r s (TF.Attribute a)

instance HasComputedAttribute s a => HasComputedAttribute (TF.Resource p s) a where
    computedAttribute = TF.configuration . computedAttribute

class HasComputedAutoscalingGroupName s a | s -> a where
    computedAutoscalingGroupName :: forall r. Getting r s (TF.Attribute a)

instance HasComputedAutoscalingGroupName s a => HasComputedAutoscalingGroupName (TF.Resource p s) a where
    computedAutoscalingGroupName = TF.configuration . computedAutoscalingGroupName

class HasComputedAvailabilityZone s a | s -> a where
    computedAvailabilityZone :: forall r. Getting r s (TF.Attribute a)

instance HasComputedAvailabilityZone s a => HasComputedAvailabilityZone (TF.Resource p s) a where
    computedAvailabilityZone = TF.configuration . computedAvailabilityZone

class HasComputedAvailabilityZones s a | s -> a where
    computedAvailabilityZones :: forall r. Getting r s (TF.Attribute a)

instance HasComputedAvailabilityZones s a => HasComputedAvailabilityZones (TF.Resource p s) a where
    computedAvailabilityZones = TF.configuration . computedAvailabilityZones

class HasComputedAwsAccountId s a | s -> a where
    computedAwsAccountId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedAwsAccountId s a => HasComputedAwsAccountId (TF.Resource p s) a where
    computedAwsAccountId = TF.configuration . computedAwsAccountId

class HasComputedBackupRetentionPeriod s a | s -> a where
    computedBackupRetentionPeriod :: forall r. Getting r s (TF.Attribute a)

instance HasComputedBackupRetentionPeriod s a => HasComputedBackupRetentionPeriod (TF.Resource p s) a where
    computedBackupRetentionPeriod = TF.configuration . computedBackupRetentionPeriod

class HasComputedBgpAsn s a | s -> a where
    computedBgpAsn :: forall r. Getting r s (TF.Attribute a)

instance HasComputedBgpAsn s a => HasComputedBgpAsn (TF.Resource p s) a where
    computedBgpAsn = TF.configuration . computedBgpAsn

class HasComputedBucketDomainName s a | s -> a where
    computedBucketDomainName :: forall r. Getting r s (TF.Attribute a)

instance HasComputedBucketDomainName s a => HasComputedBucketDomainName (TF.Resource p s) a where
    computedBucketDomainName = TF.configuration . computedBucketDomainName

class HasComputedCacheNodes s a | s -> a where
    computedCacheNodes :: forall r. Getting r s (TF.Attribute a)

instance HasComputedCacheNodes s a => HasComputedCacheNodes (TF.Resource p s) a where
    computedCacheNodes = TF.configuration . computedCacheNodes

class HasComputedCallerReference s a | s -> a where
    computedCallerReference :: forall r. Getting r s (TF.Attribute a)

instance HasComputedCallerReference s a => HasComputedCallerReference (TF.Resource p s) a where
    computedCallerReference = TF.configuration . computedCallerReference

class HasComputedCanonicalHostedZoneId s a | s -> a where
    computedCanonicalHostedZoneId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedCanonicalHostedZoneId s a => HasComputedCanonicalHostedZoneId (TF.Resource p s) a where
    computedCanonicalHostedZoneId = TF.configuration . computedCanonicalHostedZoneId

class HasComputedCertificateArn s a | s -> a where
    computedCertificateArn :: forall r. Getting r s (TF.Attribute a)

instance HasComputedCertificateArn s a => HasComputedCertificateArn (TF.Resource p s) a where
    computedCertificateArn = TF.configuration . computedCertificateArn

class HasComputedCertificateUploadDate s a | s -> a where
    computedCertificateUploadDate :: forall r. Getting r s (TF.Attribute a)

instance HasComputedCertificateUploadDate s a => HasComputedCertificateUploadDate (TF.Resource p s) a where
    computedCertificateUploadDate = TF.configuration . computedCertificateUploadDate

class HasComputedCidrBlock s a | s -> a where
    computedCidrBlock :: forall r. Getting r s (TF.Attribute a)

instance HasComputedCidrBlock s a => HasComputedCidrBlock (TF.Resource p s) a where
    computedCidrBlock = TF.configuration . computedCidrBlock

class HasComputedCidrBlocks s a | s -> a where
    computedCidrBlocks :: forall r. Getting r s (TF.Attribute a)

instance HasComputedCidrBlocks s a => HasComputedCidrBlocks (TF.Resource p s) a where
    computedCidrBlocks = TF.configuration . computedCidrBlocks

class HasComputedClientSecret s a | s -> a where
    computedClientSecret :: forall r. Getting r s (TF.Attribute a)

instance HasComputedClientSecret s a => HasComputedClientSecret (TF.Resource p s) a where
    computedClientSecret = TF.configuration . computedClientSecret

class HasComputedCloneUrlHttp s a | s -> a where
    computedCloneUrlHttp :: forall r. Getting r s (TF.Attribute a)

instance HasComputedCloneUrlHttp s a => HasComputedCloneUrlHttp (TF.Resource p s) a where
    computedCloneUrlHttp = TF.configuration . computedCloneUrlHttp

class HasComputedCloneUrlSsh s a | s -> a where
    computedCloneUrlSsh :: forall r. Getting r s (TF.Attribute a)

instance HasComputedCloneUrlSsh s a => HasComputedCloneUrlSsh (TF.Resource p s) a where
    computedCloneUrlSsh = TF.configuration . computedCloneUrlSsh

class HasComputedCloudfrontAccessIdentityPath s a | s -> a where
    computedCloudfrontAccessIdentityPath :: forall r. Getting r s (TF.Attribute a)

instance HasComputedCloudfrontAccessIdentityPath s a => HasComputedCloudfrontAccessIdentityPath (TF.Resource p s) a where
    computedCloudfrontAccessIdentityPath = TF.configuration . computedCloudfrontAccessIdentityPath

class HasComputedCloudfrontDistributionArn s a | s -> a where
    computedCloudfrontDistributionArn :: forall r. Getting r s (TF.Attribute a)

instance HasComputedCloudfrontDistributionArn s a => HasComputedCloudfrontDistributionArn (TF.Resource p s) a where
    computedCloudfrontDistributionArn = TF.configuration . computedCloudfrontDistributionArn

class HasComputedCloudfrontDomainName s a | s -> a where
    computedCloudfrontDomainName :: forall r. Getting r s (TF.Attribute a)

instance HasComputedCloudfrontDomainName s a => HasComputedCloudfrontDomainName (TF.Resource p s) a where
    computedCloudfrontDomainName = TF.configuration . computedCloudfrontDomainName

class HasComputedCloudfrontZoneId s a | s -> a where
    computedCloudfrontZoneId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedCloudfrontZoneId s a => HasComputedCloudfrontZoneId (TF.Resource p s) a where
    computedCloudfrontZoneId = TF.configuration . computedCloudfrontZoneId

class HasComputedClusterAddress s a | s -> a where
    computedClusterAddress :: forall r. Getting r s (TF.Attribute a)

instance HasComputedClusterAddress s a => HasComputedClusterAddress (TF.Resource p s) a where
    computedClusterAddress = TF.configuration . computedClusterAddress

class HasComputedClusterIdentifier s a | s -> a where
    computedClusterIdentifier :: forall r. Getting r s (TF.Attribute a)

instance HasComputedClusterIdentifier s a => HasComputedClusterIdentifier (TF.Resource p s) a where
    computedClusterIdentifier = TF.configuration . computedClusterIdentifier

class HasComputedClusterMembers s a | s -> a where
    computedClusterMembers :: forall r. Getting r s (TF.Attribute a)

instance HasComputedClusterMembers s a => HasComputedClusterMembers (TF.Resource p s) a where
    computedClusterMembers = TF.configuration . computedClusterMembers

class HasComputedClusterResourceId s a | s -> a where
    computedClusterResourceId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedClusterResourceId s a => HasComputedClusterResourceId (TF.Resource p s) a where
    computedClusterResourceId = TF.configuration . computedClusterResourceId

class HasComputedConfiguration s a | s -> a where
    computedConfiguration :: forall r. Getting r s (TF.Attribute a)

instance HasComputedConfiguration s a => HasComputedConfiguration (TF.Resource p s) a where
    computedConfiguration = TF.configuration . computedConfiguration

class HasComputedConfigurationEndpoint s a | s -> a where
    computedConfigurationEndpoint :: forall r. Getting r s (TF.Attribute a)

instance HasComputedConfigurationEndpoint s a => HasComputedConfigurationEndpoint (TF.Resource p s) a where
    computedConfigurationEndpoint = TF.configuration . computedConfigurationEndpoint

class HasComputedConfigurationEndpointAddress s a | s -> a where
    computedConfigurationEndpointAddress :: forall r. Getting r s (TF.Attribute a)

instance HasComputedConfigurationEndpointAddress s a => HasComputedConfigurationEndpointAddress (TF.Resource p s) a where
    computedConfigurationEndpointAddress = TF.configuration . computedConfigurationEndpointAddress

class HasComputedContent s a | s -> a where
    computedContent :: forall r. Getting r s (TF.Attribute a)

instance HasComputedContent s a => HasComputedContent (TF.Resource p s) a where
    computedContent = TF.configuration . computedContent

class HasComputedCookieExpirationPeriod s a | s -> a where
    computedCookieExpirationPeriod :: forall r. Getting r s (TF.Attribute a)

instance HasComputedCookieExpirationPeriod s a => HasComputedCookieExpirationPeriod (TF.Resource p s) a where
    computedCookieExpirationPeriod = TF.configuration . computedCookieExpirationPeriod

class HasComputedCookieName s a | s -> a where
    computedCookieName :: forall r. Getting r s (TF.Attribute a)

instance HasComputedCookieName s a => HasComputedCookieName (TF.Resource p s) a where
    computedCookieName = TF.configuration . computedCookieName

class HasComputedCreateDate s a | s -> a where
    computedCreateDate :: forall r. Getting r s (TF.Attribute a)

instance HasComputedCreateDate s a => HasComputedCreateDate (TF.Resource p s) a where
    computedCreateDate = TF.configuration . computedCreateDate

class HasComputedCreatedDate s a | s -> a where
    computedCreatedDate :: forall r. Getting r s (TF.Attribute a)

instance HasComputedCreatedDate s a => HasComputedCreatedDate (TF.Resource p s) a where
    computedCreatedDate = TF.configuration . computedCreatedDate

class HasComputedCreationDate s a | s -> a where
    computedCreationDate :: forall r. Getting r s (TF.Attribute a)

instance HasComputedCreationDate s a => HasComputedCreationDate (TF.Resource p s) a where
    computedCreationDate = TF.configuration . computedCreationDate

class HasComputedCustomerGatewayConfiguration s a | s -> a where
    computedCustomerGatewayConfiguration :: forall r. Getting r s (TF.Attribute a)

instance HasComputedCustomerGatewayConfiguration s a => HasComputedCustomerGatewayConfiguration (TF.Resource p s) a where
    computedCustomerGatewayConfiguration = TF.configuration . computedCustomerGatewayConfiguration

class HasComputedCustomerGatewayId s a | s -> a where
    computedCustomerGatewayId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedCustomerGatewayId s a => HasComputedCustomerGatewayId (TF.Resource p s) a where
    computedCustomerGatewayId = TF.configuration . computedCustomerGatewayId

class HasComputedDashboardArn s a | s -> a where
    computedDashboardArn :: forall r. Getting r s (TF.Attribute a)

instance HasComputedDashboardArn s a => HasComputedDashboardArn (TF.Resource p s) a where
    computedDashboardArn = TF.configuration . computedDashboardArn

class HasComputedDataEncryptionKeyId s a | s -> a where
    computedDataEncryptionKeyId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedDataEncryptionKeyId s a => HasComputedDataEncryptionKeyId (TF.Resource p s) a where
    computedDataEncryptionKeyId = TF.configuration . computedDataEncryptionKeyId

class HasComputedDatabaseName s a | s -> a where
    computedDatabaseName :: forall r. Getting r s (TF.Attribute a)

instance HasComputedDatabaseName s a => HasComputedDatabaseName (TF.Resource p s) a where
    computedDatabaseName = TF.configuration . computedDatabaseName

class HasComputedDbSnapshotArn s a | s -> a where
    computedDbSnapshotArn :: forall r. Getting r s (TF.Attribute a)

instance HasComputedDbSnapshotArn s a => HasComputedDbSnapshotArn (TF.Resource p s) a where
    computedDbSnapshotArn = TF.configuration . computedDbSnapshotArn

class HasComputedDbiResourceId s a | s -> a where
    computedDbiResourceId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedDbiResourceId s a => HasComputedDbiResourceId (TF.Resource p s) a where
    computedDbiResourceId = TF.configuration . computedDbiResourceId

class HasComputedDefaultCooldown s a | s -> a where
    computedDefaultCooldown :: forall r. Getting r s (TF.Attribute a)

instance HasComputedDefaultCooldown s a => HasComputedDefaultCooldown (TF.Resource p s) a where
    computedDefaultCooldown = TF.configuration . computedDefaultCooldown

class HasComputedDefaultNetworkAclId s a | s -> a where
    computedDefaultNetworkAclId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedDefaultNetworkAclId s a => HasComputedDefaultNetworkAclId (TF.Resource p s) a where
    computedDefaultNetworkAclId = TF.configuration . computedDefaultNetworkAclId

class HasComputedDefaultRouteTableId s a | s -> a where
    computedDefaultRouteTableId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedDefaultRouteTableId s a => HasComputedDefaultRouteTableId (TF.Resource p s) a where
    computedDefaultRouteTableId = TF.configuration . computedDefaultRouteTableId

class HasComputedDefaultSecurityGroupId s a | s -> a where
    computedDefaultSecurityGroupId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedDefaultSecurityGroupId s a => HasComputedDefaultSecurityGroupId (TF.Resource p s) a where
    computedDefaultSecurityGroupId = TF.configuration . computedDefaultSecurityGroupId

class HasComputedDefaultVersion s a | s -> a where
    computedDefaultVersion :: forall r. Getting r s (TF.Attribute a)

instance HasComputedDefaultVersion s a => HasComputedDefaultVersion (TF.Resource p s) a where
    computedDefaultVersion = TF.configuration . computedDefaultVersion

class HasComputedDefaultVersionId s a | s -> a where
    computedDefaultVersionId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedDefaultVersionId s a => HasComputedDefaultVersionId (TF.Resource p s) a where
    computedDefaultVersionId = TF.configuration . computedDefaultVersionId

class HasComputedDeploymentConfigId s a | s -> a where
    computedDeploymentConfigId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedDeploymentConfigId s a => HasComputedDeploymentConfigId (TF.Resource p s) a where
    computedDeploymentConfigId = TF.configuration . computedDeploymentConfigId

class HasComputedDescription s a | s -> a where
    computedDescription :: forall r. Getting r s (TF.Attribute a)

instance HasComputedDescription s a => HasComputedDescription (TF.Resource p s) a where
    computedDescription = TF.configuration . computedDescription

class HasComputedDesiredCapacity s a | s -> a where
    computedDesiredCapacity :: forall r. Getting r s (TF.Attribute a)

instance HasComputedDesiredCapacity s a => HasComputedDesiredCapacity (TF.Resource p s) a where
    computedDesiredCapacity = TF.configuration . computedDesiredCapacity

class HasComputedDestinationCidrBlock s a | s -> a where
    computedDestinationCidrBlock :: forall r. Getting r s (TF.Attribute a)

instance HasComputedDestinationCidrBlock s a => HasComputedDestinationCidrBlock (TF.Resource p s) a where
    computedDestinationCidrBlock = TF.configuration . computedDestinationCidrBlock

class HasComputedDestinationIpv6CidrBlock s a | s -> a where
    computedDestinationIpv6CidrBlock :: forall r. Getting r s (TF.Attribute a)

instance HasComputedDestinationIpv6CidrBlock s a => HasComputedDestinationIpv6CidrBlock (TF.Resource p s) a where
    computedDestinationIpv6CidrBlock = TF.configuration . computedDestinationIpv6CidrBlock

class HasComputedDeviceName s a | s -> a where
    computedDeviceName :: forall r. Getting r s (TF.Attribute a)

instance HasComputedDeviceName s a => HasComputedDeviceName (TF.Resource p s) a where
    computedDeviceName = TF.configuration . computedDeviceName

class HasComputedDkimTokens s a | s -> a where
    computedDkimTokens :: forall r. Getting r s (TF.Attribute a)

instance HasComputedDkimTokens s a => HasComputedDkimTokens (TF.Resource p s) a where
    computedDkimTokens = TF.configuration . computedDkimTokens

class HasComputedDnsIpAddresses s a | s -> a where
    computedDnsIpAddresses :: forall r. Getting r s (TF.Attribute a)

instance HasComputedDnsIpAddresses s a => HasComputedDnsIpAddresses (TF.Resource p s) a where
    computedDnsIpAddresses = TF.configuration . computedDnsIpAddresses

class HasComputedDnsName s a | s -> a where
    computedDnsName :: forall r. Getting r s (TF.Attribute a)

instance HasComputedDnsName s a => HasComputedDnsName (TF.Resource p s) a where
    computedDnsName = TF.configuration . computedDnsName

class HasComputedDocumentType s a | s -> a where
    computedDocumentType :: forall r. Getting r s (TF.Attribute a)

instance HasComputedDocumentType s a => HasComputedDocumentType (TF.Resource p s) a where
    computedDocumentType = TF.configuration . computedDocumentType

class HasComputedDomainId s a | s -> a where
    computedDomainId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedDomainId s a => HasComputedDomainId (TF.Resource p s) a where
    computedDomainId = TF.configuration . computedDomainId

class HasComputedEcsClusterArn s a | s -> a where
    computedEcsClusterArn :: forall r. Getting r s (TF.Attribute a)

instance HasComputedEcsClusterArn s a => HasComputedEcsClusterArn (TF.Resource p s) a where
    computedEcsClusterArn = TF.configuration . computedEcsClusterArn

class HasComputedEgressOnlyGatewayId s a | s -> a where
    computedEgressOnlyGatewayId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedEgressOnlyGatewayId s a => HasComputedEgressOnlyGatewayId (TF.Resource p s) a where
    computedEgressOnlyGatewayId = TF.configuration . computedEgressOnlyGatewayId

class HasComputedEnableClassiclink s a | s -> a where
    computedEnableClassiclink :: forall r. Getting r s (TF.Attribute a)

instance HasComputedEnableClassiclink s a => HasComputedEnableClassiclink (TF.Resource p s) a where
    computedEnableClassiclink = TF.configuration . computedEnableClassiclink

class HasComputedEnableDnsHostnames s a | s -> a where
    computedEnableDnsHostnames :: forall r. Getting r s (TF.Attribute a)

instance HasComputedEnableDnsHostnames s a => HasComputedEnableDnsHostnames (TF.Resource p s) a where
    computedEnableDnsHostnames = TF.configuration . computedEnableDnsHostnames

class HasComputedEnableDnsSupport s a | s -> a where
    computedEnableDnsSupport :: forall r. Getting r s (TF.Attribute a)

instance HasComputedEnableDnsSupport s a => HasComputedEnableDnsSupport (TF.Resource p s) a where
    computedEnableDnsSupport = TF.configuration . computedEnableDnsSupport

class HasComputedEncrypted s a | s -> a where
    computedEncrypted :: forall r. Getting r s (TF.Attribute a)

instance HasComputedEncrypted s a => HasComputedEncrypted (TF.Resource p s) a where
    computedEncrypted = TF.configuration . computedEncrypted

class HasComputedEncryptedFingerprint s a | s -> a where
    computedEncryptedFingerprint :: forall r. Getting r s (TF.Attribute a)

instance HasComputedEncryptedFingerprint s a => HasComputedEncryptedFingerprint (TF.Resource p s) a where
    computedEncryptedFingerprint = TF.configuration . computedEncryptedFingerprint

class HasComputedEncryptedPassword s a | s -> a where
    computedEncryptedPassword :: forall r. Getting r s (TF.Attribute a)

instance HasComputedEncryptedPassword s a => HasComputedEncryptedPassword (TF.Resource p s) a where
    computedEncryptedPassword = TF.configuration . computedEncryptedPassword

class HasComputedEncryptedPrivateKey s a | s -> a where
    computedEncryptedPrivateKey :: forall r. Getting r s (TF.Attribute a)

instance HasComputedEncryptedPrivateKey s a => HasComputedEncryptedPrivateKey (TF.Resource p s) a where
    computedEncryptedPrivateKey = TF.configuration . computedEncryptedPrivateKey

class HasComputedEncryptedSecret s a | s -> a where
    computedEncryptedSecret :: forall r. Getting r s (TF.Attribute a)

instance HasComputedEncryptedSecret s a => HasComputedEncryptedSecret (TF.Resource p s) a where
    computedEncryptedSecret = TF.configuration . computedEncryptedSecret

class HasComputedEncryptionKey s a | s -> a where
    computedEncryptionKey :: forall r. Getting r s (TF.Attribute a)

instance HasComputedEncryptionKey s a => HasComputedEncryptionKey (TF.Resource p s) a where
    computedEncryptionKey = TF.configuration . computedEncryptionKey

class HasComputedEndpoint s a | s -> a where
    computedEndpoint :: forall r. Getting r s (TF.Attribute a)

instance HasComputedEndpoint s a => HasComputedEndpoint (TF.Resource p s) a where
    computedEndpoint = TF.configuration . computedEndpoint

class HasComputedEndpointArn s a | s -> a where
    computedEndpointArn :: forall r. Getting r s (TF.Attribute a)

instance HasComputedEndpointArn s a => HasComputedEndpointArn (TF.Resource p s) a where
    computedEndpointArn = TF.configuration . computedEndpointArn

class HasComputedEngine s a | s -> a where
    computedEngine :: forall r. Getting r s (TF.Attribute a)

instance HasComputedEngine s a => HasComputedEngine (TF.Resource p s) a where
    computedEngine = TF.configuration . computedEngine

class HasComputedEngineVersion s a | s -> a where
    computedEngineVersion :: forall r. Getting r s (TF.Attribute a)

instance HasComputedEngineVersion s a => HasComputedEngineVersion (TF.Resource p s) a where
    computedEngineVersion = TF.configuration . computedEngineVersion

class HasComputedEtag s a | s -> a where
    computedEtag :: forall r. Getting r s (TF.Attribute a)

instance HasComputedEtag s a => HasComputedEtag (TF.Resource p s) a where
    computedEtag = TF.configuration . computedEtag

class HasComputedExecutionArn s a | s -> a where
    computedExecutionArn :: forall r. Getting r s (TF.Attribute a)

instance HasComputedExecutionArn s a => HasComputedExecutionArn (TF.Resource p s) a where
    computedExecutionArn = TF.configuration . computedExecutionArn

class HasComputedExpirationDate s a | s -> a where
    computedExpirationDate :: forall r. Getting r s (TF.Attribute a)

instance HasComputedExpirationDate s a => HasComputedExpirationDate (TF.Resource p s) a where
    computedExpirationDate = TF.configuration . computedExpirationDate

class HasComputedExpirePasswords s a | s -> a where
    computedExpirePasswords :: forall r. Getting r s (TF.Attribute a)

instance HasComputedExpirePasswords s a => HasComputedExpirePasswords (TF.Resource p s) a where
    computedExpirePasswords = TF.configuration . computedExpirePasswords

class HasComputedExpired s a | s -> a where
    computedExpired :: forall r. Getting r s (TF.Attribute a)

instance HasComputedExpired s a => HasComputedExpired (TF.Resource p s) a where
    computedExpired = TF.configuration . computedExpired

class HasComputedFingerprint s a | s -> a where
    computedFingerprint :: forall r. Getting r s (TF.Attribute a)

instance HasComputedFingerprint s a => HasComputedFingerprint (TF.Resource p s) a where
    computedFingerprint = TF.configuration . computedFingerprint

class HasComputedFqdn s a | s -> a where
    computedFqdn :: forall r. Getting r s (TF.Attribute a)

instance HasComputedFqdn s a => HasComputedFqdn (TF.Resource p s) a where
    computedFqdn = TF.configuration . computedFqdn

class HasComputedFunctionArn s a | s -> a where
    computedFunctionArn :: forall r. Getting r s (TF.Attribute a)

instance HasComputedFunctionArn s a => HasComputedFunctionArn (TF.Resource p s) a where
    computedFunctionArn = TF.configuration . computedFunctionArn

class HasComputedGatewayId s a | s -> a where
    computedGatewayId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedGatewayId s a => HasComputedGatewayId (TF.Resource p s) a where
    computedGatewayId = TF.configuration . computedGatewayId

class HasComputedGroup s a | s -> a where
    computedGroup :: forall r. Getting r s (TF.Attribute a)

instance HasComputedGroup s a => HasComputedGroup (TF.Resource p s) a where
    computedGroup = TF.configuration . computedGroup

class HasComputedHash s a | s -> a where
    computedHash :: forall r. Getting r s (TF.Attribute a)

instance HasComputedHash s a => HasComputedHash (TF.Resource p s) a where
    computedHash = TF.configuration . computedHash

class HasComputedHashType s a | s -> a where
    computedHashType :: forall r. Getting r s (TF.Attribute a)

instance HasComputedHashType s a => HasComputedHashType (TF.Resource p s) a where
    computedHashType = TF.configuration . computedHashType

class HasComputedHealthCheckGracePeriod s a | s -> a where
    computedHealthCheckGracePeriod :: forall r. Getting r s (TF.Attribute a)

instance HasComputedHealthCheckGracePeriod s a => HasComputedHealthCheckGracePeriod (TF.Resource p s) a where
    computedHealthCheckGracePeriod = TF.configuration . computedHealthCheckGracePeriod

class HasComputedHealthCheckType s a | s -> a where
    computedHealthCheckType :: forall r. Getting r s (TF.Attribute a)

instance HasComputedHealthCheckType s a => HasComputedHealthCheckType (TF.Resource p s) a where
    computedHealthCheckType = TF.configuration . computedHealthCheckType

class HasComputedHomeRegion s a | s -> a where
    computedHomeRegion :: forall r. Getting r s (TF.Attribute a)

instance HasComputedHomeRegion s a => HasComputedHomeRegion (TF.Resource p s) a where
    computedHomeRegion = TF.configuration . computedHomeRegion

class HasComputedHostedZone s a | s -> a where
    computedHostedZone :: forall r. Getting r s (TF.Attribute a)

instance HasComputedHostedZone s a => HasComputedHostedZone (TF.Resource p s) a where
    computedHostedZone = TF.configuration . computedHostedZone

class HasComputedHostedZoneId s a | s -> a where
    computedHostedZoneId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedHostedZoneId s a => HasComputedHostedZoneId (TF.Resource p s) a where
    computedHostedZoneId = TF.configuration . computedHostedZoneId

class HasComputedIamArn s a | s -> a where
    computedIamArn :: forall r. Getting r s (TF.Attribute a)

instance HasComputedIamArn s a => HasComputedIamArn (TF.Resource p s) a where
    computedIamArn = TF.configuration . computedIamArn

class HasComputedIamRole s a | s -> a where
    computedIamRole :: forall r. Getting r s (TF.Attribute a)

instance HasComputedIamRole s a => HasComputedIamRole (TF.Resource p s) a where
    computedIamRole = TF.configuration . computedIamRole

class HasComputedId s a | s -> a where
    computedId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedId s a => HasComputedId (TF.Resource p s) a where
    computedId = TF.configuration . computedId

class HasComputedIdentifier s a | s -> a where
    computedIdentifier :: forall r. Getting r s (TF.Attribute a)

instance HasComputedIdentifier s a => HasComputedIdentifier (TF.Resource p s) a where
    computedIdentifier = TF.configuration . computedIdentifier

class HasComputedInstance' s a | s -> a where
    computedInstance' :: forall r. Getting r s (TF.Attribute a)

instance HasComputedInstance' s a => HasComputedInstance' (TF.Resource p s) a where
    computedInstance' = TF.configuration . computedInstance'

class HasComputedInstanceId s a | s -> a where
    computedInstanceId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedInstanceId s a => HasComputedInstanceId (TF.Resource p s) a where
    computedInstanceId = TF.configuration . computedInstanceId

class HasComputedInstanceIds s a | s -> a where
    computedInstanceIds :: forall r. Getting r s (TF.Attribute a)

instance HasComputedInstanceIds s a => HasComputedInstanceIds (TF.Resource p s) a where
    computedInstanceIds = TF.configuration . computedInstanceIds

class HasComputedInstancePort s a | s -> a where
    computedInstancePort :: forall r. Getting r s (TF.Attribute a)

instance HasComputedInstancePort s a => HasComputedInstancePort (TF.Resource p s) a where
    computedInstancePort = TF.configuration . computedInstancePort

class HasComputedInstanceTenancy s a | s -> a where
    computedInstanceTenancy :: forall r. Getting r s (TF.Attribute a)

instance HasComputedInstanceTenancy s a => HasComputedInstanceTenancy (TF.Resource p s) a where
    computedInstanceTenancy = TF.configuration . computedInstanceTenancy

class HasComputedInvokeArn s a | s -> a where
    computedInvokeArn :: forall r. Getting r s (TF.Attribute a)

instance HasComputedInvokeArn s a => HasComputedInvokeArn (TF.Resource p s) a where
    computedInvokeArn = TF.configuration . computedInvokeArn

class HasComputedInvokeUrl s a | s -> a where
    computedInvokeUrl :: forall r. Getting r s (TF.Attribute a)

instance HasComputedInvokeUrl s a => HasComputedInvokeUrl (TF.Resource p s) a where
    computedInvokeUrl = TF.configuration . computedInvokeUrl

class HasComputedIops s a | s -> a where
    computedIops :: forall r. Getting r s (TF.Attribute a)

instance HasComputedIops s a => HasComputedIops (TF.Resource p s) a where
    computedIops = TF.configuration . computedIops

class HasComputedIpAddress s a | s -> a where
    computedIpAddress :: forall r. Getting r s (TF.Attribute a)

instance HasComputedIpAddress s a => HasComputedIpAddress (TF.Resource p s) a where
    computedIpAddress = TF.configuration . computedIpAddress

class HasComputedIpv6AssociationId s a | s -> a where
    computedIpv6AssociationId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedIpv6AssociationId s a => HasComputedIpv6AssociationId (TF.Resource p s) a where
    computedIpv6AssociationId = TF.configuration . computedIpv6AssociationId

class HasComputedIpv6CidrBlock s a | s -> a where
    computedIpv6CidrBlock :: forall r. Getting r s (TF.Attribute a)

instance HasComputedIpv6CidrBlock s a => HasComputedIpv6CidrBlock (TF.Resource p s) a where
    computedIpv6CidrBlock = TF.configuration . computedIpv6CidrBlock

class HasComputedKeyFingerprint s a | s -> a where
    computedKeyFingerprint :: forall r. Getting r s (TF.Attribute a)

instance HasComputedKeyFingerprint s a => HasComputedKeyFingerprint (TF.Resource p s) a where
    computedKeyFingerprint = TF.configuration . computedKeyFingerprint

class HasComputedKeyId s a | s -> a where
    computedKeyId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedKeyId s a => HasComputedKeyId (TF.Resource p s) a where
    computedKeyId = TF.configuration . computedKeyId

class HasComputedKeyName s a | s -> a where
    computedKeyName :: forall r. Getting r s (TF.Attribute a)

instance HasComputedKeyName s a => HasComputedKeyName (TF.Resource p s) a where
    computedKeyName = TF.configuration . computedKeyName

class HasComputedKeyType s a | s -> a where
    computedKeyType :: forall r. Getting r s (TF.Attribute a)

instance HasComputedKeyType s a => HasComputedKeyType (TF.Resource p s) a where
    computedKeyType = TF.configuration . computedKeyType

class HasComputedKibanaEndpoint s a | s -> a where
    computedKibanaEndpoint :: forall r. Getting r s (TF.Attribute a)

instance HasComputedKibanaEndpoint s a => HasComputedKibanaEndpoint (TF.Resource p s) a where
    computedKibanaEndpoint = TF.configuration . computedKibanaEndpoint

class HasComputedKmsKeyArn s a | s -> a where
    computedKmsKeyArn :: forall r. Getting r s (TF.Attribute a)

instance HasComputedKmsKeyArn s a => HasComputedKmsKeyArn (TF.Resource p s) a where
    computedKmsKeyArn = TF.configuration . computedKmsKeyArn

class HasComputedKmsKeyId s a | s -> a where
    computedKmsKeyId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedKmsKeyId s a => HasComputedKmsKeyId (TF.Resource p s) a where
    computedKmsKeyId = TF.configuration . computedKmsKeyId

class HasComputedLastModified s a | s -> a where
    computedLastModified :: forall r. Getting r s (TF.Attribute a)

instance HasComputedLastModified s a => HasComputedLastModified (TF.Resource p s) a where
    computedLastModified = TF.configuration . computedLastModified

class HasComputedLastProcessingResult s a | s -> a where
    computedLastProcessingResult :: forall r. Getting r s (TF.Attribute a)

instance HasComputedLastProcessingResult s a => HasComputedLastProcessingResult (TF.Resource p s) a where
    computedLastProcessingResult = TF.configuration . computedLastProcessingResult

class HasComputedLastUpdatedDate s a | s -> a where
    computedLastUpdatedDate :: forall r. Getting r s (TF.Attribute a)

instance HasComputedLastUpdatedDate s a => HasComputedLastUpdatedDate (TF.Resource p s) a where
    computedLastUpdatedDate = TF.configuration . computedLastUpdatedDate

class HasComputedLatestRevision s a | s -> a where
    computedLatestRevision :: forall r. Getting r s (TF.Attribute a)

instance HasComputedLatestRevision s a => HasComputedLatestRevision (TF.Resource p s) a where
    computedLatestRevision = TF.configuration . computedLatestRevision

class HasComputedLatestVersion s a | s -> a where
    computedLatestVersion :: forall r. Getting r s (TF.Attribute a)

instance HasComputedLatestVersion s a => HasComputedLatestVersion (TF.Resource p s) a where
    computedLatestVersion = TF.configuration . computedLatestVersion

class HasComputedLaunchConfiguration s a | s -> a where
    computedLaunchConfiguration :: forall r. Getting r s (TF.Attribute a)

instance HasComputedLaunchConfiguration s a => HasComputedLaunchConfiguration (TF.Resource p s) a where
    computedLaunchConfiguration = TF.configuration . computedLaunchConfiguration

class HasComputedLbPort s a | s -> a where
    computedLbPort :: forall r. Getting r s (TF.Attribute a)

instance HasComputedLbPort s a => HasComputedLbPort (TF.Resource p s) a where
    computedLbPort = TF.configuration . computedLbPort

class HasComputedLicenseModel s a | s -> a where
    computedLicenseModel :: forall r. Getting r s (TF.Attribute a)

instance HasComputedLicenseModel s a => HasComputedLicenseModel (TF.Resource p s) a where
    computedLicenseModel = TF.configuration . computedLicenseModel

class HasComputedLoadBalancer s a | s -> a where
    computedLoadBalancer :: forall r. Getting r s (TF.Attribute a)

instance HasComputedLoadBalancer s a => HasComputedLoadBalancer (TF.Resource p s) a where
    computedLoadBalancer = TF.configuration . computedLoadBalancer

class HasComputedLoadBalancerName s a | s -> a where
    computedLoadBalancerName :: forall r. Getting r s (TF.Attribute a)

instance HasComputedLoadBalancerName s a => HasComputedLoadBalancerName (TF.Resource p s) a where
    computedLoadBalancerName = TF.configuration . computedLoadBalancerName

class HasComputedLoadBalancerPort s a | s -> a where
    computedLoadBalancerPort :: forall r. Getting r s (TF.Attribute a)

instance HasComputedLoadBalancerPort s a => HasComputedLoadBalancerPort (TF.Resource p s) a where
    computedLoadBalancerPort = TF.configuration . computedLoadBalancerPort

class HasComputedLoadBalancers s a | s -> a where
    computedLoadBalancers :: forall r. Getting r s (TF.Attribute a)

instance HasComputedLoadBalancers s a => HasComputedLoadBalancers (TF.Resource p s) a where
    computedLoadBalancers = TF.configuration . computedLoadBalancers

class HasComputedLocation s a | s -> a where
    computedLocation :: forall r. Getting r s (TF.Attribute a)

instance HasComputedLocation s a => HasComputedLocation (TF.Resource p s) a where
    computedLocation = TF.configuration . computedLocation

class HasComputedMainRouteTableId s a | s -> a where
    computedMainRouteTableId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedMainRouteTableId s a => HasComputedMainRouteTableId (TF.Resource p s) a where
    computedMainRouteTableId = TF.configuration . computedMainRouteTableId

class HasComputedMaintenanceWindow s a | s -> a where
    computedMaintenanceWindow :: forall r. Getting r s (TF.Attribute a)

instance HasComputedMaintenanceWindow s a => HasComputedMaintenanceWindow (TF.Resource p s) a where
    computedMaintenanceWindow = TF.configuration . computedMaintenanceWindow

class HasComputedMasterUsername s a | s -> a where
    computedMasterUsername :: forall r. Getting r s (TF.Attribute a)

instance HasComputedMasterUsername s a => HasComputedMasterUsername (TF.Resource p s) a where
    computedMasterUsername = TF.configuration . computedMasterUsername

class HasComputedMaxSize s a | s -> a where
    computedMaxSize :: forall r. Getting r s (TF.Attribute a)

instance HasComputedMaxSize s a => HasComputedMaxSize (TF.Resource p s) a where
    computedMaxSize = TF.configuration . computedMaxSize

class HasComputedMinSize s a | s -> a where
    computedMinSize :: forall r. Getting r s (TF.Attribute a)

instance HasComputedMinSize s a => HasComputedMinSize (TF.Resource p s) a where
    computedMinSize = TF.configuration . computedMinSize

class HasComputedName s a | s -> a where
    computedName :: forall r. Getting r s (TF.Attribute a)

instance HasComputedName s a => HasComputedName (TF.Resource p s) a where
    computedName = TF.configuration . computedName

class HasComputedNameServers s a | s -> a where
    computedNameServers :: forall r. Getting r s (TF.Attribute a)

instance HasComputedNameServers s a => HasComputedNameServers (TF.Resource p s) a where
    computedNameServers = TF.configuration . computedNameServers

class HasComputedNatGatewayId s a | s -> a where
    computedNatGatewayId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedNatGatewayId s a => HasComputedNatGatewayId (TF.Resource p s) a where
    computedNatGatewayId = TF.configuration . computedNatGatewayId

class HasComputedNetworkInterface s a | s -> a where
    computedNetworkInterface :: forall r. Getting r s (TF.Attribute a)

instance HasComputedNetworkInterface s a => HasComputedNetworkInterface (TF.Resource p s) a where
    computedNetworkInterface = TF.configuration . computedNetworkInterface

class HasComputedNetworkInterfaceId s a | s -> a where
    computedNetworkInterfaceId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedNetworkInterfaceId s a => HasComputedNetworkInterfaceId (TF.Resource p s) a where
    computedNetworkInterfaceId = TF.configuration . computedNetworkInterfaceId

class HasComputedOptionGroupName s a | s -> a where
    computedOptionGroupName :: forall r. Getting r s (TF.Attribute a)

instance HasComputedOptionGroupName s a => HasComputedOptionGroupName (TF.Resource p s) a where
    computedOptionGroupName = TF.configuration . computedOptionGroupName

class HasComputedOriginalRouteTableId s a | s -> a where
    computedOriginalRouteTableId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedOriginalRouteTableId s a => HasComputedOriginalRouteTableId (TF.Resource p s) a where
    computedOriginalRouteTableId = TF.configuration . computedOriginalRouteTableId

class HasComputedOutputs s a | s -> a where
    computedOutputs :: forall r. Getting r s (TF.Attribute a)

instance HasComputedOutputs s a => HasComputedOutputs (TF.Resource p s) a where
    computedOutputs = TF.configuration . computedOutputs

class HasComputedOwner s a | s -> a where
    computedOwner :: forall r. Getting r s (TF.Attribute a)

instance HasComputedOwner s a => HasComputedOwner (TF.Resource p s) a where
    computedOwner = TF.configuration . computedOwner

class HasComputedOwnerAlias s a | s -> a where
    computedOwnerAlias :: forall r. Getting r s (TF.Attribute a)

instance HasComputedOwnerAlias s a => HasComputedOwnerAlias (TF.Resource p s) a where
    computedOwnerAlias = TF.configuration . computedOwnerAlias

class HasComputedOwnerId s a | s -> a where
    computedOwnerId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedOwnerId s a => HasComputedOwnerId (TF.Resource p s) a where
    computedOwnerId = TF.configuration . computedOwnerId

class HasComputedParameter s a | s -> a where
    computedParameter :: forall r. Getting r s (TF.Attribute a)

instance HasComputedParameter s a => HasComputedParameter (TF.Resource p s) a where
    computedParameter = TF.configuration . computedParameter

class HasComputedParameters s a | s -> a where
    computedParameters :: forall r. Getting r s (TF.Attribute a)

instance HasComputedParameters s a => HasComputedParameters (TF.Resource p s) a where
    computedParameters = TF.configuration . computedParameters

class HasComputedPath s a | s -> a where
    computedPath :: forall r. Getting r s (TF.Attribute a)

instance HasComputedPath s a => HasComputedPath (TF.Resource p s) a where
    computedPath = TF.configuration . computedPath

class HasComputedPemEncodedCertificate s a | s -> a where
    computedPemEncodedCertificate :: forall r. Getting r s (TF.Attribute a)

instance HasComputedPemEncodedCertificate s a => HasComputedPemEncodedCertificate (TF.Resource p s) a where
    computedPemEncodedCertificate = TF.configuration . computedPemEncodedCertificate

class HasComputedPerformanceInsightsEnabled s a | s -> a where
    computedPerformanceInsightsEnabled :: forall r. Getting r s (TF.Attribute a)

instance HasComputedPerformanceInsightsEnabled s a => HasComputedPerformanceInsightsEnabled (TF.Resource p s) a where
    computedPerformanceInsightsEnabled = TF.configuration . computedPerformanceInsightsEnabled

class HasComputedPerformanceInsightsKmsKeyId s a | s -> a where
    computedPerformanceInsightsKmsKeyId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedPerformanceInsightsKmsKeyId s a => HasComputedPerformanceInsightsKmsKeyId (TF.Resource p s) a where
    computedPerformanceInsightsKmsKeyId = TF.configuration . computedPerformanceInsightsKmsKeyId

class HasComputedPermissions s a | s -> a where
    computedPermissions :: forall r. Getting r s (TF.Attribute a)

instance HasComputedPermissions s a => HasComputedPermissions (TF.Resource p s) a where
    computedPermissions = TF.configuration . computedPermissions

class HasComputedPlatformTypes s a | s -> a where
    computedPlatformTypes :: forall r. Getting r s (TF.Attribute a)

instance HasComputedPlatformTypes s a => HasComputedPlatformTypes (TF.Resource p s) a where
    computedPlatformTypes = TF.configuration . computedPlatformTypes

class HasComputedPolicy s a | s -> a where
    computedPolicy :: forall r. Getting r s (TF.Attribute a)

instance HasComputedPolicy s a => HasComputedPolicy (TF.Resource p s) a where
    computedPolicy = TF.configuration . computedPolicy

class HasComputedPolicyName s a | s -> a where
    computedPolicyName :: forall r. Getting r s (TF.Attribute a)

instance HasComputedPolicyName s a => HasComputedPolicyName (TF.Resource p s) a where
    computedPolicyName = TF.configuration . computedPolicyName

class HasComputedPolicyType s a | s -> a where
    computedPolicyType :: forall r. Getting r s (TF.Attribute a)

instance HasComputedPolicyType s a => HasComputedPolicyType (TF.Resource p s) a where
    computedPolicyType = TF.configuration . computedPolicyType

class HasComputedPolicyTypeName s a | s -> a where
    computedPolicyTypeName :: forall r. Getting r s (TF.Attribute a)

instance HasComputedPolicyTypeName s a => HasComputedPolicyTypeName (TF.Resource p s) a where
    computedPolicyTypeName = TF.configuration . computedPolicyTypeName

class HasComputedPort s a | s -> a where
    computedPort :: forall r. Getting r s (TF.Attribute a)

instance HasComputedPort s a => HasComputedPort (TF.Resource p s) a where
    computedPort = TF.configuration . computedPort

class HasComputedPreferredBackupWindow s a | s -> a where
    computedPreferredBackupWindow :: forall r. Getting r s (TF.Attribute a)

instance HasComputedPreferredBackupWindow s a => HasComputedPreferredBackupWindow (TF.Resource p s) a where
    computedPreferredBackupWindow = TF.configuration . computedPreferredBackupWindow

class HasComputedPreferredMaintenanceWindow s a | s -> a where
    computedPreferredMaintenanceWindow :: forall r. Getting r s (TF.Attribute a)

instance HasComputedPreferredMaintenanceWindow s a => HasComputedPreferredMaintenanceWindow (TF.Resource p s) a where
    computedPreferredMaintenanceWindow = TF.configuration . computedPreferredMaintenanceWindow

class HasComputedPrefixListId s a | s -> a where
    computedPrefixListId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedPrefixListId s a => HasComputedPrefixListId (TF.Resource p s) a where
    computedPrefixListId = TF.configuration . computedPrefixListId

class HasComputedPrimaryEndpointAddress s a | s -> a where
    computedPrimaryEndpointAddress :: forall r. Getting r s (TF.Attribute a)

instance HasComputedPrimaryEndpointAddress s a => HasComputedPrimaryEndpointAddress (TF.Resource p s) a where
    computedPrimaryEndpointAddress = TF.configuration . computedPrimaryEndpointAddress

class HasComputedPrivateIp s a | s -> a where
    computedPrivateIp :: forall r. Getting r s (TF.Attribute a)

instance HasComputedPrivateIp s a => HasComputedPrivateIp (TF.Resource p s) a where
    computedPrivateIp = TF.configuration . computedPrivateIp

class HasComputedPrivateIpAddress s a | s -> a where
    computedPrivateIpAddress :: forall r. Getting r s (TF.Attribute a)

instance HasComputedPrivateIpAddress s a => HasComputedPrivateIpAddress (TF.Resource p s) a where
    computedPrivateIpAddress = TF.configuration . computedPrivateIpAddress

class HasComputedPrivateIps s a | s -> a where
    computedPrivateIps :: forall r. Getting r s (TF.Attribute a)

instance HasComputedPrivateIps s a => HasComputedPrivateIps (TF.Resource p s) a where
    computedPrivateIps = TF.configuration . computedPrivateIps

class HasComputedPrivateKey s a | s -> a where
    computedPrivateKey :: forall r. Getting r s (TF.Attribute a)

instance HasComputedPrivateKey s a => HasComputedPrivateKey (TF.Resource p s) a where
    computedPrivateKey = TF.configuration . computedPrivateKey

class HasComputedPublicIp s a | s -> a where
    computedPublicIp :: forall r. Getting r s (TF.Attribute a)

instance HasComputedPublicIp s a => HasComputedPublicIp (TF.Resource p s) a where
    computedPublicIp = TF.configuration . computedPublicIp

class HasComputedPublicKey s a | s -> a where
    computedPublicKey :: forall r. Getting r s (TF.Attribute a)

instance HasComputedPublicKey s a => HasComputedPublicKey (TF.Resource p s) a where
    computedPublicKey = TF.configuration . computedPublicKey

class HasComputedQualifiedArn s a | s -> a where
    computedQualifiedArn :: forall r. Getting r s (TF.Attribute a)

instance HasComputedQualifiedArn s a => HasComputedQualifiedArn (TF.Resource p s) a where
    computedQualifiedArn = TF.configuration . computedQualifiedArn

class HasComputedReaderEndpoint s a | s -> a where
    computedReaderEndpoint :: forall r. Getting r s (TF.Attribute a)

instance HasComputedReaderEndpoint s a => HasComputedReaderEndpoint (TF.Resource p s) a where
    computedReaderEndpoint = TF.configuration . computedReaderEndpoint

class HasComputedRegion s a | s -> a where
    computedRegion :: forall r. Getting r s (TF.Attribute a)

instance HasComputedRegion s a => HasComputedRegion (TF.Resource p s) a where
    computedRegion = TF.configuration . computedRegion

class HasComputedRegistrationCount s a | s -> a where
    computedRegistrationCount :: forall r. Getting r s (TF.Attribute a)

instance HasComputedRegistrationCount s a => HasComputedRegistrationCount (TF.Resource p s) a where
    computedRegistrationCount = TF.configuration . computedRegistrationCount

class HasComputedRegistrationLimit s a | s -> a where
    computedRegistrationLimit :: forall r. Getting r s (TF.Attribute a)

instance HasComputedRegistrationLimit s a => HasComputedRegistrationLimit (TF.Resource p s) a where
    computedRegistrationLimit = TF.configuration . computedRegistrationLimit

class HasComputedRegistryId s a | s -> a where
    computedRegistryId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedRegistryId s a => HasComputedRegistryId (TF.Resource p s) a where
    computedRegistryId = TF.configuration . computedRegistryId

class HasComputedReplicationInstanceArn s a | s -> a where
    computedReplicationInstanceArn :: forall r. Getting r s (TF.Attribute a)

instance HasComputedReplicationInstanceArn s a => HasComputedReplicationInstanceArn (TF.Resource p s) a where
    computedReplicationInstanceArn = TF.configuration . computedReplicationInstanceArn

class HasComputedReplicationInstancePrivateIps s a | s -> a where
    computedReplicationInstancePrivateIps :: forall r. Getting r s (TF.Attribute a)

instance HasComputedReplicationInstancePrivateIps s a => HasComputedReplicationInstancePrivateIps (TF.Resource p s) a where
    computedReplicationInstancePrivateIps = TF.configuration . computedReplicationInstancePrivateIps

class HasComputedReplicationInstancePublicIps s a | s -> a where
    computedReplicationInstancePublicIps :: forall r. Getting r s (TF.Attribute a)

instance HasComputedReplicationInstancePublicIps s a => HasComputedReplicationInstancePublicIps (TF.Resource p s) a where
    computedReplicationInstancePublicIps = TF.configuration . computedReplicationInstancePublicIps

class HasComputedReplicationSourceIdentifier s a | s -> a where
    computedReplicationSourceIdentifier :: forall r. Getting r s (TF.Attribute a)

instance HasComputedReplicationSourceIdentifier s a => HasComputedReplicationSourceIdentifier (TF.Resource p s) a where
    computedReplicationSourceIdentifier = TF.configuration . computedReplicationSourceIdentifier

class HasComputedReplicationTaskArn s a | s -> a where
    computedReplicationTaskArn :: forall r. Getting r s (TF.Attribute a)

instance HasComputedReplicationTaskArn s a => HasComputedReplicationTaskArn (TF.Resource p s) a where
    computedReplicationTaskArn = TF.configuration . computedReplicationTaskArn

class HasComputedRepository s a | s -> a where
    computedRepository :: forall r. Getting r s (TF.Attribute a)

instance HasComputedRepository s a => HasComputedRepository (TF.Resource p s) a where
    computedRepository = TF.configuration . computedRepository

class HasComputedRepositoryId s a | s -> a where
    computedRepositoryId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedRepositoryId s a => HasComputedRepositoryId (TF.Resource p s) a where
    computedRepositoryId = TF.configuration . computedRepositoryId

class HasComputedRepositoryUrl s a | s -> a where
    computedRepositoryUrl :: forall r. Getting r s (TF.Attribute a)

instance HasComputedRepositoryUrl s a => HasComputedRepositoryUrl (TF.Resource p s) a where
    computedRepositoryUrl = TF.configuration . computedRepositoryUrl

class HasComputedRole s a | s -> a where
    computedRole :: forall r. Getting r s (TF.Attribute a)

instance HasComputedRole s a => HasComputedRole (TF.Resource p s) a where
    computedRole = TF.configuration . computedRole

class HasComputedRoles s a | s -> a where
    computedRoles :: forall r. Getting r s (TF.Attribute a)

instance HasComputedRoles s a => HasComputedRoles (TF.Resource p s) a where
    computedRoles = TF.configuration . computedRoles

class HasComputedRootResourceId s a | s -> a where
    computedRootResourceId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedRootResourceId s a => HasComputedRootResourceId (TF.Resource p s) a where
    computedRootResourceId = TF.configuration . computedRootResourceId

class HasComputedRouteTableId s a | s -> a where
    computedRouteTableId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedRouteTableId s a => HasComputedRouteTableId (TF.Resource p s) a where
    computedRouteTableId = TF.configuration . computedRouteTableId

class HasComputedRunningInstanceCount s a | s -> a where
    computedRunningInstanceCount :: forall r. Getting r s (TF.Attribute a)

instance HasComputedRunningInstanceCount s a => HasComputedRunningInstanceCount (TF.Resource p s) a where
    computedRunningInstanceCount = TF.configuration . computedRunningInstanceCount

class HasComputedS3Bucket s a | s -> a where
    computedS3Bucket :: forall r. Getting r s (TF.Attribute a)

instance HasComputedS3Bucket s a => HasComputedS3Bucket (TF.Resource p s) a where
    computedS3Bucket = TF.configuration . computedS3Bucket

class HasComputedS3CanonicalUserId s a | s -> a where
    computedS3CanonicalUserId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedS3CanonicalUserId s a => HasComputedS3CanonicalUserId (TF.Resource p s) a where
    computedS3CanonicalUserId = TF.configuration . computedS3CanonicalUserId

class HasComputedSchemaVersion s a | s -> a where
    computedSchemaVersion :: forall r. Getting r s (TF.Attribute a)

instance HasComputedSchemaVersion s a => HasComputedSchemaVersion (TF.Resource p s) a where
    computedSchemaVersion = TF.configuration . computedSchemaVersion

class HasComputedSecret s a | s -> a where
    computedSecret :: forall r. Getting r s (TF.Attribute a)

instance HasComputedSecret s a => HasComputedSecret (TF.Resource p s) a where
    computedSecret = TF.configuration . computedSecret

class HasComputedSecurityGroupId s a | s -> a where
    computedSecurityGroupId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedSecurityGroupId s a => HasComputedSecurityGroupId (TF.Resource p s) a where
    computedSecurityGroupId = TF.configuration . computedSecurityGroupId

class HasComputedSecurityGroups s a | s -> a where
    computedSecurityGroups :: forall r. Getting r s (TF.Attribute a)

instance HasComputedSecurityGroups s a => HasComputedSecurityGroups (TF.Resource p s) a where
    computedSecurityGroups = TF.configuration . computedSecurityGroups

class HasComputedServiceRole s a | s -> a where
    computedServiceRole :: forall r. Getting r s (TF.Attribute a)

instance HasComputedServiceRole s a => HasComputedServiceRole (TF.Resource p s) a where
    computedServiceRole = TF.configuration . computedServiceRole

class HasComputedSesSmtpPassword s a | s -> a where
    computedSesSmtpPassword :: forall r. Getting r s (TF.Attribute a)

instance HasComputedSesSmtpPassword s a => HasComputedSesSmtpPassword (TF.Resource p s) a where
    computedSesSmtpPassword = TF.configuration . computedSesSmtpPassword

class HasComputedShardCount s a | s -> a where
    computedShardCount :: forall r. Getting r s (TF.Attribute a)

instance HasComputedShardCount s a => HasComputedShardCount (TF.Resource p s) a where
    computedShardCount = TF.configuration . computedShardCount

class HasComputedSourceCodeHash s a | s -> a where
    computedSourceCodeHash :: forall r. Getting r s (TF.Attribute a)

instance HasComputedSourceCodeHash s a => HasComputedSourceCodeHash (TF.Resource p s) a where
    computedSourceCodeHash = TF.configuration . computedSourceCodeHash

class HasComputedSourceDbSnapshotIdentifier s a | s -> a where
    computedSourceDbSnapshotIdentifier :: forall r. Getting r s (TF.Attribute a)

instance HasComputedSourceDbSnapshotIdentifier s a => HasComputedSourceDbSnapshotIdentifier (TF.Resource p s) a where
    computedSourceDbSnapshotIdentifier = TF.configuration . computedSourceDbSnapshotIdentifier

class HasComputedSourceDestCheck s a | s -> a where
    computedSourceDestCheck :: forall r. Getting r s (TF.Attribute a)

instance HasComputedSourceDestCheck s a => HasComputedSourceDestCheck (TF.Resource p s) a where
    computedSourceDestCheck = TF.configuration . computedSourceDestCheck

class HasComputedSourceRegion s a | s -> a where
    computedSourceRegion :: forall r. Getting r s (TF.Attribute a)

instance HasComputedSourceRegion s a => HasComputedSourceRegion (TF.Resource p s) a where
    computedSourceRegion = TF.configuration . computedSourceRegion

class HasComputedSshPublicKeyId s a | s -> a where
    computedSshPublicKeyId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedSshPublicKeyId s a => HasComputedSshPublicKeyId (TF.Resource p s) a where
    computedSshPublicKeyId = TF.configuration . computedSshPublicKeyId

class HasComputedState s a | s -> a where
    computedState :: forall r. Getting r s (TF.Attribute a)

instance HasComputedState s a => HasComputedState (TF.Resource p s) a where
    computedState = TF.configuration . computedState

class HasComputedStateTransitionReason s a | s -> a where
    computedStateTransitionReason :: forall r. Getting r s (TF.Attribute a)

instance HasComputedStateTransitionReason s a => HasComputedStateTransitionReason (TF.Resource p s) a where
    computedStateTransitionReason = TF.configuration . computedStateTransitionReason

class HasComputedStaticRoutesOnly s a | s -> a where
    computedStaticRoutesOnly :: forall r. Getting r s (TF.Attribute a)

instance HasComputedStaticRoutesOnly s a => HasComputedStaticRoutesOnly (TF.Resource p s) a where
    computedStaticRoutesOnly = TF.configuration . computedStaticRoutesOnly

class HasComputedStatus s a | s -> a where
    computedStatus :: forall r. Getting r s (TF.Attribute a)

instance HasComputedStatus s a => HasComputedStatus (TF.Resource p s) a where
    computedStatus = TF.configuration . computedStatus

class HasComputedStatusReason s a | s -> a where
    computedStatusReason :: forall r. Getting r s (TF.Attribute a)

instance HasComputedStatusReason s a => HasComputedStatusReason (TF.Resource p s) a where
    computedStatusReason = TF.configuration . computedStatusReason

class HasComputedStorageEncrypted s a | s -> a where
    computedStorageEncrypted :: forall r. Getting r s (TF.Attribute a)

instance HasComputedStorageEncrypted s a => HasComputedStorageEncrypted (TF.Resource p s) a where
    computedStorageEncrypted = TF.configuration . computedStorageEncrypted

class HasComputedStorageType s a | s -> a where
    computedStorageType :: forall r. Getting r s (TF.Attribute a)

instance HasComputedStorageType s a => HasComputedStorageType (TF.Resource p s) a where
    computedStorageType = TF.configuration . computedStorageType

class HasComputedSubnetId s a | s -> a where
    computedSubnetId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedSubnetId s a => HasComputedSubnetId (TF.Resource p s) a where
    computedSubnetId = TF.configuration . computedSubnetId

class HasComputedSupportCode s a | s -> a where
    computedSupportCode :: forall r. Getting r s (TF.Attribute a)

instance HasComputedSupportCode s a => HasComputedSupportCode (TF.Resource p s) a where
    computedSupportCode = TF.configuration . computedSupportCode

class HasComputedTags s a | s -> a where
    computedTags :: forall r. Getting r s (TF.Attribute a)

instance HasComputedTags s a => HasComputedTags (TF.Resource p s) a where
    computedTags = TF.configuration . computedTags

class HasComputedTargetGroupArns s a | s -> a where
    computedTargetGroupArns :: forall r. Getting r s (TF.Attribute a)

instance HasComputedTargetGroupArns s a => HasComputedTargetGroupArns (TF.Resource p s) a where
    computedTargetGroupArns = TF.configuration . computedTargetGroupArns

class HasComputedThrottleSettings s a | s -> a where
    computedThrottleSettings :: forall r. Getting r s (TF.Attribute a)

instance HasComputedThrottleSettings s a => HasComputedThrottleSettings (TF.Resource p s) a where
    computedThrottleSettings = TF.configuration . computedThrottleSettings

class HasComputedTunnel1Address s a | s -> a where
    computedTunnel1Address :: forall r. Getting r s (TF.Attribute a)

instance HasComputedTunnel1Address s a => HasComputedTunnel1Address (TF.Resource p s) a where
    computedTunnel1Address = TF.configuration . computedTunnel1Address

class HasComputedTunnel1BgpAsn s a | s -> a where
    computedTunnel1BgpAsn :: forall r. Getting r s (TF.Attribute a)

instance HasComputedTunnel1BgpAsn s a => HasComputedTunnel1BgpAsn (TF.Resource p s) a where
    computedTunnel1BgpAsn = TF.configuration . computedTunnel1BgpAsn

class HasComputedTunnel1BgpHoldtime s a | s -> a where
    computedTunnel1BgpHoldtime :: forall r. Getting r s (TF.Attribute a)

instance HasComputedTunnel1BgpHoldtime s a => HasComputedTunnel1BgpHoldtime (TF.Resource p s) a where
    computedTunnel1BgpHoldtime = TF.configuration . computedTunnel1BgpHoldtime

class HasComputedTunnel1CgwInsideAddress s a | s -> a where
    computedTunnel1CgwInsideAddress :: forall r. Getting r s (TF.Attribute a)

instance HasComputedTunnel1CgwInsideAddress s a => HasComputedTunnel1CgwInsideAddress (TF.Resource p s) a where
    computedTunnel1CgwInsideAddress = TF.configuration . computedTunnel1CgwInsideAddress

class HasComputedTunnel1PresharedKey s a | s -> a where
    computedTunnel1PresharedKey :: forall r. Getting r s (TF.Attribute a)

instance HasComputedTunnel1PresharedKey s a => HasComputedTunnel1PresharedKey (TF.Resource p s) a where
    computedTunnel1PresharedKey = TF.configuration . computedTunnel1PresharedKey

class HasComputedTunnel1VgwInsideAddress s a | s -> a where
    computedTunnel1VgwInsideAddress :: forall r. Getting r s (TF.Attribute a)

instance HasComputedTunnel1VgwInsideAddress s a => HasComputedTunnel1VgwInsideAddress (TF.Resource p s) a where
    computedTunnel1VgwInsideAddress = TF.configuration . computedTunnel1VgwInsideAddress

class HasComputedTunnel2Address s a | s -> a where
    computedTunnel2Address :: forall r. Getting r s (TF.Attribute a)

instance HasComputedTunnel2Address s a => HasComputedTunnel2Address (TF.Resource p s) a where
    computedTunnel2Address = TF.configuration . computedTunnel2Address

class HasComputedTunnel2BgpAsn s a | s -> a where
    computedTunnel2BgpAsn :: forall r. Getting r s (TF.Attribute a)

instance HasComputedTunnel2BgpAsn s a => HasComputedTunnel2BgpAsn (TF.Resource p s) a where
    computedTunnel2BgpAsn = TF.configuration . computedTunnel2BgpAsn

class HasComputedTunnel2BgpHoldtime s a | s -> a where
    computedTunnel2BgpHoldtime :: forall r. Getting r s (TF.Attribute a)

instance HasComputedTunnel2BgpHoldtime s a => HasComputedTunnel2BgpHoldtime (TF.Resource p s) a where
    computedTunnel2BgpHoldtime = TF.configuration . computedTunnel2BgpHoldtime

class HasComputedTunnel2CgwInsideAddress s a | s -> a where
    computedTunnel2CgwInsideAddress :: forall r. Getting r s (TF.Attribute a)

instance HasComputedTunnel2CgwInsideAddress s a => HasComputedTunnel2CgwInsideAddress (TF.Resource p s) a where
    computedTunnel2CgwInsideAddress = TF.configuration . computedTunnel2CgwInsideAddress

class HasComputedTunnel2PresharedKey s a | s -> a where
    computedTunnel2PresharedKey :: forall r. Getting r s (TF.Attribute a)

instance HasComputedTunnel2PresharedKey s a => HasComputedTunnel2PresharedKey (TF.Resource p s) a where
    computedTunnel2PresharedKey = TF.configuration . computedTunnel2PresharedKey

class HasComputedTunnel2VgwInsideAddress s a | s -> a where
    computedTunnel2VgwInsideAddress :: forall r. Getting r s (TF.Attribute a)

instance HasComputedTunnel2VgwInsideAddress s a => HasComputedTunnel2VgwInsideAddress (TF.Resource p s) a where
    computedTunnel2VgwInsideAddress = TF.configuration . computedTunnel2VgwInsideAddress

class HasComputedType' s a | s -> a where
    computedType' :: forall r. Getting r s (TF.Attribute a)

instance HasComputedType' s a => HasComputedType' (TF.Resource p s) a where
    computedType' = TF.configuration . computedType'

class HasComputedUniqueId s a | s -> a where
    computedUniqueId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedUniqueId s a => HasComputedUniqueId (TF.Resource p s) a where
    computedUniqueId = TF.configuration . computedUniqueId

class HasComputedUsagePlanId s a | s -> a where
    computedUsagePlanId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedUsagePlanId s a => HasComputedUsagePlanId (TF.Resource p s) a where
    computedUsagePlanId = TF.configuration . computedUsagePlanId

class HasComputedUser s a | s -> a where
    computedUser :: forall r. Getting r s (TF.Attribute a)

instance HasComputedUser s a => HasComputedUser (TF.Resource p s) a where
    computedUser = TF.configuration . computedUser

class HasComputedUsers s a | s -> a where
    computedUsers :: forall r. Getting r s (TF.Attribute a)

instance HasComputedUsers s a => HasComputedUsers (TF.Resource p s) a where
    computedUsers = TF.configuration . computedUsers

class HasComputedUuid s a | s -> a where
    computedUuid :: forall r. Getting r s (TF.Attribute a)

instance HasComputedUuid s a => HasComputedUuid (TF.Resource p s) a where
    computedUuid = TF.configuration . computedUuid

class HasComputedValidUntil s a | s -> a where
    computedValidUntil :: forall r. Getting r s (TF.Attribute a)

instance HasComputedValidUntil s a => HasComputedValidUntil (TF.Resource p s) a where
    computedValidUntil = TF.configuration . computedValidUntil

class HasComputedValue s a | s -> a where
    computedValue :: forall r. Getting r s (TF.Attribute a)

instance HasComputedValue s a => HasComputedValue (TF.Resource p s) a where
    computedValue = TF.configuration . computedValue

class HasComputedVerificationToken s a | s -> a where
    computedVerificationToken :: forall r. Getting r s (TF.Attribute a)

instance HasComputedVerificationToken s a => HasComputedVerificationToken (TF.Resource p s) a where
    computedVerificationToken = TF.configuration . computedVerificationToken

class HasComputedVersion s a | s -> a where
    computedVersion :: forall r. Getting r s (TF.Attribute a)

instance HasComputedVersion s a => HasComputedVersion (TF.Resource p s) a where
    computedVersion = TF.configuration . computedVersion

class HasComputedVersionId s a | s -> a where
    computedVersionId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedVersionId s a => HasComputedVersionId (TF.Resource p s) a where
    computedVersionId = TF.configuration . computedVersionId

class HasComputedVolumeId s a | s -> a where
    computedVolumeId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedVolumeId s a => HasComputedVolumeId (TF.Resource p s) a where
    computedVolumeId = TF.configuration . computedVolumeId

class HasComputedVolumeSize s a | s -> a where
    computedVolumeSize :: forall r. Getting r s (TF.Attribute a)

instance HasComputedVolumeSize s a => HasComputedVolumeSize (TF.Resource p s) a where
    computedVolumeSize = TF.configuration . computedVolumeSize

class HasComputedVpcId s a | s -> a where
    computedVpcId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedVpcId s a => HasComputedVpcId (TF.Resource p s) a where
    computedVpcId = TF.configuration . computedVpcId

class HasComputedVpcOptions0AvailabilityZones s a | s -> a where
    computedVpcOptions0AvailabilityZones :: forall r. Getting r s (TF.Attribute a)

instance HasComputedVpcOptions0AvailabilityZones s a => HasComputedVpcOptions0AvailabilityZones (TF.Resource p s) a where
    computedVpcOptions0AvailabilityZones = TF.configuration . computedVpcOptions0AvailabilityZones

class HasComputedVpcOptions0VpcId s a | s -> a where
    computedVpcOptions0VpcId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedVpcOptions0VpcId s a => HasComputedVpcOptions0VpcId (TF.Resource p s) a where
    computedVpcOptions0VpcId = TF.configuration . computedVpcOptions0VpcId

class HasComputedVpcPeeringConnectionId s a | s -> a where
    computedVpcPeeringConnectionId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedVpcPeeringConnectionId s a => HasComputedVpcPeeringConnectionId (TF.Resource p s) a where
    computedVpcPeeringConnectionId = TF.configuration . computedVpcPeeringConnectionId

class HasComputedVpcRegion s a | s -> a where
    computedVpcRegion :: forall r. Getting r s (TF.Attribute a)

instance HasComputedVpcRegion s a => HasComputedVpcRegion (TF.Resource p s) a where
    computedVpcRegion = TF.configuration . computedVpcRegion

class HasComputedVpcZoneIdentifier s a | s -> a where
    computedVpcZoneIdentifier :: forall r. Getting r s (TF.Attribute a)

instance HasComputedVpcZoneIdentifier s a => HasComputedVpcZoneIdentifier (TF.Resource p s) a where
    computedVpcZoneIdentifier = TF.configuration . computedVpcZoneIdentifier

class HasComputedVpnConnectionId s a | s -> a where
    computedVpnConnectionId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedVpnConnectionId s a => HasComputedVpnConnectionId (TF.Resource p s) a where
    computedVpnConnectionId = TF.configuration . computedVpnConnectionId

class HasComputedVpnGatewayId s a | s -> a where
    computedVpnGatewayId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedVpnGatewayId s a => HasComputedVpnGatewayId (TF.Resource p s) a where
    computedVpnGatewayId = TF.configuration . computedVpnGatewayId

class HasComputedWebsiteDomain s a | s -> a where
    computedWebsiteDomain :: forall r. Getting r s (TF.Attribute a)

instance HasComputedWebsiteDomain s a => HasComputedWebsiteDomain (TF.Resource p s) a where
    computedWebsiteDomain = TF.configuration . computedWebsiteDomain

class HasComputedWebsiteEndpoint s a | s -> a where
    computedWebsiteEndpoint :: forall r. Getting r s (TF.Attribute a)

instance HasComputedWebsiteEndpoint s a => HasComputedWebsiteEndpoint (TF.Resource p s) a where
    computedWebsiteEndpoint = TF.configuration . computedWebsiteEndpoint

class HasComputedWriter s a | s -> a where
    computedWriter :: forall r. Getting r s (TF.Attribute a)

instance HasComputedWriter s a => HasComputedWriter (TF.Resource p s) a where
    computedWriter = TF.configuration . computedWriter

class HasComputedZoneId s a | s -> a where
    computedZoneId :: forall r. Getting r s (TF.Attribute a)

instance HasComputedZoneId s a => HasComputedZoneId (TF.Resource p s) a where
    computedZoneId = TF.configuration . computedZoneId
