-- This module is auto-generated.

{-# LANGUAGE DuplicateRecordFields  #-}
{-# LANGUAGE FlexibleInstances      #-}
{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE MultiParamTypeClasses  #-}
{-# LANGUAGE NoImplicitPrelude      #-}
{-# LANGUAGE OverloadedStrings      #-}
{-# LANGUAGE RecordWildCards        #-}
{-# LANGUAGE ScopedTypeVariables    #-}

{-# OPTIONS_GHC -fno-warn-unused-imports #-}

-- |
-- Module      : Terrafomo.AWS.Resource
-- Copyright   : (c) 2017-2018 Brendan Hay
-- License     : Mozilla Public License, v. 2.0.
-- Maintainer  : Brendan Hay <brendan.g.hay+terrafomo@gmail.com>
-- Stability   : auto-generated
-- Portability : non-portable (GHC extensions)
--
module Terrafomo.AWS.Resource
    (
    -- * Types
      AcmCertificateResource (..)
    , acmCertificateResource

    , AcmCertificateValidationResource (..)
    , acmCertificateValidationResource

    , ActivityResource (..)
    , activityResource

    , AmiCopyResource (..)
    , amiCopyResource

    , AmiFromInstanceResource (..)
    , amiFromInstanceResource

    , AmiLaunchPermissionResource (..)
    , amiLaunchPermissionResource

    , AmiResource (..)
    , amiResource

    , ApiGatewayAccountResource (..)
    , apiGatewayAccountResource

    , ApiGatewayApiKeyResource (..)
    , apiGatewayApiKeyResource

    , ApiGatewayAuthorizerResource (..)
    , apiGatewayAuthorizerResource

    , ApiGatewayBasePathMappingResource (..)
    , apiGatewayBasePathMappingResource

    , ApiGatewayClientCertificateResource (..)
    , apiGatewayClientCertificateResource

    , ApiGatewayDeploymentResource (..)
    , apiGatewayDeploymentResource

    , ApiGatewayDocumentationPartResource (..)
    , apiGatewayDocumentationPartResource

    , ApiGatewayDocumentationVersionResource (..)
    , apiGatewayDocumentationVersionResource

    , ApiGatewayDomainNameResource (..)
    , apiGatewayDomainNameResource

    , ApiGatewayGatewayResponseResource (..)
    , apiGatewayGatewayResponseResource

    , ApiGatewayIntegrationResource (..)
    , apiGatewayIntegrationResource

    , ApiGatewayIntegrationResponseResource (..)
    , apiGatewayIntegrationResponseResource

    , ApiGatewayMethodResource (..)
    , apiGatewayMethodResource

    , ApiGatewayMethodResponseResource (..)
    , apiGatewayMethodResponseResource

    , ApiGatewayMethodSettingsResource (..)
    , apiGatewayMethodSettingsResource

    , ApiGatewayModelResource (..)
    , apiGatewayModelResource

    , ApiGatewayResourceResource (..)
    , apiGatewayResourceResource

    , ApiGatewayRestApiResource (..)
    , apiGatewayRestApiResource

    , ApiGatewayStageResource (..)
    , apiGatewayStageResource

    , ApiGatewayUsagePlanKeyResource (..)
    , apiGatewayUsagePlanKeyResource

    , ApiGatewayUsagePlanResource (..)
    , apiGatewayUsagePlanResource

    , ApiGatewayVpcLinkResource (..)
    , apiGatewayVpcLinkResource

    , AppCookieStickinessPolicyResource (..)
    , appCookieStickinessPolicyResource

    , AppautoscalingPolicyResource (..)
    , appautoscalingPolicyResource

    , AppautoscalingScheduledActionResource (..)
    , appautoscalingScheduledActionResource

    , AppautoscalingTargetResource (..)
    , appautoscalingTargetResource

    , AppsyncGraphqlApiResource (..)
    , appsyncGraphqlApiResource

    , AthenaDatabaseResource (..)
    , athenaDatabaseResource

    , AthenaNamedQueryResource (..)
    , athenaNamedQueryResource

    , AutoscalingAttachmentResource (..)
    , autoscalingAttachmentResource

    , AutoscalingGroupResource (..)
    , autoscalingGroupResource

    , AutoscalingLifecycleHookResource (..)
    , autoscalingLifecycleHookResource

    , AutoscalingNotificationResource (..)
    , autoscalingNotificationResource

    , AutoscalingPolicyResource (..)
    , autoscalingPolicyResource

    , AutoscalingScheduleResource (..)
    , autoscalingScheduleResource

    , BatchComputeEnvironmentResource (..)
    , batchComputeEnvironmentResource

    , BatchJobDefinitionResource (..)
    , batchJobDefinitionResource

    , BatchJobQueueResource (..)
    , batchJobQueueResource

    , Cloud9EnvironmentEc2Resource (..)
    , cloud9EnvironmentEc2Resource

    , CloudformationStackResource (..)
    , cloudformationStackResource

    , CloudfrontDistributionResource (..)
    , cloudfrontDistributionResource

    , CloudfrontOriginAccessIdentityResource (..)
    , cloudfrontOriginAccessIdentityResource

    , CloudtrailResource (..)
    , cloudtrailResource

    , CloudwatchDashboardResource (..)
    , cloudwatchDashboardResource

    , CloudwatchEventPermissionResource (..)
    , cloudwatchEventPermissionResource

    , CloudwatchEventRuleResource (..)
    , cloudwatchEventRuleResource

    , CloudwatchEventTargetResource (..)
    , cloudwatchEventTargetResource

    , CloudwatchLogDestinationPolicyResource (..)
    , cloudwatchLogDestinationPolicyResource

    , CloudwatchLogDestinationResource (..)
    , cloudwatchLogDestinationResource

    , CloudwatchLogGroupResource (..)
    , cloudwatchLogGroupResource

    , CloudwatchLogMetricFilterResource (..)
    , cloudwatchLogMetricFilterResource

    , CloudwatchLogResourcePolicyResource (..)
    , cloudwatchLogResourcePolicyResource

    , CloudwatchLogStreamResource (..)
    , cloudwatchLogStreamResource

    , CloudwatchLogSubscriptionFilterResource (..)
    , cloudwatchLogSubscriptionFilterResource

    , CloudwatchMetricAlarmResource (..)
    , cloudwatchMetricAlarmResource

    , CodebuildProjectResource (..)
    , codebuildProjectResource

    , CodecommitRepositoryResource (..)
    , codecommitRepositoryResource

    , CodecommitTriggerResource (..)
    , codecommitTriggerResource

    , CodedeployAppResource (..)
    , codedeployAppResource

    , CodedeployDeploymentConfigResource (..)
    , codedeployDeploymentConfigResource

    , CodedeployDeploymentGroupResource (..)
    , codedeployDeploymentGroupResource

    , CodepipelineResource (..)
    , codepipelineResource

    , CognitoIdentityPoolResource (..)
    , cognitoIdentityPoolResource

    , CognitoIdentityPoolRolesAttachmentResource (..)
    , cognitoIdentityPoolRolesAttachmentResource

    , CognitoUserGroupResource (..)
    , cognitoUserGroupResource

    , CognitoUserPoolClientResource (..)
    , cognitoUserPoolClientResource

    , CognitoUserPoolDomainResource (..)
    , cognitoUserPoolDomainResource

    , CognitoUserPoolResource (..)
    , cognitoUserPoolResource

    , ConfigConfigRuleResource (..)
    , configConfigRuleResource

    , ConfigConfigurationRecorderResource (..)
    , configConfigurationRecorderResource

    , ConfigConfigurationRecorderStatusResource (..)
    , configConfigurationRecorderStatusResource

    , ConfigDeliveryChannelResource (..)
    , configDeliveryChannelResource

    , CustomerGatewayResource (..)
    , customerGatewayResource

    , DaxClusterResource (..)
    , daxClusterResource

    , DbEventSubscriptionResource (..)
    , dbEventSubscriptionResource

    , DbInstanceResource (..)
    , dbInstanceResource

    , DbOptionGroupResource (..)
    , dbOptionGroupResource

    , DbParameterGroupResource (..)
    , dbParameterGroupResource

    , DbSecurityGroupResource (..)
    , dbSecurityGroupResource

    , DbSnapshotResource (..)
    , dbSnapshotResource

    , DbSubnetGroupResource (..)
    , dbSubnetGroupResource

    , DefaultNetworkAclResource (..)
    , defaultNetworkAclResource

    , DefaultRouteTableResource (..)
    , defaultRouteTableResource

    , DefaultSecurityGroupResource (..)
    , defaultSecurityGroupResource

    , DefaultSubnetResource (..)
    , defaultSubnetResource

    , DefaultVpcDhcpOptionsResource (..)
    , defaultVpcDhcpOptionsResource

    , DefaultVpcResource (..)
    , defaultVpcResource

    , DevicefarmProjectResource (..)
    , devicefarmProjectResource

    , DirectoryServiceDirectoryResource (..)
    , directoryServiceDirectoryResource

    , DmsCertificateResource (..)
    , dmsCertificateResource

    , DmsEndpointResource (..)
    , dmsEndpointResource

    , DmsReplicationInstanceResource (..)
    , dmsReplicationInstanceResource

    , DmsReplicationSubnetGroupResource (..)
    , dmsReplicationSubnetGroupResource

    , DmsReplicationTaskResource (..)
    , dmsReplicationTaskResource

    , DxConnectionAssociationResource (..)
    , dxConnectionAssociationResource

    , DxConnectionResource (..)
    , dxConnectionResource

    , DxLagResource (..)
    , dxLagResource

    , DynamodbGlobalTableResource (..)
    , dynamodbGlobalTableResource

    , DynamodbTableItemResource (..)
    , dynamodbTableItemResource

    , DynamodbTableResource (..)
    , dynamodbTableResource

    , EbsSnapshotResource (..)
    , ebsSnapshotResource

    , EbsVolumeResource (..)
    , ebsVolumeResource

    , EcrLifecyclePolicyResource (..)
    , ecrLifecyclePolicyResource

    , EcrRepositoryPolicyResource (..)
    , ecrRepositoryPolicyResource

    , EcrRepositoryResource (..)
    , ecrRepositoryResource

    , EcsClusterResource (..)
    , ecsClusterResource

    , EcsServiceResource (..)
    , ecsServiceResource

    , EcsTaskDefinitionResource (..)
    , ecsTaskDefinitionResource

    , EfsFileSystemResource (..)
    , efsFileSystemResource

    , EfsMountTargetResource (..)
    , efsMountTargetResource

    , EgressOnlyInternetGatewayResource (..)
    , egressOnlyInternetGatewayResource

    , EipAssociationResource (..)
    , eipAssociationResource

    , EipResource (..)
    , eipResource

    , ElasticBeanstalkApplicationResource (..)
    , elasticBeanstalkApplicationResource

    , ElasticBeanstalkApplicationVersionResource (..)
    , elasticBeanstalkApplicationVersionResource

    , ElasticBeanstalkConfigurationTemplateResource (..)
    , elasticBeanstalkConfigurationTemplateResource

    , ElasticBeanstalkEnvironmentResource (..)
    , elasticBeanstalkEnvironmentResource

    , ElasticacheClusterResource (..)
    , elasticacheClusterResource

    , ElasticacheParameterGroupResource (..)
    , elasticacheParameterGroupResource

    , ElasticacheReplicationGroupResource (..)
    , elasticacheReplicationGroupResource

    , ElasticacheSecurityGroupResource (..)
    , elasticacheSecurityGroupResource

    , ElasticacheSubnetGroupResource (..)
    , elasticacheSubnetGroupResource

    , ElasticsearchDomainPolicyResource (..)
    , elasticsearchDomainPolicyResource

    , ElasticsearchDomainResource (..)
    , elasticsearchDomainResource

    , ElastictranscoderPipelineResource (..)
    , elastictranscoderPipelineResource

    , ElastictranscoderPresetResource (..)
    , elastictranscoderPresetResource

    , ElbAttachmentResource (..)
    , elbAttachmentResource

    , ElbLoadBalancerBackendServerPolicyResource (..)
    , elbLoadBalancerBackendServerPolicyResource

    , ElbLoadBalancerListenerPolicyResource (..)
    , elbLoadBalancerListenerPolicyResource

    , ElbLoadBalancerPolicyResource (..)
    , elbLoadBalancerPolicyResource

    , ElbResource (..)
    , elbResource

    , EmrClusterResource (..)
    , emrClusterResource

    , EmrInstanceGroupResource (..)
    , emrInstanceGroupResource

    , EmrSecurityConfigurationResource (..)
    , emrSecurityConfigurationResource

    , FlowLogResource (..)
    , flowLogResource

    , GameliftAliasResource (..)
    , gameliftAliasResource

    , GameliftBuildResource (..)
    , gameliftBuildResource

    , GameliftFleetResource (..)
    , gameliftFleetResource

    , GlacierVaultResource (..)
    , glacierVaultResource

    , GlueCatalogDatabaseResource (..)
    , glueCatalogDatabaseResource

    , GuarddutyDetectorResource (..)
    , guarddutyDetectorResource

    , GuarddutyIpsetResource (..)
    , guarddutyIpsetResource

    , GuarddutyMemberResource (..)
    , guarddutyMemberResource

    , GuarddutyThreatintelsetResource (..)
    , guarddutyThreatintelsetResource

    , IamAccessKeyResource (..)
    , iamAccessKeyResource

    , IamAccountAliasResource (..)
    , iamAccountAliasResource

    , IamAccountPasswordPolicyResource (..)
    , iamAccountPasswordPolicyResource

    , IamGroupMembershipResource (..)
    , iamGroupMembershipResource

    , IamGroupPolicyAttachmentResource (..)
    , iamGroupPolicyAttachmentResource

    , IamGroupPolicyResource (..)
    , iamGroupPolicyResource

    , IamGroupResource (..)
    , iamGroupResource

    , IamInstanceProfileResource (..)
    , iamInstanceProfileResource

    , IamOpenidConnectProviderResource (..)
    , iamOpenidConnectProviderResource

    , IamPolicyAttachmentResource (..)
    , iamPolicyAttachmentResource

    , IamPolicyResource (..)
    , iamPolicyResource

    , IamRolePolicyAttachmentResource (..)
    , iamRolePolicyAttachmentResource

    , IamRolePolicyResource (..)
    , iamRolePolicyResource

    , IamRoleResource (..)
    , iamRoleResource

    , IamSamlProviderResource (..)
    , iamSamlProviderResource

    , IamServerCertificateResource (..)
    , iamServerCertificateResource

    , IamUserLoginProfileResource (..)
    , iamUserLoginProfileResource

    , IamUserPolicyAttachmentResource (..)
    , iamUserPolicyAttachmentResource

    , IamUserPolicyResource (..)
    , iamUserPolicyResource

    , IamUserResource (..)
    , iamUserResource

    , IamUserSshKeyResource (..)
    , iamUserSshKeyResource

    , InspectorAssessmentTargetResource (..)
    , inspectorAssessmentTargetResource

    , InspectorAssessmentTemplateResource (..)
    , inspectorAssessmentTemplateResource

    , InspectorResourceGroupResource (..)
    , inspectorResourceGroupResource

    , InstanceResource (..)
    , instanceResource

    , InternetGatewayResource (..)
    , internetGatewayResource

    , IotCertificateResource (..)
    , iotCertificateResource

    , IotPolicyResource (..)
    , iotPolicyResource

    , IotTopicRuleResource (..)
    , iotTopicRuleResource

    , KeyPairResource (..)
    , keyPairResource

    , KinesisFirehoseDeliveryStreamResource (..)
    , kinesisFirehoseDeliveryStreamResource

    , KinesisStreamResource (..)
    , kinesisStreamResource

    , KmsAliasResource (..)
    , kmsAliasResource

    , KmsKeyResource (..)
    , kmsKeyResource

    , LambdaAliasResource (..)
    , lambdaAliasResource

    , LambdaEventSourceMappingResource (..)
    , lambdaEventSourceMappingResource

    , LambdaFunctionResource (..)
    , lambdaFunctionResource

    , LambdaPermissionResource (..)
    , lambdaPermissionResource

    , LaunchConfigurationResource (..)
    , launchConfigurationResource

    , LbCookieStickinessPolicyResource (..)
    , lbCookieStickinessPolicyResource

    , LbListenerResource (..)
    , lbListenerResource

    , LbListenerRuleResource (..)
    , lbListenerRuleResource

    , LbResource (..)
    , lbResource

    , LbSslNegotiationPolicyResource (..)
    , lbSslNegotiationPolicyResource

    , LbTargetGroupAttachmentResource (..)
    , lbTargetGroupAttachmentResource

    , LbTargetGroupResource (..)
    , lbTargetGroupResource

    , LightsailDomainResource (..)
    , lightsailDomainResource

    , LightsailInstanceResource (..)
    , lightsailInstanceResource

    , LightsailKeyPairResource (..)
    , lightsailKeyPairResource

    , LightsailStaticIpAttachmentResource (..)
    , lightsailStaticIpAttachmentResource

    , LightsailStaticIpResource (..)
    , lightsailStaticIpResource

    , MainRouteTableAssociationResource (..)
    , mainRouteTableAssociationResource

    , MediaStoreContainerResource (..)
    , mediaStoreContainerResource

    , MqBrokerResource (..)
    , mqBrokerResource

    , MqConfigurationResource (..)
    , mqConfigurationResource

    , NatGatewayResource (..)
    , natGatewayResource

    , NetworkAclResource (..)
    , networkAclResource

    , NetworkAclRuleResource (..)
    , networkAclRuleResource

    , NetworkInterfaceAttachmentResource (..)
    , networkInterfaceAttachmentResource

    , NetworkInterfaceResource (..)
    , networkInterfaceResource

    , NetworkInterfaceSgAttachmentResource (..)
    , networkInterfaceSgAttachmentResource

    , OpsworksApplicationResource (..)
    , opsworksApplicationResource

    , OpsworksCustomLayerResource (..)
    , opsworksCustomLayerResource

    , OpsworksGangliaLayerResource (..)
    , opsworksGangliaLayerResource

    , OpsworksHaproxyLayerResource (..)
    , opsworksHaproxyLayerResource

    , OpsworksInstanceResource (..)
    , opsworksInstanceResource

    , OpsworksJavaAppLayerResource (..)
    , opsworksJavaAppLayerResource

    , OpsworksMemcachedLayerResource (..)
    , opsworksMemcachedLayerResource

    , OpsworksMysqlLayerResource (..)
    , opsworksMysqlLayerResource

    , OpsworksNodejsAppLayerResource (..)
    , opsworksNodejsAppLayerResource

    , OpsworksPermissionResource (..)
    , opsworksPermissionResource

    , OpsworksPhpAppLayerResource (..)
    , opsworksPhpAppLayerResource

    , OpsworksRailsAppLayerResource (..)
    , opsworksRailsAppLayerResource

    , OpsworksRdsDbInstanceResource (..)
    , opsworksRdsDbInstanceResource

    , OpsworksStackResource (..)
    , opsworksStackResource

    , OpsworksStaticWebLayerResource (..)
    , opsworksStaticWebLayerResource

    , OpsworksUserProfileResource (..)
    , opsworksUserProfileResource

    , PlacementGroupResource (..)
    , placementGroupResource

    , ProxyProtocolPolicyResource (..)
    , proxyProtocolPolicyResource

    , RdsClusterInstanceResource (..)
    , rdsClusterInstanceResource

    , RdsClusterParameterGroupResource (..)
    , rdsClusterParameterGroupResource

    , RdsClusterResource (..)
    , rdsClusterResource

    , RedshiftClusterResource (..)
    , redshiftClusterResource

    , RedshiftParameterGroupResource (..)
    , redshiftParameterGroupResource

    , RedshiftSecurityGroupResource (..)
    , redshiftSecurityGroupResource

    , RedshiftSubnetGroupResource (..)
    , redshiftSubnetGroupResource

    , Route53DelegationSetResource (..)
    , route53DelegationSetResource

    , Route53HealthCheckResource (..)
    , route53HealthCheckResource

    , Route53QueryLogResource (..)
    , route53QueryLogResource

    , Route53RecordResource (..)
    , route53RecordResource

    , Route53ZoneAssociationResource (..)
    , route53ZoneAssociationResource

    , Route53ZoneResource (..)
    , route53ZoneResource

    , RouteResource (..)
    , routeResource

    , RouteTableAssociationResource (..)
    , routeTableAssociationResource

    , RouteTableResource (..)
    , routeTableResource

    , S3BucketMetricResource (..)
    , s3BucketMetricResource

    , S3BucketNotificationResource (..)
    , s3BucketNotificationResource

    , S3BucketObjectResource (..)
    , s3BucketObjectResource

    , S3BucketPolicyResource (..)
    , s3BucketPolicyResource

    , S3BucketResource (..)
    , s3BucketResource

    , SecurityGroupResource (..)
    , securityGroupResource

    , SecurityGroupRuleResource (..)
    , securityGroupRuleResource

    , ServiceDiscoveryPrivateDnsNamespaceResource (..)
    , serviceDiscoveryPrivateDnsNamespaceResource

    , ServiceDiscoveryPublicDnsNamespaceResource (..)
    , serviceDiscoveryPublicDnsNamespaceResource

    , ServiceDiscoveryServiceResource (..)
    , serviceDiscoveryServiceResource

    , ServicecatalogPortfolioResource (..)
    , servicecatalogPortfolioResource

    , SesActiveReceiptRuleSetResource (..)
    , sesActiveReceiptRuleSetResource

    , SesConfigurationSetResource (..)
    , sesConfigurationSetResource

    , SesDomainDkimResource (..)
    , sesDomainDkimResource

    , SesDomainIdentityResource (..)
    , sesDomainIdentityResource

    , SesDomainMailFromResource (..)
    , sesDomainMailFromResource

    , SesEventDestinationResource (..)
    , sesEventDestinationResource

    , SesReceiptFilterResource (..)
    , sesReceiptFilterResource

    , SesReceiptRuleResource (..)
    , sesReceiptRuleResource

    , SesReceiptRuleSetResource (..)
    , sesReceiptRuleSetResource

    , SesTemplateResource (..)
    , sesTemplateResource

    , SimpledbDomainResource (..)
    , simpledbDomainResource

    , SnapshotCreateVolumePermissionResource (..)
    , snapshotCreateVolumePermissionResource

    , SnsPlatformApplicationResource (..)
    , snsPlatformApplicationResource

    , SnsTopicPolicyResource (..)
    , snsTopicPolicyResource

    , SnsTopicResource (..)
    , snsTopicResource

    , SnsTopicSubscriptionResource (..)
    , snsTopicSubscriptionResource

    , SpotDatafeedSubscriptionResource (..)
    , spotDatafeedSubscriptionResource

    , SpotFleetRequestResource (..)
    , spotFleetRequestResource

    , SpotInstanceRequestResource (..)
    , spotInstanceRequestResource

    , SqsQueuePolicyResource (..)
    , sqsQueuePolicyResource

    , SqsQueueResource (..)
    , sqsQueueResource

    , SsmActivationResource (..)
    , ssmActivationResource

    , SsmAssociationResource (..)
    , ssmAssociationResource

    , SsmDocumentResource (..)
    , ssmDocumentResource

    , SsmMaintenanceWindowResource (..)
    , ssmMaintenanceWindowResource

    , SsmMaintenanceWindowTargetResource (..)
    , ssmMaintenanceWindowTargetResource

    , SsmMaintenanceWindowTaskResource (..)
    , ssmMaintenanceWindowTaskResource

    , SsmParameterResource (..)
    , ssmParameterResource

    , SsmPatchBaselineResource (..)
    , ssmPatchBaselineResource

    , SsmPatchGroupResource (..)
    , ssmPatchGroupResource

    , StateMachineResource (..)
    , stateMachineResource

    , SubnetResource (..)
    , subnetResource

    , VolumeAttachmentResource (..)
    , volumeAttachmentResource

    , VpcDhcpOptionsAssociationResource (..)
    , vpcDhcpOptionsAssociationResource

    , VpcDhcpOptionsResource (..)
    , vpcDhcpOptionsResource

    , VpcEndpointConnectionNotificationResource (..)
    , vpcEndpointConnectionNotificationResource

    , VpcEndpointResource (..)
    , vpcEndpointResource

    , VpcEndpointRouteTableAssociationResource (..)
    , vpcEndpointRouteTableAssociationResource

    , VpcEndpointServiceAllowedPrincipalResource (..)
    , vpcEndpointServiceAllowedPrincipalResource

    , VpcEndpointServiceResource (..)
    , vpcEndpointServiceResource

    , VpcEndpointSubnetAssociationResource (..)
    , vpcEndpointSubnetAssociationResource

    , VpcPeeringConnectionAccepterResource (..)
    , vpcPeeringConnectionAccepterResource

    , VpcPeeringConnectionResource (..)
    , vpcPeeringConnectionResource

    , VpcResource (..)
    , vpcResource

    , VpnConnectionResource (..)
    , vpnConnectionResource

    , VpnConnectionRouteResource (..)
    , vpnConnectionRouteResource

    , VpnGatewayAttachmentResource (..)
    , vpnGatewayAttachmentResource

    , VpnGatewayResource (..)
    , vpnGatewayResource

    , VpnGatewayRoutePropagationResource (..)
    , vpnGatewayRoutePropagationResource

    , WafByteMatchSetResource (..)
    , wafByteMatchSetResource

    , WafIpsetResource (..)
    , wafIpsetResource

    , WafRateBasedRuleResource (..)
    , wafRateBasedRuleResource

    , WafRuleResource (..)
    , wafRuleResource

    , WafSizeConstraintSetResource (..)
    , wafSizeConstraintSetResource

    , WafSqlInjectionMatchSetResource (..)
    , wafSqlInjectionMatchSetResource

    , WafWebAclResource (..)
    , wafWebAclResource

    , WafXssMatchSetResource (..)
    , wafXssMatchSetResource

    , WafregionalByteMatchSetResource (..)
    , wafregionalByteMatchSetResource

    , WafregionalIpsetResource (..)
    , wafregionalIpsetResource

    -- * Overloaded Fields
    -- ** Arguments
    , P.HasAccelerationStatus (..)
    , P.HasAcceptanceRequired (..)
    , P.HasAccepter (..)
    , P.HasAccessLogs (..)
    , P.HasAccessPolicies (..)
    , P.HasAccessPolicy (..)
    , P.HasAccountAlias (..)
    , P.HasAccountId (..)
    , P.HasAcl (..)
    , P.HasAction (..)
    , P.HasActionsEnabled (..)
    , P.HasActivate (..)
    , P.HasActive (..)
    , P.HasAddHeaderAction (..)
    , P.HasAdjustmentType (..)
    , P.HasAdminCreateUserConfig (..)
    , P.HasAdvancedOptions (..)
    , P.HasAfter (..)
    , P.HasAgentVersion (..)
    , P.HasAlarmActions (..)
    , P.HasAlarmConfiguration (..)
    , P.HasAlarmDescription (..)
    , P.HasAlarmName (..)
    , P.HasAlbTargetGroupArn (..)
    , P.HasAlias (..)
    , P.HasAliasAttributes (..)
    , P.HasAliases (..)
    , P.HasAllocatedMemory (..)
    , P.HasAllocatedStorage (..)
    , P.HasAllocationId (..)
    , P.HasAllocationStrategy (..)
    , P.HasAllowMajorVersionUpgrade (..)
    , P.HasAllowOverwrite (..)
    , P.HasAllowReassociation (..)
    , P.HasAllowSelfManagement (..)
    , P.HasAllowSsh (..)
    , P.HasAllowSudo (..)
    , P.HasAllowUnassociatedTargets (..)
    , P.HasAllowUnauthenticatedIdentities (..)
    , P.HasAllowUsersToChangePassword (..)
    , P.HasAllowVersionUpgrade (..)
    , P.HasAllowedOauthFlows (..)
    , P.HasAllowedOauthFlowsUserPoolClient (..)
    , P.HasAllowedOauthScopes (..)
    , P.HasAllowedPrincipals (..)
    , P.HasAmazonSideAsn (..)
    , P.HasAmi (..)
    , P.HasAmiId (..)
    , P.HasApiId (..)
    , P.HasApiKeyRequired (..)
    , P.HasApiStages (..)
    , P.HasAppName (..)
    , P.HasAppServer (..)
    , P.HasAppServerVersion (..)
    , P.HasAppSource (..)
    , P.HasApplication (..)
    , P.HasApplicationFailureFeedbackRoleArn (..)
    , P.HasApplicationSuccessFeedbackRoleArn (..)
    , P.HasApplicationSuccessFeedbackSampleRate (..)
    , P.HasApplications (..)
    , P.HasApplyImmediately (..)
    , P.HasApprovalRule (..)
    , P.HasApprovedPatches (..)
    , P.HasApprovedPatchesComplianceLevel (..)
    , P.HasArchitecture (..)
    , P.HasArn (..)
    , P.HasArtifactStore (..)
    , P.HasArtifacts (..)
    , P.HasAssignGeneratedIpv6CidrBlock (..)
    , P.HasAssignIpv6AddressOnCreation (..)
    , P.HasAssociatePublicIpAddress (..)
    , P.HasAssociateWithPrivateIp (..)
    , P.HasAssociationName (..)
    , P.HasAssumeRolePolicy (..)
    , P.HasAtRestEncryptionEnabled (..)
    , P.HasAttachment (..)
    , P.HasAttribute (..)
    , P.HasAudio (..)
    , P.HasAudioCodecOptions (..)
    , P.HasAuthToken (..)
    , P.HasAuthenticationType (..)
    , P.HasAuthorization (..)
    , P.HasAuthorizerCredentials (..)
    , P.HasAuthorizerId (..)
    , P.HasAuthorizerResultTtlInSeconds (..)
    , P.HasAuthorizerUri (..)
    , P.HasAutoAccept (..)
    , P.HasAutoAssignElasticIps (..)
    , P.HasAutoAssignPublicIps (..)
    , P.HasAutoBundleOnDeploy (..)
    , P.HasAutoHealing (..)
    , P.HasAutoMinorVersionUpgrade (..)
    , P.HasAutoRollbackConfiguration (..)
    , P.HasAutoScalingType (..)
    , P.HasAutoVerifiedAttributes (..)
    , P.HasAutomatedSnapshotRetentionPeriod (..)
    , P.HasAutomaticFailoverEnabled (..)
    , P.HasAutomaticStopTimeMinutes (..)
    , P.HasAutoscalingGroupName (..)
    , P.HasAutoscalingGroups (..)
    , P.HasAutoscalingRole (..)
    , P.HasAvailabilityZone (..)
    , P.HasAvailabilityZones (..)
    , P.HasAwsFlowRubySettings (..)
    , P.HasAwsKmsKeyArn (..)
    , P.HasAzMode (..)
    , P.HasBackupRetentionPeriod (..)
    , P.HasBackupWindow (..)
    , P.HasBandwidth (..)
    , P.HasBasePath (..)
    , P.HasBaselineId (..)
    , P.HasBatchSize (..)
    , P.HasBerkshelfVersion (..)
    , P.HasBgpAsn (..)
    , P.HasBinaryMediaTypes (..)
    , P.HasBlockDurationMinutes (..)
    , P.HasBlueGreenDeploymentConfig (..)
    , P.HasBlueprintId (..)
    , P.HasBody (..)
    , P.HasBootstrapAction (..)
    , P.HasBounceAction (..)
    , P.HasBranches (..)
    , P.HasBrokerName (..)
    , P.HasBucket (..)
    , P.HasBucketPrefix (..)
    , P.HasBuildId (..)
    , P.HasBuildTimeout (..)
    , P.HasBundleId (..)
    , P.HasBundlerVersion (..)
    , P.HasByteMatchTuple (..)
    , P.HasByteMatchTuples (..)
    , P.HasCacheBehavior (..)
    , P.HasCacheClusterEnabled (..)
    , P.HasCacheClusterSize (..)
    , P.HasCacheControl (..)
    , P.HasCacheKeyNamespace (..)
    , P.HasCacheKeyParameters (..)
    , P.HasCallbackUrls (..)
    , P.HasCapabilities (..)
    , P.HasCatalogId (..)
    , P.HasCdcStartTime (..)
    , P.HasCertificateArn (..)
    , P.HasCertificateBody (..)
    , P.HasCertificateChain (..)
    , P.HasCertificateId (..)
    , P.HasCertificateName (..)
    , P.HasCertificatePem (..)
    , P.HasCertificatePrivateKey (..)
    , P.HasCertificateWallet (..)
    , P.HasCharacterSetName (..)
    , P.HasChildHealthThreshold (..)
    , P.HasChildHealthchecks (..)
    , P.HasCidr (..)
    , P.HasCidrBlock (..)
    , P.HasCidrBlocks (..)
    , P.HasClientCertificateId (..)
    , P.HasClientIdList (..)
    , P.HasCloudWatchLogsGroupArn (..)
    , P.HasCloudWatchLogsRoleArn (..)
    , P.HasCloudwatchAlarmName (..)
    , P.HasCloudwatchAlarmRegion (..)
    , P.HasCloudwatchDestination (..)
    , P.HasCloudwatchLogGroupArn (..)
    , P.HasCloudwatchRoleArn (..)
    , P.HasCluster (..)
    , P.HasClusterConfig (..)
    , P.HasClusterId (..)
    , P.HasClusterIdentifier (..)
    , P.HasClusterIdentifierPrefix (..)
    , P.HasClusterMode (..)
    , P.HasClusterName (..)
    , P.HasClusterParameterGroupName (..)
    , P.HasClusterSecurityGroups (..)
    , P.HasClusterSubnetGroupName (..)
    , P.HasClusterType (..)
    , P.HasClusterVersion (..)
    , P.HasCnamePrefix (..)
    , P.HasCognitoIdentityProviders (..)
    , P.HasColor (..)
    , P.HasComment (..)
    , P.HasComparisonOperator (..)
    , P.HasComputeEnvironmentName (..)
    , P.HasComputeEnvironments (..)
    , P.HasComputeResources (..)
    , P.HasCondition (..)
    , P.HasConfiguration (..)
    , P.HasConfigurationManagerName (..)
    , P.HasConfigurationManagerVersion (..)
    , P.HasConfigurationSetName (..)
    , P.HasConfigurations (..)
    , P.HasConfirmationTimeoutInMinutes (..)
    , P.HasConnectSettings (..)
    , P.HasConnectionDraining (..)
    , P.HasConnectionDrainingTimeout (..)
    , P.HasConnectionEvents (..)
    , P.HasConnectionId (..)
    , P.HasConnectionNotificationArn (..)
    , P.HasConnectionsBandwidth (..)
    , P.HasContainer (..)
    , P.HasContainerDefinitions (..)
    , P.HasContainerProperties (..)
    , P.HasContent (..)
    , P.HasContentBasedDeduplication (..)
    , P.HasContentConfig (..)
    , P.HasContentConfigPermissions (..)
    , P.HasContentDisposition (..)
    , P.HasContentEncoding (..)
    , P.HasContentHandling (..)
    , P.HasContentLanguage (..)
    , P.HasContentType (..)
    , P.HasCookieExpirationPeriod (..)
    , P.HasCookieName (..)
    , P.HasCopyTagsToSnapshot (..)
    , P.HasCoreInstanceCount (..)
    , P.HasCoreInstanceType (..)
    , P.HasCorsRule (..)
    , P.HasCreationToken (..)
    , P.HasCredentials (..)
    , P.HasCrossZoneLoadBalancing (..)
    , P.HasCsr (..)
    , P.HasCustomAmiId (..)
    , P.HasCustomCookbooksSource (..)
    , P.HasCustomData (..)
    , P.HasCustomErrorResponse (..)
    , P.HasCustomInstanceProfileArn (..)
    , P.HasCustomJson (..)
    , P.HasCustomSecurityGroupIds (..)
    , P.HasCustomerGatewayId (..)
    , P.HasCutoff (..)
    , P.HasDashboardBody (..)
    , P.HasDashboardName (..)
    , P.HasData' (..)
    , P.HasDataSourceArn (..)
    , P.HasDataSourceDatabaseName (..)
    , P.HasDataSourceType (..)
    , P.HasDatabase (..)
    , P.HasDatabaseName (..)
    , P.HasDatapointsToAlarm (..)
    , P.HasDbClusterParameterGroupName (..)
    , P.HasDbInstanceIdentifier (..)
    , P.HasDbParameterGroupName (..)
    , P.HasDbPassword (..)
    , P.HasDbSnapshotIdentifier (..)
    , P.HasDbSubnetGroupName (..)
    , P.HasDbUser (..)
    , P.HasDeadLetterConfig (..)
    , P.HasDefaultAction (..)
    , P.HasDefaultAvailabilityZone (..)
    , P.HasDefaultBranch (..)
    , P.HasDefaultCacheBehavior (..)
    , P.HasDefaultCooldown (..)
    , P.HasDefaultInstanceProfileArn (..)
    , P.HasDefaultNetworkAclId (..)
    , P.HasDefaultOs (..)
    , P.HasDefaultRedirectUri (..)
    , P.HasDefaultResult (..)
    , P.HasDefaultRootDeviceType (..)
    , P.HasDefaultRootObject (..)
    , P.HasDefaultRouteTableId (..)
    , P.HasDefaultSshKeyName (..)
    , P.HasDefaultSubnetId (..)
    , P.HasDefinition (..)
    , P.HasDelaySeconds (..)
    , P.HasDelegationSetId (..)
    , P.HasDeletionWindowInDays (..)
    , P.HasDeliveryPolicy (..)
    , P.HasDeploymentConfigName (..)
    , P.HasDeploymentGroupName (..)
    , P.HasDeploymentId (..)
    , P.HasDeploymentMaximumPercent (..)
    , P.HasDeploymentMinimumHealthyPercent (..)
    , P.HasDeploymentMode (..)
    , P.HasDeploymentStyle (..)
    , P.HasDeregistrationDelay (..)
    , P.HasDescription (..)
    , P.HasDesiredCapacity (..)
    , P.HasDesiredCount (..)
    , P.HasDestination (..)
    , P.HasDestinationArn (..)
    , P.HasDestinationCidrBlock (..)
    , P.HasDestinationIpv6CidrBlock (..)
    , P.HasDestinationName (..)
    , P.HasDetectorId (..)
    , P.HasDeveloperProviderName (..)
    , P.HasDeviceConfiguration (..)
    , P.HasDeviceIndex (..)
    , P.HasDeviceName (..)
    , P.HasDhcpOptionsId (..)
    , P.HasDimensions (..)
    , P.HasDisableApiTermination (..)
    , P.HasDisableRollback (..)
    , P.HasDisplayName (..)
    , P.HasDistribution (..)
    , P.HasDnsConfig (..)
    , P.HasDocumentRoot (..)
    , P.HasDocumentType (..)
    , P.HasDocumentVersion (..)
    , P.HasDocumentationVersion (..)
    , P.HasDomain (..)
    , P.HasDomainName (..)
    , P.HasDomainNameServers (..)
    , P.HasDomains (..)
    , P.HasDrainElbOnShutdown (..)
    , P.HasDuration (..)
    , P.HasEbsBlockDevice (..)
    , P.HasEbsConfig (..)
    , P.HasEbsOptimized (..)
    , P.HasEbsOptions (..)
    , P.HasEbsRootVolumeSize (..)
    , P.HasEbsVolume (..)
    , P.HasEc2Attributes (..)
    , P.HasEc2InboundPermission (..)
    , P.HasEc2InstanceType (..)
    , P.HasEc2TagFilter (..)
    , P.HasEcsTarget (..)
    , P.HasEgress (..)
    , P.HasEgressOnlyGatewayId (..)
    , P.HasElasticIp (..)
    , P.HasElasticLoadBalancer (..)
    , P.HasElasticsearchVersion (..)
    , P.HasElb (..)
    , P.HasEmail (..)
    , P.HasEmailConfiguration (..)
    , P.HasEmailVerificationMessage (..)
    , P.HasEmailVerificationSubject (..)
    , P.HasEnable (..)
    , P.HasEnableClassiclink (..)
    , P.HasEnableClassiclinkDnsSupport (..)
    , P.HasEnableDeletionProtection (..)
    , P.HasEnableDnsHostnames (..)
    , P.HasEnableDnsSupport (..)
    , P.HasEnableKeyRotation (..)
    , P.HasEnableLogFileValidation (..)
    , P.HasEnableLogging (..)
    , P.HasEnableMonitoring (..)
    , P.HasEnableSni (..)
    , P.HasEnableSsl (..)
    , P.HasEnableSso (..)
    , P.HasEnabled (..)
    , P.HasEnabledMetrics (..)
    , P.HasEncoding (..)
    , P.HasEncryptAtRest (..)
    , P.HasEncrypted (..)
    , P.HasEncryptionKey (..)
    , P.HasEncryptionType (..)
    , P.HasEndTime (..)
    , P.HasEndpoint (..)
    , P.HasEndpointAutoConfirms (..)
    , P.HasEndpointId (..)
    , P.HasEndpointType (..)
    , P.HasEngine (..)
    , P.HasEngineName (..)
    , P.HasEngineType (..)
    , P.HasEngineVersion (..)
    , P.HasEnhancedVpcRouting (..)
    , P.HasEniId (..)
    , P.HasEnvironment (..)
    , P.HasEnvironmentId (..)
    , P.HasEphemeralBlockDevice (..)
    , P.HasEtag (..)
    , P.HasEvaluateLowSampleCountPercentiles (..)
    , P.HasEvaluationPeriods (..)
    , P.HasEventCategories (..)
    , P.HasEventDeliveryFailureTopicArn (..)
    , P.HasEventEndpointCreatedTopicArn (..)
    , P.HasEventEndpointDeletedTopicArn (..)
    , P.HasEventEndpointUpdatedTopic (..)
    , P.HasEventPattern (..)
    , P.HasEventSourceArn (..)
    , P.HasEvents (..)
    , P.HasExcessCapacityTerminationPolicy (..)
    , P.HasExpirationDate (..)
    , P.HasExplicitAuthFlows (..)
    , P.HasExtendedS3Configuration (..)
    , P.HasExtendedStatistic (..)
    , P.HasExtraConnectionAttributes (..)
    , P.HasFailoverRoutingPolicy (..)
    , P.HasFailureFeedbackRoleArn (..)
    , P.HasFailureThreshold (..)
    , P.HasFamily' (..)
    , P.HasFifoQueue (..)
    , P.HasFileSystemId (..)
    , P.HasFilename (..)
    , P.HasFilter (..)
    , P.HasFilterPattern (..)
    , P.HasFilterPolicy (..)
    , P.HasFinalSnapshotIdentifier (..)
    , P.HasForceDelete (..)
    , P.HasForceDestroy (..)
    , P.HasForceDetach (..)
    , P.HasFormat (..)
    , P.HasFqdn (..)
    , P.HasFromPort (..)
    , P.HasFunctionName (..)
    , P.HasFunctionVersion (..)
    , P.HasGatewayId (..)
    , P.HasGenerateSecret (..)
    , P.HasGeolocationRoutingPolicy (..)
    , P.HasGlobalFilter (..)
    , P.HasGlobalSecondaryIndex (..)
    , P.HasGroup (..)
    , P.HasGroupNames (..)
    , P.HasGroups (..)
    , P.HasHandler (..)
    , P.HasHardExpiry (..)
    , P.HasHashKey (..)
    , P.HasHealthCheck (..)
    , P.HasHealthCheckConfig (..)
    , P.HasHealthCheckGracePeriod (..)
    , P.HasHealthCheckGracePeriodSeconds (..)
    , P.HasHealthCheckId (..)
    , P.HasHealthCheckType (..)
    , P.HasHealthcheckMethod (..)
    , P.HasHealthcheckUrl (..)
    , P.HasHeartbeatTimeout (..)
    , P.HasHostInstanceType (..)
    , P.HasHostname (..)
    , P.HasHostnameTheme (..)
    , P.HasHtml (..)
    , P.HasHttpFailureFeedbackRoleArn (..)
    , P.HasHttpMethod (..)
    , P.HasHttpSuccessFeedbackRoleArn (..)
    , P.HasHttpSuccessFeedbackSampleRate (..)
    , P.HasHttpVersion (..)
    , P.HasIamDatabaseAuthenticationEnabled (..)
    , P.HasIamFleetRole (..)
    , P.HasIamInstanceProfile (..)
    , P.HasIamRole (..)
    , P.HasIamRoleArn (..)
    , P.HasIamRoles (..)
    , P.HasIcmpCode (..)
    , P.HasIcmpType (..)
    , P.HasIdentifier (..)
    , P.HasIdentifierPrefix (..)
    , P.HasIdentityPoolId (..)
    , P.HasIdentityPoolName (..)
    , P.HasIdentitySource (..)
    , P.HasIdentityValidationExpression (..)
    , P.HasIdleTimeout (..)
    , P.HasImageId (..)
    , P.HasIncludeGlobalServiceEvents (..)
    , P.HasIngress (..)
    , P.HasInitialLifecycleHook (..)
    , P.HasInput (..)
    , P.HasInputBucket (..)
    , P.HasInputParameters (..)
    , P.HasInputPath (..)
    , P.HasInputTransformer (..)
    , P.HasInstallUpdatesOnBoot (..)
    , P.HasInstance' (..)
    , P.HasInstanceClass (..)
    , P.HasInstanceCount (..)
    , P.HasInstanceGroup (..)
    , P.HasInstanceId (..)
    , P.HasInstanceInitiatedShutdownBehavior (..)
    , P.HasInstanceInterruptionBehavior (..)
    , P.HasInstanceName (..)
    , P.HasInstancePort (..)
    , P.HasInstancePorts (..)
    , P.HasInstanceShutdownTimeout (..)
    , P.HasInstanceTenancy (..)
    , P.HasInstanceType (..)
    , P.HasInstances (..)
    , P.HasInsufficientDataActions (..)
    , P.HasInsufficientDataHealthStatus (..)
    , P.HasIntegrationHttpMethod (..)
    , P.HasInternal (..)
    , P.HasInvertHealthcheck (..)
    , P.HasIops (..)
    , P.HasIpAddress (..)
    , P.HasIpAddressType (..)
    , P.HasIpSetDescriptor (..)
    , P.HasIpSetDescriptors (..)
    , P.HasIpv6AddressCount (..)
    , P.HasIpv6Addresses (..)
    , P.HasIpv6CidrBlock (..)
    , P.HasIpv6CidrBlocks (..)
    , P.HasIsEnabled (..)
    , P.HasIsIpv6Enabled (..)
    , P.HasIsMultiRegionTrail (..)
    , P.HasItem (..)
    , P.HasJvmOptions (..)
    , P.HasJvmType (..)
    , P.HasJvmVersion (..)
    , P.HasKeepJobFlowAliveWhenNoSteps (..)
    , P.HasKey (..)
    , P.HasKeyId (..)
    , P.HasKeyName (..)
    , P.HasKeyNamePrefix (..)
    , P.HasKeyPairName (..)
    , P.HasKeyType (..)
    , P.HasKeyUsage (..)
    , P.HasKinesisDestination (..)
    , P.HasKinesisSourceConfiguration (..)
    , P.HasKmsDataKeyReusePeriodSeconds (..)
    , P.HasKmsKeyArn (..)
    , P.HasKmsKeyId (..)
    , P.HasKmsMasterKeyId (..)
    , P.HasLagId (..)
    , P.HasLambdaAction (..)
    , P.HasLambdaConfig (..)
    , P.HasLambdaFailureFeedbackRoleArn (..)
    , P.HasLambdaFunction (..)
    , P.HasLambdaSuccessFeedbackRoleArn (..)
    , P.HasLambdaSuccessFeedbackSampleRate (..)
    , P.HasLatencyRoutingPolicy (..)
    , P.HasLaunchConfiguration (..)
    , P.HasLaunchGroup (..)
    , P.HasLaunchSpecification (..)
    , P.HasLaunchType (..)
    , P.HasLayerIds (..)
    , P.HasLbPort (..)
    , P.HasLevel (..)
    , P.HasLicenseModel (..)
    , P.HasLifecycleRule (..)
    , P.HasLifecycleTransition (..)
    , P.HasListener (..)
    , P.HasListenerArn (..)
    , P.HasLoadBalancer (..)
    , P.HasLoadBalancerArn (..)
    , P.HasLoadBalancerInfo (..)
    , P.HasLoadBalancerName (..)
    , P.HasLoadBalancerPort (..)
    , P.HasLoadBalancerType (..)
    , P.HasLoadBalancers (..)
    , P.HasLocalSecondaryIndex (..)
    , P.HasLocation (..)
    , P.HasLocationUri (..)
    , P.HasLogGroupName (..)
    , P.HasLogPublishingOptions (..)
    , P.HasLogUri (..)
    , P.HasLogging (..)
    , P.HasLoggingConfig (..)
    , P.HasLoggingInfo (..)
    , P.HasLogoutUrls (..)
    , P.HasMailFromDomain (..)
    , P.HasMaintenanceWindow (..)
    , P.HasMaintenanceWindowStartTime (..)
    , P.HasMajorEngineVersion (..)
    , P.HasManageBerkshelf (..)
    , P.HasManageBundler (..)
    , P.HasMapPublicIpOnLaunch (..)
    , P.HasMasterInstanceType (..)
    , P.HasMasterPassword (..)
    , P.HasMasterUsername (..)
    , P.HasMatchingTypes (..)
    , P.HasMaxCapacity (..)
    , P.HasMaxConcurrency (..)
    , P.HasMaxErrors (..)
    , P.HasMaxMessageSize (..)
    , P.HasMaxPasswordAge (..)
    , P.HasMaxSize (..)
    , P.HasMaximumExecutionFrequency (..)
    , P.HasMeasureLatency (..)
    , P.HasMemorySize (..)
    , P.HasMessageRetentionSeconds (..)
    , P.HasMethodPath (..)
    , P.HasMetricGroups (..)
    , P.HasMetricName (..)
    , P.HasMetricTransformation (..)
    , P.HasMetricsGranularity (..)
    , P.HasMfaConfiguration (..)
    , P.HasMigrationType (..)
    , P.HasMinCapacity (..)
    , P.HasMinElbCapacity (..)
    , P.HasMinSize (..)
    , P.HasMinimumHealthyHosts (..)
    , P.HasMinimumPasswordLength (..)
    , P.HasMonitoring (..)
    , P.HasMonitoringInterval (..)
    , P.HasMonitoringRoleArn (..)
    , P.HasMultiAz (..)
    , P.HasMultivalueAnswerRoutingPolicy (..)
    , P.HasName (..)
    , P.HasNamePrefix (..)
    , P.HasNamespace (..)
    , P.HasNatGatewayId (..)
    , P.HasNetbiosNameServers (..)
    , P.HasNetbiosNodeType (..)
    , P.HasNetworkAclId (..)
    , P.HasNetworkConfiguration (..)
    , P.HasNetworkInterface (..)
    , P.HasNetworkInterfaceId (..)
    , P.HasNetworkLoadBalancerArns (..)
    , P.HasNewGameSessionProtectionPolicy (..)
    , P.HasNodeType (..)
    , P.HasNodejsVersion (..)
    , P.HasNotification (..)
    , P.HasNotificationArns (..)
    , P.HasNotificationMetadata (..)
    , P.HasNotificationTargetArn (..)
    , P.HasNotificationTopicArn (..)
    , P.HasNotifications (..)
    , P.HasNtpServers (..)
    , P.HasNumCacheNodes (..)
    , P.HasNumberCacheClusters (..)
    , P.HasNumberOfConnections (..)
    , P.HasNumberOfNodes (..)
    , P.HasOkActions (..)
    , P.HasOnFailure (..)
    , P.HasOnPremisesInstanceTagFilter (..)
    , P.HasOpenidConnectProviderArns (..)
    , P.HasOperatingSystem (..)
    , P.HasOption (..)
    , P.HasOptionGroupDescription (..)
    , P.HasOptionGroupName (..)
    , P.HasOrigin (..)
    , P.HasOs (..)
    , P.HasOutputBucket (..)
    , P.HasOutputLocation (..)
    , P.HasOverwrite (..)
    , P.HasOwnerAccount (..)
    , P.HasOwnerArn (..)
    , P.HasOwnerInformation (..)
    , P.HasParameter (..)
    , P.HasParameterGroupName (..)
    , P.HasParameters (..)
    , P.HasParentId (..)
    , P.HasPassengerVersion (..)
    , P.HasPassthroughBehavior (..)
    , P.HasPassword (..)
    , P.HasPasswordLength (..)
    , P.HasPasswordPolicy (..)
    , P.HasPasswordResetRequired (..)
    , P.HasPasswordReusePrevention (..)
    , P.HasPatchGroup (..)
    , P.HasPath (..)
    , P.HasPathPart (..)
    , P.HasPattern (..)
    , P.HasPeerOwnerId (..)
    , P.HasPeerRegion (..)
    , P.HasPeerVpcId (..)
    , P.HasPerformanceInsightsEnabled (..)
    , P.HasPerformanceInsightsKmsKeyId (..)
    , P.HasPerformanceMode (..)
    , P.HasPeriod (..)
    , P.HasPermissions (..)
    , P.HasPgpKey (..)
    , P.HasPlacementConstraints (..)
    , P.HasPlacementGroup (..)
    , P.HasPlacementStrategy (..)
    , P.HasPlacementTenancy (..)
    , P.HasPlatform (..)
    , P.HasPlatformCredential (..)
    , P.HasPlatformPrincipal (..)
    , P.HasPolicy (..)
    , P.HasPolicyArn (..)
    , P.HasPolicyAttribute (..)
    , P.HasPolicyBody (..)
    , P.HasPolicyDocument (..)
    , P.HasPolicyName (..)
    , P.HasPolicyNames (..)
    , P.HasPolicyType (..)
    , P.HasPolicyTypeName (..)
    , P.HasPolicyUrl (..)
    , P.HasPollInterval (..)
    , P.HasPort (..)
    , P.HasPrecedence (..)
    , P.HasPredicates (..)
    , P.HasPreferredBackupWindow (..)
    , P.HasPreferredMaintenanceWindow (..)
    , P.HasPrefix (..)
    , P.HasPrefixListIds (..)
    , P.HasPriceClass (..)
    , P.HasPrincipal (..)
    , P.HasPrincipalArn (..)
    , P.HasPriority (..)
    , P.HasPrivateDnsEnabled (..)
    , P.HasPrivateIp (..)
    , P.HasPrivateIpAddress (..)
    , P.HasPrivateIps (..)
    , P.HasPrivateIpsCount (..)
    , P.HasPrivateKey (..)
    , P.HasProductCode (..)
    , P.HasPromotionTier (..)
    , P.HasPropagatingVgws (..)
    , P.HasProperties (..)
    , P.HasProtectFromScaleIn (..)
    , P.HasProtocol (..)
    , P.HasProviderName (..)
    , P.HasPublicIp (..)
    , P.HasPublicKey (..)
    , P.HasPubliclyAccessible (..)
    , P.HasPublish (..)
    , P.HasQualifier (..)
    , P.HasQuery (..)
    , P.HasQueue (..)
    , P.HasQueueUrl (..)
    , P.HasQuotaSettings (..)
    , P.HasRailsEnv (..)
    , P.HasRangeKey (..)
    , P.HasRateKey (..)
    , P.HasRateLimit (..)
    , P.HasRawMessageDelivery (..)
    , P.HasRdsDbInstanceArn (..)
    , P.HasReadAttributes (..)
    , P.HasReadCapacity (..)
    , P.HasReceiveWaitTimeSeconds (..)
    , P.HasRecipients (..)
    , P.HasRecordingGroup (..)
    , P.HasRecords (..)
    , P.HasRecurrence (..)
    , P.HasRedrivePolicy (..)
    , P.HasRedshiftConfiguration (..)
    , P.HasReferenceName (..)
    , P.HasRefreshTokenValidity (..)
    , P.HasRegion (..)
    , P.HasRegions (..)
    , P.HasRegistrationLimit (..)
    , P.HasRejectedPatches (..)
    , P.HasReleaseLabel (..)
    , P.HasReplaceUnhealthyInstances (..)
    , P.HasReplica (..)
    , P.HasReplicateSourceDb (..)
    , P.HasReplicationConfiguration (..)
    , P.HasReplicationFactor (..)
    , P.HasReplicationGroupDescription (..)
    , P.HasReplicationGroupId (..)
    , P.HasReplicationInstanceArn (..)
    , P.HasReplicationInstanceClass (..)
    , P.HasReplicationInstanceId (..)
    , P.HasReplicationSubnetGroupDescription (..)
    , P.HasReplicationSubnetGroupId (..)
    , P.HasReplicationTaskId (..)
    , P.HasReplicationTaskSettings (..)
    , P.HasRepository (..)
    , P.HasRepositoryName (..)
    , P.HasRequestInterval (..)
    , P.HasRequestModels (..)
    , P.HasRequestParameters (..)
    , P.HasRequestParametersInJson (..)
    , P.HasRequestPayer (..)
    , P.HasRequestTemplates (..)
    , P.HasRequestValidatorId (..)
    , P.HasRequester (..)
    , P.HasRequireLowercaseCharacters (..)
    , P.HasRequireNumbers (..)
    , P.HasRequireSymbols (..)
    , P.HasRequireUppercaseCharacters (..)
    , P.HasReservedConcurrentExecutions (..)
    , P.HasResourceCreationLimitPolicy (..)
    , P.HasResourceGroupArn (..)
    , P.HasResourceId (..)
    , P.HasResourcePath (..)
    , P.HasResourceType (..)
    , P.HasResponseModels (..)
    , P.HasResponseParameters (..)
    , P.HasResponseParametersInJson (..)
    , P.HasResponseTemplates (..)
    , P.HasResponseType (..)
    , P.HasRestApiId (..)
    , P.HasRestrictions (..)
    , P.HasRetainOnDelete (..)
    , P.HasRetentionInDays (..)
    , P.HasRetentionPeriod (..)
    , P.HasRetryStrategy (..)
    , P.HasRevokeRulesOnDelete (..)
    , P.HasRole (..)
    , P.HasRoleArn (..)
    , P.HasRoleMapping (..)
    , P.HasRoles (..)
    , P.HasRootBlockDevice (..)
    , P.HasRootDeviceName (..)
    , P.HasRootDeviceType (..)
    , P.HasRootPassword (..)
    , P.HasRootPasswordOnAllInstances (..)
    , P.HasRoute (..)
    , P.HasRouteTableId (..)
    , P.HasRouteTableIds (..)
    , P.HasRoutingStrategy (..)
    , P.HasRubyVersion (..)
    , P.HasRubygemsVersion (..)
    , P.HasRule (..)
    , P.HasRuleAction (..)
    , P.HasRuleNumber (..)
    , P.HasRuleSetName (..)
    , P.HasRules (..)
    , P.HasRulesPackageArns (..)
    , P.HasRunCommandTargets (..)
    , P.HasRuntime (..)
    , P.HasRuntimeConfiguration (..)
    , P.HasS3Action (..)
    , P.HasS3Bucket (..)
    , P.HasS3BucketName (..)
    , P.HasS3Configuration (..)
    , P.HasS3Destination (..)
    , P.HasS3Key (..)
    , P.HasS3KeyPrefix (..)
    , P.HasS3ObjectVersion (..)
    , P.HasSamlMetadataDocument (..)
    , P.HasSamlProviderArns (..)
    , P.HasScalableDimension (..)
    , P.HasScalableTargetAction (..)
    , P.HasScanEnabled (..)
    , P.HasSchedule (..)
    , P.HasScheduleExpression (..)
    , P.HasScheduledActionName (..)
    , P.HasSchema (..)
    , P.HasScope (..)
    , P.HasSearchString (..)
    , P.HasSecurityConfiguration (..)
    , P.HasSecurityGroupId (..)
    , P.HasSecurityGroupIds (..)
    , P.HasSecurityGroupNames (..)
    , P.HasSecurityGroups (..)
    , P.HasSelectionPattern (..)
    , P.HasSelf (..)
    , P.HasServerName (..)
    , P.HasServerSideEncryption (..)
    , P.HasServerSideEncryptionConfiguration (..)
    , P.HasServiceAccessRole (..)
    , P.HasServiceName (..)
    , P.HasServiceNamespace (..)
    , P.HasServiceRole (..)
    , P.HasServiceRoleArn (..)
    , P.HasSetIdentifier (..)
    , P.HasSetting (..)
    , P.HasSettings (..)
    , P.HasShardCount (..)
    , P.HasShardLevelMetrics (..)
    , P.HasShortName (..)
    , P.HasSize (..)
    , P.HasSizeConstraints (..)
    , P.HasSkipDestroy (..)
    , P.HasSkipFinalSnapshot (..)
    , P.HasSmsAuthenticationMessage (..)
    , P.HasSmsConfiguration (..)
    , P.HasSmsVerificationMessage (..)
    , P.HasSnapshotArns (..)
    , P.HasSnapshotClusterIdentifier (..)
    , P.HasSnapshotCopy (..)
    , P.HasSnapshotDeliveryProperties (..)
    , P.HasSnapshotId (..)
    , P.HasSnapshotIdentifier (..)
    , P.HasSnapshotName (..)
    , P.HasSnapshotOptions (..)
    , P.HasSnapshotRetentionLimit (..)
    , P.HasSnapshotWindow (..)
    , P.HasSnapshotWithoutReboot (..)
    , P.HasSnsAction (..)
    , P.HasSnsDestination (..)
    , P.HasSnsTopic (..)
    , P.HasSnsTopicArn (..)
    , P.HasSnsTopicName (..)
    , P.HasSolutionStackName (..)
    , P.HasSource (..)
    , P.HasSourceAccount (..)
    , P.HasSourceAmiId (..)
    , P.HasSourceAmiRegion (..)
    , P.HasSourceArn (..)
    , P.HasSourceCodeHash (..)
    , P.HasSourceDestCheck (..)
    , P.HasSourceEndpointArn (..)
    , P.HasSourceIds (..)
    , P.HasSourceInstanceId (..)
    , P.HasSourceSecurityGroupId (..)
    , P.HasSourceType (..)
    , P.HasSpotPrice (..)
    , P.HasSpotType (..)
    , P.HasSql (..)
    , P.HasSqlInjectionMatchTuples (..)
    , P.HasSqlVersion (..)
    , P.HasSqsFailureFeedbackRoleArn (..)
    , P.HasSqsSuccessFeedbackRoleArn (..)
    , P.HasSqsSuccessFeedbackSampleRate (..)
    , P.HasSshKeyName (..)
    , P.HasSshPublicKey (..)
    , P.HasSshUsername (..)
    , P.HasSslConfiguration (..)
    , P.HasSslMode (..)
    , P.HasSslPolicy (..)
    , P.HasStackId (..)
    , P.HasStage (..)
    , P.HasStageDescription (..)
    , P.HasStageKey (..)
    , P.HasStageName (..)
    , P.HasStartTime (..)
    , P.HasStartingPosition (..)
    , P.HasState (..)
    , P.HasStatementId (..)
    , P.HasStaticIpName (..)
    , P.HasStaticRoutesOnly (..)
    , P.HasStatistic (..)
    , P.HasStatsEnabled (..)
    , P.HasStatsPassword (..)
    , P.HasStatsUrl (..)
    , P.HasStatsUser (..)
    , P.HasStatus (..)
    , P.HasStatusCode (..)
    , P.HasStepScalingPolicyConfiguration (..)
    , P.HasStickiness (..)
    , P.HasStopAction (..)
    , P.HasStorageClass (..)
    , P.HasStorageEncrypted (..)
    , P.HasStorageLocation (..)
    , P.HasStorageType (..)
    , P.HasStrategy (..)
    , P.HasStreamEnabled (..)
    , P.HasStreamViewType (..)
    , P.HasSubject (..)
    , P.HasSubjectAlternativeNames (..)
    , P.HasSubnetGroupName (..)
    , P.HasSubnetId (..)
    , P.HasSubnetIds (..)
    , P.HasSubnetMapping (..)
    , P.HasSubnets (..)
    , P.HasSuccessFeedbackRoleArn (..)
    , P.HasSuccessFeedbackSampleRate (..)
    , P.HasSupportedIdentityProviders (..)
    , P.HasSupportedLoginProviders (..)
    , P.HasSuspendedProcesses (..)
    , P.HasSystemPackages (..)
    , P.HasTableMappings (..)
    , P.HasTableName (..)
    , P.HasTag (..)
    , P.HasTags (..)
    , P.HasTargetArn (..)
    , P.HasTargetCapacity (..)
    , P.HasTargetEndpointArn (..)
    , P.HasTargetGroupArn (..)
    , P.HasTargetGroupArns (..)
    , P.HasTargetId (..)
    , P.HasTargetKeyId (..)
    , P.HasTargetTrackingScalingPolicyConfiguration (..)
    , P.HasTargetType (..)
    , P.HasTargets (..)
    , P.HasTaskArn (..)
    , P.HasTaskDefinition (..)
    , P.HasTaskParameters (..)
    , P.HasTaskType (..)
    , P.HasTemplateBody (..)
    , P.HasTemplateName (..)
    , P.HasTemplateUrl (..)
    , P.HasTenancy (..)
    , P.HasTerminateInstancesWithExpiration (..)
    , P.HasTerminationPolicies (..)
    , P.HasTerminationProtection (..)
    , P.HasText (..)
    , P.HasThreshold (..)
    , P.HasThrottleSettings (..)
    , P.HasThumbnailConfig (..)
    , P.HasThumbnailConfigPermissions (..)
    , P.HasThumbnails (..)
    , P.HasThumbprintList (..)
    , P.HasTier (..)
    , P.HasTimeout (..)
    , P.HasTimeoutInMinutes (..)
    , P.HasTimezone (..)
    , P.HasTlsPolicy (..)
    , P.HasToPort (..)
    , P.HasTopic (..)
    , P.HasTopicArn (..)
    , P.HasTrafficType (..)
    , P.HasTransitEncryptionEnabled (..)
    , P.HasTreatMissingData (..)
    , P.HasTriggerConfiguration (..)
    , P.HasTtl (..)
    , P.HasTunnel1InsideCidr (..)
    , P.HasTunnel1PresharedKey (..)
    , P.HasTunnel2InsideCidr (..)
    , P.HasTunnel2PresharedKey (..)
    , P.HasType' (..)
    , P.HasUnit (..)
    , P.HasUri (..)
    , P.HasUrl (..)
    , P.HasUsagePlanId (..)
    , P.HasUseCustomCookbooks (..)
    , P.HasUseEbsOptimizedInstances (..)
    , P.HasUseOpsworksSecurityGroups (..)
    , P.HasUser (..)
    , P.HasUserArn (..)
    , P.HasUserData (..)
    , P.HasUserDataBase64 (..)
    , P.HasUserPoolConfig (..)
    , P.HasUserPoolId (..)
    , P.HasUsername (..)
    , P.HasUsernameAttributes (..)
    , P.HasUsers (..)
    , P.HasValidUntil (..)
    , P.HasValidationMethod (..)
    , P.HasValidationRecordFqdns (..)
    , P.HasValue (..)
    , P.HasVariables (..)
    , P.HasVerificationMessageTemplate (..)
    , P.HasVersion (..)
    , P.HasVersionLabel (..)
    , P.HasVersioning (..)
    , P.HasVideo (..)
    , P.HasVideoCodecOptions (..)
    , P.HasVideoWatermarks (..)
    , P.HasViewerCertificate (..)
    , P.HasVirtualizationType (..)
    , P.HasVisibilityTimeoutSeconds (..)
    , P.HasVisibleToAllUsers (..)
    , P.HasVolumeId (..)
    , P.HasVolumeTags (..)
    , P.HasVpc (..)
    , P.HasVpcClassicLinkId (..)
    , P.HasVpcClassicLinkSecurityGroups (..)
    , P.HasVpcConfig (..)
    , P.HasVpcEndpointId (..)
    , P.HasVpcEndpointServiceId (..)
    , P.HasVpcEndpointType (..)
    , P.HasVpcId (..)
    , P.HasVpcOptions (..)
    , P.HasVpcPeeringConnectionId (..)
    , P.HasVpcRegion (..)
    , P.HasVpcSecurityGroupIds (..)
    , P.HasVpcSettings (..)
    , P.HasVpcZoneIdentifier (..)
    , P.HasVpnConnectionId (..)
    , P.HasVpnGatewayId (..)
    , P.HasWaitForCapacityTimeout (..)
    , P.HasWaitForElbCapacity (..)
    , P.HasWaitForFulfillment (..)
    , P.HasWaitForReadyTimeout (..)
    , P.HasWebAclId (..)
    , P.HasWebsite (..)
    , P.HasWebsiteRedirect (..)
    , P.HasWeightedRoutingPolicy (..)
    , P.HasWindowId (..)
    , P.HasWorkmailAction (..)
    , P.HasWriteAttributes (..)
    , P.HasWriteCapacity (..)
    , P.HasXssMatchTuples (..)
    , P.HasZoneId (..)

    -- ** Computed Attributes
    , P.HasComputedAccelerationStatus (..)
    , P.HasComputedAcceptStatus (..)
    , P.HasComputedAcceptanceRequired (..)
    , P.HasComputedAccepter (..)
    , P.HasComputedAccessLogs (..)
    , P.HasComputedAccessPolicies (..)
    , P.HasComputedAccessPolicy (..)
    , P.HasComputedAccessUrl (..)
    , P.HasComputedAccountAlias (..)
    , P.HasComputedAccountId (..)
    , P.HasComputedAcl (..)
    , P.HasComputedAction (..)
    , P.HasComputedActionsEnabled (..)
    , P.HasComputedActivate (..)
    , P.HasComputedActivationCode (..)
    , P.HasComputedActive (..)
    , P.HasComputedActiveTrustedSigners (..)
    , P.HasComputedAddHeaderAction (..)
    , P.HasComputedAddress (..)
    , P.HasComputedAdjustmentType (..)
    , P.HasComputedAdminCreateUserConfig (..)
    , P.HasComputedAdvancedOptions (..)
    , P.HasComputedAfter (..)
    , P.HasComputedAgentVersion (..)
    , P.HasComputedAlarmActions (..)
    , P.HasComputedAlarmConfiguration (..)
    , P.HasComputedAlarmDescription (..)
    , P.HasComputedAlarmName (..)
    , P.HasComputedAlbTargetGroupArn (..)
    , P.HasComputedAlias (..)
    , P.HasComputedAliasAttributes (..)
    , P.HasComputedAliases (..)
    , P.HasComputedAllSettings (..)
    , P.HasComputedAllocatedMemory (..)
    , P.HasComputedAllocatedStorage (..)
    , P.HasComputedAllocationId (..)
    , P.HasComputedAllocationStrategy (..)
    , P.HasComputedAllowMajorVersionUpgrade (..)
    , P.HasComputedAllowOverwrite (..)
    , P.HasComputedAllowReassociation (..)
    , P.HasComputedAllowSelfManagement (..)
    , P.HasComputedAllowSsh (..)
    , P.HasComputedAllowSudo (..)
    , P.HasComputedAllowUnassociatedTargets (..)
    , P.HasComputedAllowUnauthenticatedIdentities (..)
    , P.HasComputedAllowUsersToChangePassword (..)
    , P.HasComputedAllowVersionUpgrade (..)
    , P.HasComputedAllowedOauthFlows (..)
    , P.HasComputedAllowedOauthFlowsUserPoolClient (..)
    , P.HasComputedAllowedOauthScopes (..)
    , P.HasComputedAllowedPrincipals (..)
    , P.HasComputedAmazonSideAsn (..)
    , P.HasComputedAmi (..)
    , P.HasComputedAmiId (..)
    , P.HasComputedApiId (..)
    , P.HasComputedApiKeyRequired (..)
    , P.HasComputedApiStages (..)
    , P.HasComputedAppName (..)
    , P.HasComputedAppServer (..)
    , P.HasComputedAppServerVersion (..)
    , P.HasComputedAppSource (..)
    , P.HasComputedApplication (..)
    , P.HasComputedApplicationFailureFeedbackRoleArn (..)
    , P.HasComputedApplicationSuccessFeedbackRoleArn (..)
    , P.HasComputedApplicationSuccessFeedbackSampleRate (..)
    , P.HasComputedApplications (..)
    , P.HasComputedApplyImmediately (..)
    , P.HasComputedApprovalRule (..)
    , P.HasComputedApprovedPatches (..)
    , P.HasComputedApprovedPatchesComplianceLevel (..)
    , P.HasComputedArchitecture (..)
    , P.HasComputedArn (..)
    , P.HasComputedArnSuffix (..)
    , P.HasComputedArtifactStore (..)
    , P.HasComputedArtifacts (..)
    , P.HasComputedAssignGeneratedIpv6CidrBlock (..)
    , P.HasComputedAssignIpv6AddressOnCreation (..)
    , P.HasComputedAssociatePublicIpAddress (..)
    , P.HasComputedAssociateWithPrivateIp (..)
    , P.HasComputedAssociationId (..)
    , P.HasComputedAssociationName (..)
    , P.HasComputedAssumeRolePolicy (..)
    , P.HasComputedAtRestEncryptionEnabled (..)
    , P.HasComputedAttachment (..)
    , P.HasComputedAttachmentId (..)
    , P.HasComputedAttribute (..)
    , P.HasComputedAudio (..)
    , P.HasComputedAudioCodecOptions (..)
    , P.HasComputedAuthToken (..)
    , P.HasComputedAuthenticationType (..)
    , P.HasComputedAuthorization (..)
    , P.HasComputedAuthorizerCredentials (..)
    , P.HasComputedAuthorizerId (..)
    , P.HasComputedAuthorizerResultTtlInSeconds (..)
    , P.HasComputedAuthorizerUri (..)
    , P.HasComputedAutoAccept (..)
    , P.HasComputedAutoAssignElasticIps (..)
    , P.HasComputedAutoAssignPublicIps (..)
    , P.HasComputedAutoBundleOnDeploy (..)
    , P.HasComputedAutoHealing (..)
    , P.HasComputedAutoMinorVersionUpgrade (..)
    , P.HasComputedAutoRollbackConfiguration (..)
    , P.HasComputedAutoScalingType (..)
    , P.HasComputedAutoVerifiedAttributes (..)
    , P.HasComputedAutomatedSnapshotRetentionPeriod (..)
    , P.HasComputedAutomaticFailoverEnabled (..)
    , P.HasComputedAutomaticStopTimeMinutes (..)
    , P.HasComputedAutoscalingGroupName (..)
    , P.HasComputedAutoscalingGroups (..)
    , P.HasComputedAutoscalingRole (..)
    , P.HasComputedAvailabilityZone (..)
    , P.HasComputedAvailabilityZones (..)
    , P.HasComputedAwsAccountId (..)
    , P.HasComputedAwsFlowRubySettings (..)
    , P.HasComputedAwsKmsKeyArn (..)
    , P.HasComputedAzMode (..)
    , P.HasComputedBackupRetentionPeriod (..)
    , P.HasComputedBackupWindow (..)
    , P.HasComputedBandwidth (..)
    , P.HasComputedBaseEndpointDnsNames (..)
    , P.HasComputedBasePath (..)
    , P.HasComputedBaselineId (..)
    , P.HasComputedBatchSize (..)
    , P.HasComputedBerkshelfVersion (..)
    , P.HasComputedBgpAsn (..)
    , P.HasComputedBinaryMediaTypes (..)
    , P.HasComputedBlockDurationMinutes (..)
    , P.HasComputedBlueGreenDeploymentConfig (..)
    , P.HasComputedBlueprintId (..)
    , P.HasComputedBody (..)
    , P.HasComputedBootstrapAction (..)
    , P.HasComputedBounceAction (..)
    , P.HasComputedBranches (..)
    , P.HasComputedBrokerName (..)
    , P.HasComputedBucket (..)
    , P.HasComputedBucketDomainName (..)
    , P.HasComputedBucketPrefix (..)
    , P.HasComputedBuildId (..)
    , P.HasComputedBuildTimeout (..)
    , P.HasComputedBundleId (..)
    , P.HasComputedBundlerVersion (..)
    , P.HasComputedByteMatchTuple (..)
    , P.HasComputedByteMatchTuples (..)
    , P.HasComputedCaCertIdentifier (..)
    , P.HasComputedCacheBehavior (..)
    , P.HasComputedCacheClusterEnabled (..)
    , P.HasComputedCacheClusterSize (..)
    , P.HasComputedCacheControl (..)
    , P.HasComputedCacheKeyNamespace (..)
    , P.HasComputedCacheKeyParameters (..)
    , P.HasComputedCacheNodes (..)
    , P.HasComputedCallbackUrls (..)
    , P.HasComputedCallerReference (..)
    , P.HasComputedCanonicalHostedZoneId (..)
    , P.HasComputedCapabilities (..)
    , P.HasComputedCatalogId (..)
    , P.HasComputedCdcStartTime (..)
    , P.HasComputedCertificateArn (..)
    , P.HasComputedCertificateBody (..)
    , P.HasComputedCertificateChain (..)
    , P.HasComputedCertificateId (..)
    , P.HasComputedCertificateName (..)
    , P.HasComputedCertificatePem (..)
    , P.HasComputedCertificatePrivateKey (..)
    , P.HasComputedCertificateUploadDate (..)
    , P.HasComputedCertificateWallet (..)
    , P.HasComputedCharacterSetName (..)
    , P.HasComputedChildHealthThreshold (..)
    , P.HasComputedChildHealthchecks (..)
    , P.HasComputedCidr (..)
    , P.HasComputedCidrBlock (..)
    , P.HasComputedCidrBlocks (..)
    , P.HasComputedClientCertificateId (..)
    , P.HasComputedClientIdList (..)
    , P.HasComputedClientSecret (..)
    , P.HasComputedCloneUrlHttp (..)
    , P.HasComputedCloneUrlSsh (..)
    , P.HasComputedCloudWatchLogsGroupArn (..)
    , P.HasComputedCloudWatchLogsRoleArn (..)
    , P.HasComputedCloudfrontAccessIdentityPath (..)
    , P.HasComputedCloudfrontDistributionArn (..)
    , P.HasComputedCloudfrontDomainName (..)
    , P.HasComputedCloudfrontZoneId (..)
    , P.HasComputedCloudwatchAlarmName (..)
    , P.HasComputedCloudwatchAlarmRegion (..)
    , P.HasComputedCloudwatchDestination (..)
    , P.HasComputedCloudwatchLogGroupArn (..)
    , P.HasComputedCloudwatchRoleArn (..)
    , P.HasComputedCluster (..)
    , P.HasComputedClusterAddress (..)
    , P.HasComputedClusterConfig (..)
    , P.HasComputedClusterId (..)
    , P.HasComputedClusterIdentifier (..)
    , P.HasComputedClusterIdentifierPrefix (..)
    , P.HasComputedClusterMembers (..)
    , P.HasComputedClusterMode (..)
    , P.HasComputedClusterName (..)
    , P.HasComputedClusterParameterGroupName (..)
    , P.HasComputedClusterPublicKey (..)
    , P.HasComputedClusterResourceId (..)
    , P.HasComputedClusterRevisionNumber (..)
    , P.HasComputedClusterSecurityGroups (..)
    , P.HasComputedClusterSubnetGroupName (..)
    , P.HasComputedClusterType (..)
    , P.HasComputedClusterVersion (..)
    , P.HasComputedCname (..)
    , P.HasComputedCnamePrefix (..)
    , P.HasComputedCognitoIdentityProviders (..)
    , P.HasComputedColor (..)
    , P.HasComputedComment (..)
    , P.HasComputedComparisonOperator (..)
    , P.HasComputedComputeEnvironmentName (..)
    , P.HasComputedComputeEnvironments (..)
    , P.HasComputedComputeResources (..)
    , P.HasComputedCondition (..)
    , P.HasComputedConfiguration (..)
    , P.HasComputedConfigurationEndpoint (..)
    , P.HasComputedConfigurationEndpointAddress (..)
    , P.HasComputedConfigurationManagerName (..)
    , P.HasComputedConfigurationManagerVersion (..)
    , P.HasComputedConfigurationSetName (..)
    , P.HasComputedConfigurations (..)
    , P.HasComputedConfirmationTimeoutInMinutes (..)
    , P.HasComputedConnectSettings (..)
    , P.HasComputedConnectionDraining (..)
    , P.HasComputedConnectionDrainingTimeout (..)
    , P.HasComputedConnectionEvents (..)
    , P.HasComputedConnectionId (..)
    , P.HasComputedConnectionNotificationArn (..)
    , P.HasComputedConnectionsBandwidth (..)
    , P.HasComputedContainer (..)
    , P.HasComputedContainerDefinitions (..)
    , P.HasComputedContainerProperties (..)
    , P.HasComputedContent (..)
    , P.HasComputedContentBasedDeduplication (..)
    , P.HasComputedContentConfig (..)
    , P.HasComputedContentConfigPermissions (..)
    , P.HasComputedContentDisposition (..)
    , P.HasComputedContentEncoding (..)
    , P.HasComputedContentHandling (..)
    , P.HasComputedContentLanguage (..)
    , P.HasComputedContentType (..)
    , P.HasComputedCookieExpirationPeriod (..)
    , P.HasComputedCookieName (..)
    , P.HasComputedCopyTagsToSnapshot (..)
    , P.HasComputedCoreInstanceCount (..)
    , P.HasComputedCoreInstanceType (..)
    , P.HasComputedCorsRule (..)
    , P.HasComputedCreateDate (..)
    , P.HasComputedCreatedDate (..)
    , P.HasComputedCreationDate (..)
    , P.HasComputedCreationToken (..)
    , P.HasComputedCredentials (..)
    , P.HasComputedCrossZoneLoadBalancing (..)
    , P.HasComputedCsr (..)
    , P.HasComputedCustomAmiId (..)
    , P.HasComputedCustomCookbooksSource (..)
    , P.HasComputedCustomData (..)
    , P.HasComputedCustomErrorResponse (..)
    , P.HasComputedCustomInstanceProfileArn (..)
    , P.HasComputedCustomJson (..)
    , P.HasComputedCustomSecurityGroupIds (..)
    , P.HasComputedCustomerGatewayConfiguration (..)
    , P.HasComputedCustomerGatewayId (..)
    , P.HasComputedCutoff (..)
    , P.HasComputedDashboardArn (..)
    , P.HasComputedDashboardBody (..)
    , P.HasComputedDashboardName (..)
    , P.HasComputedData' (..)
    , P.HasComputedDataEncryptionKeyId (..)
    , P.HasComputedDataSourceArn (..)
    , P.HasComputedDataSourceDatabaseName (..)
    , P.HasComputedDataSourceType (..)
    , P.HasComputedDatabase (..)
    , P.HasComputedDatabaseName (..)
    , P.HasComputedDatapointsToAlarm (..)
    , P.HasComputedDbClusterParameterGroupName (..)
    , P.HasComputedDbInstanceIdentifier (..)
    , P.HasComputedDbParameterGroupName (..)
    , P.HasComputedDbPassword (..)
    , P.HasComputedDbSnapshotArn (..)
    , P.HasComputedDbSnapshotIdentifier (..)
    , P.HasComputedDbSubnetGroupName (..)
    , P.HasComputedDbUser (..)
    , P.HasComputedDbiResourceId (..)
    , P.HasComputedDeadLetterConfig (..)
    , P.HasComputedDefaultAction (..)
    , P.HasComputedDefaultAvailabilityZone (..)
    , P.HasComputedDefaultBranch (..)
    , P.HasComputedDefaultCacheBehavior (..)
    , P.HasComputedDefaultCooldown (..)
    , P.HasComputedDefaultInstanceProfileArn (..)
    , P.HasComputedDefaultNetworkAclId (..)
    , P.HasComputedDefaultOs (..)
    , P.HasComputedDefaultRedirectUri (..)
    , P.HasComputedDefaultResult (..)
    , P.HasComputedDefaultRootDeviceType (..)
    , P.HasComputedDefaultRootObject (..)
    , P.HasComputedDefaultRouteTableId (..)
    , P.HasComputedDefaultSecurityGroupId (..)
    , P.HasComputedDefaultSshKeyName (..)
    , P.HasComputedDefaultSubnetId (..)
    , P.HasComputedDefaultVersion (..)
    , P.HasComputedDefaultVersionId (..)
    , P.HasComputedDefinition (..)
    , P.HasComputedDelaySeconds (..)
    , P.HasComputedDelegationSetId (..)
    , P.HasComputedDeletionWindowInDays (..)
    , P.HasComputedDeliveryPolicy (..)
    , P.HasComputedDeploymentConfigId (..)
    , P.HasComputedDeploymentConfigName (..)
    , P.HasComputedDeploymentGroupName (..)
    , P.HasComputedDeploymentId (..)
    , P.HasComputedDeploymentMaximumPercent (..)
    , P.HasComputedDeploymentMinimumHealthyPercent (..)
    , P.HasComputedDeploymentMode (..)
    , P.HasComputedDeploymentStyle (..)
    , P.HasComputedDeregistrationDelay (..)
    , P.HasComputedDescription (..)
    , P.HasComputedDesiredCapacity (..)
    , P.HasComputedDesiredCount (..)
    , P.HasComputedDestination (..)
    , P.HasComputedDestinationArn (..)
    , P.HasComputedDestinationCidrBlock (..)
    , P.HasComputedDestinationIpv6CidrBlock (..)
    , P.HasComputedDestinationName (..)
    , P.HasComputedDetectorId (..)
    , P.HasComputedDeveloperProviderName (..)
    , P.HasComputedDeviceConfiguration (..)
    , P.HasComputedDeviceIndex (..)
    , P.HasComputedDeviceName (..)
    , P.HasComputedDhcpOptionsId (..)
    , P.HasComputedDimensions (..)
    , P.HasComputedDisableApiTermination (..)
    , P.HasComputedDisableRollback (..)
    , P.HasComputedDisplayName (..)
    , P.HasComputedDistribution (..)
    , P.HasComputedDkimTokens (..)
    , P.HasComputedDnsConfig (..)
    , P.HasComputedDnsEntry (..)
    , P.HasComputedDnsIpAddresses (..)
    , P.HasComputedDnsName (..)
    , P.HasComputedDocumentRoot (..)
    , P.HasComputedDocumentType (..)
    , P.HasComputedDocumentVersion (..)
    , P.HasComputedDocumentationVersion (..)
    , P.HasComputedDomain (..)
    , P.HasComputedDomainId (..)
    , P.HasComputedDomainName (..)
    , P.HasComputedDomainNameServers (..)
    , P.HasComputedDomainValidationOptions (..)
    , P.HasComputedDomains (..)
    , P.HasComputedDrainElbOnShutdown (..)
    , P.HasComputedDuration (..)
    , P.HasComputedEbsBlockDevice (..)
    , P.HasComputedEbsConfig (..)
    , P.HasComputedEbsOptimized (..)
    , P.HasComputedEbsOptions (..)
    , P.HasComputedEbsRootVolumeSize (..)
    , P.HasComputedEbsVolume (..)
    , P.HasComputedEc2Attributes (..)
    , P.HasComputedEc2InboundPermission (..)
    , P.HasComputedEc2InstanceType (..)
    , P.HasComputedEc2TagFilter (..)
    , P.HasComputedEcsClusterArn (..)
    , P.HasComputedEcsTarget (..)
    , P.HasComputedEgress (..)
    , P.HasComputedEgressOnlyGatewayId (..)
    , P.HasComputedElasticIp (..)
    , P.HasComputedElasticLoadBalancer (..)
    , P.HasComputedElasticsearchVersion (..)
    , P.HasComputedElb (..)
    , P.HasComputedEmail (..)
    , P.HasComputedEmailConfiguration (..)
    , P.HasComputedEmailVerificationMessage (..)
    , P.HasComputedEmailVerificationSubject (..)
    , P.HasComputedEnable (..)
    , P.HasComputedEnableClassiclink (..)
    , P.HasComputedEnableClassiclinkDnsSupport (..)
    , P.HasComputedEnableDeletionProtection (..)
    , P.HasComputedEnableDnsHostnames (..)
    , P.HasComputedEnableDnsSupport (..)
    , P.HasComputedEnableKeyRotation (..)
    , P.HasComputedEnableLogFileValidation (..)
    , P.HasComputedEnableLogging (..)
    , P.HasComputedEnableMonitoring (..)
    , P.HasComputedEnableSni (..)
    , P.HasComputedEnableSsl (..)
    , P.HasComputedEnableSso (..)
    , P.HasComputedEnabled (..)
    , P.HasComputedEnabledMetrics (..)
    , P.HasComputedEncoding (..)
    , P.HasComputedEncryptAtRest (..)
    , P.HasComputedEncrypted (..)
    , P.HasComputedEncryptedFingerprint (..)
    , P.HasComputedEncryptedPassword (..)
    , P.HasComputedEncryptedPrivateKey (..)
    , P.HasComputedEncryptedSecret (..)
    , P.HasComputedEncryptionKey (..)
    , P.HasComputedEncryptionType (..)
    , P.HasComputedEndTime (..)
    , P.HasComputedEndpoint (..)
    , P.HasComputedEndpointArn (..)
    , P.HasComputedEndpointAutoConfirms (..)
    , P.HasComputedEndpointId (..)
    , P.HasComputedEndpointType (..)
    , P.HasComputedEngine (..)
    , P.HasComputedEngineName (..)
    , P.HasComputedEngineType (..)
    , P.HasComputedEngineVersion (..)
    , P.HasComputedEnhancedVpcRouting (..)
    , P.HasComputedEniId (..)
    , P.HasComputedEnvironment (..)
    , P.HasComputedEnvironmentId (..)
    , P.HasComputedEphemeralBlockDevice (..)
    , P.HasComputedEtag (..)
    , P.HasComputedEvaluateLowSampleCountPercentiles (..)
    , P.HasComputedEvaluationPeriods (..)
    , P.HasComputedEventCategories (..)
    , P.HasComputedEventDeliveryFailureTopicArn (..)
    , P.HasComputedEventEndpointCreatedTopicArn (..)
    , P.HasComputedEventEndpointDeletedTopicArn (..)
    , P.HasComputedEventEndpointUpdatedTopic (..)
    , P.HasComputedEventPattern (..)
    , P.HasComputedEventSourceArn (..)
    , P.HasComputedEvents (..)
    , P.HasComputedExcessCapacityTerminationPolicy (..)
    , P.HasComputedExecutionArn (..)
    , P.HasComputedExpirationDate (..)
    , P.HasComputedExpirePasswords (..)
    , P.HasComputedExpired (..)
    , P.HasComputedExplicitAuthFlows (..)
    , P.HasComputedExtendedS3Configuration (..)
    , P.HasComputedExtendedStatistic (..)
    , P.HasComputedExtraConnectionAttributes (..)
    , P.HasComputedFailoverRoutingPolicy (..)
    , P.HasComputedFailureFeedbackRoleArn (..)
    , P.HasComputedFailureThreshold (..)
    , P.HasComputedFamily' (..)
    , P.HasComputedFifoQueue (..)
    , P.HasComputedFileSystemId (..)
    , P.HasComputedFilename (..)
    , P.HasComputedFilter (..)
    , P.HasComputedFilterPattern (..)
    , P.HasComputedFilterPolicy (..)
    , P.HasComputedFinalSnapshotIdentifier (..)
    , P.HasComputedFingerprint (..)
    , P.HasComputedForceDelete (..)
    , P.HasComputedForceDestroy (..)
    , P.HasComputedForceDetach (..)
    , P.HasComputedFormat (..)
    , P.HasComputedFqdn (..)
    , P.HasComputedFromPort (..)
    , P.HasComputedFunctionArn (..)
    , P.HasComputedFunctionName (..)
    , P.HasComputedFunctionVersion (..)
    , P.HasComputedGatewayId (..)
    , P.HasComputedGenerateSecret (..)
    , P.HasComputedGeolocationRoutingPolicy (..)
    , P.HasComputedGlobalFilter (..)
    , P.HasComputedGlobalSecondaryIndex (..)
    , P.HasComputedGroup (..)
    , P.HasComputedGroupNames (..)
    , P.HasComputedGroups (..)
    , P.HasComputedHandler (..)
    , P.HasComputedHardExpiry (..)
    , P.HasComputedHash (..)
    , P.HasComputedHashKey (..)
    , P.HasComputedHashType (..)
    , P.HasComputedHealthCheck (..)
    , P.HasComputedHealthCheckConfig (..)
    , P.HasComputedHealthCheckGracePeriod (..)
    , P.HasComputedHealthCheckGracePeriodSeconds (..)
    , P.HasComputedHealthCheckId (..)
    , P.HasComputedHealthCheckType (..)
    , P.HasComputedHealthcheckMethod (..)
    , P.HasComputedHealthcheckUrl (..)
    , P.HasComputedHeartbeatTimeout (..)
    , P.HasComputedHomeRegion (..)
    , P.HasComputedHostInstanceType (..)
    , P.HasComputedHostedZone (..)
    , P.HasComputedHostedZoneId (..)
    , P.HasComputedHostname (..)
    , P.HasComputedHostnameTheme (..)
    , P.HasComputedHtml (..)
    , P.HasComputedHttpFailureFeedbackRoleArn (..)
    , P.HasComputedHttpMethod (..)
    , P.HasComputedHttpSuccessFeedbackRoleArn (..)
    , P.HasComputedHttpSuccessFeedbackSampleRate (..)
    , P.HasComputedHttpVersion (..)
    , P.HasComputedIamArn (..)
    , P.HasComputedIamDatabaseAuthenticationEnabled (..)
    , P.HasComputedIamFleetRole (..)
    , P.HasComputedIamInstanceProfile (..)
    , P.HasComputedIamRole (..)
    , P.HasComputedIamRoleArn (..)
    , P.HasComputedIamRoles (..)
    , P.HasComputedIcmpCode (..)
    , P.HasComputedIcmpType (..)
    , P.HasComputedId (..)
    , P.HasComputedIdentifier (..)
    , P.HasComputedIdentifierPrefix (..)
    , P.HasComputedIdentityPoolId (..)
    , P.HasComputedIdentityPoolName (..)
    , P.HasComputedIdentitySource (..)
    , P.HasComputedIdentityValidationExpression (..)
    , P.HasComputedIdleTimeout (..)
    , P.HasComputedImageId (..)
    , P.HasComputedInProgressValidationBatches (..)
    , P.HasComputedIncludeGlobalServiceEvents (..)
    , P.HasComputedIngress (..)
    , P.HasComputedInitialLifecycleHook (..)
    , P.HasComputedInput (..)
    , P.HasComputedInputBucket (..)
    , P.HasComputedInputParameters (..)
    , P.HasComputedInputPath (..)
    , P.HasComputedInputTransformer (..)
    , P.HasComputedInstallUpdatesOnBoot (..)
    , P.HasComputedInstance' (..)
    , P.HasComputedInstanceClass (..)
    , P.HasComputedInstanceCount (..)
    , P.HasComputedInstanceGroup (..)
    , P.HasComputedInstanceId (..)
    , P.HasComputedInstanceIds (..)
    , P.HasComputedInstanceInitiatedShutdownBehavior (..)
    , P.HasComputedInstanceInterruptionBehavior (..)
    , P.HasComputedInstanceName (..)
    , P.HasComputedInstancePort (..)
    , P.HasComputedInstancePorts (..)
    , P.HasComputedInstanceShutdownTimeout (..)
    , P.HasComputedInstanceTenancy (..)
    , P.HasComputedInstanceType (..)
    , P.HasComputedInstances (..)
    , P.HasComputedInsufficientDataActions (..)
    , P.HasComputedInsufficientDataHealthStatus (..)
    , P.HasComputedIntegrationHttpMethod (..)
    , P.HasComputedInternal (..)
    , P.HasComputedInvertHealthcheck (..)
    , P.HasComputedInvokeArn (..)
    , P.HasComputedInvokeUrl (..)
    , P.HasComputedIops (..)
    , P.HasComputedIpAddress (..)
    , P.HasComputedIpAddressType (..)
    , P.HasComputedIpSetDescriptor (..)
    , P.HasComputedIpSetDescriptors (..)
    , P.HasComputedIpv6AddressCount (..)
    , P.HasComputedIpv6Addresses (..)
    , P.HasComputedIpv6AssociationId (..)
    , P.HasComputedIpv6CidrBlock (..)
    , P.HasComputedIpv6CidrBlocks (..)
    , P.HasComputedIsEnabled (..)
    , P.HasComputedIsIpv6Enabled (..)
    , P.HasComputedIsMultiRegionTrail (..)
    , P.HasComputedItem (..)
    , P.HasComputedJvmOptions (..)
    , P.HasComputedJvmType (..)
    , P.HasComputedJvmVersion (..)
    , P.HasComputedKeepJobFlowAliveWhenNoSteps (..)
    , P.HasComputedKey (..)
    , P.HasComputedKeyFingerprint (..)
    , P.HasComputedKeyId (..)
    , P.HasComputedKeyName (..)
    , P.HasComputedKeyNamePrefix (..)
    , P.HasComputedKeyPairName (..)
    , P.HasComputedKeyType (..)
    , P.HasComputedKeyUsage (..)
    , P.HasComputedKibanaEndpoint (..)
    , P.HasComputedKinesisDestination (..)
    , P.HasComputedKinesisSourceConfiguration (..)
    , P.HasComputedKmsDataKeyReusePeriodSeconds (..)
    , P.HasComputedKmsKeyArn (..)
    , P.HasComputedKmsKeyId (..)
    , P.HasComputedKmsMasterKeyId (..)
    , P.HasComputedLagId (..)
    , P.HasComputedLambdaAction (..)
    , P.HasComputedLambdaConfig (..)
    , P.HasComputedLambdaFailureFeedbackRoleArn (..)
    , P.HasComputedLambdaFunction (..)
    , P.HasComputedLambdaSuccessFeedbackRoleArn (..)
    , P.HasComputedLambdaSuccessFeedbackSampleRate (..)
    , P.HasComputedLastModified (..)
    , P.HasComputedLastModifiedDate (..)
    , P.HasComputedLastModifiedTime (..)
    , P.HasComputedLastProcessingResult (..)
    , P.HasComputedLastUpdatedDate (..)
    , P.HasComputedLatencyRoutingPolicy (..)
    , P.HasComputedLatestRevision (..)
    , P.HasComputedLatestVersion (..)
    , P.HasComputedLaunchConfiguration (..)
    , P.HasComputedLaunchConfigurations (..)
    , P.HasComputedLaunchGroup (..)
    , P.HasComputedLaunchSpecification (..)
    , P.HasComputedLaunchType (..)
    , P.HasComputedLayerIds (..)
    , P.HasComputedLbPort (..)
    , P.HasComputedLevel (..)
    , P.HasComputedLicenseModel (..)
    , P.HasComputedLifecycleRule (..)
    , P.HasComputedLifecycleTransition (..)
    , P.HasComputedListener (..)
    , P.HasComputedListenerArn (..)
    , P.HasComputedLoadBalancer (..)
    , P.HasComputedLoadBalancerArn (..)
    , P.HasComputedLoadBalancerInfo (..)
    , P.HasComputedLoadBalancerName (..)
    , P.HasComputedLoadBalancerPort (..)
    , P.HasComputedLoadBalancerType (..)
    , P.HasComputedLoadBalancers (..)
    , P.HasComputedLocalSecondaryIndex (..)
    , P.HasComputedLocation (..)
    , P.HasComputedLocationUri (..)
    , P.HasComputedLogGroupName (..)
    , P.HasComputedLogPublishingOptions (..)
    , P.HasComputedLogUri (..)
    , P.HasComputedLogging (..)
    , P.HasComputedLoggingConfig (..)
    , P.HasComputedLoggingInfo (..)
    , P.HasComputedLogoutUrls (..)
    , P.HasComputedMailFromDomain (..)
    , P.HasComputedMainRouteTableId (..)
    , P.HasComputedMaintenanceWindow (..)
    , P.HasComputedMaintenanceWindowStartTime (..)
    , P.HasComputedMajorEngineVersion (..)
    , P.HasComputedManageBerkshelf (..)
    , P.HasComputedManageBundler (..)
    , P.HasComputedMapPublicIpOnLaunch (..)
    , P.HasComputedMasterInstanceType (..)
    , P.HasComputedMasterPassword (..)
    , P.HasComputedMasterPublicDns (..)
    , P.HasComputedMasterUsername (..)
    , P.HasComputedMatchingTypes (..)
    , P.HasComputedMaxCapacity (..)
    , P.HasComputedMaxConcurrency (..)
    , P.HasComputedMaxErrors (..)
    , P.HasComputedMaxMessageSize (..)
    , P.HasComputedMaxPasswordAge (..)
    , P.HasComputedMaxSize (..)
    , P.HasComputedMaximumExecutionFrequency (..)
    , P.HasComputedMeasureLatency (..)
    , P.HasComputedMemorySize (..)
    , P.HasComputedMessageRetentionSeconds (..)
    , P.HasComputedMethodPath (..)
    , P.HasComputedMetricGroups (..)
    , P.HasComputedMetricName (..)
    , P.HasComputedMetricTransformation (..)
    , P.HasComputedMetricsGranularity (..)
    , P.HasComputedMfaConfiguration (..)
    , P.HasComputedMigrationType (..)
    , P.HasComputedMinCapacity (..)
    , P.HasComputedMinElbCapacity (..)
    , P.HasComputedMinSize (..)
    , P.HasComputedMinimumHealthyHosts (..)
    , P.HasComputedMinimumPasswordLength (..)
    , P.HasComputedMonitoring (..)
    , P.HasComputedMonitoringInterval (..)
    , P.HasComputedMonitoringRoleArn (..)
    , P.HasComputedMultiAz (..)
    , P.HasComputedMultivalueAnswerRoutingPolicy (..)
    , P.HasComputedName (..)
    , P.HasComputedNamePrefix (..)
    , P.HasComputedNameServers (..)
    , P.HasComputedNamespace (..)
    , P.HasComputedNatGatewayId (..)
    , P.HasComputedNetbiosNameServers (..)
    , P.HasComputedNetbiosNodeType (..)
    , P.HasComputedNetworkAclId (..)
    , P.HasComputedNetworkConfiguration (..)
    , P.HasComputedNetworkInterface (..)
    , P.HasComputedNetworkInterfaceId (..)
    , P.HasComputedNetworkInterfaceIds (..)
    , P.HasComputedNetworkLoadBalancerArns (..)
    , P.HasComputedNewGameSessionProtectionPolicy (..)
    , P.HasComputedNodeType (..)
    , P.HasComputedNodejsVersion (..)
    , P.HasComputedNodes (..)
    , P.HasComputedNotification (..)
    , P.HasComputedNotificationArns (..)
    , P.HasComputedNotificationMetadata (..)
    , P.HasComputedNotificationTargetArn (..)
    , P.HasComputedNotificationTopicArn (..)
    , P.HasComputedNotificationType (..)
    , P.HasComputedNotifications (..)
    , P.HasComputedNtpServers (..)
    , P.HasComputedNumCacheNodes (..)
    , P.HasComputedNumberCacheClusters (..)
    , P.HasComputedNumberOfConnections (..)
    , P.HasComputedNumberOfNodes (..)
    , P.HasComputedOkActions (..)
    , P.HasComputedOnFailure (..)
    , P.HasComputedOnPremisesInstanceTagFilter (..)
    , P.HasComputedOpenidConnectProviderArns (..)
    , P.HasComputedOperatingSystem (..)
    , P.HasComputedOption (..)
    , P.HasComputedOptionGroupDescription (..)
    , P.HasComputedOptionGroupName (..)
    , P.HasComputedOrigin (..)
    , P.HasComputedOriginalRouteTableId (..)
    , P.HasComputedOs (..)
    , P.HasComputedOutputBucket (..)
    , P.HasComputedOutputLocation (..)
    , P.HasComputedOutputs (..)
    , P.HasComputedOverwrite (..)
    , P.HasComputedOwner (..)
    , P.HasComputedOwnerAccount (..)
    , P.HasComputedOwnerAlias (..)
    , P.HasComputedOwnerArn (..)
    , P.HasComputedOwnerId (..)
    , P.HasComputedOwnerInformation (..)
    , P.HasComputedParameter (..)
    , P.HasComputedParameterGroupName (..)
    , P.HasComputedParameters (..)
    , P.HasComputedParentId (..)
    , P.HasComputedPassengerVersion (..)
    , P.HasComputedPassthroughBehavior (..)
    , P.HasComputedPassword (..)
    , P.HasComputedPasswordLength (..)
    , P.HasComputedPasswordPolicy (..)
    , P.HasComputedPasswordResetRequired (..)
    , P.HasComputedPasswordReusePrevention (..)
    , P.HasComputedPatchGroup (..)
    , P.HasComputedPath (..)
    , P.HasComputedPathPart (..)
    , P.HasComputedPattern (..)
    , P.HasComputedPeerOwnerId (..)
    , P.HasComputedPeerRegion (..)
    , P.HasComputedPeerVpcId (..)
    , P.HasComputedPemEncodedCertificate (..)
    , P.HasComputedPerformanceInsightsEnabled (..)
    , P.HasComputedPerformanceInsightsKmsKeyId (..)
    , P.HasComputedPerformanceMode (..)
    , P.HasComputedPeriod (..)
    , P.HasComputedPermissions (..)
    , P.HasComputedPgpKey (..)
    , P.HasComputedPlacementConstraints (..)
    , P.HasComputedPlacementGroup (..)
    , P.HasComputedPlacementStrategy (..)
    , P.HasComputedPlacementTenancy (..)
    , P.HasComputedPlatform (..)
    , P.HasComputedPlatformCredential (..)
    , P.HasComputedPlatformPrincipal (..)
    , P.HasComputedPlatformTypes (..)
    , P.HasComputedPolicy (..)
    , P.HasComputedPolicyArn (..)
    , P.HasComputedPolicyAttribute (..)
    , P.HasComputedPolicyBody (..)
    , P.HasComputedPolicyDocument (..)
    , P.HasComputedPolicyName (..)
    , P.HasComputedPolicyNames (..)
    , P.HasComputedPolicyType (..)
    , P.HasComputedPolicyTypeName (..)
    , P.HasComputedPolicyUrl (..)
    , P.HasComputedPollInterval (..)
    , P.HasComputedPort (..)
    , P.HasComputedPrecedence (..)
    , P.HasComputedPredicates (..)
    , P.HasComputedPreferredBackupWindow (..)
    , P.HasComputedPreferredMaintenanceWindow (..)
    , P.HasComputedPrefix (..)
    , P.HasComputedPrefixListId (..)
    , P.HasComputedPrefixListIds (..)
    , P.HasComputedPriceClass (..)
    , P.HasComputedPrimaryEndpointAddress (..)
    , P.HasComputedPrimaryNetworkInterfaceId (..)
    , P.HasComputedPrincipal (..)
    , P.HasComputedPrincipalArn (..)
    , P.HasComputedPriority (..)
    , P.HasComputedPrivateDns (..)
    , P.HasComputedPrivateDnsEnabled (..)
    , P.HasComputedPrivateDnsName (..)
    , P.HasComputedPrivateIp (..)
    , P.HasComputedPrivateIpAddress (..)
    , P.HasComputedPrivateIps (..)
    , P.HasComputedPrivateIpsCount (..)
    , P.HasComputedPrivateKey (..)
    , P.HasComputedProductCode (..)
    , P.HasComputedPromotionTier (..)
    , P.HasComputedPropagatingVgws (..)
    , P.HasComputedProperties (..)
    , P.HasComputedProtectFromScaleIn (..)
    , P.HasComputedProtocol (..)
    , P.HasComputedProviderName (..)
    , P.HasComputedPublicDns (..)
    , P.HasComputedPublicIp (..)
    , P.HasComputedPublicKey (..)
    , P.HasComputedPubliclyAccessible (..)
    , P.HasComputedPublish (..)
    , P.HasComputedQualifiedArn (..)
    , P.HasComputedQualifier (..)
    , P.HasComputedQuery (..)
    , P.HasComputedQueue (..)
    , P.HasComputedQueueUrl (..)
    , P.HasComputedQueues (..)
    , P.HasComputedQuotaSettings (..)
    , P.HasComputedRailsEnv (..)
    , P.HasComputedRangeKey (..)
    , P.HasComputedRateKey (..)
    , P.HasComputedRateLimit (..)
    , P.HasComputedRawMessageDelivery (..)
    , P.HasComputedRdsDbInstanceArn (..)
    , P.HasComputedReadAttributes (..)
    , P.HasComputedReadCapacity (..)
    , P.HasComputedReaderEndpoint (..)
    , P.HasComputedReceiveWaitTimeSeconds (..)
    , P.HasComputedRecipients (..)
    , P.HasComputedRecordingGroup (..)
    , P.HasComputedRecords (..)
    , P.HasComputedRecurrence (..)
    , P.HasComputedRedrivePolicy (..)
    , P.HasComputedRedshiftConfiguration (..)
    , P.HasComputedReferenceName (..)
    , P.HasComputedRefreshTokenValidity (..)
    , P.HasComputedRegion (..)
    , P.HasComputedRegions (..)
    , P.HasComputedRegistrationCount (..)
    , P.HasComputedRegistrationLimit (..)
    , P.HasComputedRegistryId (..)
    , P.HasComputedRejectedPatches (..)
    , P.HasComputedReleaseLabel (..)
    , P.HasComputedReplaceUnhealthyInstances (..)
    , P.HasComputedReplica (..)
    , P.HasComputedReplicateSourceDb (..)
    , P.HasComputedReplicationConfiguration (..)
    , P.HasComputedReplicationFactor (..)
    , P.HasComputedReplicationGroupDescription (..)
    , P.HasComputedReplicationGroupId (..)
    , P.HasComputedReplicationInstanceArn (..)
    , P.HasComputedReplicationInstanceClass (..)
    , P.HasComputedReplicationInstanceId (..)
    , P.HasComputedReplicationInstancePrivateIps (..)
    , P.HasComputedReplicationInstancePublicIps (..)
    , P.HasComputedReplicationSourceIdentifier (..)
    , P.HasComputedReplicationSubnetGroupDescription (..)
    , P.HasComputedReplicationSubnetGroupId (..)
    , P.HasComputedReplicationTaskArn (..)
    , P.HasComputedReplicationTaskId (..)
    , P.HasComputedReplicationTaskSettings (..)
    , P.HasComputedRepository (..)
    , P.HasComputedRepositoryId (..)
    , P.HasComputedRepositoryName (..)
    , P.HasComputedRepositoryUrl (..)
    , P.HasComputedRequestInterval (..)
    , P.HasComputedRequestModels (..)
    , P.HasComputedRequestParameters (..)
    , P.HasComputedRequestParametersInJson (..)
    , P.HasComputedRequestPayer (..)
    , P.HasComputedRequestTemplates (..)
    , P.HasComputedRequestValidatorId (..)
    , P.HasComputedRequester (..)
    , P.HasComputedRequireLowercaseCharacters (..)
    , P.HasComputedRequireNumbers (..)
    , P.HasComputedRequireSymbols (..)
    , P.HasComputedRequireUppercaseCharacters (..)
    , P.HasComputedReservedConcurrentExecutions (..)
    , P.HasComputedResourceCreationLimitPolicy (..)
    , P.HasComputedResourceGroupArn (..)
    , P.HasComputedResourceId (..)
    , P.HasComputedResourcePath (..)
    , P.HasComputedResourceType (..)
    , P.HasComputedResponseModels (..)
    , P.HasComputedResponseParameters (..)
    , P.HasComputedResponseParametersInJson (..)
    , P.HasComputedResponseTemplates (..)
    , P.HasComputedResponseType (..)
    , P.HasComputedRestApiId (..)
    , P.HasComputedRestrictions (..)
    , P.HasComputedRetainOnDelete (..)
    , P.HasComputedRetentionInDays (..)
    , P.HasComputedRetentionPeriod (..)
    , P.HasComputedRetryStrategy (..)
    , P.HasComputedRevision (..)
    , P.HasComputedRevokeRulesOnDelete (..)
    , P.HasComputedRole (..)
    , P.HasComputedRoleArn (..)
    , P.HasComputedRoleMapping (..)
    , P.HasComputedRoles (..)
    , P.HasComputedRootBlockDevice (..)
    , P.HasComputedRootDeviceName (..)
    , P.HasComputedRootDeviceType (..)
    , P.HasComputedRootPassword (..)
    , P.HasComputedRootPasswordOnAllInstances (..)
    , P.HasComputedRootResourceId (..)
    , P.HasComputedRootSnapshotId (..)
    , P.HasComputedRoute (..)
    , P.HasComputedRouteTableId (..)
    , P.HasComputedRouteTableIds (..)
    , P.HasComputedRoutingStrategy (..)
    , P.HasComputedRubyVersion (..)
    , P.HasComputedRubygemsVersion (..)
    , P.HasComputedRule (..)
    , P.HasComputedRuleAction (..)
    , P.HasComputedRuleId (..)
    , P.HasComputedRuleNumber (..)
    , P.HasComputedRuleSetName (..)
    , P.HasComputedRules (..)
    , P.HasComputedRulesPackageArns (..)
    , P.HasComputedRunCommandTargets (..)
    , P.HasComputedRunningInstanceCount (..)
    , P.HasComputedRuntime (..)
    , P.HasComputedRuntimeConfiguration (..)
    , P.HasComputedS3Action (..)
    , P.HasComputedS3Bucket (..)
    , P.HasComputedS3BucketName (..)
    , P.HasComputedS3CanonicalUserId (..)
    , P.HasComputedS3Configuration (..)
    , P.HasComputedS3Destination (..)
    , P.HasComputedS3Key (..)
    , P.HasComputedS3KeyPrefix (..)
    , P.HasComputedS3ObjectVersion (..)
    , P.HasComputedSamlMetadataDocument (..)
    , P.HasComputedSamlProviderArns (..)
    , P.HasComputedScalableDimension (..)
    , P.HasComputedScalableTargetAction (..)
    , P.HasComputedScanEnabled (..)
    , P.HasComputedSchedule (..)
    , P.HasComputedScheduleExpression (..)
    , P.HasComputedScheduledActionName (..)
    , P.HasComputedSchema (..)
    , P.HasComputedSchemaVersion (..)
    , P.HasComputedScope (..)
    , P.HasComputedSearchString (..)
    , P.HasComputedSecret (..)
    , P.HasComputedSecurityConfiguration (..)
    , P.HasComputedSecurityGroupId (..)
    , P.HasComputedSecurityGroupIds (..)
    , P.HasComputedSecurityGroupNames (..)
    , P.HasComputedSecurityGroups (..)
    , P.HasComputedSelectionPattern (..)
    , P.HasComputedSelf (..)
    , P.HasComputedServerName (..)
    , P.HasComputedServerSideEncryption (..)
    , P.HasComputedServerSideEncryptionConfiguration (..)
    , P.HasComputedServiceAccessRole (..)
    , P.HasComputedServiceName (..)
    , P.HasComputedServiceNamespace (..)
    , P.HasComputedServiceRole (..)
    , P.HasComputedServiceRoleArn (..)
    , P.HasComputedServiceType (..)
    , P.HasComputedSesSmtpPassword (..)
    , P.HasComputedSetIdentifier (..)
    , P.HasComputedSetting (..)
    , P.HasComputedSettings (..)
    , P.HasComputedShardCount (..)
    , P.HasComputedShardLevelMetrics (..)
    , P.HasComputedShortName (..)
    , P.HasComputedSize (..)
    , P.HasComputedSizeConstraints (..)
    , P.HasComputedSkipDestroy (..)
    , P.HasComputedSkipFinalSnapshot (..)
    , P.HasComputedSmsAuthenticationMessage (..)
    , P.HasComputedSmsConfiguration (..)
    , P.HasComputedSmsVerificationMessage (..)
    , P.HasComputedSnapshotArns (..)
    , P.HasComputedSnapshotClusterIdentifier (..)
    , P.HasComputedSnapshotCopy (..)
    , P.HasComputedSnapshotDeliveryProperties (..)
    , P.HasComputedSnapshotId (..)
    , P.HasComputedSnapshotIdentifier (..)
    , P.HasComputedSnapshotName (..)
    , P.HasComputedSnapshotOptions (..)
    , P.HasComputedSnapshotRetentionLimit (..)
    , P.HasComputedSnapshotWindow (..)
    , P.HasComputedSnapshotWithoutReboot (..)
    , P.HasComputedSnsAction (..)
    , P.HasComputedSnsDestination (..)
    , P.HasComputedSnsTopic (..)
    , P.HasComputedSnsTopicArn (..)
    , P.HasComputedSnsTopicName (..)
    , P.HasComputedSolutionStackName (..)
    , P.HasComputedSource (..)
    , P.HasComputedSourceAccount (..)
    , P.HasComputedSourceAmiId (..)
    , P.HasComputedSourceAmiRegion (..)
    , P.HasComputedSourceArn (..)
    , P.HasComputedSourceCodeHash (..)
    , P.HasComputedSourceDbSnapshotIdentifier (..)
    , P.HasComputedSourceDestCheck (..)
    , P.HasComputedSourceEndpointArn (..)
    , P.HasComputedSourceIds (..)
    , P.HasComputedSourceInstanceId (..)
    , P.HasComputedSourceRegion (..)
    , P.HasComputedSourceSecurityGroup (..)
    , P.HasComputedSourceSecurityGroupId (..)
    , P.HasComputedSourceType (..)
    , P.HasComputedSpotPrice (..)
    , P.HasComputedSpotRequestState (..)
    , P.HasComputedSpotType (..)
    , P.HasComputedSql (..)
    , P.HasComputedSqlInjectionMatchTuples (..)
    , P.HasComputedSqlVersion (..)
    , P.HasComputedSqsFailureFeedbackRoleArn (..)
    , P.HasComputedSqsSuccessFeedbackRoleArn (..)
    , P.HasComputedSqsSuccessFeedbackSampleRate (..)
    , P.HasComputedSshKeyName (..)
    , P.HasComputedSshPublicKey (..)
    , P.HasComputedSshPublicKeyId (..)
    , P.HasComputedSshUsername (..)
    , P.HasComputedSslConfiguration (..)
    , P.HasComputedSslMode (..)
    , P.HasComputedSslPolicy (..)
    , P.HasComputedStackId (..)
    , P.HasComputedStage (..)
    , P.HasComputedStageDescription (..)
    , P.HasComputedStageKey (..)
    , P.HasComputedStageName (..)
    , P.HasComputedStartTime (..)
    , P.HasComputedStartingPosition (..)
    , P.HasComputedState (..)
    , P.HasComputedStateTransitionReason (..)
    , P.HasComputedStatementId (..)
    , P.HasComputedStaticIpName (..)
    , P.HasComputedStaticRoutesOnly (..)
    , P.HasComputedStatistic (..)
    , P.HasComputedStatsEnabled (..)
    , P.HasComputedStatsPassword (..)
    , P.HasComputedStatsUrl (..)
    , P.HasComputedStatsUser (..)
    , P.HasComputedStatus (..)
    , P.HasComputedStatusCode (..)
    , P.HasComputedStatusReason (..)
    , P.HasComputedStepScalingPolicyConfiguration (..)
    , P.HasComputedStickiness (..)
    , P.HasComputedStopAction (..)
    , P.HasComputedStorageClass (..)
    , P.HasComputedStorageEncrypted (..)
    , P.HasComputedStorageLocation (..)
    , P.HasComputedStorageType (..)
    , P.HasComputedStrategy (..)
    , P.HasComputedStreamArn (..)
    , P.HasComputedStreamEnabled (..)
    , P.HasComputedStreamLabel (..)
    , P.HasComputedStreamViewType (..)
    , P.HasComputedSubject (..)
    , P.HasComputedSubjectAlternativeNames (..)
    , P.HasComputedSubnetGroupName (..)
    , P.HasComputedSubnetId (..)
    , P.HasComputedSubnetIds (..)
    , P.HasComputedSubnetMapping (..)
    , P.HasComputedSubnets (..)
    , P.HasComputedSuccessFeedbackRoleArn (..)
    , P.HasComputedSuccessFeedbackSampleRate (..)
    , P.HasComputedSupportCode (..)
    , P.HasComputedSupportedIdentityProviders (..)
    , P.HasComputedSupportedLoginProviders (..)
    , P.HasComputedSuspendedProcesses (..)
    , P.HasComputedSystemPackages (..)
    , P.HasComputedTableMappings (..)
    , P.HasComputedTableName (..)
    , P.HasComputedTag (..)
    , P.HasComputedTags (..)
    , P.HasComputedTargetArn (..)
    , P.HasComputedTargetCapacity (..)
    , P.HasComputedTargetEndpointArn (..)
    , P.HasComputedTargetGroupArn (..)
    , P.HasComputedTargetGroupArns (..)
    , P.HasComputedTargetId (..)
    , P.HasComputedTargetKeyArn (..)
    , P.HasComputedTargetKeyId (..)
    , P.HasComputedTargetTrackingScalingPolicyConfiguration (..)
    , P.HasComputedTargetType (..)
    , P.HasComputedTargets (..)
    , P.HasComputedTaskArn (..)
    , P.HasComputedTaskDefinition (..)
    , P.HasComputedTaskParameters (..)
    , P.HasComputedTaskType (..)
    , P.HasComputedTemplateBody (..)
    , P.HasComputedTemplateName (..)
    , P.HasComputedTemplateUrl (..)
    , P.HasComputedTenancy (..)
    , P.HasComputedTerminateInstancesWithExpiration (..)
    , P.HasComputedTerminationPolicies (..)
    , P.HasComputedTerminationProtection (..)
    , P.HasComputedText (..)
    , P.HasComputedThreshold (..)
    , P.HasComputedThrottleSettings (..)
    , P.HasComputedThumbnailConfig (..)
    , P.HasComputedThumbnailConfigPermissions (..)
    , P.HasComputedThumbnails (..)
    , P.HasComputedThumbprintList (..)
    , P.HasComputedTier (..)
    , P.HasComputedTimeout (..)
    , P.HasComputedTimeoutInMinutes (..)
    , P.HasComputedTimezone (..)
    , P.HasComputedTlsPolicy (..)
    , P.HasComputedToPort (..)
    , P.HasComputedTopic (..)
    , P.HasComputedTopicArn (..)
    , P.HasComputedTrafficType (..)
    , P.HasComputedTransitEncryptionEnabled (..)
    , P.HasComputedTreatMissingData (..)
    , P.HasComputedTriggerConfiguration (..)
    , P.HasComputedTriggers (..)
    , P.HasComputedTtl (..)
    , P.HasComputedTunnel1Address (..)
    , P.HasComputedTunnel1BgpAsn (..)
    , P.HasComputedTunnel1BgpHoldtime (..)
    , P.HasComputedTunnel1CgwInsideAddress (..)
    , P.HasComputedTunnel1InsideCidr (..)
    , P.HasComputedTunnel1PresharedKey (..)
    , P.HasComputedTunnel1VgwInsideAddress (..)
    , P.HasComputedTunnel2Address (..)
    , P.HasComputedTunnel2BgpAsn (..)
    , P.HasComputedTunnel2BgpHoldtime (..)
    , P.HasComputedTunnel2CgwInsideAddress (..)
    , P.HasComputedTunnel2InsideCidr (..)
    , P.HasComputedTunnel2PresharedKey (..)
    , P.HasComputedTunnel2VgwInsideAddress (..)
    , P.HasComputedType' (..)
    , P.HasComputedUniqueId (..)
    , P.HasComputedUnit (..)
    , P.HasComputedUri (..)
    , P.HasComputedUrl (..)
    , P.HasComputedUsagePlanId (..)
    , P.HasComputedUseCustomCookbooks (..)
    , P.HasComputedUseEbsOptimizedInstances (..)
    , P.HasComputedUseOpsworksSecurityGroups (..)
    , P.HasComputedUser (..)
    , P.HasComputedUserArn (..)
    , P.HasComputedUserData (..)
    , P.HasComputedUserDataBase64 (..)
    , P.HasComputedUserPoolConfig (..)
    , P.HasComputedUserPoolId (..)
    , P.HasComputedUsername (..)
    , P.HasComputedUsernameAttributes (..)
    , P.HasComputedUsers (..)
    , P.HasComputedUuid (..)
    , P.HasComputedValidUntil (..)
    , P.HasComputedValidationEmails (..)
    , P.HasComputedValidationMethod (..)
    , P.HasComputedValidationRecordFqdns (..)
    , P.HasComputedValue (..)
    , P.HasComputedVariables (..)
    , P.HasComputedVerificationMessageTemplate (..)
    , P.HasComputedVerificationToken (..)
    , P.HasComputedVersion (..)
    , P.HasComputedVersionId (..)
    , P.HasComputedVersionLabel (..)
    , P.HasComputedVersioning (..)
    , P.HasComputedVideo (..)
    , P.HasComputedVideoCodecOptions (..)
    , P.HasComputedVideoWatermarks (..)
    , P.HasComputedViewerCertificate (..)
    , P.HasComputedVirtualizationType (..)
    , P.HasComputedVisibilityTimeoutSeconds (..)
    , P.HasComputedVisibleToAllUsers (..)
    , P.HasComputedVolumeId (..)
    , P.HasComputedVolumeSize (..)
    , P.HasComputedVolumeTags (..)
    , P.HasComputedVpc (..)
    , P.HasComputedVpcClassicLinkId (..)
    , P.HasComputedVpcClassicLinkSecurityGroups (..)
    , P.HasComputedVpcConfig (..)
    , P.HasComputedVpcEndpointId (..)
    , P.HasComputedVpcEndpointServiceId (..)
    , P.HasComputedVpcEndpointType (..)
    , P.HasComputedVpcId (..)
    , P.HasComputedVpcOptions (..)
    , P.HasComputedVpcOptions0AvailabilityZones (..)
    , P.HasComputedVpcOptions0VpcId (..)
    , P.HasComputedVpcPeeringConnectionId (..)
    , P.HasComputedVpcRegion (..)
    , P.HasComputedVpcSecurityGroupIds (..)
    , P.HasComputedVpcSettings (..)
    , P.HasComputedVpcZoneIdentifier (..)
    , P.HasComputedVpnConnectionId (..)
    , P.HasComputedVpnGatewayId (..)
    , P.HasComputedWaitForCapacityTimeout (..)
    , P.HasComputedWaitForElbCapacity (..)
    , P.HasComputedWaitForFulfillment (..)
    , P.HasComputedWaitForReadyTimeout (..)
    , P.HasComputedWebAclId (..)
    , P.HasComputedWebsite (..)
    , P.HasComputedWebsiteDomain (..)
    , P.HasComputedWebsiteEndpoint (..)
    , P.HasComputedWebsiteRedirect (..)
    , P.HasComputedWeightedRoutingPolicy (..)
    , P.HasComputedWindowId (..)
    , P.HasComputedWorkmailAction (..)
    , P.HasComputedWriteAttributes (..)
    , P.HasComputedWriteCapacity (..)
    , P.HasComputedWriter (..)
    , P.HasComputedXssMatchTuples (..)
    , P.HasComputedZoneId (..)

    -- * Re-exported Types
    , module P
    ) where

import Data.Functor ((<$>))
import Data.Maybe   (catMaybes)
import Data.Text    (Text)

import GHC.Base (Eq, ($), (.))
import GHC.Show (Show)

import Lens.Micro (lens)

import qualified Data.Word              as P
import qualified GHC.Base               as P
import qualified Numeric.Natural        as P
import qualified Terrafomo.AWS.Lens     as P
import qualified Terrafomo.AWS.Provider as P
import           Terrafomo.AWS.Types    as P
import qualified Terrafomo.IP           as P

import qualified Terrafomo.Attribute as TF
import qualified Terrafomo.HCL       as TF
import qualified Terrafomo.Name      as TF
import qualified Terrafomo.Schema    as TF

{- | The @aws_acm_certificate@ AWS resource.

The ACM certificate resource allows requesting and management of
certificates from the Amazon Certificate Manager. It deals with requesting
certificates and managing their attributes and life-cycle. This resource
does not deal with validation of a certificate but can provide inputs for
other resources implementing the validation. It does not wait for a
certificate to be issued. Use a <acm_certificate_validation.html> resource
for this. Most commonly, this resource is used to together with
<route53_record.html> and <acm_certificate_validation.html> to request a DNS
validated certificate, deploy the required validation records and wait for
validation to complete. Domain validation through E-Mail is also supported
but should be avoided as it requires a manual step outside of Terraform.
-}
data AcmCertificateResource s = AcmCertificateResource {
      _domain_name               :: !(TF.Attr s Text)
    {- ^ (Required) A domain name for which the certificate should be issued -}
    , _subject_alternative_names :: !(TF.Attr s Text)
    {- ^ (Optional) A list of domains that should be SANs in the issued certificate -}
    , _tags                      :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    , _validation_method         :: !(TF.Attr s Text)
    {- ^ (Required) Which method to use for validation. @DNS@ or @EMAIL@ are valid, @NONE@ can be used for certificates that were imported into ACM and then into Terraform. -}
    } deriving (Show, Eq)

instance TF.ToHCL (AcmCertificateResource s) where
    toHCL AcmCertificateResource{..} = TF.inline $ catMaybes
        [ TF.assign "domain_name" <$> TF.attribute _domain_name
        , TF.assign "subject_alternative_names" <$> TF.attribute _subject_alternative_names
        , TF.assign "tags" <$> TF.attribute _tags
        , TF.assign "validation_method" <$> TF.attribute _validation_method
        ]

instance P.HasDomainName (AcmCertificateResource s) (TF.Attr s Text) where
    domainName =
        lens (_domain_name :: AcmCertificateResource s -> TF.Attr s Text)
             (\s a -> s { _domain_name = a } :: AcmCertificateResource s)

instance P.HasSubjectAlternativeNames (AcmCertificateResource s) (TF.Attr s Text) where
    subjectAlternativeNames =
        lens (_subject_alternative_names :: AcmCertificateResource s -> TF.Attr s Text)
             (\s a -> s { _subject_alternative_names = a } :: AcmCertificateResource s)

instance P.HasTags (AcmCertificateResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: AcmCertificateResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: AcmCertificateResource s)

instance P.HasValidationMethod (AcmCertificateResource s) (TF.Attr s Text) where
    validationMethod =
        lens (_validation_method :: AcmCertificateResource s -> TF.Attr s Text)
             (\s a -> s { _validation_method = a } :: AcmCertificateResource s)

instance P.HasComputedArn (AcmCertificateResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedDomainName (AcmCertificateResource s) s (TF.Attr s Text) where
    computedDomainName =
        (_domain_name :: AcmCertificateResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDomainValidationOptions (AcmCertificateResource s) s (TF.Attr s Text) where
    computedDomainValidationOptions x = TF.compute (TF.refKey x) "domain_validation_options"

instance P.HasComputedId (AcmCertificateResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedSubjectAlternativeNames (AcmCertificateResource s) s (TF.Attr s Text) where
    computedSubjectAlternativeNames =
        (_subject_alternative_names :: AcmCertificateResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (AcmCertificateResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: AcmCertificateResource s -> TF.Attr s P.Tags)
            . TF.refValue

instance P.HasComputedValidationEmails (AcmCertificateResource s) s (TF.Attr s Text) where
    computedValidationEmails x = TF.compute (TF.refKey x) "validation_emails"

instance P.HasComputedValidationMethod (AcmCertificateResource s) s (TF.Attr s Text) where
    computedValidationMethod =
        (_validation_method :: AcmCertificateResource s -> TF.Attr s Text)
            . TF.refValue

acmCertificateResource :: TF.Schema TF.Resource P.AWS (AcmCertificateResource s)
acmCertificateResource =
    TF.newResource "aws_acm_certificate" $
        AcmCertificateResource {
              _domain_name = TF.Nil
            , _subject_alternative_names = TF.Nil
            , _tags = TF.Nil
            , _validation_method = TF.Nil
            }

{- | The @aws_acm_certificate_validation@ AWS resource.

This resource represents a successful validation of an ACM certificate in
concert with other resources. Most commonly, this resource is used to
together with <route53_record.html> and <acm_certificate.html> to request a
DNS validated certificate, deploy the required validation records and wait
for validation to complete. ~> WARNING: This resource implements a part of
the validation workflow. It does not represent a real-world entity in AWS,
therefore changing or deleting this resource on its own has no immediate
effect.
-}
data AcmCertificateValidationResource s = AcmCertificateValidationResource {
      _certificate_arn         :: !(TF.Attr s Text)
    {- ^ (Required) The ARN of the certificate that is being validated. -}
    , _validation_record_fqdns :: !(TF.Attr s Text)
    {- ^ (Optional) List of FQDNs that implement the validation. Only valid for DNS validation method ACM certificates. If this is set, the resource can implement additional sanity checks and has an explicit dependency on the resource that is implementing the validation -}
    } deriving (Show, Eq)

instance TF.ToHCL (AcmCertificateValidationResource s) where
    toHCL AcmCertificateValidationResource{..} = TF.inline $ catMaybes
        [ TF.assign "certificate_arn" <$> TF.attribute _certificate_arn
        , TF.assign "validation_record_fqdns" <$> TF.attribute _validation_record_fqdns
        ]

instance P.HasCertificateArn (AcmCertificateValidationResource s) (TF.Attr s Text) where
    certificateArn =
        lens (_certificate_arn :: AcmCertificateValidationResource s -> TF.Attr s Text)
             (\s a -> s { _certificate_arn = a } :: AcmCertificateValidationResource s)

instance P.HasValidationRecordFqdns (AcmCertificateValidationResource s) (TF.Attr s Text) where
    validationRecordFqdns =
        lens (_validation_record_fqdns :: AcmCertificateValidationResource s -> TF.Attr s Text)
             (\s a -> s { _validation_record_fqdns = a } :: AcmCertificateValidationResource s)

instance P.HasComputedCertificateArn (AcmCertificateValidationResource s) s (TF.Attr s Text) where
    computedCertificateArn =
        (_certificate_arn :: AcmCertificateValidationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedValidationRecordFqdns (AcmCertificateValidationResource s) s (TF.Attr s Text) where
    computedValidationRecordFqdns =
        (_validation_record_fqdns :: AcmCertificateValidationResource s -> TF.Attr s Text)
            . TF.refValue

acmCertificateValidationResource :: TF.Schema TF.Resource P.AWS (AcmCertificateValidationResource s)
acmCertificateValidationResource =
    TF.newResource "aws_acm_certificate_validation" $
        AcmCertificateValidationResource {
              _certificate_arn = TF.Nil
            , _validation_record_fqdns = TF.Nil
            }

{- | The @sfn_activity@ AWS resource.

Provides a Step Function Activity resource
-}
data ActivityResource s = ActivityResource {
      _name :: !(TF.Attr s Text)
    {- ^ (Required) The name of the activity to create. -}
    } deriving (Show, Eq)

instance TF.ToHCL (ActivityResource s) where
    toHCL ActivityResource{..} = TF.inline $ catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        ]

instance P.HasName (ActivityResource s) (TF.Attr s Text) where
    name =
        lens (_name :: ActivityResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: ActivityResource s)

instance P.HasComputedCreationDate (ActivityResource s) s (TF.Attr s Text) where
    computedCreationDate x = TF.compute (TF.refKey x) "creation_date"

instance P.HasComputedId (ActivityResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (ActivityResource s) s (TF.Attr s Text) where
    computedName x = TF.compute (TF.refKey x) "name"

activityResource :: TF.Schema TF.Resource P.AWS (ActivityResource s)
activityResource =
    TF.newResource "sfn_activity" $
        ActivityResource {
              _name = TF.Nil
            }

{- | The @aws_ami_copy@ AWS resource.

The "AMI copy" resource allows duplication of an Amazon Machine Image (AMI),
including cross-region copies. If the source AMI has associated EBS
snapshots, those will also be duplicated along with the AMI. This is useful
for taking a single AMI provisioned in one region and making it available in
another for a multi-region deployment. Copying an AMI can take several
minutes. The creation of this resource will block until the new AMI is
available for use on new instances.
-}
data AmiCopyResource s = AmiCopyResource {
      _encrypted         :: !(TF.Attr s Text)
    {- ^ (Optional) Specifies whether the destination snapshots of the copied image should be encrypted. Defaults to @false@ -}
    , _kms_key_id        :: !(TF.Attr s Text)
    {- ^ (Optional) The full ARN of the KMS Key to use when encrypting the snapshots of an image during a copy operation. If not specified, then the default AWS KMS Key will be used -}
    , _name              :: !(TF.Attr s Text)
    {- ^ (Required) A region-unique name for the AMI. -}
    , _source_ami_id     :: !(TF.Attr s Text)
    {- ^ (Required) The id of the AMI to copy. This id must be valid in the region given by @source_ami_region@ . -}
    , _source_ami_region :: !(TF.Attr s P.Region)
    {- ^ (Required) The region from which the AMI will be copied. This may be the same as the AWS provider region in order to create a copy within the same region. -}
    } deriving (Show, Eq)

instance TF.ToHCL (AmiCopyResource s) where
    toHCL AmiCopyResource{..} = TF.inline $ catMaybes
        [ TF.assign "encrypted" <$> TF.attribute _encrypted
        , TF.assign "kms_key_id" <$> TF.attribute _kms_key_id
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "source_ami_id" <$> TF.attribute _source_ami_id
        , TF.assign "source_ami_region" <$> TF.attribute _source_ami_region
        ]

instance P.HasEncrypted (AmiCopyResource s) (TF.Attr s Text) where
    encrypted =
        lens (_encrypted :: AmiCopyResource s -> TF.Attr s Text)
             (\s a -> s { _encrypted = a } :: AmiCopyResource s)

instance P.HasKmsKeyId (AmiCopyResource s) (TF.Attr s Text) where
    kmsKeyId =
        lens (_kms_key_id :: AmiCopyResource s -> TF.Attr s Text)
             (\s a -> s { _kms_key_id = a } :: AmiCopyResource s)

instance P.HasName (AmiCopyResource s) (TF.Attr s Text) where
    name =
        lens (_name :: AmiCopyResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: AmiCopyResource s)

instance P.HasSourceAmiId (AmiCopyResource s) (TF.Attr s Text) where
    sourceAmiId =
        lens (_source_ami_id :: AmiCopyResource s -> TF.Attr s Text)
             (\s a -> s { _source_ami_id = a } :: AmiCopyResource s)

instance P.HasSourceAmiRegion (AmiCopyResource s) (TF.Attr s P.Region) where
    sourceAmiRegion =
        lens (_source_ami_region :: AmiCopyResource s -> TF.Attr s P.Region)
             (\s a -> s { _source_ami_region = a } :: AmiCopyResource s)

instance P.HasComputedEncrypted (AmiCopyResource s) s (TF.Attr s Text) where
    computedEncrypted =
        (_encrypted :: AmiCopyResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (AmiCopyResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedKmsKeyId (AmiCopyResource s) s (TF.Attr s Text) where
    computedKmsKeyId =
        (_kms_key_id :: AmiCopyResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (AmiCopyResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: AmiCopyResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSourceAmiId (AmiCopyResource s) s (TF.Attr s Text) where
    computedSourceAmiId =
        (_source_ami_id :: AmiCopyResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSourceAmiRegion (AmiCopyResource s) s (TF.Attr s P.Region) where
    computedSourceAmiRegion =
        (_source_ami_region :: AmiCopyResource s -> TF.Attr s P.Region)
            . TF.refValue

amiCopyResource :: TF.Schema TF.Resource P.AWS (AmiCopyResource s)
amiCopyResource =
    TF.newResource "aws_ami_copy" $
        AmiCopyResource {
              _encrypted = TF.Nil
            , _kms_key_id = TF.Nil
            , _name = TF.Nil
            , _source_ami_id = TF.Nil
            , _source_ami_region = TF.Nil
            }

{- | The @aws_ami_from_instance@ AWS resource.

The "AMI from instance" resource allows the creation of an Amazon Machine
Image (AMI) modelled after an existing EBS-backed EC2 instance. The created
AMI will refer to implicitly-created snapshots of the instance's EBS volumes
and mimick its assigned block device configuration at the time the resource
is created. This resource is best applied to an instance that is stopped
when this instance is created, so that the contents of the created image are
predictable. When applied to an instance that is running, the instance will
be stopped before taking the snapshots and then started back up again ,
resulting in a period of downtime. Note that the source instance is
inspected only at the initial creation of this resource. Ongoing updates to
the referenced instance will not be propagated into the generated AMI. Users
may taint or otherwise recreate the resource in order to produce a fresh
snapshot.
-}
data AmiFromInstanceResource s = AmiFromInstanceResource {
      _name                    :: !(TF.Attr s Text)
    {- ^ (Required) A region-unique name for the AMI. -}
    , _snapshot_without_reboot :: !(TF.Attr s Text)
    {- ^ (Optional) Boolean that overrides the behavior of stopping the instance before snapshotting. This is risky since it may cause a snapshot of an inconsistent filesystem state, but can be used to avoid downtime if the user otherwise guarantees that no filesystem writes will be underway at the time of snapshot. -}
    , _source_instance_id      :: !(TF.Attr s Text)
    {- ^ (Required) The id of the instance to use as the basis of the AMI. -}
    } deriving (Show, Eq)

instance TF.ToHCL (AmiFromInstanceResource s) where
    toHCL AmiFromInstanceResource{..} = TF.inline $ catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "snapshot_without_reboot" <$> TF.attribute _snapshot_without_reboot
        , TF.assign "source_instance_id" <$> TF.attribute _source_instance_id
        ]

instance P.HasName (AmiFromInstanceResource s) (TF.Attr s Text) where
    name =
        lens (_name :: AmiFromInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: AmiFromInstanceResource s)

instance P.HasSnapshotWithoutReboot (AmiFromInstanceResource s) (TF.Attr s Text) where
    snapshotWithoutReboot =
        lens (_snapshot_without_reboot :: AmiFromInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _snapshot_without_reboot = a } :: AmiFromInstanceResource s)

instance P.HasSourceInstanceId (AmiFromInstanceResource s) (TF.Attr s Text) where
    sourceInstanceId =
        lens (_source_instance_id :: AmiFromInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _source_instance_id = a } :: AmiFromInstanceResource s)

instance P.HasComputedId (AmiFromInstanceResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (AmiFromInstanceResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: AmiFromInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSnapshotWithoutReboot (AmiFromInstanceResource s) s (TF.Attr s Text) where
    computedSnapshotWithoutReboot =
        (_snapshot_without_reboot :: AmiFromInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSourceInstanceId (AmiFromInstanceResource s) s (TF.Attr s Text) where
    computedSourceInstanceId =
        (_source_instance_id :: AmiFromInstanceResource s -> TF.Attr s Text)
            . TF.refValue

amiFromInstanceResource :: TF.Schema TF.Resource P.AWS (AmiFromInstanceResource s)
amiFromInstanceResource =
    TF.newResource "aws_ami_from_instance" $
        AmiFromInstanceResource {
              _name = TF.Nil
            , _snapshot_without_reboot = TF.Nil
            , _source_instance_id = TF.Nil
            }

{- | The @aws_ami_launch_permission@ AWS resource.

Adds launch permission to Amazon Machine Image (AMI) from another AWS
account.
-}
data AmiLaunchPermissionResource s = AmiLaunchPermissionResource {
      _account_id :: !(TF.Attr s Text)
    {- ^ - (required) An AWS Account ID to add launch permissions. -}
    , _image_id   :: !(TF.Attr s Text)
    {- ^ - (required) A region-unique name for the AMI. -}
    } deriving (Show, Eq)

instance TF.ToHCL (AmiLaunchPermissionResource s) where
    toHCL AmiLaunchPermissionResource{..} = TF.inline $ catMaybes
        [ TF.assign "account_id" <$> TF.attribute _account_id
        , TF.assign "image_id" <$> TF.attribute _image_id
        ]

instance P.HasAccountId (AmiLaunchPermissionResource s) (TF.Attr s Text) where
    accountId =
        lens (_account_id :: AmiLaunchPermissionResource s -> TF.Attr s Text)
             (\s a -> s { _account_id = a } :: AmiLaunchPermissionResource s)

instance P.HasImageId (AmiLaunchPermissionResource s) (TF.Attr s Text) where
    imageId =
        lens (_image_id :: AmiLaunchPermissionResource s -> TF.Attr s Text)
             (\s a -> s { _image_id = a } :: AmiLaunchPermissionResource s)

instance P.HasComputedAccountId (AmiLaunchPermissionResource s) s (TF.Attr s Text) where
    computedAccountId =
        (_account_id :: AmiLaunchPermissionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (AmiLaunchPermissionResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedImageId (AmiLaunchPermissionResource s) s (TF.Attr s Text) where
    computedImageId =
        (_image_id :: AmiLaunchPermissionResource s -> TF.Attr s Text)
            . TF.refValue

amiLaunchPermissionResource :: TF.Schema TF.Resource P.AWS (AmiLaunchPermissionResource s)
amiLaunchPermissionResource =
    TF.newResource "aws_ami_launch_permission" $
        AmiLaunchPermissionResource {
              _account_id = TF.Nil
            , _image_id = TF.Nil
            }

{- | The @aws_ami@ AWS resource.

The AMI resource allows the creation and management of a completely-custom
Amazon Machine Image (AMI). If you just want to duplicate an existing AMI,
possibly copying it to another region, it's better to use @aws_ami_copy@
instead. If you just want to share an existing AMI with another AWS account,
it's better to use @aws_ami_launch_permission@ instead.
-}
data AmiResource s = AmiResource {
      _architecture           :: !(TF.Attr s Text)
    {- ^ (Optional) Machine architecture for created instances. Defaults to "x86_64". -}
    , _description            :: !(TF.Attr s Text)
    {- ^ (Optional) A longer, human-readable description for the AMI. -}
    , _ebs_block_device       :: !(TF.Attr s Text)
    {- ^ (Optional) Nested block describing an EBS block device that should be attached to created instances. The structure of this block is described below. -}
    , _ephemeral_block_device :: !(TF.Attr s Text)
    {- ^ (Optional) Nested block describing an ephemeral block device that should be attached to created instances. The structure of this block is described below. -}
    , _name                   :: !(TF.Attr s Text)
    {- ^ (Required) A region-unique name for the AMI. -}
    , _root_device_name       :: !(TF.Attr s Text)
    {- ^ (Optional) The name of the root device (for example, @/dev/sda1@ , or @/dev/xvda@ ). -}
    , _virtualization_type    :: !(TF.Attr s Text)
    {- ^ (Optional) Keyword to choose what virtualization mode created instances will use. Can be either "paravirtual" (the default) or "hvm". The choice of virtualization type changes the set of further arguments that are required, as described below. -}
    } deriving (Show, Eq)

instance TF.ToHCL (AmiResource s) where
    toHCL AmiResource{..} = TF.inline $ catMaybes
        [ TF.assign "architecture" <$> TF.attribute _architecture
        , TF.assign "description" <$> TF.attribute _description
        , TF.assign "ebs_block_device" <$> TF.attribute _ebs_block_device
        , TF.assign "ephemeral_block_device" <$> TF.attribute _ephemeral_block_device
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "root_device_name" <$> TF.attribute _root_device_name
        , TF.assign "virtualization_type" <$> TF.attribute _virtualization_type
        ]

instance P.HasArchitecture (AmiResource s) (TF.Attr s Text) where
    architecture =
        lens (_architecture :: AmiResource s -> TF.Attr s Text)
             (\s a -> s { _architecture = a } :: AmiResource s)

instance P.HasDescription (AmiResource s) (TF.Attr s Text) where
    description =
        lens (_description :: AmiResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: AmiResource s)

instance P.HasEbsBlockDevice (AmiResource s) (TF.Attr s Text) where
    ebsBlockDevice =
        lens (_ebs_block_device :: AmiResource s -> TF.Attr s Text)
             (\s a -> s { _ebs_block_device = a } :: AmiResource s)

instance P.HasEphemeralBlockDevice (AmiResource s) (TF.Attr s Text) where
    ephemeralBlockDevice =
        lens (_ephemeral_block_device :: AmiResource s -> TF.Attr s Text)
             (\s a -> s { _ephemeral_block_device = a } :: AmiResource s)

instance P.HasName (AmiResource s) (TF.Attr s Text) where
    name =
        lens (_name :: AmiResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: AmiResource s)

instance P.HasRootDeviceName (AmiResource s) (TF.Attr s Text) where
    rootDeviceName =
        lens (_root_device_name :: AmiResource s -> TF.Attr s Text)
             (\s a -> s { _root_device_name = a } :: AmiResource s)

instance P.HasVirtualizationType (AmiResource s) (TF.Attr s Text) where
    virtualizationType =
        lens (_virtualization_type :: AmiResource s -> TF.Attr s Text)
             (\s a -> s { _virtualization_type = a } :: AmiResource s)

instance P.HasComputedArchitecture (AmiResource s) s (TF.Attr s Text) where
    computedArchitecture =
        (_architecture :: AmiResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDescription (AmiResource s) s (TF.Attr s Text) where
    computedDescription =
        (_description :: AmiResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEbsBlockDevice (AmiResource s) s (TF.Attr s Text) where
    computedEbsBlockDevice =
        (_ebs_block_device :: AmiResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEphemeralBlockDevice (AmiResource s) s (TF.Attr s Text) where
    computedEphemeralBlockDevice =
        (_ephemeral_block_device :: AmiResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (AmiResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (AmiResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: AmiResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRootDeviceName (AmiResource s) s (TF.Attr s Text) where
    computedRootDeviceName =
        (_root_device_name :: AmiResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRootSnapshotId (AmiResource s) s (TF.Attr s Text) where
    computedRootSnapshotId x = TF.compute (TF.refKey x) "root_snapshot_id"

instance P.HasComputedVirtualizationType (AmiResource s) s (TF.Attr s Text) where
    computedVirtualizationType =
        (_virtualization_type :: AmiResource s -> TF.Attr s Text)
            . TF.refValue

amiResource :: TF.Schema TF.Resource P.AWS (AmiResource s)
amiResource =
    TF.newResource "aws_ami" $
        AmiResource {
              _architecture = TF.Nil
            , _description = TF.Nil
            , _ebs_block_device = TF.Nil
            , _ephemeral_block_device = TF.Nil
            , _name = TF.Nil
            , _root_device_name = TF.Nil
            , _virtualization_type = TF.Nil
            }

{- | The @aws_api_gateway_account@ AWS resource.

Provides a settings of an API Gateway Account. Settings is applied
region-wide per @provider@ block. -> Note: As there is no API method for
deleting account settings or resetting it to defaults, destroying this
resource will keep your account settings intact
-}
data ApiGatewayAccountResource s = ApiGatewayAccountResource {
      _cloudwatch_role_arn :: !(TF.Attr s Text)
    {- ^ (Optional) The ARN of an IAM role for CloudWatch (to allow logging & monitoring). See more <https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-stage-settings.html#how-to-stage-settings-console> . Logging & monitoring can be enabled/disabled and otherwise tuned on the API Gateway Stage level. -}
    } deriving (Show, Eq)

instance TF.ToHCL (ApiGatewayAccountResource s) where
    toHCL ApiGatewayAccountResource{..} = TF.inline $ catMaybes
        [ TF.assign "cloudwatch_role_arn" <$> TF.attribute _cloudwatch_role_arn
        ]

instance P.HasCloudwatchRoleArn (ApiGatewayAccountResource s) (TF.Attr s Text) where
    cloudwatchRoleArn =
        lens (_cloudwatch_role_arn :: ApiGatewayAccountResource s -> TF.Attr s Text)
             (\s a -> s { _cloudwatch_role_arn = a } :: ApiGatewayAccountResource s)

instance P.HasComputedCloudwatchRoleArn (ApiGatewayAccountResource s) s (TF.Attr s Text) where
    computedCloudwatchRoleArn =
        (_cloudwatch_role_arn :: ApiGatewayAccountResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedThrottleSettings (ApiGatewayAccountResource s) s (TF.Attr s Text) where
    computedThrottleSettings x = TF.compute (TF.refKey x) "throttle_settings"

apiGatewayAccountResource :: TF.Schema TF.Resource P.AWS (ApiGatewayAccountResource s)
apiGatewayAccountResource =
    TF.newResource "aws_api_gateway_account" $
        ApiGatewayAccountResource {
              _cloudwatch_role_arn = TF.Nil
            }

{- | The @aws_api_gateway_api_key@ AWS resource.

Provides an API Gateway API Key. ~> Warning: Since the API Gateway usage
plans feature was launched on August 11, 2016, usage plans are now required
to associate an API key with an API stage.
-}
data ApiGatewayApiKeyResource s = ApiGatewayApiKeyResource {
      _description :: !(TF.Attr s Text)
    {- ^ (Optional) The API key description. Defaults to "Managed by Terraform". -}
    , _enabled     :: !(TF.Attr s P.Bool)
    {- ^ (Optional) Specifies whether the API key can be used by callers. Defaults to @true@ . -}
    , _name        :: !(TF.Attr s Text)
    {- ^ (Required) The name of the API key -}
    , _stage_key   :: !(TF.Attr s Text)
    {- ^ (Optional) A list of stage keys associated with the API key - see below -}
    , _value       :: !(TF.Attr s Text)
    {- ^ (Optional) The value of the API key. If not specified, it will be automatically generated by AWS on creation. -}
    } deriving (Show, Eq)

instance TF.ToHCL (ApiGatewayApiKeyResource s) where
    toHCL ApiGatewayApiKeyResource{..} = TF.inline $ catMaybes
        [ TF.assign "description" <$> TF.attribute _description
        , TF.assign "enabled" <$> TF.attribute _enabled
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "stage_key" <$> TF.attribute _stage_key
        , TF.assign "value" <$> TF.attribute _value
        ]

instance P.HasDescription (ApiGatewayApiKeyResource s) (TF.Attr s Text) where
    description =
        lens (_description :: ApiGatewayApiKeyResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: ApiGatewayApiKeyResource s)

instance P.HasEnabled (ApiGatewayApiKeyResource s) (TF.Attr s P.Bool) where
    enabled =
        lens (_enabled :: ApiGatewayApiKeyResource s -> TF.Attr s P.Bool)
             (\s a -> s { _enabled = a } :: ApiGatewayApiKeyResource s)

instance P.HasName (ApiGatewayApiKeyResource s) (TF.Attr s Text) where
    name =
        lens (_name :: ApiGatewayApiKeyResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: ApiGatewayApiKeyResource s)

instance P.HasStageKey (ApiGatewayApiKeyResource s) (TF.Attr s Text) where
    stageKey =
        lens (_stage_key :: ApiGatewayApiKeyResource s -> TF.Attr s Text)
             (\s a -> s { _stage_key = a } :: ApiGatewayApiKeyResource s)

instance P.HasValue (ApiGatewayApiKeyResource s) (TF.Attr s Text) where
    value =
        lens (_value :: ApiGatewayApiKeyResource s -> TF.Attr s Text)
             (\s a -> s { _value = a } :: ApiGatewayApiKeyResource s)

instance P.HasComputedCreatedDate (ApiGatewayApiKeyResource s) s (TF.Attr s Text) where
    computedCreatedDate x = TF.compute (TF.refKey x) "created_date"

instance P.HasComputedDescription (ApiGatewayApiKeyResource s) s (TF.Attr s Text) where
    computedDescription =
        (_description :: ApiGatewayApiKeyResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEnabled (ApiGatewayApiKeyResource s) s (TF.Attr s P.Bool) where
    computedEnabled =
        (_enabled :: ApiGatewayApiKeyResource s -> TF.Attr s P.Bool)
            . TF.refValue

instance P.HasComputedId (ApiGatewayApiKeyResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedLastUpdatedDate (ApiGatewayApiKeyResource s) s (TF.Attr s Text) where
    computedLastUpdatedDate x = TF.compute (TF.refKey x) "last_updated_date"

instance P.HasComputedName (ApiGatewayApiKeyResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: ApiGatewayApiKeyResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedStageKey (ApiGatewayApiKeyResource s) s (TF.Attr s Text) where
    computedStageKey =
        (_stage_key :: ApiGatewayApiKeyResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedValue (ApiGatewayApiKeyResource s) s (TF.Attr s Text) where
    computedValue x = TF.compute (TF.refKey x) "value"

apiGatewayApiKeyResource :: TF.Schema TF.Resource P.AWS (ApiGatewayApiKeyResource s)
apiGatewayApiKeyResource =
    TF.newResource "aws_api_gateway_api_key" $
        ApiGatewayApiKeyResource {
              _description = TF.Nil
            , _enabled = TF.Nil
            , _name = TF.Nil
            , _stage_key = TF.Nil
            , _value = TF.Nil
            }

{- | The @aws_api_gateway_authorizer@ AWS resource.

Provides an API Gateway Authorizer.
-}
data ApiGatewayAuthorizerResource s = ApiGatewayAuthorizerResource {
      _authorizer_credentials           :: !(TF.Attr s Text)
    {- ^ (Optional) The credentials required for the authorizer. To specify an IAM Role for API Gateway to assume, use the IAM Role ARN. -}
    , _authorizer_result_ttl_in_seconds :: !(TF.Attr s Text)
    {- ^ (Optional) The TTL of cached authorizer results in seconds. Defaults to @300@ . -}
    , _authorizer_uri                   :: !(TF.Attr s Text)
    {- ^ (Required) The authorizer's Uniform Resource Identifier (URI). For @TOKEN@ type, this must be a well-formed Lambda function URI in the form of @arn:aws:apigateway:{region}:lambda:path/{service_api}@ . e.g. @arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:012345678912:function:my-function/invocations@ -}
    , _identity_source                  :: !(TF.Attr s Text)
    {- ^ (Optional) The source of the identity in an incoming request. Defaults to @method.request.header.Authorization@ . For @REQUEST@ type, this may be a comma-separated list of values, including headers, query string parameters and stage variables - e.g. @"method.request.header.SomeHeaderName,method.request.querystring.SomeQueryStringName,stageVariables.SomeStageVariableName"@ -}
    , _identity_validation_expression   :: !(TF.Attr s Text)
    {- ^ (Optional) A validation expression for the incoming identity. For @TOKEN@ type, this value should be a regular expression. The incoming token from the client is matched against this expression, and will proceed if the token matches. If the token doesn't match, the client receives a 401 Unauthorized response. -}
    , _name                             :: !(TF.Attr s Text)
    {- ^ (Required) The name of the authorizer -}
    , _rest_api_id                      :: !(TF.Attr s Text)
    {- ^ (Required) The ID of the associated REST API -}
    , _type'                            :: !(TF.Attr s Text)
    {- ^ (Optional) The type of the authorizer. Possible values are @TOKEN@ and @REQUEST@ . Defaults to @TOKEN@ . -}
    } deriving (Show, Eq)

instance TF.ToHCL (ApiGatewayAuthorizerResource s) where
    toHCL ApiGatewayAuthorizerResource{..} = TF.inline $ catMaybes
        [ TF.assign "authorizer_credentials" <$> TF.attribute _authorizer_credentials
        , TF.assign "authorizer_result_ttl_in_seconds" <$> TF.attribute _authorizer_result_ttl_in_seconds
        , TF.assign "authorizer_uri" <$> TF.attribute _authorizer_uri
        , TF.assign "identity_source" <$> TF.attribute _identity_source
        , TF.assign "identity_validation_expression" <$> TF.attribute _identity_validation_expression
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "rest_api_id" <$> TF.attribute _rest_api_id
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance P.HasAuthorizerCredentials (ApiGatewayAuthorizerResource s) (TF.Attr s Text) where
    authorizerCredentials =
        lens (_authorizer_credentials :: ApiGatewayAuthorizerResource s -> TF.Attr s Text)
             (\s a -> s { _authorizer_credentials = a } :: ApiGatewayAuthorizerResource s)

instance P.HasAuthorizerResultTtlInSeconds (ApiGatewayAuthorizerResource s) (TF.Attr s Text) where
    authorizerResultTtlInSeconds =
        lens (_authorizer_result_ttl_in_seconds :: ApiGatewayAuthorizerResource s -> TF.Attr s Text)
             (\s a -> s { _authorizer_result_ttl_in_seconds = a } :: ApiGatewayAuthorizerResource s)

instance P.HasAuthorizerUri (ApiGatewayAuthorizerResource s) (TF.Attr s Text) where
    authorizerUri =
        lens (_authorizer_uri :: ApiGatewayAuthorizerResource s -> TF.Attr s Text)
             (\s a -> s { _authorizer_uri = a } :: ApiGatewayAuthorizerResource s)

instance P.HasIdentitySource (ApiGatewayAuthorizerResource s) (TF.Attr s Text) where
    identitySource =
        lens (_identity_source :: ApiGatewayAuthorizerResource s -> TF.Attr s Text)
             (\s a -> s { _identity_source = a } :: ApiGatewayAuthorizerResource s)

instance P.HasIdentityValidationExpression (ApiGatewayAuthorizerResource s) (TF.Attr s Text) where
    identityValidationExpression =
        lens (_identity_validation_expression :: ApiGatewayAuthorizerResource s -> TF.Attr s Text)
             (\s a -> s { _identity_validation_expression = a } :: ApiGatewayAuthorizerResource s)

instance P.HasName (ApiGatewayAuthorizerResource s) (TF.Attr s Text) where
    name =
        lens (_name :: ApiGatewayAuthorizerResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: ApiGatewayAuthorizerResource s)

instance P.HasRestApiId (ApiGatewayAuthorizerResource s) (TF.Attr s Text) where
    restApiId =
        lens (_rest_api_id :: ApiGatewayAuthorizerResource s -> TF.Attr s Text)
             (\s a -> s { _rest_api_id = a } :: ApiGatewayAuthorizerResource s)

instance P.HasType' (ApiGatewayAuthorizerResource s) (TF.Attr s Text) where
    type' =
        lens (_type' :: ApiGatewayAuthorizerResource s -> TF.Attr s Text)
             (\s a -> s { _type' = a } :: ApiGatewayAuthorizerResource s)

instance P.HasComputedAuthorizerCredentials (ApiGatewayAuthorizerResource s) s (TF.Attr s Text) where
    computedAuthorizerCredentials =
        (_authorizer_credentials :: ApiGatewayAuthorizerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAuthorizerResultTtlInSeconds (ApiGatewayAuthorizerResource s) s (TF.Attr s Text) where
    computedAuthorizerResultTtlInSeconds =
        (_authorizer_result_ttl_in_seconds :: ApiGatewayAuthorizerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAuthorizerUri (ApiGatewayAuthorizerResource s) s (TF.Attr s Text) where
    computedAuthorizerUri =
        (_authorizer_uri :: ApiGatewayAuthorizerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedIdentitySource (ApiGatewayAuthorizerResource s) s (TF.Attr s Text) where
    computedIdentitySource =
        (_identity_source :: ApiGatewayAuthorizerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedIdentityValidationExpression (ApiGatewayAuthorizerResource s) s (TF.Attr s Text) where
    computedIdentityValidationExpression =
        (_identity_validation_expression :: ApiGatewayAuthorizerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (ApiGatewayAuthorizerResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: ApiGatewayAuthorizerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRestApiId (ApiGatewayAuthorizerResource s) s (TF.Attr s Text) where
    computedRestApiId =
        (_rest_api_id :: ApiGatewayAuthorizerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedType' (ApiGatewayAuthorizerResource s) s (TF.Attr s Text) where
    computedType' =
        (_type' :: ApiGatewayAuthorizerResource s -> TF.Attr s Text)
            . TF.refValue

apiGatewayAuthorizerResource :: TF.Schema TF.Resource P.AWS (ApiGatewayAuthorizerResource s)
apiGatewayAuthorizerResource =
    TF.newResource "aws_api_gateway_authorizer" $
        ApiGatewayAuthorizerResource {
              _authorizer_credentials = TF.Nil
            , _authorizer_result_ttl_in_seconds = TF.Nil
            , _authorizer_uri = TF.Nil
            , _identity_source = TF.Nil
            , _identity_validation_expression = TF.Nil
            , _name = TF.Nil
            , _rest_api_id = TF.Nil
            , _type' = TF.Nil
            }

{- | The @aws_api_gateway_base_path_mapping@ AWS resource.

Connects a custom domain name registered via @aws_api_gateway_domain_name@
with a deployed API so that its methods can be called via the custom domain
name.
-}
data ApiGatewayBasePathMappingResource s = ApiGatewayBasePathMappingResource {
      _api_id      :: !(TF.Attr s Text)
    {- ^ (Required) The id of the API to connect. -}
    , _base_path   :: !(TF.Attr s Text)
    {- ^ (Optional) Path segment that must be prepended to the path when accessing the API via this mapping. If omitted, the API is exposed at the root of the given domain. -}
    , _domain_name :: !(TF.Attr s Text)
    {- ^ (Required) The already-registered domain name to connect the API to. -}
    , _stage_name  :: !(TF.Attr s Text)
    {- ^ (Optional) The name of a specific deployment stage to expose at the given path. If omitted, callers may select any stage by including its name as a path element after the base path. -}
    } deriving (Show, Eq)

instance TF.ToHCL (ApiGatewayBasePathMappingResource s) where
    toHCL ApiGatewayBasePathMappingResource{..} = TF.inline $ catMaybes
        [ TF.assign "api_id" <$> TF.attribute _api_id
        , TF.assign "base_path" <$> TF.attribute _base_path
        , TF.assign "domain_name" <$> TF.attribute _domain_name
        , TF.assign "stage_name" <$> TF.attribute _stage_name
        ]

instance P.HasApiId (ApiGatewayBasePathMappingResource s) (TF.Attr s Text) where
    apiId =
        lens (_api_id :: ApiGatewayBasePathMappingResource s -> TF.Attr s Text)
             (\s a -> s { _api_id = a } :: ApiGatewayBasePathMappingResource s)

instance P.HasBasePath (ApiGatewayBasePathMappingResource s) (TF.Attr s Text) where
    basePath =
        lens (_base_path :: ApiGatewayBasePathMappingResource s -> TF.Attr s Text)
             (\s a -> s { _base_path = a } :: ApiGatewayBasePathMappingResource s)

instance P.HasDomainName (ApiGatewayBasePathMappingResource s) (TF.Attr s Text) where
    domainName =
        lens (_domain_name :: ApiGatewayBasePathMappingResource s -> TF.Attr s Text)
             (\s a -> s { _domain_name = a } :: ApiGatewayBasePathMappingResource s)

instance P.HasStageName (ApiGatewayBasePathMappingResource s) (TF.Attr s Text) where
    stageName =
        lens (_stage_name :: ApiGatewayBasePathMappingResource s -> TF.Attr s Text)
             (\s a -> s { _stage_name = a } :: ApiGatewayBasePathMappingResource s)

instance P.HasComputedApiId (ApiGatewayBasePathMappingResource s) s (TF.Attr s Text) where
    computedApiId =
        (_api_id :: ApiGatewayBasePathMappingResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedBasePath (ApiGatewayBasePathMappingResource s) s (TF.Attr s Text) where
    computedBasePath =
        (_base_path :: ApiGatewayBasePathMappingResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDomainName (ApiGatewayBasePathMappingResource s) s (TF.Attr s Text) where
    computedDomainName =
        (_domain_name :: ApiGatewayBasePathMappingResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedStageName (ApiGatewayBasePathMappingResource s) s (TF.Attr s Text) where
    computedStageName =
        (_stage_name :: ApiGatewayBasePathMappingResource s -> TF.Attr s Text)
            . TF.refValue

apiGatewayBasePathMappingResource :: TF.Schema TF.Resource P.AWS (ApiGatewayBasePathMappingResource s)
apiGatewayBasePathMappingResource =
    TF.newResource "aws_api_gateway_base_path_mapping" $
        ApiGatewayBasePathMappingResource {
              _api_id = TF.Nil
            , _base_path = TF.Nil
            , _domain_name = TF.Nil
            , _stage_name = TF.Nil
            }

{- | The @aws_api_gateway_client_certificate@ AWS resource.

Provides an API Gateway Client Certificate.
-}
data ApiGatewayClientCertificateResource s = ApiGatewayClientCertificateResource {
      _description :: !(TF.Attr s Text)
    {- ^ (Optional) The description of the client certificate. -}
    } deriving (Show, Eq)

instance TF.ToHCL (ApiGatewayClientCertificateResource s) where
    toHCL ApiGatewayClientCertificateResource{..} = TF.inline $ catMaybes
        [ TF.assign "description" <$> TF.attribute _description
        ]

instance P.HasDescription (ApiGatewayClientCertificateResource s) (TF.Attr s Text) where
    description =
        lens (_description :: ApiGatewayClientCertificateResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: ApiGatewayClientCertificateResource s)

instance P.HasComputedCreatedDate (ApiGatewayClientCertificateResource s) s (TF.Attr s Text) where
    computedCreatedDate x = TF.compute (TF.refKey x) "created_date"

instance P.HasComputedDescription (ApiGatewayClientCertificateResource s) s (TF.Attr s Text) where
    computedDescription =
        (_description :: ApiGatewayClientCertificateResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedExpirationDate (ApiGatewayClientCertificateResource s) s (TF.Attr s Text) where
    computedExpirationDate x = TF.compute (TF.refKey x) "expiration_date"

instance P.HasComputedId (ApiGatewayClientCertificateResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedPemEncodedCertificate (ApiGatewayClientCertificateResource s) s (TF.Attr s Text) where
    computedPemEncodedCertificate x = TF.compute (TF.refKey x) "pem_encoded_certificate"

apiGatewayClientCertificateResource :: TF.Schema TF.Resource P.AWS (ApiGatewayClientCertificateResource s)
apiGatewayClientCertificateResource =
    TF.newResource "aws_api_gateway_client_certificate" $
        ApiGatewayClientCertificateResource {
              _description = TF.Nil
            }

{- | The @aws_api_gateway_deployment@ AWS resource.

Provides an API Gateway Deployment. -> Note: Depends on having
@aws_api_gateway_integration@ inside your rest api (which in turn depends on
@aws_api_gateway_method@ ). To avoid race conditions you might need to add
an explicit @depends_on = ["aws_api_gateway_integration.name"]@ .
-}
data ApiGatewayDeploymentResource s = ApiGatewayDeploymentResource {
      _description       :: !(TF.Attr s Text)
    {- ^ (Optional) The description of the deployment -}
    , _rest_api_id       :: !(TF.Attr s Text)
    {- ^ (Required) The ID of the associated REST API -}
    , _stage_description :: !(TF.Attr s Text)
    {- ^ (Optional) The description of the stage -}
    , _stage_name        :: !(TF.Attr s Text)
    {- ^ (Required) The name of the stage -}
    , _variables         :: !(TF.Attr s Text)
    {- ^ (Optional) A map that defines variables for the stage -}
    } deriving (Show, Eq)

instance TF.ToHCL (ApiGatewayDeploymentResource s) where
    toHCL ApiGatewayDeploymentResource{..} = TF.inline $ catMaybes
        [ TF.assign "description" <$> TF.attribute _description
        , TF.assign "rest_api_id" <$> TF.attribute _rest_api_id
        , TF.assign "stage_description" <$> TF.attribute _stage_description
        , TF.assign "stage_name" <$> TF.attribute _stage_name
        , TF.assign "variables" <$> TF.attribute _variables
        ]

instance P.HasDescription (ApiGatewayDeploymentResource s) (TF.Attr s Text) where
    description =
        lens (_description :: ApiGatewayDeploymentResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: ApiGatewayDeploymentResource s)

instance P.HasRestApiId (ApiGatewayDeploymentResource s) (TF.Attr s Text) where
    restApiId =
        lens (_rest_api_id :: ApiGatewayDeploymentResource s -> TF.Attr s Text)
             (\s a -> s { _rest_api_id = a } :: ApiGatewayDeploymentResource s)

instance P.HasStageDescription (ApiGatewayDeploymentResource s) (TF.Attr s Text) where
    stageDescription =
        lens (_stage_description :: ApiGatewayDeploymentResource s -> TF.Attr s Text)
             (\s a -> s { _stage_description = a } :: ApiGatewayDeploymentResource s)

instance P.HasStageName (ApiGatewayDeploymentResource s) (TF.Attr s Text) where
    stageName =
        lens (_stage_name :: ApiGatewayDeploymentResource s -> TF.Attr s Text)
             (\s a -> s { _stage_name = a } :: ApiGatewayDeploymentResource s)

instance P.HasVariables (ApiGatewayDeploymentResource s) (TF.Attr s Text) where
    variables =
        lens (_variables :: ApiGatewayDeploymentResource s -> TF.Attr s Text)
             (\s a -> s { _variables = a } :: ApiGatewayDeploymentResource s)

instance P.HasComputedCreatedDate (ApiGatewayDeploymentResource s) s (TF.Attr s Text) where
    computedCreatedDate x = TF.compute (TF.refKey x) "created_date"

instance P.HasComputedDescription (ApiGatewayDeploymentResource s) s (TF.Attr s Text) where
    computedDescription =
        (_description :: ApiGatewayDeploymentResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedExecutionArn (ApiGatewayDeploymentResource s) s (TF.Attr s Text) where
    computedExecutionArn x = TF.compute (TF.refKey x) "execution_arn"

instance P.HasComputedId (ApiGatewayDeploymentResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedInvokeUrl (ApiGatewayDeploymentResource s) s (TF.Attr s Text) where
    computedInvokeUrl x = TF.compute (TF.refKey x) "invoke_url"

instance P.HasComputedRestApiId (ApiGatewayDeploymentResource s) s (TF.Attr s Text) where
    computedRestApiId =
        (_rest_api_id :: ApiGatewayDeploymentResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedStageDescription (ApiGatewayDeploymentResource s) s (TF.Attr s Text) where
    computedStageDescription =
        (_stage_description :: ApiGatewayDeploymentResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedStageName (ApiGatewayDeploymentResource s) s (TF.Attr s Text) where
    computedStageName =
        (_stage_name :: ApiGatewayDeploymentResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedVariables (ApiGatewayDeploymentResource s) s (TF.Attr s Text) where
    computedVariables =
        (_variables :: ApiGatewayDeploymentResource s -> TF.Attr s Text)
            . TF.refValue

apiGatewayDeploymentResource :: TF.Schema TF.Resource P.AWS (ApiGatewayDeploymentResource s)
apiGatewayDeploymentResource =
    TF.newResource "aws_api_gateway_deployment" $
        ApiGatewayDeploymentResource {
              _description = TF.Nil
            , _rest_api_id = TF.Nil
            , _stage_description = TF.Nil
            , _stage_name = TF.Nil
            , _variables = TF.Nil
            }

{- | The @aws_api_gateway_documentation_part@ AWS resource.

Provides a settings of an API Gateway Documentation Part.
-}
data ApiGatewayDocumentationPartResource s = ApiGatewayDocumentationPartResource {
      _location    :: !(TF.Attr s Text)
    {- ^ (Required) The location of the targeted API entity of the to-be-created documentation part. See below. -}
    , _properties  :: !(TF.Attr s Text)
    {- ^ (Required) A content map of API-specific key-value pairs describing the targeted API entity. The map must be encoded as a JSON string, e.g., "{ "description": "The API does ..." }". Only Swagger-compliant key-value pairs can be exported and, hence, published. -}
    , _rest_api_id :: !(TF.Attr s Text)
    {- ^ (Required) The ID of the associated Rest API -}
    } deriving (Show, Eq)

instance TF.ToHCL (ApiGatewayDocumentationPartResource s) where
    toHCL ApiGatewayDocumentationPartResource{..} = TF.inline $ catMaybes
        [ TF.assign "location" <$> TF.attribute _location
        , TF.assign "properties" <$> TF.attribute _properties
        , TF.assign "rest_api_id" <$> TF.attribute _rest_api_id
        ]

instance P.HasLocation (ApiGatewayDocumentationPartResource s) (TF.Attr s Text) where
    location =
        lens (_location :: ApiGatewayDocumentationPartResource s -> TF.Attr s Text)
             (\s a -> s { _location = a } :: ApiGatewayDocumentationPartResource s)

instance P.HasProperties (ApiGatewayDocumentationPartResource s) (TF.Attr s Text) where
    properties =
        lens (_properties :: ApiGatewayDocumentationPartResource s -> TF.Attr s Text)
             (\s a -> s { _properties = a } :: ApiGatewayDocumentationPartResource s)

instance P.HasRestApiId (ApiGatewayDocumentationPartResource s) (TF.Attr s Text) where
    restApiId =
        lens (_rest_api_id :: ApiGatewayDocumentationPartResource s -> TF.Attr s Text)
             (\s a -> s { _rest_api_id = a } :: ApiGatewayDocumentationPartResource s)

instance P.HasComputedId (ApiGatewayDocumentationPartResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedLocation (ApiGatewayDocumentationPartResource s) s (TF.Attr s Text) where
    computedLocation =
        (_location :: ApiGatewayDocumentationPartResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedProperties (ApiGatewayDocumentationPartResource s) s (TF.Attr s Text) where
    computedProperties =
        (_properties :: ApiGatewayDocumentationPartResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRestApiId (ApiGatewayDocumentationPartResource s) s (TF.Attr s Text) where
    computedRestApiId =
        (_rest_api_id :: ApiGatewayDocumentationPartResource s -> TF.Attr s Text)
            . TF.refValue

apiGatewayDocumentationPartResource :: TF.Schema TF.Resource P.AWS (ApiGatewayDocumentationPartResource s)
apiGatewayDocumentationPartResource =
    TF.newResource "aws_api_gateway_documentation_part" $
        ApiGatewayDocumentationPartResource {
              _location = TF.Nil
            , _properties = TF.Nil
            , _rest_api_id = TF.Nil
            }

{- | The @aws_api_gateway_documentation_version@ AWS resource.

Provides a resource to manage an API Gateway Documentation Version.
-}
data ApiGatewayDocumentationVersionResource s = ApiGatewayDocumentationVersionResource {
      _description :: !(TF.Attr s Text)
    {- ^ (Optional) The description of the API documentation version. -}
    , _rest_api_id :: !(TF.Attr s Text)
    {- ^ (Required) The ID of the associated Rest API -}
    , _version     :: !(TF.Attr s Text)
    {- ^ (Required) The version identifier of the API documentation snapshot. -}
    } deriving (Show, Eq)

instance TF.ToHCL (ApiGatewayDocumentationVersionResource s) where
    toHCL ApiGatewayDocumentationVersionResource{..} = TF.inline $ catMaybes
        [ TF.assign "description" <$> TF.attribute _description
        , TF.assign "rest_api_id" <$> TF.attribute _rest_api_id
        , TF.assign "version" <$> TF.attribute _version
        ]

instance P.HasDescription (ApiGatewayDocumentationVersionResource s) (TF.Attr s Text) where
    description =
        lens (_description :: ApiGatewayDocumentationVersionResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: ApiGatewayDocumentationVersionResource s)

instance P.HasRestApiId (ApiGatewayDocumentationVersionResource s) (TF.Attr s Text) where
    restApiId =
        lens (_rest_api_id :: ApiGatewayDocumentationVersionResource s -> TF.Attr s Text)
             (\s a -> s { _rest_api_id = a } :: ApiGatewayDocumentationVersionResource s)

instance P.HasVersion (ApiGatewayDocumentationVersionResource s) (TF.Attr s Text) where
    version =
        lens (_version :: ApiGatewayDocumentationVersionResource s -> TF.Attr s Text)
             (\s a -> s { _version = a } :: ApiGatewayDocumentationVersionResource s)

instance P.HasComputedDescription (ApiGatewayDocumentationVersionResource s) s (TF.Attr s Text) where
    computedDescription =
        (_description :: ApiGatewayDocumentationVersionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRestApiId (ApiGatewayDocumentationVersionResource s) s (TF.Attr s Text) where
    computedRestApiId =
        (_rest_api_id :: ApiGatewayDocumentationVersionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedVersion (ApiGatewayDocumentationVersionResource s) s (TF.Attr s Text) where
    computedVersion =
        (_version :: ApiGatewayDocumentationVersionResource s -> TF.Attr s Text)
            . TF.refValue

apiGatewayDocumentationVersionResource :: TF.Schema TF.Resource P.AWS (ApiGatewayDocumentationVersionResource s)
apiGatewayDocumentationVersionResource =
    TF.newResource "aws_api_gateway_documentation_version" $
        ApiGatewayDocumentationVersionResource {
              _description = TF.Nil
            , _rest_api_id = TF.Nil
            , _version = TF.Nil
            }

{- | The @aws_api_gateway_domain_name@ AWS resource.

Registers a custom domain name for use with AWS API Gateway. This resource
just establishes ownership of and the TLS settings for a particular domain
name. An API can be attached to a particular path under the registered
domain name using <api_gateway_base_path_mapping.html> . Internally API
Gateway creates a CloudFront distribution to route requests on the given
hostname. In addition to this resource it's necessary to create a DNS record
corresponding to the given domain name which is an alias (either Route53
alias or traditional CNAME) to the Cloudfront domain name exported in the
@cloudfront_domain_name@ attribute. ~> Note: All arguments including the
private key will be stored in the raw state as plain-text.
</docs/state/sensitive-data.html> .
-}
data ApiGatewayDomainNameResource s = ApiGatewayDomainNameResource {
      _certificate_arn         :: !(TF.Attr s Text)
    {- ^ (Optional) The ARN for an AWS-managed certificate. Conflicts with @certificate_name@ , @certificate_body@ , @certificate_chain@ and @certificate_private_key@ . -}
    , _certificate_body        :: !(TF.Attr s Text)
    {- ^ (Optional) The certificate issued for the domain name being registered, in PEM format. Conflicts with @certificate_arn@ . -}
    , _certificate_chain       :: !(TF.Attr s Text)
    {- ^ (Optional) The certificate for the CA that issued the certificate, along with any intermediate CA certificates required to create an unbroken chain to a certificate trusted by the intended API clients. Conflicts with @certificate_arn@ . -}
    , _certificate_name        :: !(TF.Attr s Text)
    {- ^ (Optional) The unique name to use when registering this cert as an IAM server certificate. Conflicts with @certificate_arn@ . Required if @certificate_arn@ is not set. -}
    , _certificate_private_key :: !(TF.Attr s Text)
    {- ^ (Optional) The private key associated with the domain certificate given in @certificate_body@ . Conflicts with @certificate_arn@ . -}
    , _domain_name             :: !(TF.Attr s Text)
    {- ^ (Required) The fully-qualified domain name to register -}
    } deriving (Show, Eq)

instance TF.ToHCL (ApiGatewayDomainNameResource s) where
    toHCL ApiGatewayDomainNameResource{..} = TF.inline $ catMaybes
        [ TF.assign "certificate_arn" <$> TF.attribute _certificate_arn
        , TF.assign "certificate_body" <$> TF.attribute _certificate_body
        , TF.assign "certificate_chain" <$> TF.attribute _certificate_chain
        , TF.assign "certificate_name" <$> TF.attribute _certificate_name
        , TF.assign "certificate_private_key" <$> TF.attribute _certificate_private_key
        , TF.assign "domain_name" <$> TF.attribute _domain_name
        ]

instance P.HasCertificateArn (ApiGatewayDomainNameResource s) (TF.Attr s Text) where
    certificateArn =
        lens (_certificate_arn :: ApiGatewayDomainNameResource s -> TF.Attr s Text)
             (\s a -> s { _certificate_arn = a } :: ApiGatewayDomainNameResource s)

instance P.HasCertificateBody (ApiGatewayDomainNameResource s) (TF.Attr s Text) where
    certificateBody =
        lens (_certificate_body :: ApiGatewayDomainNameResource s -> TF.Attr s Text)
             (\s a -> s { _certificate_body = a } :: ApiGatewayDomainNameResource s)

instance P.HasCertificateChain (ApiGatewayDomainNameResource s) (TF.Attr s Text) where
    certificateChain =
        lens (_certificate_chain :: ApiGatewayDomainNameResource s -> TF.Attr s Text)
             (\s a -> s { _certificate_chain = a } :: ApiGatewayDomainNameResource s)

instance P.HasCertificateName (ApiGatewayDomainNameResource s) (TF.Attr s Text) where
    certificateName =
        lens (_certificate_name :: ApiGatewayDomainNameResource s -> TF.Attr s Text)
             (\s a -> s { _certificate_name = a } :: ApiGatewayDomainNameResource s)

instance P.HasCertificatePrivateKey (ApiGatewayDomainNameResource s) (TF.Attr s Text) where
    certificatePrivateKey =
        lens (_certificate_private_key :: ApiGatewayDomainNameResource s -> TF.Attr s Text)
             (\s a -> s { _certificate_private_key = a } :: ApiGatewayDomainNameResource s)

instance P.HasDomainName (ApiGatewayDomainNameResource s) (TF.Attr s Text) where
    domainName =
        lens (_domain_name :: ApiGatewayDomainNameResource s -> TF.Attr s Text)
             (\s a -> s { _domain_name = a } :: ApiGatewayDomainNameResource s)

instance P.HasComputedCertificateArn (ApiGatewayDomainNameResource s) s (TF.Attr s Text) where
    computedCertificateArn =
        (_certificate_arn :: ApiGatewayDomainNameResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCertificateBody (ApiGatewayDomainNameResource s) s (TF.Attr s Text) where
    computedCertificateBody =
        (_certificate_body :: ApiGatewayDomainNameResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCertificateChain (ApiGatewayDomainNameResource s) s (TF.Attr s Text) where
    computedCertificateChain =
        (_certificate_chain :: ApiGatewayDomainNameResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCertificateName (ApiGatewayDomainNameResource s) s (TF.Attr s Text) where
    computedCertificateName =
        (_certificate_name :: ApiGatewayDomainNameResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCertificatePrivateKey (ApiGatewayDomainNameResource s) s (TF.Attr s Text) where
    computedCertificatePrivateKey =
        (_certificate_private_key :: ApiGatewayDomainNameResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCertificateUploadDate (ApiGatewayDomainNameResource s) s (TF.Attr s Text) where
    computedCertificateUploadDate x = TF.compute (TF.refKey x) "certificate_upload_date"

instance P.HasComputedCloudfrontDomainName (ApiGatewayDomainNameResource s) s (TF.Attr s Text) where
    computedCloudfrontDomainName x = TF.compute (TF.refKey x) "cloudfront_domain_name"

instance P.HasComputedCloudfrontZoneId (ApiGatewayDomainNameResource s) s (TF.Attr s Text) where
    computedCloudfrontZoneId x = TF.compute (TF.refKey x) "cloudfront_zone_id"

instance P.HasComputedDomainName (ApiGatewayDomainNameResource s) s (TF.Attr s Text) where
    computedDomainName =
        (_domain_name :: ApiGatewayDomainNameResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (ApiGatewayDomainNameResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

apiGatewayDomainNameResource :: TF.Schema TF.Resource P.AWS (ApiGatewayDomainNameResource s)
apiGatewayDomainNameResource =
    TF.newResource "aws_api_gateway_domain_name" $
        ApiGatewayDomainNameResource {
              _certificate_arn = TF.Nil
            , _certificate_body = TF.Nil
            , _certificate_chain = TF.Nil
            , _certificate_name = TF.Nil
            , _certificate_private_key = TF.Nil
            , _domain_name = TF.Nil
            }

{- | The @aws_api_gateway_gateway_response@ AWS resource.

Provides an API Gateway Gateway Response for a REST API Gateway.
-}
data ApiGatewayGatewayResponseResource s = ApiGatewayGatewayResponseResource {
      _response_parameters :: !(TF.Attr s Text)
    {- ^ (Optional) A map specifying the templates used to transform the response body. -}
    , _response_templates  :: !(TF.Attr s Text)
    {- ^ (Optional) A map specifying the parameters (paths, query strings and headers) of the Gateway Response. -}
    , _response_type       :: !(TF.Attr s Text)
    {- ^ (Required) The response type of the associated GatewayResponse. -}
    , _rest_api_id         :: !(TF.Attr s Text)
    {- ^ (Required) The string identifier of the associated REST API. -}
    , _status_code         :: !(TF.Attr s Text)
    {- ^ (Optional) The HTTP status code of the Gateway Response. -}
    } deriving (Show, Eq)

instance TF.ToHCL (ApiGatewayGatewayResponseResource s) where
    toHCL ApiGatewayGatewayResponseResource{..} = TF.inline $ catMaybes
        [ TF.assign "response_parameters" <$> TF.attribute _response_parameters
        , TF.assign "response_templates" <$> TF.attribute _response_templates
        , TF.assign "response_type" <$> TF.attribute _response_type
        , TF.assign "rest_api_id" <$> TF.attribute _rest_api_id
        , TF.assign "status_code" <$> TF.attribute _status_code
        ]

instance P.HasResponseParameters (ApiGatewayGatewayResponseResource s) (TF.Attr s Text) where
    responseParameters =
        lens (_response_parameters :: ApiGatewayGatewayResponseResource s -> TF.Attr s Text)
             (\s a -> s { _response_parameters = a } :: ApiGatewayGatewayResponseResource s)

instance P.HasResponseTemplates (ApiGatewayGatewayResponseResource s) (TF.Attr s Text) where
    responseTemplates =
        lens (_response_templates :: ApiGatewayGatewayResponseResource s -> TF.Attr s Text)
             (\s a -> s { _response_templates = a } :: ApiGatewayGatewayResponseResource s)

instance P.HasResponseType (ApiGatewayGatewayResponseResource s) (TF.Attr s Text) where
    responseType =
        lens (_response_type :: ApiGatewayGatewayResponseResource s -> TF.Attr s Text)
             (\s a -> s { _response_type = a } :: ApiGatewayGatewayResponseResource s)

instance P.HasRestApiId (ApiGatewayGatewayResponseResource s) (TF.Attr s Text) where
    restApiId =
        lens (_rest_api_id :: ApiGatewayGatewayResponseResource s -> TF.Attr s Text)
             (\s a -> s { _rest_api_id = a } :: ApiGatewayGatewayResponseResource s)

instance P.HasStatusCode (ApiGatewayGatewayResponseResource s) (TF.Attr s Text) where
    statusCode =
        lens (_status_code :: ApiGatewayGatewayResponseResource s -> TF.Attr s Text)
             (\s a -> s { _status_code = a } :: ApiGatewayGatewayResponseResource s)

instance P.HasComputedResponseParameters (ApiGatewayGatewayResponseResource s) s (TF.Attr s Text) where
    computedResponseParameters =
        (_response_parameters :: ApiGatewayGatewayResponseResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedResponseTemplates (ApiGatewayGatewayResponseResource s) s (TF.Attr s Text) where
    computedResponseTemplates =
        (_response_templates :: ApiGatewayGatewayResponseResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedResponseType (ApiGatewayGatewayResponseResource s) s (TF.Attr s Text) where
    computedResponseType =
        (_response_type :: ApiGatewayGatewayResponseResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRestApiId (ApiGatewayGatewayResponseResource s) s (TF.Attr s Text) where
    computedRestApiId =
        (_rest_api_id :: ApiGatewayGatewayResponseResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedStatusCode (ApiGatewayGatewayResponseResource s) s (TF.Attr s Text) where
    computedStatusCode =
        (_status_code :: ApiGatewayGatewayResponseResource s -> TF.Attr s Text)
            . TF.refValue

apiGatewayGatewayResponseResource :: TF.Schema TF.Resource P.AWS (ApiGatewayGatewayResponseResource s)
apiGatewayGatewayResponseResource =
    TF.newResource "aws_api_gateway_gateway_response" $
        ApiGatewayGatewayResponseResource {
              _response_parameters = TF.Nil
            , _response_templates = TF.Nil
            , _response_type = TF.Nil
            , _rest_api_id = TF.Nil
            , _status_code = TF.Nil
            }

{- | The @aws_api_gateway_integration@ AWS resource.

Provides an HTTP Method Integration for an API Gateway Integration.
-}
data ApiGatewayIntegrationResource s = ApiGatewayIntegrationResource {
      _cache_key_namespace        :: !(TF.Attr s Text)
    {- ^ (Optional) The integration's cache namespace. -}
    , _cache_key_parameters       :: !(TF.Attr s Text)
    {- ^ (Optional) A list of cache key parameters for the integration. -}
    , _content_handling           :: !(TF.Attr s Text)
    {- ^ (Optional) Specifies how to handle request payload content type conversions. Supported values are @CONVERT_TO_BINARY@ and @CONVERT_TO_TEXT@ . If this property is not defined, the request payload will be passed through from the method request to integration request without modification, provided that the passthroughBehaviors is configured to support payload pass-through. -}
    , _credentials                :: !(TF.Attr s Text)
    {- ^ (Optional) The credentials required for the integration. For @AWS@ integrations, 2 options are available. To specify an IAM Role for Amazon API Gateway to assume, use the role's ARN. To require that the caller's identity be passed through from the request, specify the string @arn:aws:iam::\*:user/\*@ . -}
    , _http_method                :: !(TF.Attr s Text)
    {- ^ (Required) The HTTP method ( @GET@ , @POST@ , @PUT@ , @DELETE@ , @HEAD@ , @OPTION@ , @ANY@ ) when calling the associated resource. -}
    , _integration_http_method    :: !(TF.Attr s Text)
    {- ^ (Optional) The integration HTTP method ( @GET@ , @POST@ , @PUT@ , @DELETE@ , @HEAD@ , @OPTION@ ) specifying how API Gateway will interact with the back end. Required if @type@ is @AWS@ , @AWS_PROXY@ , @HTTP@ or @HTTP_PROXY@ . Not all methods are compatible with all @AWS@ integrations. e.g. Lambda function <https://github.com/awslabs/aws-apigateway-importer/issues/9#issuecomment-129651005> via @POST@ . -}
    , _passthrough_behavior       :: !(TF.Attr s Text)
    {- ^ (Optional) The integration passthrough behavior ( @WHEN_NO_MATCH@ , @WHEN_NO_TEMPLATES@ , @NEVER@ ). Required if @request_templates@ is used. -}
    , _request_parameters         :: !(TF.Attr s Text)
    {- ^ (Optional) A map of request query string parameters and headers that should be passed to the backend responder. For example: @request_parameters = { "integration.request.header.X-Some-Other-Header" = "method.request.header.X-Some-Header" }@ -}
    , _request_parameters_in_json :: !(TF.Attr s Text)
    {- ^ - Deprecated , use @request_parameters@ instead. -}
    , _request_templates          :: !(TF.Attr s Text)
    {- ^ (Optional) A map of the integration's request templates. -}
    , _resource_id                :: !(TF.Attr s Text)
    {- ^ (Required) The API resource ID. -}
    , _rest_api_id                :: !(TF.Attr s Text)
    {- ^ (Required) The ID of the associated REST API. -}
    , _type'                      :: !(TF.Attr s Text)
    {- ^ (Required) The integration input's <https://docs.aws.amazon.com/apigateway/api-reference/resource/integration/> . Valid values are @HTTP@ (for HTTP backends), @MOCK@ (not calling any real backend), @AWS@ (for AWS services), @AWS_PROXY@ (for Lambda proxy integration) and @HTTP_PROXY@ (for HTTP proxy integration). -}
    , _uri                        :: !(TF.Attr s Text)
    {- ^ (Optional) The input's URI (HTTP, AWS). Required if @type@ is @HTTP@ or @AWS@ . For HTTP integrations, the URI must be a fully formed, encoded HTTP(S) URL according to the RFC-3986 specification . For AWS integrations, the URI should be of the form @arn:aws:apigateway:{region}:{subdomain.service|service}:{path|action}/{service_api}@ . @region@ , @subdomain@ and @service@ are used to determine the right endpoint. e.g. @arn:aws:apigateway:eu-west-1:lambda:path/2015-03-31/functions/arn:aws:lambda:eu-west-1:012345678901:function:my-func/invocations@ -}
    } deriving (Show, Eq)

instance TF.ToHCL (ApiGatewayIntegrationResource s) where
    toHCL ApiGatewayIntegrationResource{..} = TF.inline $ catMaybes
        [ TF.assign "cache_key_namespace" <$> TF.attribute _cache_key_namespace
        , TF.assign "cache_key_parameters" <$> TF.attribute _cache_key_parameters
        , TF.assign "content_handling" <$> TF.attribute _content_handling
        , TF.assign "credentials" <$> TF.attribute _credentials
        , TF.assign "http_method" <$> TF.attribute _http_method
        , TF.assign "integration_http_method" <$> TF.attribute _integration_http_method
        , TF.assign "passthrough_behavior" <$> TF.attribute _passthrough_behavior
        , TF.assign "request_parameters" <$> TF.attribute _request_parameters
        , TF.assign "request_parameters_in_json" <$> TF.attribute _request_parameters_in_json
        , TF.assign "request_templates" <$> TF.attribute _request_templates
        , TF.assign "resource_id" <$> TF.attribute _resource_id
        , TF.assign "rest_api_id" <$> TF.attribute _rest_api_id
        , TF.assign "type" <$> TF.attribute _type'
        , TF.assign "uri" <$> TF.attribute _uri
        ]

instance P.HasCacheKeyNamespace (ApiGatewayIntegrationResource s) (TF.Attr s Text) where
    cacheKeyNamespace =
        lens (_cache_key_namespace :: ApiGatewayIntegrationResource s -> TF.Attr s Text)
             (\s a -> s { _cache_key_namespace = a } :: ApiGatewayIntegrationResource s)

instance P.HasCacheKeyParameters (ApiGatewayIntegrationResource s) (TF.Attr s Text) where
    cacheKeyParameters =
        lens (_cache_key_parameters :: ApiGatewayIntegrationResource s -> TF.Attr s Text)
             (\s a -> s { _cache_key_parameters = a } :: ApiGatewayIntegrationResource s)

instance P.HasContentHandling (ApiGatewayIntegrationResource s) (TF.Attr s Text) where
    contentHandling =
        lens (_content_handling :: ApiGatewayIntegrationResource s -> TF.Attr s Text)
             (\s a -> s { _content_handling = a } :: ApiGatewayIntegrationResource s)

instance P.HasCredentials (ApiGatewayIntegrationResource s) (TF.Attr s Text) where
    credentials =
        lens (_credentials :: ApiGatewayIntegrationResource s -> TF.Attr s Text)
             (\s a -> s { _credentials = a } :: ApiGatewayIntegrationResource s)

instance P.HasHttpMethod (ApiGatewayIntegrationResource s) (TF.Attr s Text) where
    httpMethod =
        lens (_http_method :: ApiGatewayIntegrationResource s -> TF.Attr s Text)
             (\s a -> s { _http_method = a } :: ApiGatewayIntegrationResource s)

instance P.HasIntegrationHttpMethod (ApiGatewayIntegrationResource s) (TF.Attr s Text) where
    integrationHttpMethod =
        lens (_integration_http_method :: ApiGatewayIntegrationResource s -> TF.Attr s Text)
             (\s a -> s { _integration_http_method = a } :: ApiGatewayIntegrationResource s)

instance P.HasPassthroughBehavior (ApiGatewayIntegrationResource s) (TF.Attr s Text) where
    passthroughBehavior =
        lens (_passthrough_behavior :: ApiGatewayIntegrationResource s -> TF.Attr s Text)
             (\s a -> s { _passthrough_behavior = a } :: ApiGatewayIntegrationResource s)

instance P.HasRequestParameters (ApiGatewayIntegrationResource s) (TF.Attr s Text) where
    requestParameters =
        lens (_request_parameters :: ApiGatewayIntegrationResource s -> TF.Attr s Text)
             (\s a -> s { _request_parameters = a } :: ApiGatewayIntegrationResource s)

instance P.HasRequestParametersInJson (ApiGatewayIntegrationResource s) (TF.Attr s Text) where
    requestParametersInJson =
        lens (_request_parameters_in_json :: ApiGatewayIntegrationResource s -> TF.Attr s Text)
             (\s a -> s { _request_parameters_in_json = a } :: ApiGatewayIntegrationResource s)

instance P.HasRequestTemplates (ApiGatewayIntegrationResource s) (TF.Attr s Text) where
    requestTemplates =
        lens (_request_templates :: ApiGatewayIntegrationResource s -> TF.Attr s Text)
             (\s a -> s { _request_templates = a } :: ApiGatewayIntegrationResource s)

instance P.HasResourceId (ApiGatewayIntegrationResource s) (TF.Attr s Text) where
    resourceId =
        lens (_resource_id :: ApiGatewayIntegrationResource s -> TF.Attr s Text)
             (\s a -> s { _resource_id = a } :: ApiGatewayIntegrationResource s)

instance P.HasRestApiId (ApiGatewayIntegrationResource s) (TF.Attr s Text) where
    restApiId =
        lens (_rest_api_id :: ApiGatewayIntegrationResource s -> TF.Attr s Text)
             (\s a -> s { _rest_api_id = a } :: ApiGatewayIntegrationResource s)

instance P.HasType' (ApiGatewayIntegrationResource s) (TF.Attr s Text) where
    type' =
        lens (_type' :: ApiGatewayIntegrationResource s -> TF.Attr s Text)
             (\s a -> s { _type' = a } :: ApiGatewayIntegrationResource s)

instance P.HasUri (ApiGatewayIntegrationResource s) (TF.Attr s Text) where
    uri =
        lens (_uri :: ApiGatewayIntegrationResource s -> TF.Attr s Text)
             (\s a -> s { _uri = a } :: ApiGatewayIntegrationResource s)

instance P.HasComputedCacheKeyNamespace (ApiGatewayIntegrationResource s) s (TF.Attr s Text) where
    computedCacheKeyNamespace =
        (_cache_key_namespace :: ApiGatewayIntegrationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCacheKeyParameters (ApiGatewayIntegrationResource s) s (TF.Attr s Text) where
    computedCacheKeyParameters =
        (_cache_key_parameters :: ApiGatewayIntegrationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedContentHandling (ApiGatewayIntegrationResource s) s (TF.Attr s Text) where
    computedContentHandling =
        (_content_handling :: ApiGatewayIntegrationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCredentials (ApiGatewayIntegrationResource s) s (TF.Attr s Text) where
    computedCredentials =
        (_credentials :: ApiGatewayIntegrationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedHttpMethod (ApiGatewayIntegrationResource s) s (TF.Attr s Text) where
    computedHttpMethod =
        (_http_method :: ApiGatewayIntegrationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedIntegrationHttpMethod (ApiGatewayIntegrationResource s) s (TF.Attr s Text) where
    computedIntegrationHttpMethod =
        (_integration_http_method :: ApiGatewayIntegrationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPassthroughBehavior (ApiGatewayIntegrationResource s) s (TF.Attr s Text) where
    computedPassthroughBehavior =
        (_passthrough_behavior :: ApiGatewayIntegrationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRequestParameters (ApiGatewayIntegrationResource s) s (TF.Attr s Text) where
    computedRequestParameters =
        (_request_parameters :: ApiGatewayIntegrationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRequestParametersInJson (ApiGatewayIntegrationResource s) s (TF.Attr s Text) where
    computedRequestParametersInJson =
        (_request_parameters_in_json :: ApiGatewayIntegrationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRequestTemplates (ApiGatewayIntegrationResource s) s (TF.Attr s Text) where
    computedRequestTemplates =
        (_request_templates :: ApiGatewayIntegrationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedResourceId (ApiGatewayIntegrationResource s) s (TF.Attr s Text) where
    computedResourceId =
        (_resource_id :: ApiGatewayIntegrationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRestApiId (ApiGatewayIntegrationResource s) s (TF.Attr s Text) where
    computedRestApiId =
        (_rest_api_id :: ApiGatewayIntegrationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedType' (ApiGatewayIntegrationResource s) s (TF.Attr s Text) where
    computedType' =
        (_type' :: ApiGatewayIntegrationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedUri (ApiGatewayIntegrationResource s) s (TF.Attr s Text) where
    computedUri =
        (_uri :: ApiGatewayIntegrationResource s -> TF.Attr s Text)
            . TF.refValue

apiGatewayIntegrationResource :: TF.Schema TF.Resource P.AWS (ApiGatewayIntegrationResource s)
apiGatewayIntegrationResource =
    TF.newResource "aws_api_gateway_integration" $
        ApiGatewayIntegrationResource {
              _cache_key_namespace = TF.Nil
            , _cache_key_parameters = TF.Nil
            , _content_handling = TF.Nil
            , _credentials = TF.Nil
            , _http_method = TF.Nil
            , _integration_http_method = TF.Nil
            , _passthrough_behavior = TF.Nil
            , _request_parameters = TF.Nil
            , _request_parameters_in_json = TF.Nil
            , _request_templates = TF.Nil
            , _resource_id = TF.Nil
            , _rest_api_id = TF.Nil
            , _type' = TF.Nil
            , _uri = TF.Nil
            }

{- | The @aws_api_gateway_integration_response@ AWS resource.

Provides an HTTP Method Integration Response for an API Gateway Resource. ->
Note: Depends on having @aws_api_gateway_integration@ inside your rest api.
To ensure this you might need to add an explicit @depends_on@ for clean
runs.
-}
data ApiGatewayIntegrationResponseResource s = ApiGatewayIntegrationResponseResource {
      _content_handling            :: !(TF.Attr s Text)
    {- ^ (Optional) Specifies how to handle request payload content type conversions. Supported values are @CONVERT_TO_BINARY@ and @CONVERT_TO_TEXT@ . If this property is not defined, the response payload will be passed through from the integration response to the method response without modification. -}
    , _http_method                 :: !(TF.Attr s Text)
    {- ^ (Required) The HTTP method ( @GET@ , @POST@ , @PUT@ , @DELETE@ , @HEAD@ , @OPTIONS@ , @ANY@ ) -}
    , _resource_id                 :: !(TF.Attr s Text)
    {- ^ (Required) The API resource ID -}
    , _response_parameters         :: !(TF.Attr s Text)
    {- ^ (Optional) A map of response parameters that can be read from the backend response. For example: @response_parameters = { "method.response.header.X-Some-Header" = "integration.response.header.X-Some-Other-Header" }@ , -}
    , _response_parameters_in_json :: !(TF.Attr s Text)
    {- ^ - Deprecated , use @response_parameters@ instead. -}
    , _response_templates          :: !(TF.Attr s Text)
    {- ^ (Optional) A map specifying the templates used to transform the integration response body -}
    , _rest_api_id                 :: !(TF.Attr s Text)
    {- ^ (Required) The ID of the associated REST API -}
    , _selection_pattern           :: !(TF.Attr s Text)
    {- ^ (Optional) Specifies the regular expression pattern used to choose an integration response based on the response from the backend. Setting this to @-@ makes the integration the default one. If the backend is an @AWS@ Lambda function, the AWS Lambda function error header is matched. For all other @HTTP@ and @AWS@ backends, the HTTP status code is matched. -}
    , _status_code                 :: !(TF.Attr s Text)
    {- ^ (Required) The HTTP status code -}
    } deriving (Show, Eq)

instance TF.ToHCL (ApiGatewayIntegrationResponseResource s) where
    toHCL ApiGatewayIntegrationResponseResource{..} = TF.inline $ catMaybes
        [ TF.assign "content_handling" <$> TF.attribute _content_handling
        , TF.assign "http_method" <$> TF.attribute _http_method
        , TF.assign "resource_id" <$> TF.attribute _resource_id
        , TF.assign "response_parameters" <$> TF.attribute _response_parameters
        , TF.assign "response_parameters_in_json" <$> TF.attribute _response_parameters_in_json
        , TF.assign "response_templates" <$> TF.attribute _response_templates
        , TF.assign "rest_api_id" <$> TF.attribute _rest_api_id
        , TF.assign "selection_pattern" <$> TF.attribute _selection_pattern
        , TF.assign "status_code" <$> TF.attribute _status_code
        ]

instance P.HasContentHandling (ApiGatewayIntegrationResponseResource s) (TF.Attr s Text) where
    contentHandling =
        lens (_content_handling :: ApiGatewayIntegrationResponseResource s -> TF.Attr s Text)
             (\s a -> s { _content_handling = a } :: ApiGatewayIntegrationResponseResource s)

instance P.HasHttpMethod (ApiGatewayIntegrationResponseResource s) (TF.Attr s Text) where
    httpMethod =
        lens (_http_method :: ApiGatewayIntegrationResponseResource s -> TF.Attr s Text)
             (\s a -> s { _http_method = a } :: ApiGatewayIntegrationResponseResource s)

instance P.HasResourceId (ApiGatewayIntegrationResponseResource s) (TF.Attr s Text) where
    resourceId =
        lens (_resource_id :: ApiGatewayIntegrationResponseResource s -> TF.Attr s Text)
             (\s a -> s { _resource_id = a } :: ApiGatewayIntegrationResponseResource s)

instance P.HasResponseParameters (ApiGatewayIntegrationResponseResource s) (TF.Attr s Text) where
    responseParameters =
        lens (_response_parameters :: ApiGatewayIntegrationResponseResource s -> TF.Attr s Text)
             (\s a -> s { _response_parameters = a } :: ApiGatewayIntegrationResponseResource s)

instance P.HasResponseParametersInJson (ApiGatewayIntegrationResponseResource s) (TF.Attr s Text) where
    responseParametersInJson =
        lens (_response_parameters_in_json :: ApiGatewayIntegrationResponseResource s -> TF.Attr s Text)
             (\s a -> s { _response_parameters_in_json = a } :: ApiGatewayIntegrationResponseResource s)

instance P.HasResponseTemplates (ApiGatewayIntegrationResponseResource s) (TF.Attr s Text) where
    responseTemplates =
        lens (_response_templates :: ApiGatewayIntegrationResponseResource s -> TF.Attr s Text)
             (\s a -> s { _response_templates = a } :: ApiGatewayIntegrationResponseResource s)

instance P.HasRestApiId (ApiGatewayIntegrationResponseResource s) (TF.Attr s Text) where
    restApiId =
        lens (_rest_api_id :: ApiGatewayIntegrationResponseResource s -> TF.Attr s Text)
             (\s a -> s { _rest_api_id = a } :: ApiGatewayIntegrationResponseResource s)

instance P.HasSelectionPattern (ApiGatewayIntegrationResponseResource s) (TF.Attr s Text) where
    selectionPattern =
        lens (_selection_pattern :: ApiGatewayIntegrationResponseResource s -> TF.Attr s Text)
             (\s a -> s { _selection_pattern = a } :: ApiGatewayIntegrationResponseResource s)

instance P.HasStatusCode (ApiGatewayIntegrationResponseResource s) (TF.Attr s Text) where
    statusCode =
        lens (_status_code :: ApiGatewayIntegrationResponseResource s -> TF.Attr s Text)
             (\s a -> s { _status_code = a } :: ApiGatewayIntegrationResponseResource s)

instance P.HasComputedContentHandling (ApiGatewayIntegrationResponseResource s) s (TF.Attr s Text) where
    computedContentHandling =
        (_content_handling :: ApiGatewayIntegrationResponseResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedHttpMethod (ApiGatewayIntegrationResponseResource s) s (TF.Attr s Text) where
    computedHttpMethod =
        (_http_method :: ApiGatewayIntegrationResponseResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedResourceId (ApiGatewayIntegrationResponseResource s) s (TF.Attr s Text) where
    computedResourceId =
        (_resource_id :: ApiGatewayIntegrationResponseResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedResponseParameters (ApiGatewayIntegrationResponseResource s) s (TF.Attr s Text) where
    computedResponseParameters =
        (_response_parameters :: ApiGatewayIntegrationResponseResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedResponseParametersInJson (ApiGatewayIntegrationResponseResource s) s (TF.Attr s Text) where
    computedResponseParametersInJson =
        (_response_parameters_in_json :: ApiGatewayIntegrationResponseResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedResponseTemplates (ApiGatewayIntegrationResponseResource s) s (TF.Attr s Text) where
    computedResponseTemplates =
        (_response_templates :: ApiGatewayIntegrationResponseResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRestApiId (ApiGatewayIntegrationResponseResource s) s (TF.Attr s Text) where
    computedRestApiId =
        (_rest_api_id :: ApiGatewayIntegrationResponseResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSelectionPattern (ApiGatewayIntegrationResponseResource s) s (TF.Attr s Text) where
    computedSelectionPattern =
        (_selection_pattern :: ApiGatewayIntegrationResponseResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedStatusCode (ApiGatewayIntegrationResponseResource s) s (TF.Attr s Text) where
    computedStatusCode =
        (_status_code :: ApiGatewayIntegrationResponseResource s -> TF.Attr s Text)
            . TF.refValue

apiGatewayIntegrationResponseResource :: TF.Schema TF.Resource P.AWS (ApiGatewayIntegrationResponseResource s)
apiGatewayIntegrationResponseResource =
    TF.newResource "aws_api_gateway_integration_response" $
        ApiGatewayIntegrationResponseResource {
              _content_handling = TF.Nil
            , _http_method = TF.Nil
            , _resource_id = TF.Nil
            , _response_parameters = TF.Nil
            , _response_parameters_in_json = TF.Nil
            , _response_templates = TF.Nil
            , _rest_api_id = TF.Nil
            , _selection_pattern = TF.Nil
            , _status_code = TF.Nil
            }

{- | The @aws_api_gateway_method@ AWS resource.

Provides a HTTP Method for an API Gateway Resource.
-}
data ApiGatewayMethodResource s = ApiGatewayMethodResource {
      _api_key_required     :: !(TF.Attr s Text)
    {- ^ (Optional) Specify if the method requires an API key -}
    , _authorization        :: !(TF.Attr s Text)
    {- ^ (Required) The type of authorization used for the method ( @NONE@ , @CUSTOM@ , @AWS_IAM@ ) -}
    , _authorizer_id        :: !(TF.Attr s Text)
    {- ^ (Optional) The authorizer id to be used when the authorization is @CUSTOM@ -}
    , _http_method          :: !(TF.Attr s Text)
    {- ^ (Required) The HTTP Method ( @GET@ , @POST@ , @PUT@ , @DELETE@ , @HEAD@ , @OPTIONS@ , @ANY@ ) -}
    , _request_models       :: !(TF.Attr s Text)
    {- ^ (Optional) A map of the API models used for the request's content type where key is the content type (e.g. @application/json@ ) and value is either @Error@ , @Empty@ (built-in models) or @aws_api_gateway_model@ 's @name@ . -}
    , _request_parameters   :: !(TF.Attr s Text)
    {- ^ (Optional) A map of request query string parameters and headers that should be passed to the integration. For example: -}
    , _request_validator_id :: !(TF.Attr s Text)
    {- ^ (Optional) The ID of a @aws_api_gateway_request_validator@ -}
    , _resource_id          :: !(TF.Attr s Text)
    {- ^ (Required) The API resource ID -}
    , _rest_api_id          :: !(TF.Attr s Text)
    {- ^ (Required) The ID of the associated REST API -}
    } deriving (Show, Eq)

instance TF.ToHCL (ApiGatewayMethodResource s) where
    toHCL ApiGatewayMethodResource{..} = TF.inline $ catMaybes
        [ TF.assign "api_key_required" <$> TF.attribute _api_key_required
        , TF.assign "authorization" <$> TF.attribute _authorization
        , TF.assign "authorizer_id" <$> TF.attribute _authorizer_id
        , TF.assign "http_method" <$> TF.attribute _http_method
        , TF.assign "request_models" <$> TF.attribute _request_models
        , TF.assign "request_parameters" <$> TF.attribute _request_parameters
        , TF.assign "request_validator_id" <$> TF.attribute _request_validator_id
        , TF.assign "resource_id" <$> TF.attribute _resource_id
        , TF.assign "rest_api_id" <$> TF.attribute _rest_api_id
        ]

instance P.HasApiKeyRequired (ApiGatewayMethodResource s) (TF.Attr s Text) where
    apiKeyRequired =
        lens (_api_key_required :: ApiGatewayMethodResource s -> TF.Attr s Text)
             (\s a -> s { _api_key_required = a } :: ApiGatewayMethodResource s)

instance P.HasAuthorization (ApiGatewayMethodResource s) (TF.Attr s Text) where
    authorization =
        lens (_authorization :: ApiGatewayMethodResource s -> TF.Attr s Text)
             (\s a -> s { _authorization = a } :: ApiGatewayMethodResource s)

instance P.HasAuthorizerId (ApiGatewayMethodResource s) (TF.Attr s Text) where
    authorizerId =
        lens (_authorizer_id :: ApiGatewayMethodResource s -> TF.Attr s Text)
             (\s a -> s { _authorizer_id = a } :: ApiGatewayMethodResource s)

instance P.HasHttpMethod (ApiGatewayMethodResource s) (TF.Attr s Text) where
    httpMethod =
        lens (_http_method :: ApiGatewayMethodResource s -> TF.Attr s Text)
             (\s a -> s { _http_method = a } :: ApiGatewayMethodResource s)

instance P.HasRequestModels (ApiGatewayMethodResource s) (TF.Attr s Text) where
    requestModels =
        lens (_request_models :: ApiGatewayMethodResource s -> TF.Attr s Text)
             (\s a -> s { _request_models = a } :: ApiGatewayMethodResource s)

instance P.HasRequestParameters (ApiGatewayMethodResource s) (TF.Attr s Text) where
    requestParameters =
        lens (_request_parameters :: ApiGatewayMethodResource s -> TF.Attr s Text)
             (\s a -> s { _request_parameters = a } :: ApiGatewayMethodResource s)

instance P.HasRequestValidatorId (ApiGatewayMethodResource s) (TF.Attr s Text) where
    requestValidatorId =
        lens (_request_validator_id :: ApiGatewayMethodResource s -> TF.Attr s Text)
             (\s a -> s { _request_validator_id = a } :: ApiGatewayMethodResource s)

instance P.HasResourceId (ApiGatewayMethodResource s) (TF.Attr s Text) where
    resourceId =
        lens (_resource_id :: ApiGatewayMethodResource s -> TF.Attr s Text)
             (\s a -> s { _resource_id = a } :: ApiGatewayMethodResource s)

instance P.HasRestApiId (ApiGatewayMethodResource s) (TF.Attr s Text) where
    restApiId =
        lens (_rest_api_id :: ApiGatewayMethodResource s -> TF.Attr s Text)
             (\s a -> s { _rest_api_id = a } :: ApiGatewayMethodResource s)

instance P.HasComputedApiKeyRequired (ApiGatewayMethodResource s) s (TF.Attr s Text) where
    computedApiKeyRequired =
        (_api_key_required :: ApiGatewayMethodResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAuthorization (ApiGatewayMethodResource s) s (TF.Attr s Text) where
    computedAuthorization =
        (_authorization :: ApiGatewayMethodResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAuthorizerId (ApiGatewayMethodResource s) s (TF.Attr s Text) where
    computedAuthorizerId =
        (_authorizer_id :: ApiGatewayMethodResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedHttpMethod (ApiGatewayMethodResource s) s (TF.Attr s Text) where
    computedHttpMethod =
        (_http_method :: ApiGatewayMethodResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRequestModels (ApiGatewayMethodResource s) s (TF.Attr s Text) where
    computedRequestModels =
        (_request_models :: ApiGatewayMethodResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRequestParameters (ApiGatewayMethodResource s) s (TF.Attr s Text) where
    computedRequestParameters =
        (_request_parameters :: ApiGatewayMethodResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRequestValidatorId (ApiGatewayMethodResource s) s (TF.Attr s Text) where
    computedRequestValidatorId =
        (_request_validator_id :: ApiGatewayMethodResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedResourceId (ApiGatewayMethodResource s) s (TF.Attr s Text) where
    computedResourceId =
        (_resource_id :: ApiGatewayMethodResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRestApiId (ApiGatewayMethodResource s) s (TF.Attr s Text) where
    computedRestApiId =
        (_rest_api_id :: ApiGatewayMethodResource s -> TF.Attr s Text)
            . TF.refValue

apiGatewayMethodResource :: TF.Schema TF.Resource P.AWS (ApiGatewayMethodResource s)
apiGatewayMethodResource =
    TF.newResource "aws_api_gateway_method" $
        ApiGatewayMethodResource {
              _api_key_required = TF.Nil
            , _authorization = TF.Nil
            , _authorizer_id = TF.Nil
            , _http_method = TF.Nil
            , _request_models = TF.Nil
            , _request_parameters = TF.Nil
            , _request_validator_id = TF.Nil
            , _resource_id = TF.Nil
            , _rest_api_id = TF.Nil
            }

{- | The @aws_api_gateway_method_response@ AWS resource.

Provides an HTTP Method Response for an API Gateway Resource.
-}
data ApiGatewayMethodResponseResource s = ApiGatewayMethodResponseResource {
      _http_method                 :: !(TF.Attr s Text)
    {- ^ (Required) The HTTP Method ( @GET@ , @POST@ , @PUT@ , @DELETE@ , @HEAD@ , @OPTIONS@ , @ANY@ ) -}
    , _resource_id                 :: !(TF.Attr s Text)
    {- ^ (Required) The API resource ID -}
    , _response_models             :: !(TF.Attr s Text)
    {- ^ (Optional) A map of the API models used for the response's content type -}
    , _response_parameters         :: !(TF.Attr s Text)
    {- ^ (Optional) A map of response parameters that can be sent to the caller. For example: @response_parameters = { "method.response.header.X-Some-Header" = true }@ would define that the header @X-Some-Header@ can be provided on the response. -}
    , _response_parameters_in_json :: !(TF.Attr s Text)
    {- ^ - Deprecated , use @response_parameters@ instead. -}
    , _rest_api_id                 :: !(TF.Attr s Text)
    {- ^ (Required) The ID of the associated REST API -}
    , _status_code                 :: !(TF.Attr s Text)
    {- ^ (Required) The HTTP status code -}
    } deriving (Show, Eq)

instance TF.ToHCL (ApiGatewayMethodResponseResource s) where
    toHCL ApiGatewayMethodResponseResource{..} = TF.inline $ catMaybes
        [ TF.assign "http_method" <$> TF.attribute _http_method
        , TF.assign "resource_id" <$> TF.attribute _resource_id
        , TF.assign "response_models" <$> TF.attribute _response_models
        , TF.assign "response_parameters" <$> TF.attribute _response_parameters
        , TF.assign "response_parameters_in_json" <$> TF.attribute _response_parameters_in_json
        , TF.assign "rest_api_id" <$> TF.attribute _rest_api_id
        , TF.assign "status_code" <$> TF.attribute _status_code
        ]

instance P.HasHttpMethod (ApiGatewayMethodResponseResource s) (TF.Attr s Text) where
    httpMethod =
        lens (_http_method :: ApiGatewayMethodResponseResource s -> TF.Attr s Text)
             (\s a -> s { _http_method = a } :: ApiGatewayMethodResponseResource s)

instance P.HasResourceId (ApiGatewayMethodResponseResource s) (TF.Attr s Text) where
    resourceId =
        lens (_resource_id :: ApiGatewayMethodResponseResource s -> TF.Attr s Text)
             (\s a -> s { _resource_id = a } :: ApiGatewayMethodResponseResource s)

instance P.HasResponseModels (ApiGatewayMethodResponseResource s) (TF.Attr s Text) where
    responseModels =
        lens (_response_models :: ApiGatewayMethodResponseResource s -> TF.Attr s Text)
             (\s a -> s { _response_models = a } :: ApiGatewayMethodResponseResource s)

instance P.HasResponseParameters (ApiGatewayMethodResponseResource s) (TF.Attr s Text) where
    responseParameters =
        lens (_response_parameters :: ApiGatewayMethodResponseResource s -> TF.Attr s Text)
             (\s a -> s { _response_parameters = a } :: ApiGatewayMethodResponseResource s)

instance P.HasResponseParametersInJson (ApiGatewayMethodResponseResource s) (TF.Attr s Text) where
    responseParametersInJson =
        lens (_response_parameters_in_json :: ApiGatewayMethodResponseResource s -> TF.Attr s Text)
             (\s a -> s { _response_parameters_in_json = a } :: ApiGatewayMethodResponseResource s)

instance P.HasRestApiId (ApiGatewayMethodResponseResource s) (TF.Attr s Text) where
    restApiId =
        lens (_rest_api_id :: ApiGatewayMethodResponseResource s -> TF.Attr s Text)
             (\s a -> s { _rest_api_id = a } :: ApiGatewayMethodResponseResource s)

instance P.HasStatusCode (ApiGatewayMethodResponseResource s) (TF.Attr s Text) where
    statusCode =
        lens (_status_code :: ApiGatewayMethodResponseResource s -> TF.Attr s Text)
             (\s a -> s { _status_code = a } :: ApiGatewayMethodResponseResource s)

instance P.HasComputedHttpMethod (ApiGatewayMethodResponseResource s) s (TF.Attr s Text) where
    computedHttpMethod =
        (_http_method :: ApiGatewayMethodResponseResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedResourceId (ApiGatewayMethodResponseResource s) s (TF.Attr s Text) where
    computedResourceId =
        (_resource_id :: ApiGatewayMethodResponseResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedResponseModels (ApiGatewayMethodResponseResource s) s (TF.Attr s Text) where
    computedResponseModels =
        (_response_models :: ApiGatewayMethodResponseResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedResponseParameters (ApiGatewayMethodResponseResource s) s (TF.Attr s Text) where
    computedResponseParameters =
        (_response_parameters :: ApiGatewayMethodResponseResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedResponseParametersInJson (ApiGatewayMethodResponseResource s) s (TF.Attr s Text) where
    computedResponseParametersInJson =
        (_response_parameters_in_json :: ApiGatewayMethodResponseResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRestApiId (ApiGatewayMethodResponseResource s) s (TF.Attr s Text) where
    computedRestApiId =
        (_rest_api_id :: ApiGatewayMethodResponseResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedStatusCode (ApiGatewayMethodResponseResource s) s (TF.Attr s Text) where
    computedStatusCode =
        (_status_code :: ApiGatewayMethodResponseResource s -> TF.Attr s Text)
            . TF.refValue

apiGatewayMethodResponseResource :: TF.Schema TF.Resource P.AWS (ApiGatewayMethodResponseResource s)
apiGatewayMethodResponseResource =
    TF.newResource "aws_api_gateway_method_response" $
        ApiGatewayMethodResponseResource {
              _http_method = TF.Nil
            , _resource_id = TF.Nil
            , _response_models = TF.Nil
            , _response_parameters = TF.Nil
            , _response_parameters_in_json = TF.Nil
            , _rest_api_id = TF.Nil
            , _status_code = TF.Nil
            }

{- | The @aws_api_gateway_method_settings@ AWS resource.

Provides an API Gateway Method Settings, e.g. logging or monitoring.
-}
data ApiGatewayMethodSettingsResource s = ApiGatewayMethodSettingsResource {
      _method_path :: !(TF.Attr s Text)
    {- ^ (Required) Method path defined as @{resource_path}/{http_method}@ for an individual method override, or @*/*@ for overriding all methods in the stage. -}
    , _rest_api_id :: !(TF.Attr s Text)
    {- ^ (Required) The ID of the REST API -}
    , _settings    :: !(TF.Attr s Text)
    {- ^ (Required) The settings block, see below. -}
    , _stage_name  :: !(TF.Attr s Text)
    {- ^ (Required) The name of the stage -}
    } deriving (Show, Eq)

instance TF.ToHCL (ApiGatewayMethodSettingsResource s) where
    toHCL ApiGatewayMethodSettingsResource{..} = TF.inline $ catMaybes
        [ TF.assign "method_path" <$> TF.attribute _method_path
        , TF.assign "rest_api_id" <$> TF.attribute _rest_api_id
        , TF.assign "settings" <$> TF.attribute _settings
        , TF.assign "stage_name" <$> TF.attribute _stage_name
        ]

instance P.HasMethodPath (ApiGatewayMethodSettingsResource s) (TF.Attr s Text) where
    methodPath =
        lens (_method_path :: ApiGatewayMethodSettingsResource s -> TF.Attr s Text)
             (\s a -> s { _method_path = a } :: ApiGatewayMethodSettingsResource s)

instance P.HasRestApiId (ApiGatewayMethodSettingsResource s) (TF.Attr s Text) where
    restApiId =
        lens (_rest_api_id :: ApiGatewayMethodSettingsResource s -> TF.Attr s Text)
             (\s a -> s { _rest_api_id = a } :: ApiGatewayMethodSettingsResource s)

instance P.HasSettings (ApiGatewayMethodSettingsResource s) (TF.Attr s Text) where
    settings =
        lens (_settings :: ApiGatewayMethodSettingsResource s -> TF.Attr s Text)
             (\s a -> s { _settings = a } :: ApiGatewayMethodSettingsResource s)

instance P.HasStageName (ApiGatewayMethodSettingsResource s) (TF.Attr s Text) where
    stageName =
        lens (_stage_name :: ApiGatewayMethodSettingsResource s -> TF.Attr s Text)
             (\s a -> s { _stage_name = a } :: ApiGatewayMethodSettingsResource s)

instance P.HasComputedMethodPath (ApiGatewayMethodSettingsResource s) s (TF.Attr s Text) where
    computedMethodPath =
        (_method_path :: ApiGatewayMethodSettingsResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRestApiId (ApiGatewayMethodSettingsResource s) s (TF.Attr s Text) where
    computedRestApiId =
        (_rest_api_id :: ApiGatewayMethodSettingsResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSettings (ApiGatewayMethodSettingsResource s) s (TF.Attr s Text) where
    computedSettings =
        (_settings :: ApiGatewayMethodSettingsResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedStageName (ApiGatewayMethodSettingsResource s) s (TF.Attr s Text) where
    computedStageName =
        (_stage_name :: ApiGatewayMethodSettingsResource s -> TF.Attr s Text)
            . TF.refValue

apiGatewayMethodSettingsResource :: TF.Schema TF.Resource P.AWS (ApiGatewayMethodSettingsResource s)
apiGatewayMethodSettingsResource =
    TF.newResource "aws_api_gateway_method_settings" $
        ApiGatewayMethodSettingsResource {
              _method_path = TF.Nil
            , _rest_api_id = TF.Nil
            , _settings = TF.Nil
            , _stage_name = TF.Nil
            }

{- | The @aws_api_gateway_model@ AWS resource.

Provides a Model for a API Gateway.
-}
data ApiGatewayModelResource s = ApiGatewayModelResource {
      _content_type :: !(TF.Attr s Text)
    {- ^ (Required) The content type of the model -}
    , _description  :: !(TF.Attr s Text)
    {- ^ (Optional) The description of the model -}
    , _name         :: !(TF.Attr s Text)
    {- ^ (Required) The name of the model -}
    , _rest_api_id  :: !(TF.Attr s Text)
    {- ^ (Required) The ID of the associated REST API -}
    , _schema       :: !(TF.Attr s Text)
    {- ^ (Required) The schema of the model in a JSON form -}
    } deriving (Show, Eq)

instance TF.ToHCL (ApiGatewayModelResource s) where
    toHCL ApiGatewayModelResource{..} = TF.inline $ catMaybes
        [ TF.assign "content_type" <$> TF.attribute _content_type
        , TF.assign "description" <$> TF.attribute _description
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "rest_api_id" <$> TF.attribute _rest_api_id
        , TF.assign "schema" <$> TF.attribute _schema
        ]

instance P.HasContentType (ApiGatewayModelResource s) (TF.Attr s Text) where
    contentType =
        lens (_content_type :: ApiGatewayModelResource s -> TF.Attr s Text)
             (\s a -> s { _content_type = a } :: ApiGatewayModelResource s)

instance P.HasDescription (ApiGatewayModelResource s) (TF.Attr s Text) where
    description =
        lens (_description :: ApiGatewayModelResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: ApiGatewayModelResource s)

instance P.HasName (ApiGatewayModelResource s) (TF.Attr s Text) where
    name =
        lens (_name :: ApiGatewayModelResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: ApiGatewayModelResource s)

instance P.HasRestApiId (ApiGatewayModelResource s) (TF.Attr s Text) where
    restApiId =
        lens (_rest_api_id :: ApiGatewayModelResource s -> TF.Attr s Text)
             (\s a -> s { _rest_api_id = a } :: ApiGatewayModelResource s)

instance P.HasSchema (ApiGatewayModelResource s) (TF.Attr s Text) where
    schema =
        lens (_schema :: ApiGatewayModelResource s -> TF.Attr s Text)
             (\s a -> s { _schema = a } :: ApiGatewayModelResource s)

instance P.HasComputedContentType (ApiGatewayModelResource s) s (TF.Attr s Text) where
    computedContentType =
        (_content_type :: ApiGatewayModelResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDescription (ApiGatewayModelResource s) s (TF.Attr s Text) where
    computedDescription =
        (_description :: ApiGatewayModelResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (ApiGatewayModelResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (ApiGatewayModelResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: ApiGatewayModelResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRestApiId (ApiGatewayModelResource s) s (TF.Attr s Text) where
    computedRestApiId =
        (_rest_api_id :: ApiGatewayModelResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSchema (ApiGatewayModelResource s) s (TF.Attr s Text) where
    computedSchema =
        (_schema :: ApiGatewayModelResource s -> TF.Attr s Text)
            . TF.refValue

apiGatewayModelResource :: TF.Schema TF.Resource P.AWS (ApiGatewayModelResource s)
apiGatewayModelResource =
    TF.newResource "aws_api_gateway_model" $
        ApiGatewayModelResource {
              _content_type = TF.Nil
            , _description = TF.Nil
            , _name = TF.Nil
            , _rest_api_id = TF.Nil
            , _schema = TF.Nil
            }

{- | The @aws_api_gateway_resource@ AWS resource.

Provides an API Gateway Resource.
-}
data ApiGatewayResourceResource s = ApiGatewayResourceResource {
      _parent_id   :: !(TF.Attr s Text)
    {- ^ (Required) The ID of the parent API resource -}
    , _path_part   :: !(TF.Attr s Text)
    {- ^ (Required) The last path segment of this API resource. -}
    , _rest_api_id :: !(TF.Attr s Text)
    {- ^ (Required) The ID of the associated REST API -}
    } deriving (Show, Eq)

instance TF.ToHCL (ApiGatewayResourceResource s) where
    toHCL ApiGatewayResourceResource{..} = TF.inline $ catMaybes
        [ TF.assign "parent_id" <$> TF.attribute _parent_id
        , TF.assign "path_part" <$> TF.attribute _path_part
        , TF.assign "rest_api_id" <$> TF.attribute _rest_api_id
        ]

instance P.HasParentId (ApiGatewayResourceResource s) (TF.Attr s Text) where
    parentId =
        lens (_parent_id :: ApiGatewayResourceResource s -> TF.Attr s Text)
             (\s a -> s { _parent_id = a } :: ApiGatewayResourceResource s)

instance P.HasPathPart (ApiGatewayResourceResource s) (TF.Attr s Text) where
    pathPart =
        lens (_path_part :: ApiGatewayResourceResource s -> TF.Attr s Text)
             (\s a -> s { _path_part = a } :: ApiGatewayResourceResource s)

instance P.HasRestApiId (ApiGatewayResourceResource s) (TF.Attr s Text) where
    restApiId =
        lens (_rest_api_id :: ApiGatewayResourceResource s -> TF.Attr s Text)
             (\s a -> s { _rest_api_id = a } :: ApiGatewayResourceResource s)

instance P.HasComputedId (ApiGatewayResourceResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedParentId (ApiGatewayResourceResource s) s (TF.Attr s Text) where
    computedParentId =
        (_parent_id :: ApiGatewayResourceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPath (ApiGatewayResourceResource s) s (TF.Attr s Text) where
    computedPath x = TF.compute (TF.refKey x) "path"

instance P.HasComputedPathPart (ApiGatewayResourceResource s) s (TF.Attr s Text) where
    computedPathPart =
        (_path_part :: ApiGatewayResourceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRestApiId (ApiGatewayResourceResource s) s (TF.Attr s Text) where
    computedRestApiId =
        (_rest_api_id :: ApiGatewayResourceResource s -> TF.Attr s Text)
            . TF.refValue

apiGatewayResourceResource :: TF.Schema TF.Resource P.AWS (ApiGatewayResourceResource s)
apiGatewayResourceResource =
    TF.newResource "aws_api_gateway_resource" $
        ApiGatewayResourceResource {
              _parent_id = TF.Nil
            , _path_part = TF.Nil
            , _rest_api_id = TF.Nil
            }

{- | The @aws_api_gateway_rest_api@ AWS resource.

Provides an API Gateway REST API.
-}
data ApiGatewayRestApiResource s = ApiGatewayRestApiResource {
      _binary_media_types :: !(TF.Attr s Text)
    {- ^ (Optional) The list of binary media types supported by the RestApi. By default, the RestApi supports only UTF-8-encoded text payloads. -}
    , _body               :: !(TF.Attr s Text)
    {- ^ (Optional) An OpenAPI specification that defines the set of routes and integrations to create as part of the REST API. -}
    , _description        :: !(TF.Attr s Text)
    {- ^ (Optional) The description of the REST API -}
    , _name               :: !(TF.Attr s Text)
    {- ^ (Required) The name of the REST API -}
    } deriving (Show, Eq)

instance TF.ToHCL (ApiGatewayRestApiResource s) where
    toHCL ApiGatewayRestApiResource{..} = TF.inline $ catMaybes
        [ TF.assign "binary_media_types" <$> TF.attribute _binary_media_types
        , TF.assign "body" <$> TF.attribute _body
        , TF.assign "description" <$> TF.attribute _description
        , TF.assign "name" <$> TF.attribute _name
        ]

instance P.HasBinaryMediaTypes (ApiGatewayRestApiResource s) (TF.Attr s Text) where
    binaryMediaTypes =
        lens (_binary_media_types :: ApiGatewayRestApiResource s -> TF.Attr s Text)
             (\s a -> s { _binary_media_types = a } :: ApiGatewayRestApiResource s)

instance P.HasBody (ApiGatewayRestApiResource s) (TF.Attr s Text) where
    body =
        lens (_body :: ApiGatewayRestApiResource s -> TF.Attr s Text)
             (\s a -> s { _body = a } :: ApiGatewayRestApiResource s)

instance P.HasDescription (ApiGatewayRestApiResource s) (TF.Attr s Text) where
    description =
        lens (_description :: ApiGatewayRestApiResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: ApiGatewayRestApiResource s)

instance P.HasName (ApiGatewayRestApiResource s) (TF.Attr s Text) where
    name =
        lens (_name :: ApiGatewayRestApiResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: ApiGatewayRestApiResource s)

instance P.HasComputedBinaryMediaTypes (ApiGatewayRestApiResource s) s (TF.Attr s Text) where
    computedBinaryMediaTypes =
        (_binary_media_types :: ApiGatewayRestApiResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedBody (ApiGatewayRestApiResource s) s (TF.Attr s Text) where
    computedBody =
        (_body :: ApiGatewayRestApiResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCreatedDate (ApiGatewayRestApiResource s) s (TF.Attr s Text) where
    computedCreatedDate x = TF.compute (TF.refKey x) "created_date"

instance P.HasComputedDescription (ApiGatewayRestApiResource s) s (TF.Attr s Text) where
    computedDescription =
        (_description :: ApiGatewayRestApiResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (ApiGatewayRestApiResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (ApiGatewayRestApiResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: ApiGatewayRestApiResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRootResourceId (ApiGatewayRestApiResource s) s (TF.Attr s Text) where
    computedRootResourceId x = TF.compute (TF.refKey x) "root_resource_id"

apiGatewayRestApiResource :: TF.Schema TF.Resource P.AWS (ApiGatewayRestApiResource s)
apiGatewayRestApiResource =
    TF.newResource "aws_api_gateway_rest_api" $
        ApiGatewayRestApiResource {
              _binary_media_types = TF.Nil
            , _body = TF.Nil
            , _description = TF.Nil
            , _name = TF.Nil
            }

{- | The @aws_api_gateway_stage@ AWS resource.

Provides an API Gateway Stage.
-}
data ApiGatewayStageResource s = ApiGatewayStageResource {
      _cache_cluster_enabled :: !(TF.Attr s P.Bool)
    {- ^ (Optional) Specifies whether a cache cluster is enabled for the stage -}
    , _cache_cluster_size    :: !(TF.Attr s Text)
    {- ^ (Optional) The size of the cache cluster for the stage, if enabled. Allowed values include @0.5@ , @1.6@ , @6.1@ , @13.5@ , @28.4@ , @58.2@ , @118@ and @237@ . -}
    , _client_certificate_id :: !(TF.Attr s Text)
    {- ^ (Optional) The identifier of a client certificate for the stage. -}
    , _deployment_id         :: !(TF.Attr s Text)
    {- ^ (Required) The ID of the deployment that the stage points to -}
    , _description           :: !(TF.Attr s Text)
    {- ^ (Optional) The description of the stage -}
    , _documentation_version :: !(TF.Attr s Text)
    {- ^ (Optional) The version of the associated API documentation -}
    , _rest_api_id           :: !(TF.Attr s Text)
    {- ^ (Required) The ID of the associated REST API -}
    , _stage_name            :: !(TF.Attr s Text)
    {- ^ (Required) The name of the stage -}
    , _variables             :: !(TF.Attr s Text)
    {- ^ (Optional) A map that defines the stage variables -}
    } deriving (Show, Eq)

instance TF.ToHCL (ApiGatewayStageResource s) where
    toHCL ApiGatewayStageResource{..} = TF.inline $ catMaybes
        [ TF.assign "cache_cluster_enabled" <$> TF.attribute _cache_cluster_enabled
        , TF.assign "cache_cluster_size" <$> TF.attribute _cache_cluster_size
        , TF.assign "client_certificate_id" <$> TF.attribute _client_certificate_id
        , TF.assign "deployment_id" <$> TF.attribute _deployment_id
        , TF.assign "description" <$> TF.attribute _description
        , TF.assign "documentation_version" <$> TF.attribute _documentation_version
        , TF.assign "rest_api_id" <$> TF.attribute _rest_api_id
        , TF.assign "stage_name" <$> TF.attribute _stage_name
        , TF.assign "variables" <$> TF.attribute _variables
        ]

instance P.HasCacheClusterEnabled (ApiGatewayStageResource s) (TF.Attr s P.Bool) where
    cacheClusterEnabled =
        lens (_cache_cluster_enabled :: ApiGatewayStageResource s -> TF.Attr s P.Bool)
             (\s a -> s { _cache_cluster_enabled = a } :: ApiGatewayStageResource s)

instance P.HasCacheClusterSize (ApiGatewayStageResource s) (TF.Attr s Text) where
    cacheClusterSize =
        lens (_cache_cluster_size :: ApiGatewayStageResource s -> TF.Attr s Text)
             (\s a -> s { _cache_cluster_size = a } :: ApiGatewayStageResource s)

instance P.HasClientCertificateId (ApiGatewayStageResource s) (TF.Attr s Text) where
    clientCertificateId =
        lens (_client_certificate_id :: ApiGatewayStageResource s -> TF.Attr s Text)
             (\s a -> s { _client_certificate_id = a } :: ApiGatewayStageResource s)

instance P.HasDeploymentId (ApiGatewayStageResource s) (TF.Attr s Text) where
    deploymentId =
        lens (_deployment_id :: ApiGatewayStageResource s -> TF.Attr s Text)
             (\s a -> s { _deployment_id = a } :: ApiGatewayStageResource s)

instance P.HasDescription (ApiGatewayStageResource s) (TF.Attr s Text) where
    description =
        lens (_description :: ApiGatewayStageResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: ApiGatewayStageResource s)

instance P.HasDocumentationVersion (ApiGatewayStageResource s) (TF.Attr s Text) where
    documentationVersion =
        lens (_documentation_version :: ApiGatewayStageResource s -> TF.Attr s Text)
             (\s a -> s { _documentation_version = a } :: ApiGatewayStageResource s)

instance P.HasRestApiId (ApiGatewayStageResource s) (TF.Attr s Text) where
    restApiId =
        lens (_rest_api_id :: ApiGatewayStageResource s -> TF.Attr s Text)
             (\s a -> s { _rest_api_id = a } :: ApiGatewayStageResource s)

instance P.HasStageName (ApiGatewayStageResource s) (TF.Attr s Text) where
    stageName =
        lens (_stage_name :: ApiGatewayStageResource s -> TF.Attr s Text)
             (\s a -> s { _stage_name = a } :: ApiGatewayStageResource s)

instance P.HasVariables (ApiGatewayStageResource s) (TF.Attr s Text) where
    variables =
        lens (_variables :: ApiGatewayStageResource s -> TF.Attr s Text)
             (\s a -> s { _variables = a } :: ApiGatewayStageResource s)

instance P.HasComputedCacheClusterEnabled (ApiGatewayStageResource s) s (TF.Attr s P.Bool) where
    computedCacheClusterEnabled =
        (_cache_cluster_enabled :: ApiGatewayStageResource s -> TF.Attr s P.Bool)
            . TF.refValue

instance P.HasComputedCacheClusterSize (ApiGatewayStageResource s) s (TF.Attr s Text) where
    computedCacheClusterSize =
        (_cache_cluster_size :: ApiGatewayStageResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedClientCertificateId (ApiGatewayStageResource s) s (TF.Attr s Text) where
    computedClientCertificateId =
        (_client_certificate_id :: ApiGatewayStageResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDeploymentId (ApiGatewayStageResource s) s (TF.Attr s Text) where
    computedDeploymentId =
        (_deployment_id :: ApiGatewayStageResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDescription (ApiGatewayStageResource s) s (TF.Attr s Text) where
    computedDescription =
        (_description :: ApiGatewayStageResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDocumentationVersion (ApiGatewayStageResource s) s (TF.Attr s Text) where
    computedDocumentationVersion =
        (_documentation_version :: ApiGatewayStageResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRestApiId (ApiGatewayStageResource s) s (TF.Attr s Text) where
    computedRestApiId =
        (_rest_api_id :: ApiGatewayStageResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedStageName (ApiGatewayStageResource s) s (TF.Attr s Text) where
    computedStageName =
        (_stage_name :: ApiGatewayStageResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedVariables (ApiGatewayStageResource s) s (TF.Attr s Text) where
    computedVariables =
        (_variables :: ApiGatewayStageResource s -> TF.Attr s Text)
            . TF.refValue

apiGatewayStageResource :: TF.Schema TF.Resource P.AWS (ApiGatewayStageResource s)
apiGatewayStageResource =
    TF.newResource "aws_api_gateway_stage" $
        ApiGatewayStageResource {
              _cache_cluster_enabled = TF.Nil
            , _cache_cluster_size = TF.Nil
            , _client_certificate_id = TF.Nil
            , _deployment_id = TF.Nil
            , _description = TF.Nil
            , _documentation_version = TF.Nil
            , _rest_api_id = TF.Nil
            , _stage_name = TF.Nil
            , _variables = TF.Nil
            }

{- | The @aws_api_gateway_usage_plan_key@ AWS resource.

Provides an API Gateway Usage Plan Key.
-}
data ApiGatewayUsagePlanKeyResource s = ApiGatewayUsagePlanKeyResource {
      _key_id        :: !(TF.Attr s Text)
    {- ^ (Required) The identifier of the API key resource. -}
    , _key_type      :: !(TF.Attr s Text)
    {- ^ (Required) The type of the API key resource. Currently, the valid key type is API_KEY. -}
    , _usage_plan_id :: !(TF.Attr s Text)
    {- ^ (Required) The Id of the usage plan resource representing to associate the key to. -}
    } deriving (Show, Eq)

instance TF.ToHCL (ApiGatewayUsagePlanKeyResource s) where
    toHCL ApiGatewayUsagePlanKeyResource{..} = TF.inline $ catMaybes
        [ TF.assign "key_id" <$> TF.attribute _key_id
        , TF.assign "key_type" <$> TF.attribute _key_type
        , TF.assign "usage_plan_id" <$> TF.attribute _usage_plan_id
        ]

instance P.HasKeyId (ApiGatewayUsagePlanKeyResource s) (TF.Attr s Text) where
    keyId =
        lens (_key_id :: ApiGatewayUsagePlanKeyResource s -> TF.Attr s Text)
             (\s a -> s { _key_id = a } :: ApiGatewayUsagePlanKeyResource s)

instance P.HasKeyType (ApiGatewayUsagePlanKeyResource s) (TF.Attr s Text) where
    keyType =
        lens (_key_type :: ApiGatewayUsagePlanKeyResource s -> TF.Attr s Text)
             (\s a -> s { _key_type = a } :: ApiGatewayUsagePlanKeyResource s)

instance P.HasUsagePlanId (ApiGatewayUsagePlanKeyResource s) (TF.Attr s Text) where
    usagePlanId =
        lens (_usage_plan_id :: ApiGatewayUsagePlanKeyResource s -> TF.Attr s Text)
             (\s a -> s { _usage_plan_id = a } :: ApiGatewayUsagePlanKeyResource s)

instance P.HasComputedId (ApiGatewayUsagePlanKeyResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedKeyId (ApiGatewayUsagePlanKeyResource s) s (TF.Attr s Text) where
    computedKeyId x = TF.compute (TF.refKey x) "key_id"

instance P.HasComputedKeyType (ApiGatewayUsagePlanKeyResource s) s (TF.Attr s Text) where
    computedKeyType x = TF.compute (TF.refKey x) "key_type"

instance P.HasComputedName (ApiGatewayUsagePlanKeyResource s) s (TF.Attr s Text) where
    computedName x = TF.compute (TF.refKey x) "name"

instance P.HasComputedUsagePlanId (ApiGatewayUsagePlanKeyResource s) s (TF.Attr s Text) where
    computedUsagePlanId x = TF.compute (TF.refKey x) "usage_plan_id"

instance P.HasComputedValue (ApiGatewayUsagePlanKeyResource s) s (TF.Attr s Text) where
    computedValue x = TF.compute (TF.refKey x) "value"

apiGatewayUsagePlanKeyResource :: TF.Schema TF.Resource P.AWS (ApiGatewayUsagePlanKeyResource s)
apiGatewayUsagePlanKeyResource =
    TF.newResource "aws_api_gateway_usage_plan_key" $
        ApiGatewayUsagePlanKeyResource {
              _key_id = TF.Nil
            , _key_type = TF.Nil
            , _usage_plan_id = TF.Nil
            }

{- | The @aws_api_gateway_usage_plan@ AWS resource.

Provides an API Gateway Usage Plan.
-}
data ApiGatewayUsagePlanResource s = ApiGatewayUsagePlanResource {
      _api_stages        :: !(TF.Attr s Text)
    {- ^ (Optional) The associated <#api-stages-arguments> of the usage plan. -}
    , _description       :: !(TF.Attr s Text)
    {- ^ (Required) The description of a usage plan. -}
    , _name              :: !(TF.Attr s Text)
    {- ^ (Required) The name of the usage plan. -}
    , _product_code      :: !(TF.Attr s Text)
    {- ^ (Optional) The AWS Markeplace product identifier to associate with the usage plan as a SaaS product on AWS Marketplace. -}
    , _quota_settings    :: !(TF.Attr s Text)
    {- ^ (Optional) The <#quota-settings-arguments> of the usage plan. -}
    , _throttle_settings :: !(TF.Attr s Text)
    {- ^ (Optional) The <#throttling-settings-arguments> of the usage plan. -}
    } deriving (Show, Eq)

instance TF.ToHCL (ApiGatewayUsagePlanResource s) where
    toHCL ApiGatewayUsagePlanResource{..} = TF.inline $ catMaybes
        [ TF.assign "api_stages" <$> TF.attribute _api_stages
        , TF.assign "description" <$> TF.attribute _description
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "product_code" <$> TF.attribute _product_code
        , TF.assign "quota_settings" <$> TF.attribute _quota_settings
        , TF.assign "throttle_settings" <$> TF.attribute _throttle_settings
        ]

instance P.HasApiStages (ApiGatewayUsagePlanResource s) (TF.Attr s Text) where
    apiStages =
        lens (_api_stages :: ApiGatewayUsagePlanResource s -> TF.Attr s Text)
             (\s a -> s { _api_stages = a } :: ApiGatewayUsagePlanResource s)

instance P.HasDescription (ApiGatewayUsagePlanResource s) (TF.Attr s Text) where
    description =
        lens (_description :: ApiGatewayUsagePlanResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: ApiGatewayUsagePlanResource s)

instance P.HasName (ApiGatewayUsagePlanResource s) (TF.Attr s Text) where
    name =
        lens (_name :: ApiGatewayUsagePlanResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: ApiGatewayUsagePlanResource s)

instance P.HasProductCode (ApiGatewayUsagePlanResource s) (TF.Attr s Text) where
    productCode =
        lens (_product_code :: ApiGatewayUsagePlanResource s -> TF.Attr s Text)
             (\s a -> s { _product_code = a } :: ApiGatewayUsagePlanResource s)

instance P.HasQuotaSettings (ApiGatewayUsagePlanResource s) (TF.Attr s Text) where
    quotaSettings =
        lens (_quota_settings :: ApiGatewayUsagePlanResource s -> TF.Attr s Text)
             (\s a -> s { _quota_settings = a } :: ApiGatewayUsagePlanResource s)

instance P.HasThrottleSettings (ApiGatewayUsagePlanResource s) (TF.Attr s Text) where
    throttleSettings =
        lens (_throttle_settings :: ApiGatewayUsagePlanResource s -> TF.Attr s Text)
             (\s a -> s { _throttle_settings = a } :: ApiGatewayUsagePlanResource s)

instance P.HasComputedApiStages (ApiGatewayUsagePlanResource s) s (TF.Attr s Text) where
    computedApiStages x = TF.compute (TF.refKey x) "api_stages"

instance P.HasComputedDescription (ApiGatewayUsagePlanResource s) s (TF.Attr s Text) where
    computedDescription x = TF.compute (TF.refKey x) "description"

instance P.HasComputedId (ApiGatewayUsagePlanResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (ApiGatewayUsagePlanResource s) s (TF.Attr s Text) where
    computedName x = TF.compute (TF.refKey x) "name"

instance P.HasComputedProductCode (ApiGatewayUsagePlanResource s) s (TF.Attr s Text) where
    computedProductCode x = TF.compute (TF.refKey x) "product_code"

instance P.HasComputedQuotaSettings (ApiGatewayUsagePlanResource s) s (TF.Attr s Text) where
    computedQuotaSettings x = TF.compute (TF.refKey x) "quota_settings"

instance P.HasComputedThrottleSettings (ApiGatewayUsagePlanResource s) s (TF.Attr s Text) where
    computedThrottleSettings x = TF.compute (TF.refKey x) "throttle_settings"

apiGatewayUsagePlanResource :: TF.Schema TF.Resource P.AWS (ApiGatewayUsagePlanResource s)
apiGatewayUsagePlanResource =
    TF.newResource "aws_api_gateway_usage_plan" $
        ApiGatewayUsagePlanResource {
              _api_stages = TF.Nil
            , _description = TF.Nil
            , _name = TF.Nil
            , _product_code = TF.Nil
            , _quota_settings = TF.Nil
            , _throttle_settings = TF.Nil
            }

{- | The @aws_api_gateway_vpc_link@ AWS resource.

Provides an API Gateway VPC Link.
-}
data ApiGatewayVpcLinkResource s = ApiGatewayVpcLinkResource {
      _description :: !(TF.Attr s Text)
    {- ^ (Optional) The description of the VPC link. -}
    , _name        :: !(TF.Attr s Text)
    {- ^ (Required) The name used to label and identify the VPC link. -}
    , _target_arn  :: !(TF.Attr s Text)
    {- ^ (Required, ForceNew) The ARN of a network load balancer in the VPC targeted by the VPC link. -}
    } deriving (Show, Eq)

instance TF.ToHCL (ApiGatewayVpcLinkResource s) where
    toHCL ApiGatewayVpcLinkResource{..} = TF.inline $ catMaybes
        [ TF.assign "description" <$> TF.attribute _description
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "target_arn" <$> TF.attribute _target_arn
        ]

instance P.HasDescription (ApiGatewayVpcLinkResource s) (TF.Attr s Text) where
    description =
        lens (_description :: ApiGatewayVpcLinkResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: ApiGatewayVpcLinkResource s)

instance P.HasName (ApiGatewayVpcLinkResource s) (TF.Attr s Text) where
    name =
        lens (_name :: ApiGatewayVpcLinkResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: ApiGatewayVpcLinkResource s)

instance P.HasTargetArn (ApiGatewayVpcLinkResource s) (TF.Attr s Text) where
    targetArn =
        lens (_target_arn :: ApiGatewayVpcLinkResource s -> TF.Attr s Text)
             (\s a -> s { _target_arn = a } :: ApiGatewayVpcLinkResource s)

instance P.HasComputedDescription (ApiGatewayVpcLinkResource s) s (TF.Attr s Text) where
    computedDescription =
        (_description :: ApiGatewayVpcLinkResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (ApiGatewayVpcLinkResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (ApiGatewayVpcLinkResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: ApiGatewayVpcLinkResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTargetArn (ApiGatewayVpcLinkResource s) s (TF.Attr s Text) where
    computedTargetArn =
        (_target_arn :: ApiGatewayVpcLinkResource s -> TF.Attr s Text)
            . TF.refValue

apiGatewayVpcLinkResource :: TF.Schema TF.Resource P.AWS (ApiGatewayVpcLinkResource s)
apiGatewayVpcLinkResource =
    TF.newResource "aws_api_gateway_vpc_link" $
        ApiGatewayVpcLinkResource {
              _description = TF.Nil
            , _name = TF.Nil
            , _target_arn = TF.Nil
            }

{- | The @aws_app_cookie_stickiness_policy@ AWS resource.

Provides an application cookie stickiness policy, which allows an ELB to wed
its sticky cookie's expiration to a cookie generated by your application.
-}
data AppCookieStickinessPolicyResource s = AppCookieStickinessPolicyResource {
      _cookie_name   :: !(TF.Attr s Text)
    {- ^ (Required) The application cookie whose lifetime the ELB's cookie should follow. -}
    , _lb_port       :: !(TF.Attr s P.Word16)
    {- ^ (Required) The load balancer port to which the policy should be applied. This must be an active listener on the load balancer. -}
    , _load_balancer :: !(TF.Attr s Text)
    {- ^ (Required) The name of load balancer to which the policy should be attached. -}
    , _name          :: !(TF.Attr s Text)
    {- ^ (Required) The name of the stickiness policy. -}
    } deriving (Show, Eq)

instance TF.ToHCL (AppCookieStickinessPolicyResource s) where
    toHCL AppCookieStickinessPolicyResource{..} = TF.inline $ catMaybes
        [ TF.assign "cookie_name" <$> TF.attribute _cookie_name
        , TF.assign "lb_port" <$> TF.attribute _lb_port
        , TF.assign "load_balancer" <$> TF.attribute _load_balancer
        , TF.assign "name" <$> TF.attribute _name
        ]

instance P.HasCookieName (AppCookieStickinessPolicyResource s) (TF.Attr s Text) where
    cookieName =
        lens (_cookie_name :: AppCookieStickinessPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _cookie_name = a } :: AppCookieStickinessPolicyResource s)

instance P.HasLbPort (AppCookieStickinessPolicyResource s) (TF.Attr s P.Word16) where
    lbPort =
        lens (_lb_port :: AppCookieStickinessPolicyResource s -> TF.Attr s P.Word16)
             (\s a -> s { _lb_port = a } :: AppCookieStickinessPolicyResource s)

instance P.HasLoadBalancer (AppCookieStickinessPolicyResource s) (TF.Attr s Text) where
    loadBalancer =
        lens (_load_balancer :: AppCookieStickinessPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _load_balancer = a } :: AppCookieStickinessPolicyResource s)

instance P.HasName (AppCookieStickinessPolicyResource s) (TF.Attr s Text) where
    name =
        lens (_name :: AppCookieStickinessPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: AppCookieStickinessPolicyResource s)

instance P.HasComputedCookieName (AppCookieStickinessPolicyResource s) s (TF.Attr s Text) where
    computedCookieName x = TF.compute (TF.refKey x) "cookie_name"

instance P.HasComputedId (AppCookieStickinessPolicyResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedLbPort (AppCookieStickinessPolicyResource s) s (TF.Attr s P.Word16) where
    computedLbPort x = TF.compute (TF.refKey x) "lb_port"

instance P.HasComputedLoadBalancer (AppCookieStickinessPolicyResource s) s (TF.Attr s Text) where
    computedLoadBalancer x = TF.compute (TF.refKey x) "load_balancer"

instance P.HasComputedName (AppCookieStickinessPolicyResource s) s (TF.Attr s Text) where
    computedName x = TF.compute (TF.refKey x) "name"

appCookieStickinessPolicyResource :: TF.Schema TF.Resource P.AWS (AppCookieStickinessPolicyResource s)
appCookieStickinessPolicyResource =
    TF.newResource "aws_app_cookie_stickiness_policy" $
        AppCookieStickinessPolicyResource {
              _cookie_name = TF.Nil
            , _lb_port = TF.Nil
            , _load_balancer = TF.Nil
            , _name = TF.Nil
            }

{- | The @aws_appautoscaling_policy@ AWS resource.

Provides an Application AutoScaling Policy resource.
-}
data AppautoscalingPolicyResource s = AppautoscalingPolicyResource {
      _name                                         :: !(TF.Attr s Text)
    {- ^ (Required) The name of the policy. -}
    , _policy_type                                  :: !(TF.Attr s Text)
    {- ^ (Optional) For DynamoDB, only @TargetTrackingScaling@ is supported. For any other service, only @StepScaling@ is supported. Defaults to @StepScaling@ . -}
    , _resource_id                                  :: !(TF.Attr s Text)
    {- ^ (Required) The resource type and unique identifier string for the resource associated with the scaling policy. Documentation can be found in the @ResourceId@ parameter at: <http://docs.aws.amazon.com/ApplicationAutoScaling/latest/APIReference/API_RegisterScalableTarget.html#API_RegisterScalableTarget_RequestParameters> -}
    , _scalable_dimension                           :: !(TF.Attr s Text)
    {- ^ (Required) The scalable dimension of the scalable target. Documentation can be found in the @ScalableDimension@ parameter at: <http://docs.aws.amazon.com/ApplicationAutoScaling/latest/APIReference/API_RegisterScalableTarget.html#API_RegisterScalableTarget_RequestParameters> -}
    , _service_namespace                            :: !(TF.Attr s Text)
    {- ^ (Required) The AWS service namespace of the scalable target. Documentation can be found in the @ServiceNamespace@ parameter at: <http://docs.aws.amazon.com/ApplicationAutoScaling/latest/APIReference/API_RegisterScalableTarget.html#API_RegisterScalableTarget_RequestParameters> -}
    , _step_scaling_policy_configuration            :: !(TF.Attr s Text)
    {- ^ (Optional) Step scaling policy configuration, requires @policy_type = "StepScaling"@ (default). See supported fields below. -}
    , _target_tracking_scaling_policy_configuration :: !(TF.Attr s Text)
    {- ^ (Optional) A target tracking policy, requires @policy_type = "TargetTrackingScaling"@ . See supported fields below. -}
    } deriving (Show, Eq)

instance TF.ToHCL (AppautoscalingPolicyResource s) where
    toHCL AppautoscalingPolicyResource{..} = TF.inline $ catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "policy_type" <$> TF.attribute _policy_type
        , TF.assign "resource_id" <$> TF.attribute _resource_id
        , TF.assign "scalable_dimension" <$> TF.attribute _scalable_dimension
        , TF.assign "service_namespace" <$> TF.attribute _service_namespace
        , TF.assign "step_scaling_policy_configuration" <$> TF.attribute _step_scaling_policy_configuration
        , TF.assign "target_tracking_scaling_policy_configuration" <$> TF.attribute _target_tracking_scaling_policy_configuration
        ]

instance P.HasName (AppautoscalingPolicyResource s) (TF.Attr s Text) where
    name =
        lens (_name :: AppautoscalingPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: AppautoscalingPolicyResource s)

instance P.HasPolicyType (AppautoscalingPolicyResource s) (TF.Attr s Text) where
    policyType =
        lens (_policy_type :: AppautoscalingPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _policy_type = a } :: AppautoscalingPolicyResource s)

instance P.HasResourceId (AppautoscalingPolicyResource s) (TF.Attr s Text) where
    resourceId =
        lens (_resource_id :: AppautoscalingPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _resource_id = a } :: AppautoscalingPolicyResource s)

instance P.HasScalableDimension (AppautoscalingPolicyResource s) (TF.Attr s Text) where
    scalableDimension =
        lens (_scalable_dimension :: AppautoscalingPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _scalable_dimension = a } :: AppautoscalingPolicyResource s)

instance P.HasServiceNamespace (AppautoscalingPolicyResource s) (TF.Attr s Text) where
    serviceNamespace =
        lens (_service_namespace :: AppautoscalingPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _service_namespace = a } :: AppautoscalingPolicyResource s)

instance P.HasStepScalingPolicyConfiguration (AppautoscalingPolicyResource s) (TF.Attr s Text) where
    stepScalingPolicyConfiguration =
        lens (_step_scaling_policy_configuration :: AppautoscalingPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _step_scaling_policy_configuration = a } :: AppautoscalingPolicyResource s)

instance P.HasTargetTrackingScalingPolicyConfiguration (AppautoscalingPolicyResource s) (TF.Attr s Text) where
    targetTrackingScalingPolicyConfiguration =
        lens (_target_tracking_scaling_policy_configuration :: AppautoscalingPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _target_tracking_scaling_policy_configuration = a } :: AppautoscalingPolicyResource s)

instance P.HasComputedAdjustmentType (AppautoscalingPolicyResource s) s (TF.Attr s Text) where
    computedAdjustmentType x = TF.compute (TF.refKey x) "adjustment_type"

instance P.HasComputedArn (AppautoscalingPolicyResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedName (AppautoscalingPolicyResource s) s (TF.Attr s Text) where
    computedName x = TF.compute (TF.refKey x) "name"

instance P.HasComputedPolicyType (AppautoscalingPolicyResource s) s (TF.Attr s Text) where
    computedPolicyType x = TF.compute (TF.refKey x) "policy_type"

instance P.HasComputedResourceId (AppautoscalingPolicyResource s) s (TF.Attr s Text) where
    computedResourceId =
        (_resource_id :: AppautoscalingPolicyResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedScalableDimension (AppautoscalingPolicyResource s) s (TF.Attr s Text) where
    computedScalableDimension =
        (_scalable_dimension :: AppautoscalingPolicyResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedServiceNamespace (AppautoscalingPolicyResource s) s (TF.Attr s Text) where
    computedServiceNamespace =
        (_service_namespace :: AppautoscalingPolicyResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedStepScalingPolicyConfiguration (AppautoscalingPolicyResource s) s (TF.Attr s Text) where
    computedStepScalingPolicyConfiguration =
        (_step_scaling_policy_configuration :: AppautoscalingPolicyResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTargetTrackingScalingPolicyConfiguration (AppautoscalingPolicyResource s) s (TF.Attr s Text) where
    computedTargetTrackingScalingPolicyConfiguration =
        (_target_tracking_scaling_policy_configuration :: AppautoscalingPolicyResource s -> TF.Attr s Text)
            . TF.refValue

appautoscalingPolicyResource :: TF.Schema TF.Resource P.AWS (AppautoscalingPolicyResource s)
appautoscalingPolicyResource =
    TF.newResource "aws_appautoscaling_policy" $
        AppautoscalingPolicyResource {
              _name = TF.Nil
            , _policy_type = TF.Nil
            , _resource_id = TF.Nil
            , _scalable_dimension = TF.Nil
            , _service_namespace = TF.Nil
            , _step_scaling_policy_configuration = TF.Nil
            , _target_tracking_scaling_policy_configuration = TF.Nil
            }

{- | The @aws_appautoscaling_scheduled_action@ AWS resource.

Provides an Application AutoScaling ScheduledAction resource.
-}
data AppautoscalingScheduledActionResource s = AppautoscalingScheduledActionResource {
      _end_time               :: !(TF.Attr s Text)
    {- ^ (Optional) The date and time for the scheduled action to end. Specify the following format: 2006-01-02T15:04:05Z -}
    , _name                   :: !(TF.Attr s Text)
    {- ^ (Required) The name of the scheduled action. -}
    , _resource_id            :: !(TF.Attr s Text)
    {- ^ (Required) The identifier of the resource associated with the scheduled action. Documentation can be found in the parameter at: <https://docs.aws.amazon.com/ApplicationAutoScaling/latest/APIReference/API_PutScheduledAction.html#ApplicationAutoScaling-PutScheduledAction-request-ResourceId> -}
    , _scalable_dimension     :: !(TF.Attr s Text)
    {- ^ (Optional) The scalable dimension. Documentation can be found in the parameter at: <https://docs.aws.amazon.com/ApplicationAutoScaling/latest/APIReference/API_PutScheduledAction.html#ApplicationAutoScaling-PutScheduledAction-request-ScalableDimension> Example: ecs:service:DesiredCount -}
    , _scalable_target_action :: !(TF.Attr s Text)
    {- ^ (Optional) The new minimum and maximum capacity. You can set both values or just one. See <#scalable-target-action-arguments> -}
    , _schedule               :: !(TF.Attr s Text)
    {- ^ (Optional) The schedule for this action. The following formats are supported: At expressions - at(yyyy-mm-ddThh:mm:ss), Rate expressions - rate(valueunit), Cron expressions - cron(fields). In UTC. Documentation can be found in the parameter at: <https://docs.aws.amazon.com/ApplicationAutoScaling/latest/APIReference/API_PutScheduledAction.html#ApplicationAutoScaling-PutScheduledAction-request-Schedule> -}
    , _service_namespace      :: !(TF.Attr s Text)
    {- ^ (Required) The namespace of the AWS service. Documentation can be found in the parameter at: <https://docs.aws.amazon.com/ApplicationAutoScaling/latest/APIReference/API_PutScheduledAction.html#ApplicationAutoScaling-PutScheduledAction-request-ServiceNamespace> Example: ecs -}
    , _start_time             :: !(TF.Attr s Text)
    {- ^ (Optional) The date and time for the scheduled action to start. Specify the following format: 2006-01-02T15:04:05Z -}
    } deriving (Show, Eq)

instance TF.ToHCL (AppautoscalingScheduledActionResource s) where
    toHCL AppautoscalingScheduledActionResource{..} = TF.inline $ catMaybes
        [ TF.assign "end_time" <$> TF.attribute _end_time
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "resource_id" <$> TF.attribute _resource_id
        , TF.assign "scalable_dimension" <$> TF.attribute _scalable_dimension
        , TF.assign "scalable_target_action" <$> TF.attribute _scalable_target_action
        , TF.assign "schedule" <$> TF.attribute _schedule
        , TF.assign "service_namespace" <$> TF.attribute _service_namespace
        , TF.assign "start_time" <$> TF.attribute _start_time
        ]

instance P.HasEndTime (AppautoscalingScheduledActionResource s) (TF.Attr s Text) where
    endTime =
        lens (_end_time :: AppautoscalingScheduledActionResource s -> TF.Attr s Text)
             (\s a -> s { _end_time = a } :: AppautoscalingScheduledActionResource s)

instance P.HasName (AppautoscalingScheduledActionResource s) (TF.Attr s Text) where
    name =
        lens (_name :: AppautoscalingScheduledActionResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: AppautoscalingScheduledActionResource s)

instance P.HasResourceId (AppautoscalingScheduledActionResource s) (TF.Attr s Text) where
    resourceId =
        lens (_resource_id :: AppautoscalingScheduledActionResource s -> TF.Attr s Text)
             (\s a -> s { _resource_id = a } :: AppautoscalingScheduledActionResource s)

instance P.HasScalableDimension (AppautoscalingScheduledActionResource s) (TF.Attr s Text) where
    scalableDimension =
        lens (_scalable_dimension :: AppautoscalingScheduledActionResource s -> TF.Attr s Text)
             (\s a -> s { _scalable_dimension = a } :: AppautoscalingScheduledActionResource s)

instance P.HasScalableTargetAction (AppautoscalingScheduledActionResource s) (TF.Attr s Text) where
    scalableTargetAction =
        lens (_scalable_target_action :: AppautoscalingScheduledActionResource s -> TF.Attr s Text)
             (\s a -> s { _scalable_target_action = a } :: AppautoscalingScheduledActionResource s)

instance P.HasSchedule (AppautoscalingScheduledActionResource s) (TF.Attr s Text) where
    schedule =
        lens (_schedule :: AppautoscalingScheduledActionResource s -> TF.Attr s Text)
             (\s a -> s { _schedule = a } :: AppautoscalingScheduledActionResource s)

instance P.HasServiceNamespace (AppautoscalingScheduledActionResource s) (TF.Attr s Text) where
    serviceNamespace =
        lens (_service_namespace :: AppautoscalingScheduledActionResource s -> TF.Attr s Text)
             (\s a -> s { _service_namespace = a } :: AppautoscalingScheduledActionResource s)

instance P.HasStartTime (AppautoscalingScheduledActionResource s) (TF.Attr s Text) where
    startTime =
        lens (_start_time :: AppautoscalingScheduledActionResource s -> TF.Attr s Text)
             (\s a -> s { _start_time = a } :: AppautoscalingScheduledActionResource s)

instance P.HasComputedArn (AppautoscalingScheduledActionResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedEndTime (AppautoscalingScheduledActionResource s) s (TF.Attr s Text) where
    computedEndTime =
        (_end_time :: AppautoscalingScheduledActionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (AppautoscalingScheduledActionResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: AppautoscalingScheduledActionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedResourceId (AppautoscalingScheduledActionResource s) s (TF.Attr s Text) where
    computedResourceId =
        (_resource_id :: AppautoscalingScheduledActionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedScalableDimension (AppautoscalingScheduledActionResource s) s (TF.Attr s Text) where
    computedScalableDimension =
        (_scalable_dimension :: AppautoscalingScheduledActionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedScalableTargetAction (AppautoscalingScheduledActionResource s) s (TF.Attr s Text) where
    computedScalableTargetAction =
        (_scalable_target_action :: AppautoscalingScheduledActionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSchedule (AppautoscalingScheduledActionResource s) s (TF.Attr s Text) where
    computedSchedule =
        (_schedule :: AppautoscalingScheduledActionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedServiceNamespace (AppautoscalingScheduledActionResource s) s (TF.Attr s Text) where
    computedServiceNamespace =
        (_service_namespace :: AppautoscalingScheduledActionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedStartTime (AppautoscalingScheduledActionResource s) s (TF.Attr s Text) where
    computedStartTime =
        (_start_time :: AppautoscalingScheduledActionResource s -> TF.Attr s Text)
            . TF.refValue

appautoscalingScheduledActionResource :: TF.Schema TF.Resource P.AWS (AppautoscalingScheduledActionResource s)
appautoscalingScheduledActionResource =
    TF.newResource "aws_appautoscaling_scheduled_action" $
        AppautoscalingScheduledActionResource {
              _end_time = TF.Nil
            , _name = TF.Nil
            , _resource_id = TF.Nil
            , _scalable_dimension = TF.Nil
            , _scalable_target_action = TF.Nil
            , _schedule = TF.Nil
            , _service_namespace = TF.Nil
            , _start_time = TF.Nil
            }

{- | The @aws_appautoscaling_target@ AWS resource.

Provides an Application AutoScaling ScalableTarget resource.
-}
data AppautoscalingTargetResource s = AppautoscalingTargetResource {
      _max_capacity       :: !(TF.Attr s Text)
    {- ^ (Required) The max capacity of the scalable target. -}
    , _min_capacity       :: !(TF.Attr s Text)
    {- ^ (Required) The min capacity of the scalable target. -}
    , _resource_id        :: !(TF.Attr s Text)
    {- ^ (Required) The resource type and unique identifier string for the resource associated with the scaling policy. Documentation can be found in the @ResourceId@ parameter at: <https://docs.aws.amazon.com/autoscaling/application/APIReference/API_RegisterScalableTarget.html#API_RegisterScalableTarget_RequestParameters> -}
    , _role_arn           :: !(TF.Attr s Text)
    {- ^ (Optional) The ARN of the IAM role that allows Application AutoScaling to modify your scalable target on your behalf. -}
    , _scalable_dimension :: !(TF.Attr s Text)
    {- ^ (Required) The scalable dimension of the scalable target. Documentation can be found in the @ScalableDimension@ parameter at: <https://docs.aws.amazon.com/autoscaling/application/APIReference/API_RegisterScalableTarget.html#API_RegisterScalableTarget_RequestParameters> -}
    , _service_namespace  :: !(TF.Attr s Text)
    {- ^ (Required) The AWS service namespace of the scalable target. Documentation can be found in the @ServiceNamespace@ parameter at: <https://docs.aws.amazon.com/autoscaling/application/APIReference/API_RegisterScalableTarget.html#API_RegisterScalableTarget_RequestParameters> -}
    } deriving (Show, Eq)

instance TF.ToHCL (AppautoscalingTargetResource s) where
    toHCL AppautoscalingTargetResource{..} = TF.inline $ catMaybes
        [ TF.assign "max_capacity" <$> TF.attribute _max_capacity
        , TF.assign "min_capacity" <$> TF.attribute _min_capacity
        , TF.assign "resource_id" <$> TF.attribute _resource_id
        , TF.assign "role_arn" <$> TF.attribute _role_arn
        , TF.assign "scalable_dimension" <$> TF.attribute _scalable_dimension
        , TF.assign "service_namespace" <$> TF.attribute _service_namespace
        ]

instance P.HasMaxCapacity (AppautoscalingTargetResource s) (TF.Attr s Text) where
    maxCapacity =
        lens (_max_capacity :: AppautoscalingTargetResource s -> TF.Attr s Text)
             (\s a -> s { _max_capacity = a } :: AppautoscalingTargetResource s)

instance P.HasMinCapacity (AppautoscalingTargetResource s) (TF.Attr s Text) where
    minCapacity =
        lens (_min_capacity :: AppautoscalingTargetResource s -> TF.Attr s Text)
             (\s a -> s { _min_capacity = a } :: AppautoscalingTargetResource s)

instance P.HasResourceId (AppautoscalingTargetResource s) (TF.Attr s Text) where
    resourceId =
        lens (_resource_id :: AppautoscalingTargetResource s -> TF.Attr s Text)
             (\s a -> s { _resource_id = a } :: AppautoscalingTargetResource s)

instance P.HasRoleArn (AppautoscalingTargetResource s) (TF.Attr s Text) where
    roleArn =
        lens (_role_arn :: AppautoscalingTargetResource s -> TF.Attr s Text)
             (\s a -> s { _role_arn = a } :: AppautoscalingTargetResource s)

instance P.HasScalableDimension (AppautoscalingTargetResource s) (TF.Attr s Text) where
    scalableDimension =
        lens (_scalable_dimension :: AppautoscalingTargetResource s -> TF.Attr s Text)
             (\s a -> s { _scalable_dimension = a } :: AppautoscalingTargetResource s)

instance P.HasServiceNamespace (AppautoscalingTargetResource s) (TF.Attr s Text) where
    serviceNamespace =
        lens (_service_namespace :: AppautoscalingTargetResource s -> TF.Attr s Text)
             (\s a -> s { _service_namespace = a } :: AppautoscalingTargetResource s)

instance P.HasComputedMaxCapacity (AppautoscalingTargetResource s) s (TF.Attr s Text) where
    computedMaxCapacity =
        (_max_capacity :: AppautoscalingTargetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedMinCapacity (AppautoscalingTargetResource s) s (TF.Attr s Text) where
    computedMinCapacity =
        (_min_capacity :: AppautoscalingTargetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedResourceId (AppautoscalingTargetResource s) s (TF.Attr s Text) where
    computedResourceId =
        (_resource_id :: AppautoscalingTargetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRoleArn (AppautoscalingTargetResource s) s (TF.Attr s Text) where
    computedRoleArn =
        (_role_arn :: AppautoscalingTargetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedScalableDimension (AppautoscalingTargetResource s) s (TF.Attr s Text) where
    computedScalableDimension =
        (_scalable_dimension :: AppautoscalingTargetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedServiceNamespace (AppautoscalingTargetResource s) s (TF.Attr s Text) where
    computedServiceNamespace =
        (_service_namespace :: AppautoscalingTargetResource s -> TF.Attr s Text)
            . TF.refValue

appautoscalingTargetResource :: TF.Schema TF.Resource P.AWS (AppautoscalingTargetResource s)
appautoscalingTargetResource =
    TF.newResource "aws_appautoscaling_target" $
        AppautoscalingTargetResource {
              _max_capacity = TF.Nil
            , _min_capacity = TF.Nil
            , _resource_id = TF.Nil
            , _role_arn = TF.Nil
            , _scalable_dimension = TF.Nil
            , _service_namespace = TF.Nil
            }

{- | The @aws_appsync_graphql_api@ AWS resource.

Provides an AppSync GraphQL API.
-}
data AppsyncGraphqlApiResource s = AppsyncGraphqlApiResource {
      _authentication_type :: !(TF.Attr s Text)
    {- ^ (Required) The authentication type. Valid values: @API_KEY@ , @AWS_IAM@ and @AMAZON_COGNITO_USER_POOLS@ -}
    , _name                :: !(TF.Attr s Text)
    {- ^ (Required) A user-supplied name for the GraphqlApi. -}
    , _user_pool_config    :: !(TF.Attr s Text)
    {- ^ (Optional) The Amazon Cognito User Pool configuration. See <#user_pool_config> -}
    } deriving (Show, Eq)

instance TF.ToHCL (AppsyncGraphqlApiResource s) where
    toHCL AppsyncGraphqlApiResource{..} = TF.inline $ catMaybes
        [ TF.assign "authentication_type" <$> TF.attribute _authentication_type
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "user_pool_config" <$> TF.attribute _user_pool_config
        ]

instance P.HasAuthenticationType (AppsyncGraphqlApiResource s) (TF.Attr s Text) where
    authenticationType =
        lens (_authentication_type :: AppsyncGraphqlApiResource s -> TF.Attr s Text)
             (\s a -> s { _authentication_type = a } :: AppsyncGraphqlApiResource s)

instance P.HasName (AppsyncGraphqlApiResource s) (TF.Attr s Text) where
    name =
        lens (_name :: AppsyncGraphqlApiResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: AppsyncGraphqlApiResource s)

instance P.HasUserPoolConfig (AppsyncGraphqlApiResource s) (TF.Attr s Text) where
    userPoolConfig =
        lens (_user_pool_config :: AppsyncGraphqlApiResource s -> TF.Attr s Text)
             (\s a -> s { _user_pool_config = a } :: AppsyncGraphqlApiResource s)

instance P.HasComputedArn (AppsyncGraphqlApiResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedAuthenticationType (AppsyncGraphqlApiResource s) s (TF.Attr s Text) where
    computedAuthenticationType =
        (_authentication_type :: AppsyncGraphqlApiResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (AppsyncGraphqlApiResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (AppsyncGraphqlApiResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: AppsyncGraphqlApiResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedUserPoolConfig (AppsyncGraphqlApiResource s) s (TF.Attr s Text) where
    computedUserPoolConfig =
        (_user_pool_config :: AppsyncGraphqlApiResource s -> TF.Attr s Text)
            . TF.refValue

appsyncGraphqlApiResource :: TF.Schema TF.Resource P.AWS (AppsyncGraphqlApiResource s)
appsyncGraphqlApiResource =
    TF.newResource "aws_appsync_graphql_api" $
        AppsyncGraphqlApiResource {
              _authentication_type = TF.Nil
            , _name = TF.Nil
            , _user_pool_config = TF.Nil
            }

{- | The @aws_athena_database@ AWS resource.

Provides a SSM resource data sync.
-}
data AthenaDatabaseResource s = AthenaDatabaseResource {
      _name           :: !(TF.Attr s Text)
    {- ^ (Required) Name for the configuration. -}
    , _s3_destination :: !(TF.Attr s Text)
    {- ^ (Required) Amazon S3 configuration details for the sync. -}
    } deriving (Show, Eq)

instance TF.ToHCL (AthenaDatabaseResource s) where
    toHCL AthenaDatabaseResource{..} = TF.inline $ catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "s3_destination" <$> TF.attribute _s3_destination
        ]

instance P.HasName (AthenaDatabaseResource s) (TF.Attr s Text) where
    name =
        lens (_name :: AthenaDatabaseResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: AthenaDatabaseResource s)

instance P.HasS3Destination (AthenaDatabaseResource s) (TF.Attr s Text) where
    s3Destination =
        lens (_s3_destination :: AthenaDatabaseResource s -> TF.Attr s Text)
             (\s a -> s { _s3_destination = a } :: AthenaDatabaseResource s)

instance P.HasComputedName (AthenaDatabaseResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: AthenaDatabaseResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedS3Destination (AthenaDatabaseResource s) s (TF.Attr s Text) where
    computedS3Destination =
        (_s3_destination :: AthenaDatabaseResource s -> TF.Attr s Text)
            . TF.refValue

athenaDatabaseResource :: TF.Schema TF.Resource P.AWS (AthenaDatabaseResource s)
athenaDatabaseResource =
    TF.newResource "aws_athena_database" $
        AthenaDatabaseResource {
              _name = TF.Nil
            , _s3_destination = TF.Nil
            }

{- | The @aws_athena_named_query@ AWS resource.

Provides an Athena Named Query resource.
-}
data AthenaNamedQueryResource s = AthenaNamedQueryResource {
      _database    :: !(TF.Attr s Text)
    {- ^ (Required) The database to which the query belongs. -}
    , _description :: !(TF.Attr s Text)
    {- ^ (Optional) A brief explanation of the query. Maximum length of 1024. -}
    , _name        :: !(TF.Attr s Text)
    {- ^ (Required) The plain language name for the query. Maximum length of 128. -}
    , _query       :: !(TF.Attr s Text)
    {- ^ (Required) The text of the query itself. In other words, all query statements. Maximum length of 262144. -}
    } deriving (Show, Eq)

instance TF.ToHCL (AthenaNamedQueryResource s) where
    toHCL AthenaNamedQueryResource{..} = TF.inline $ catMaybes
        [ TF.assign "database" <$> TF.attribute _database
        , TF.assign "description" <$> TF.attribute _description
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "query" <$> TF.attribute _query
        ]

instance P.HasDatabase (AthenaNamedQueryResource s) (TF.Attr s Text) where
    database =
        lens (_database :: AthenaNamedQueryResource s -> TF.Attr s Text)
             (\s a -> s { _database = a } :: AthenaNamedQueryResource s)

instance P.HasDescription (AthenaNamedQueryResource s) (TF.Attr s Text) where
    description =
        lens (_description :: AthenaNamedQueryResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: AthenaNamedQueryResource s)

instance P.HasName (AthenaNamedQueryResource s) (TF.Attr s Text) where
    name =
        lens (_name :: AthenaNamedQueryResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: AthenaNamedQueryResource s)

instance P.HasQuery (AthenaNamedQueryResource s) (TF.Attr s Text) where
    query =
        lens (_query :: AthenaNamedQueryResource s -> TF.Attr s Text)
             (\s a -> s { _query = a } :: AthenaNamedQueryResource s)

instance P.HasComputedDatabase (AthenaNamedQueryResource s) s (TF.Attr s Text) where
    computedDatabase =
        (_database :: AthenaNamedQueryResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDescription (AthenaNamedQueryResource s) s (TF.Attr s Text) where
    computedDescription =
        (_description :: AthenaNamedQueryResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (AthenaNamedQueryResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (AthenaNamedQueryResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: AthenaNamedQueryResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedQuery (AthenaNamedQueryResource s) s (TF.Attr s Text) where
    computedQuery =
        (_query :: AthenaNamedQueryResource s -> TF.Attr s Text)
            . TF.refValue

athenaNamedQueryResource :: TF.Schema TF.Resource P.AWS (AthenaNamedQueryResource s)
athenaNamedQueryResource =
    TF.newResource "aws_athena_named_query" $
        AthenaNamedQueryResource {
              _database = TF.Nil
            , _description = TF.Nil
            , _name = TF.Nil
            , _query = TF.Nil
            }

{- | The @aws_autoscaling_attachment@ AWS resource.

Provides an AutoScaling Attachment resource. ~> NOTE on AutoScaling Groups
and ASG Attachments: Terraform currently provides both a standalone ASG
Attachment resource (describing an ASG attached to an ELB), and an
<autoscaling_group.html> with @load_balancers@ defined in-line. At this time
you cannot use an ASG with in-line load balancers in conjunction with an ASG
Attachment resource. Doing so will cause a conflict and will overwrite
attachments.
-}
data AutoscalingAttachmentResource s = AutoscalingAttachmentResource {
      _alb_target_group_arn   :: !(TF.Attr s Text)
    {- ^ (Optional) The ARN of an ALB Target Group. -}
    , _autoscaling_group_name :: !(TF.Attr s Text)
    {- ^ (Required) Name of ASG to associate with the ELB. -}
    , _elb                    :: !(TF.Attr s Text)
    {- ^ (Optional) The name of the ELB. -}
    } deriving (Show, Eq)

instance TF.ToHCL (AutoscalingAttachmentResource s) where
    toHCL AutoscalingAttachmentResource{..} = TF.inline $ catMaybes
        [ TF.assign "alb_target_group_arn" <$> TF.attribute _alb_target_group_arn
        , TF.assign "autoscaling_group_name" <$> TF.attribute _autoscaling_group_name
        , TF.assign "elb" <$> TF.attribute _elb
        ]

instance P.HasAlbTargetGroupArn (AutoscalingAttachmentResource s) (TF.Attr s Text) where
    albTargetGroupArn =
        lens (_alb_target_group_arn :: AutoscalingAttachmentResource s -> TF.Attr s Text)
             (\s a -> s { _alb_target_group_arn = a } :: AutoscalingAttachmentResource s)

instance P.HasAutoscalingGroupName (AutoscalingAttachmentResource s) (TF.Attr s Text) where
    autoscalingGroupName =
        lens (_autoscaling_group_name :: AutoscalingAttachmentResource s -> TF.Attr s Text)
             (\s a -> s { _autoscaling_group_name = a } :: AutoscalingAttachmentResource s)

instance P.HasElb (AutoscalingAttachmentResource s) (TF.Attr s Text) where
    elb =
        lens (_elb :: AutoscalingAttachmentResource s -> TF.Attr s Text)
             (\s a -> s { _elb = a } :: AutoscalingAttachmentResource s)

instance P.HasComputedAlbTargetGroupArn (AutoscalingAttachmentResource s) s (TF.Attr s Text) where
    computedAlbTargetGroupArn =
        (_alb_target_group_arn :: AutoscalingAttachmentResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAutoscalingGroupName (AutoscalingAttachmentResource s) s (TF.Attr s Text) where
    computedAutoscalingGroupName =
        (_autoscaling_group_name :: AutoscalingAttachmentResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedElb (AutoscalingAttachmentResource s) s (TF.Attr s Text) where
    computedElb =
        (_elb :: AutoscalingAttachmentResource s -> TF.Attr s Text)
            . TF.refValue

autoscalingAttachmentResource :: TF.Schema TF.Resource P.AWS (AutoscalingAttachmentResource s)
autoscalingAttachmentResource =
    TF.newResource "aws_autoscaling_attachment" $
        AutoscalingAttachmentResource {
              _alb_target_group_arn = TF.Nil
            , _autoscaling_group_name = TF.Nil
            , _elb = TF.Nil
            }

{- | The @aws_autoscaling_group@ AWS resource.

Provides an AutoScaling Group resource.
-}
data AutoscalingGroupResource s = AutoscalingGroupResource {
      _availability_zones        :: !(TF.Attr s Text)
    {- ^ (Optional) A list of AZs to launch resources in. Required only if you do not specify any @vpc_zone_identifier@ -}
    , _default_cooldown          :: !(TF.Attr s Text)
    {- ^ (Optional) The amount of time, in seconds, after a scaling activity completes before another scaling activity can start. -}
    , _desired_capacity          :: !(TF.Attr s Text)
    {- ^ (Optional) The number of Amazon EC2 instances that should be running in the group. (See also <#waiting-for-capacity> below.) -}
    , _enabled_metrics           :: !(TF.Attr s P.Bool)
    {- ^ (Optional) A list of metrics to collect. The allowed values are @GroupMinSize@ , @GroupMaxSize@ , @GroupDesiredCapacity@ , @GroupInServiceInstances@ , @GroupPendingInstances@ , @GroupStandbyInstances@ , @GroupTerminatingInstances@ , @GroupTotalInstances@ . -}
    , _force_delete              :: !(TF.Attr s Text)
    {- ^ (Optional) Allows deleting the autoscaling group without waiting for all instances in the pool to terminate.  You can force an autoscaling group to delete even if it's in the process of scaling a resource. Normally, Terraform drains all the instances before deleting the group.  This bypasses that behavior and potentially leaves resources dangling. -}
    , _health_check_grace_period :: !(TF.Attr s Text)
    {- ^ (Optional, Default: 300) Time (in seconds) after instance comes into service before checking health. -}
    , _health_check_type         :: !(TF.Attr s Text)
    {- ^ (Optional) "EC2" or "ELB". Controls how health checking is done. -}
    , _initial_lifecycle_hook    :: !(TF.Attr s Text)
    {- ^ (Optional) One or more <http://docs.aws.amazon.com/autoscaling/latest/userguide/lifecycle-hooks.html> to attach to the autoscaling group before instances are launched. The syntax is exactly the same as the separate </docs/providers/aws/r/autoscaling_lifecycle_hooks.html> resource, without the @autoscaling_group_name@ attribute. Please note that this will only work when creating a new autoscaling group. For all other use-cases, please use @aws_autoscaling_lifecycle_hook@ resource. -}
    , _launch_configuration      :: !(TF.Attr s Text)
    {- ^ (Required) The name of the launch configuration to use. -}
    , _load_balancers            :: !(TF.Attr s Text)
    {- ^ (Optional) A list of elastic load balancer names to add to the autoscaling group names. Only valid for classic load balancers. For ALBs, use @target_group_arns@ instead. -}
    , _max_size                  :: !(TF.Attr s Text)
    {- ^ (Required) The maximum size of the auto scale group. -}
    , _metrics_granularity       :: !(TF.Attr s Text)
    {- ^ (Optional) The granularity to associate with the metrics to collect. The only valid value is @1Minute@ . Default is @1Minute@ . -}
    , _min_elb_capacity          :: !(TF.Attr s Text)
    {- ^ (Optional) Setting this causes Terraform to wait for this number of instances to show up healthy in the ELB only on creation. Updates will not wait on ELB instance number changes. (See also <#waiting-for-capacity> below.) -}
    , _min_size                  :: !(TF.Attr s Text)
    {- ^ (Required) The minimum size of the auto scale group. (See also <#waiting-for-capacity> below.) -}
    , _name                      :: !(TF.Attr s Text)
    {- ^ (Optional) The name of the auto scaling group. By default generated by Terraform. -}
    , _name_prefix               :: !(TF.Attr s Text)
    {- ^ (Optional) Creates a unique name beginning with the specified prefix. Conflicts with @name@ . -}
    , _placement_group           :: !(TF.Attr s Text)
    {- ^ (Optional) The name of the placement group into which you'll launch your instances, if any. -}
    , _protect_from_scale_in     :: !(TF.Attr s Text)
    {- ^ (Optional) Allows setting instance protection. The autoscaling group will not select instances with this setting for terminination during scale in events. -}
    , _suspended_processes       :: !(TF.Attr s Text)
    {- ^ (Optional) A list of processes to suspend for the AutoScaling Group. The allowed values are @Launch@ , @Terminate@ , @HealthCheck@ , @ReplaceUnhealthy@ , @AZRebalance@ , @AlarmNotification@ , @ScheduledActions@ , @AddToLoadBalancer@ . Note that if you suspend either the @Launch@ or @Terminate@ process types, it can prevent your autoscaling group from functioning properly. -}
    , _tag                       :: !(TF.Attr s Text)
    {- ^ (Optional) A list of tag blocks. Tags documented below. -}
    , _tags                      :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A list of tag blocks (maps). Tags documented below. -}
    , _target_group_arns         :: !(TF.Attr s Text)
    {- ^ (Optional) A list of @aws_alb_target_group@ ARNs, for use with Application Load Balancing. -}
    , _termination_policies      :: !(TF.Attr s Text)
    {- ^ (Optional) A list of policies to decide how the instances in the auto scale group should be terminated. The allowed values are @OldestInstance@ , @NewestInstance@ , @OldestLaunchConfiguration@ , @ClosestToNextInstanceHour@ , @Default@ . -}
    , _vpc_zone_identifier       :: !(TF.Attr s Text)
    {- ^ (Optional) A list of subnet IDs to launch resources in. -}
    , _wait_for_capacity_timeout :: !(TF.Attr s Text)
    {- ^ (Default: "10m") A maximum <https://golang.org/pkg/time/#ParseDuration> that Terraform should wait for ASG instances to be healthy before timing out.  (See also <#waiting-for-capacity> below.) Setting this to "0" causes Terraform to skip all Capacity Waiting behavior. -}
    , _wait_for_elb_capacity     :: !(TF.Attr s Text)
    {- ^ (Optional) Setting this will cause Terraform to wait for exactly this number of healthy instances in all attached load balancers on both create and update operations. (Takes precedence over @min_elb_capacity@ behavior.) (See also <#waiting-for-capacity> below.) -}
    } deriving (Show, Eq)

instance TF.ToHCL (AutoscalingGroupResource s) where
    toHCL AutoscalingGroupResource{..} = TF.inline $ catMaybes
        [ TF.assign "availability_zones" <$> TF.attribute _availability_zones
        , TF.assign "default_cooldown" <$> TF.attribute _default_cooldown
        , TF.assign "desired_capacity" <$> TF.attribute _desired_capacity
        , TF.assign "enabled_metrics" <$> TF.attribute _enabled_metrics
        , TF.assign "force_delete" <$> TF.attribute _force_delete
        , TF.assign "health_check_grace_period" <$> TF.attribute _health_check_grace_period
        , TF.assign "health_check_type" <$> TF.attribute _health_check_type
        , TF.assign "initial_lifecycle_hook" <$> TF.attribute _initial_lifecycle_hook
        , TF.assign "launch_configuration" <$> TF.attribute _launch_configuration
        , TF.assign "load_balancers" <$> TF.attribute _load_balancers
        , TF.assign "max_size" <$> TF.attribute _max_size
        , TF.assign "metrics_granularity" <$> TF.attribute _metrics_granularity
        , TF.assign "min_elb_capacity" <$> TF.attribute _min_elb_capacity
        , TF.assign "min_size" <$> TF.attribute _min_size
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "name_prefix" <$> TF.attribute _name_prefix
        , TF.assign "placement_group" <$> TF.attribute _placement_group
        , TF.assign "protect_from_scale_in" <$> TF.attribute _protect_from_scale_in
        , TF.assign "suspended_processes" <$> TF.attribute _suspended_processes
        , TF.assign "tag" <$> TF.attribute _tag
        , TF.assign "tags" <$> TF.attribute _tags
        , TF.assign "target_group_arns" <$> TF.attribute _target_group_arns
        , TF.assign "termination_policies" <$> TF.attribute _termination_policies
        , TF.assign "vpc_zone_identifier" <$> TF.attribute _vpc_zone_identifier
        , TF.assign "wait_for_capacity_timeout" <$> TF.attribute _wait_for_capacity_timeout
        , TF.assign "wait_for_elb_capacity" <$> TF.attribute _wait_for_elb_capacity
        ]

instance P.HasAvailabilityZones (AutoscalingGroupResource s) (TF.Attr s Text) where
    availabilityZones =
        lens (_availability_zones :: AutoscalingGroupResource s -> TF.Attr s Text)
             (\s a -> s { _availability_zones = a } :: AutoscalingGroupResource s)

instance P.HasDefaultCooldown (AutoscalingGroupResource s) (TF.Attr s Text) where
    defaultCooldown =
        lens (_default_cooldown :: AutoscalingGroupResource s -> TF.Attr s Text)
             (\s a -> s { _default_cooldown = a } :: AutoscalingGroupResource s)

instance P.HasDesiredCapacity (AutoscalingGroupResource s) (TF.Attr s Text) where
    desiredCapacity =
        lens (_desired_capacity :: AutoscalingGroupResource s -> TF.Attr s Text)
             (\s a -> s { _desired_capacity = a } :: AutoscalingGroupResource s)

instance P.HasEnabledMetrics (AutoscalingGroupResource s) (TF.Attr s P.Bool) where
    enabledMetrics =
        lens (_enabled_metrics :: AutoscalingGroupResource s -> TF.Attr s P.Bool)
             (\s a -> s { _enabled_metrics = a } :: AutoscalingGroupResource s)

instance P.HasForceDelete (AutoscalingGroupResource s) (TF.Attr s Text) where
    forceDelete =
        lens (_force_delete :: AutoscalingGroupResource s -> TF.Attr s Text)
             (\s a -> s { _force_delete = a } :: AutoscalingGroupResource s)

instance P.HasHealthCheckGracePeriod (AutoscalingGroupResource s) (TF.Attr s Text) where
    healthCheckGracePeriod =
        lens (_health_check_grace_period :: AutoscalingGroupResource s -> TF.Attr s Text)
             (\s a -> s { _health_check_grace_period = a } :: AutoscalingGroupResource s)

instance P.HasHealthCheckType (AutoscalingGroupResource s) (TF.Attr s Text) where
    healthCheckType =
        lens (_health_check_type :: AutoscalingGroupResource s -> TF.Attr s Text)
             (\s a -> s { _health_check_type = a } :: AutoscalingGroupResource s)

instance P.HasInitialLifecycleHook (AutoscalingGroupResource s) (TF.Attr s Text) where
    initialLifecycleHook =
        lens (_initial_lifecycle_hook :: AutoscalingGroupResource s -> TF.Attr s Text)
             (\s a -> s { _initial_lifecycle_hook = a } :: AutoscalingGroupResource s)

instance P.HasLaunchConfiguration (AutoscalingGroupResource s) (TF.Attr s Text) where
    launchConfiguration =
        lens (_launch_configuration :: AutoscalingGroupResource s -> TF.Attr s Text)
             (\s a -> s { _launch_configuration = a } :: AutoscalingGroupResource s)

instance P.HasLoadBalancers (AutoscalingGroupResource s) (TF.Attr s Text) where
    loadBalancers =
        lens (_load_balancers :: AutoscalingGroupResource s -> TF.Attr s Text)
             (\s a -> s { _load_balancers = a } :: AutoscalingGroupResource s)

instance P.HasMaxSize (AutoscalingGroupResource s) (TF.Attr s Text) where
    maxSize =
        lens (_max_size :: AutoscalingGroupResource s -> TF.Attr s Text)
             (\s a -> s { _max_size = a } :: AutoscalingGroupResource s)

instance P.HasMetricsGranularity (AutoscalingGroupResource s) (TF.Attr s Text) where
    metricsGranularity =
        lens (_metrics_granularity :: AutoscalingGroupResource s -> TF.Attr s Text)
             (\s a -> s { _metrics_granularity = a } :: AutoscalingGroupResource s)

instance P.HasMinElbCapacity (AutoscalingGroupResource s) (TF.Attr s Text) where
    minElbCapacity =
        lens (_min_elb_capacity :: AutoscalingGroupResource s -> TF.Attr s Text)
             (\s a -> s { _min_elb_capacity = a } :: AutoscalingGroupResource s)

instance P.HasMinSize (AutoscalingGroupResource s) (TF.Attr s Text) where
    minSize =
        lens (_min_size :: AutoscalingGroupResource s -> TF.Attr s Text)
             (\s a -> s { _min_size = a } :: AutoscalingGroupResource s)

instance P.HasName (AutoscalingGroupResource s) (TF.Attr s Text) where
    name =
        lens (_name :: AutoscalingGroupResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: AutoscalingGroupResource s)

instance P.HasNamePrefix (AutoscalingGroupResource s) (TF.Attr s Text) where
    namePrefix =
        lens (_name_prefix :: AutoscalingGroupResource s -> TF.Attr s Text)
             (\s a -> s { _name_prefix = a } :: AutoscalingGroupResource s)

instance P.HasPlacementGroup (AutoscalingGroupResource s) (TF.Attr s Text) where
    placementGroup =
        lens (_placement_group :: AutoscalingGroupResource s -> TF.Attr s Text)
             (\s a -> s { _placement_group = a } :: AutoscalingGroupResource s)

instance P.HasProtectFromScaleIn (AutoscalingGroupResource s) (TF.Attr s Text) where
    protectFromScaleIn =
        lens (_protect_from_scale_in :: AutoscalingGroupResource s -> TF.Attr s Text)
             (\s a -> s { _protect_from_scale_in = a } :: AutoscalingGroupResource s)

instance P.HasSuspendedProcesses (AutoscalingGroupResource s) (TF.Attr s Text) where
    suspendedProcesses =
        lens (_suspended_processes :: AutoscalingGroupResource s -> TF.Attr s Text)
             (\s a -> s { _suspended_processes = a } :: AutoscalingGroupResource s)

instance P.HasTag (AutoscalingGroupResource s) (TF.Attr s Text) where
    tag =
        lens (_tag :: AutoscalingGroupResource s -> TF.Attr s Text)
             (\s a -> s { _tag = a } :: AutoscalingGroupResource s)

instance P.HasTags (AutoscalingGroupResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: AutoscalingGroupResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: AutoscalingGroupResource s)

instance P.HasTargetGroupArns (AutoscalingGroupResource s) (TF.Attr s Text) where
    targetGroupArns =
        lens (_target_group_arns :: AutoscalingGroupResource s -> TF.Attr s Text)
             (\s a -> s { _target_group_arns = a } :: AutoscalingGroupResource s)

instance P.HasTerminationPolicies (AutoscalingGroupResource s) (TF.Attr s Text) where
    terminationPolicies =
        lens (_termination_policies :: AutoscalingGroupResource s -> TF.Attr s Text)
             (\s a -> s { _termination_policies = a } :: AutoscalingGroupResource s)

instance P.HasVpcZoneIdentifier (AutoscalingGroupResource s) (TF.Attr s Text) where
    vpcZoneIdentifier =
        lens (_vpc_zone_identifier :: AutoscalingGroupResource s -> TF.Attr s Text)
             (\s a -> s { _vpc_zone_identifier = a } :: AutoscalingGroupResource s)

instance P.HasWaitForCapacityTimeout (AutoscalingGroupResource s) (TF.Attr s Text) where
    waitForCapacityTimeout =
        lens (_wait_for_capacity_timeout :: AutoscalingGroupResource s -> TF.Attr s Text)
             (\s a -> s { _wait_for_capacity_timeout = a } :: AutoscalingGroupResource s)

instance P.HasWaitForElbCapacity (AutoscalingGroupResource s) (TF.Attr s Text) where
    waitForElbCapacity =
        lens (_wait_for_elb_capacity :: AutoscalingGroupResource s -> TF.Attr s Text)
             (\s a -> s { _wait_for_elb_capacity = a } :: AutoscalingGroupResource s)

instance P.HasComputedArn (AutoscalingGroupResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedAvailabilityZones (AutoscalingGroupResource s) s (TF.Attr s Text) where
    computedAvailabilityZones x = TF.compute (TF.refKey x) "availability_zones"

instance P.HasComputedDefaultCooldown (AutoscalingGroupResource s) s (TF.Attr s Text) where
    computedDefaultCooldown x = TF.compute (TF.refKey x) "default_cooldown"

instance P.HasComputedDesiredCapacity (AutoscalingGroupResource s) s (TF.Attr s Text) where
    computedDesiredCapacity x = TF.compute (TF.refKey x) "desired_capacity"

instance P.HasComputedEnabledMetrics (AutoscalingGroupResource s) s (TF.Attr s P.Bool) where
    computedEnabledMetrics =
        (_enabled_metrics :: AutoscalingGroupResource s -> TF.Attr s P.Bool)
            . TF.refValue

instance P.HasComputedForceDelete (AutoscalingGroupResource s) s (TF.Attr s Text) where
    computedForceDelete =
        (_force_delete :: AutoscalingGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedHealthCheckGracePeriod (AutoscalingGroupResource s) s (TF.Attr s Text) where
    computedHealthCheckGracePeriod x = TF.compute (TF.refKey x) "health_check_grace_period"

instance P.HasComputedHealthCheckType (AutoscalingGroupResource s) s (TF.Attr s Text) where
    computedHealthCheckType x = TF.compute (TF.refKey x) "health_check_type"

instance P.HasComputedId (AutoscalingGroupResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedInitialLifecycleHook (AutoscalingGroupResource s) s (TF.Attr s Text) where
    computedInitialLifecycleHook =
        (_initial_lifecycle_hook :: AutoscalingGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedLaunchConfiguration (AutoscalingGroupResource s) s (TF.Attr s Text) where
    computedLaunchConfiguration x = TF.compute (TF.refKey x) "launch_configuration"

instance P.HasComputedLoadBalancers (AutoscalingGroupResource s) s (TF.Attr s Text) where
    computedLoadBalancers x = TF.compute (TF.refKey x) "load_balancers"

instance P.HasComputedMaxSize (AutoscalingGroupResource s) s (TF.Attr s Text) where
    computedMaxSize x = TF.compute (TF.refKey x) "max_size"

instance P.HasComputedMetricsGranularity (AutoscalingGroupResource s) s (TF.Attr s Text) where
    computedMetricsGranularity =
        (_metrics_granularity :: AutoscalingGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedMinElbCapacity (AutoscalingGroupResource s) s (TF.Attr s Text) where
    computedMinElbCapacity =
        (_min_elb_capacity :: AutoscalingGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedMinSize (AutoscalingGroupResource s) s (TF.Attr s Text) where
    computedMinSize x = TF.compute (TF.refKey x) "min_size"

instance P.HasComputedName (AutoscalingGroupResource s) s (TF.Attr s Text) where
    computedName x = TF.compute (TF.refKey x) "name"

instance P.HasComputedNamePrefix (AutoscalingGroupResource s) s (TF.Attr s Text) where
    computedNamePrefix =
        (_name_prefix :: AutoscalingGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPlacementGroup (AutoscalingGroupResource s) s (TF.Attr s Text) where
    computedPlacementGroup =
        (_placement_group :: AutoscalingGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedProtectFromScaleIn (AutoscalingGroupResource s) s (TF.Attr s Text) where
    computedProtectFromScaleIn =
        (_protect_from_scale_in :: AutoscalingGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSuspendedProcesses (AutoscalingGroupResource s) s (TF.Attr s Text) where
    computedSuspendedProcesses =
        (_suspended_processes :: AutoscalingGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTag (AutoscalingGroupResource s) s (TF.Attr s Text) where
    computedTag =
        (_tag :: AutoscalingGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (AutoscalingGroupResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: AutoscalingGroupResource s -> TF.Attr s P.Tags)
            . TF.refValue

instance P.HasComputedTargetGroupArns (AutoscalingGroupResource s) s (TF.Attr s Text) where
    computedTargetGroupArns x = TF.compute (TF.refKey x) "target_group_arns"

instance P.HasComputedTerminationPolicies (AutoscalingGroupResource s) s (TF.Attr s Text) where
    computedTerminationPolicies =
        (_termination_policies :: AutoscalingGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedVpcZoneIdentifier (AutoscalingGroupResource s) s (TF.Attr s Text) where
    computedVpcZoneIdentifier x = TF.compute (TF.refKey x) "vpc_zone_identifier"

instance P.HasComputedWaitForCapacityTimeout (AutoscalingGroupResource s) s (TF.Attr s Text) where
    computedWaitForCapacityTimeout =
        (_wait_for_capacity_timeout :: AutoscalingGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedWaitForElbCapacity (AutoscalingGroupResource s) s (TF.Attr s Text) where
    computedWaitForElbCapacity =
        (_wait_for_elb_capacity :: AutoscalingGroupResource s -> TF.Attr s Text)
            . TF.refValue

autoscalingGroupResource :: TF.Schema TF.Resource P.AWS (AutoscalingGroupResource s)
autoscalingGroupResource =
    TF.newResource "aws_autoscaling_group" $
        AutoscalingGroupResource {
              _availability_zones = TF.Nil
            , _default_cooldown = TF.Nil
            , _desired_capacity = TF.Nil
            , _enabled_metrics = TF.Nil
            , _force_delete = TF.Nil
            , _health_check_grace_period = TF.Nil
            , _health_check_type = TF.Nil
            , _initial_lifecycle_hook = TF.Nil
            , _launch_configuration = TF.Nil
            , _load_balancers = TF.Nil
            , _max_size = TF.Nil
            , _metrics_granularity = TF.Nil
            , _min_elb_capacity = TF.Nil
            , _min_size = TF.Nil
            , _name = TF.Nil
            , _name_prefix = TF.Nil
            , _placement_group = TF.Nil
            , _protect_from_scale_in = TF.Nil
            , _suspended_processes = TF.Nil
            , _tag = TF.Nil
            , _tags = TF.Nil
            , _target_group_arns = TF.Nil
            , _termination_policies = TF.Nil
            , _vpc_zone_identifier = TF.Nil
            , _wait_for_capacity_timeout = TF.Nil
            , _wait_for_elb_capacity = TF.Nil
            }

{- | The @aws_autoscaling_lifecycle_hook@ AWS resource.

Provides an AutoScaling Lifecycle Hook resource. ~> NOTE: Terraform has two
types of ways you can add lifecycle hooks - via the @initial_lifecycle_hook@
attribute from the </docs/providers/aws/r/autoscaling_group.html> resource,
or via this one. Hooks added via this resource will not be added until the
autoscaling group has been created, and depending on your
</docs/providers/aws/r/autoscaling_group.html#waiting-for-capacity>
settings, after the initial instances have been launched, creating
unintended behavior. If you need hooks to run on all instances, add them
with @initial_lifecycle_hook@ in
</docs/providers/aws/r/autoscaling_group.html> , but take care to not
duplicate those hooks with this resource.
-}
data AutoscalingLifecycleHookResource s = AutoscalingLifecycleHookResource {
      _autoscaling_group_name  :: !(TF.Attr s Text)
    {- ^ (Required) The name of the Auto Scaling group to which you want to assign the lifecycle hook -}
    , _default_result          :: !(TF.Attr s Text)
    {- ^ (Optional) Defines the action the Auto Scaling group should take when the lifecycle hook timeout elapses or if an unexpected failure occurs. The value for this parameter can be either CONTINUE or ABANDON. The default value for this parameter is ABANDON. -}
    , _heartbeat_timeout       :: !(TF.Attr s Text)
    {- ^ (Optional) Defines the amount of time, in seconds, that can elapse before the lifecycle hook times out. When the lifecycle hook times out, Auto Scaling performs the action defined in the DefaultResult parameter -}
    , _lifecycle_transition    :: !(TF.Attr s Text)
    {- ^ (Required) The instance state to which you want to attach the lifecycle hook. For a list of lifecycle hook types, see <https://docs.aws.amazon.com/cli/latest/reference/autoscaling/describe-lifecycle-hook-types.html#examples> -}
    , _name                    :: !(TF.Attr s Text)
    {- ^ (Required) The name of the lifecycle hook. -}
    , _notification_metadata   :: !(TF.Attr s Text)
    {- ^ (Optional) Contains additional information that you want to include any time Auto Scaling sends a message to the notification target. -}
    , _notification_target_arn :: !(TF.Attr s Text)
    {- ^ (Optional) The ARN of the notification target that Auto Scaling will use to notify you when an instance is in the transition state for the lifecycle hook. This ARN target can be either an SQS queue or an SNS topic. -}
    , _role_arn                :: !(TF.Attr s Text)
    {- ^ (Optional) The ARN of the IAM role that allows the Auto Scaling group to publish to the specified notification target. -}
    } deriving (Show, Eq)

instance TF.ToHCL (AutoscalingLifecycleHookResource s) where
    toHCL AutoscalingLifecycleHookResource{..} = TF.inline $ catMaybes
        [ TF.assign "autoscaling_group_name" <$> TF.attribute _autoscaling_group_name
        , TF.assign "default_result" <$> TF.attribute _default_result
        , TF.assign "heartbeat_timeout" <$> TF.attribute _heartbeat_timeout
        , TF.assign "lifecycle_transition" <$> TF.attribute _lifecycle_transition
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "notification_metadata" <$> TF.attribute _notification_metadata
        , TF.assign "notification_target_arn" <$> TF.attribute _notification_target_arn
        , TF.assign "role_arn" <$> TF.attribute _role_arn
        ]

instance P.HasAutoscalingGroupName (AutoscalingLifecycleHookResource s) (TF.Attr s Text) where
    autoscalingGroupName =
        lens (_autoscaling_group_name :: AutoscalingLifecycleHookResource s -> TF.Attr s Text)
             (\s a -> s { _autoscaling_group_name = a } :: AutoscalingLifecycleHookResource s)

instance P.HasDefaultResult (AutoscalingLifecycleHookResource s) (TF.Attr s Text) where
    defaultResult =
        lens (_default_result :: AutoscalingLifecycleHookResource s -> TF.Attr s Text)
             (\s a -> s { _default_result = a } :: AutoscalingLifecycleHookResource s)

instance P.HasHeartbeatTimeout (AutoscalingLifecycleHookResource s) (TF.Attr s Text) where
    heartbeatTimeout =
        lens (_heartbeat_timeout :: AutoscalingLifecycleHookResource s -> TF.Attr s Text)
             (\s a -> s { _heartbeat_timeout = a } :: AutoscalingLifecycleHookResource s)

instance P.HasLifecycleTransition (AutoscalingLifecycleHookResource s) (TF.Attr s Text) where
    lifecycleTransition =
        lens (_lifecycle_transition :: AutoscalingLifecycleHookResource s -> TF.Attr s Text)
             (\s a -> s { _lifecycle_transition = a } :: AutoscalingLifecycleHookResource s)

instance P.HasName (AutoscalingLifecycleHookResource s) (TF.Attr s Text) where
    name =
        lens (_name :: AutoscalingLifecycleHookResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: AutoscalingLifecycleHookResource s)

instance P.HasNotificationMetadata (AutoscalingLifecycleHookResource s) (TF.Attr s Text) where
    notificationMetadata =
        lens (_notification_metadata :: AutoscalingLifecycleHookResource s -> TF.Attr s Text)
             (\s a -> s { _notification_metadata = a } :: AutoscalingLifecycleHookResource s)

instance P.HasNotificationTargetArn (AutoscalingLifecycleHookResource s) (TF.Attr s Text) where
    notificationTargetArn =
        lens (_notification_target_arn :: AutoscalingLifecycleHookResource s -> TF.Attr s Text)
             (\s a -> s { _notification_target_arn = a } :: AutoscalingLifecycleHookResource s)

instance P.HasRoleArn (AutoscalingLifecycleHookResource s) (TF.Attr s Text) where
    roleArn =
        lens (_role_arn :: AutoscalingLifecycleHookResource s -> TF.Attr s Text)
             (\s a -> s { _role_arn = a } :: AutoscalingLifecycleHookResource s)

instance P.HasComputedAutoscalingGroupName (AutoscalingLifecycleHookResource s) s (TF.Attr s Text) where
    computedAutoscalingGroupName =
        (_autoscaling_group_name :: AutoscalingLifecycleHookResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDefaultResult (AutoscalingLifecycleHookResource s) s (TF.Attr s Text) where
    computedDefaultResult =
        (_default_result :: AutoscalingLifecycleHookResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedHeartbeatTimeout (AutoscalingLifecycleHookResource s) s (TF.Attr s Text) where
    computedHeartbeatTimeout =
        (_heartbeat_timeout :: AutoscalingLifecycleHookResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedLifecycleTransition (AutoscalingLifecycleHookResource s) s (TF.Attr s Text) where
    computedLifecycleTransition =
        (_lifecycle_transition :: AutoscalingLifecycleHookResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (AutoscalingLifecycleHookResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: AutoscalingLifecycleHookResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedNotificationMetadata (AutoscalingLifecycleHookResource s) s (TF.Attr s Text) where
    computedNotificationMetadata =
        (_notification_metadata :: AutoscalingLifecycleHookResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedNotificationTargetArn (AutoscalingLifecycleHookResource s) s (TF.Attr s Text) where
    computedNotificationTargetArn =
        (_notification_target_arn :: AutoscalingLifecycleHookResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRoleArn (AutoscalingLifecycleHookResource s) s (TF.Attr s Text) where
    computedRoleArn =
        (_role_arn :: AutoscalingLifecycleHookResource s -> TF.Attr s Text)
            . TF.refValue

autoscalingLifecycleHookResource :: TF.Schema TF.Resource P.AWS (AutoscalingLifecycleHookResource s)
autoscalingLifecycleHookResource =
    TF.newResource "aws_autoscaling_lifecycle_hook" $
        AutoscalingLifecycleHookResource {
              _autoscaling_group_name = TF.Nil
            , _default_result = TF.Nil
            , _heartbeat_timeout = TF.Nil
            , _lifecycle_transition = TF.Nil
            , _name = TF.Nil
            , _notification_metadata = TF.Nil
            , _notification_target_arn = TF.Nil
            , _role_arn = TF.Nil
            }

{- | The @aws_autoscaling_notification@ AWS resource.

Provides an AutoScaling Group with Notification support, via SNS Topics.
Each of the @notifications@ map to a
<https://docs.aws.amazon.com/AutoScaling/latest/APIReference/API_DescribeNotificationConfigurations.html>
inside Amazon Web Services, and are applied to each AutoScaling Group you
supply.
-}
data AutoscalingNotificationResource s = AutoscalingNotificationResource {
      _group_names   :: !(TF.Attr s Text)
    {- ^ (Required) A list of AutoScaling Group Names -}
    , _notifications :: !(TF.Attr s Text)
    {- ^ (Required) A list of Notification Types that trigger notifications. Acceptable values are documented <https://docs.aws.amazon.com/AutoScaling/latest/APIReference/API_NotificationConfiguration.html> -}
    , _topic_arn     :: !(TF.Attr s Text)
    {- ^ (Required) The Topic ARN for notifications to be sent through -}
    } deriving (Show, Eq)

instance TF.ToHCL (AutoscalingNotificationResource s) where
    toHCL AutoscalingNotificationResource{..} = TF.inline $ catMaybes
        [ TF.assign "group_names" <$> TF.attribute _group_names
        , TF.assign "notifications" <$> TF.attribute _notifications
        , TF.assign "topic_arn" <$> TF.attribute _topic_arn
        ]

instance P.HasGroupNames (AutoscalingNotificationResource s) (TF.Attr s Text) where
    groupNames =
        lens (_group_names :: AutoscalingNotificationResource s -> TF.Attr s Text)
             (\s a -> s { _group_names = a } :: AutoscalingNotificationResource s)

instance P.HasNotifications (AutoscalingNotificationResource s) (TF.Attr s Text) where
    notifications =
        lens (_notifications :: AutoscalingNotificationResource s -> TF.Attr s Text)
             (\s a -> s { _notifications = a } :: AutoscalingNotificationResource s)

instance P.HasTopicArn (AutoscalingNotificationResource s) (TF.Attr s Text) where
    topicArn =
        lens (_topic_arn :: AutoscalingNotificationResource s -> TF.Attr s Text)
             (\s a -> s { _topic_arn = a } :: AutoscalingNotificationResource s)

instance P.HasComputedGroupNames (AutoscalingNotificationResource s) s (TF.Attr s Text) where
    computedGroupNames =
        (_group_names :: AutoscalingNotificationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedNotifications (AutoscalingNotificationResource s) s (TF.Attr s Text) where
    computedNotifications =
        (_notifications :: AutoscalingNotificationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTopicArn (AutoscalingNotificationResource s) s (TF.Attr s Text) where
    computedTopicArn =
        (_topic_arn :: AutoscalingNotificationResource s -> TF.Attr s Text)
            . TF.refValue

autoscalingNotificationResource :: TF.Schema TF.Resource P.AWS (AutoscalingNotificationResource s)
autoscalingNotificationResource =
    TF.newResource "aws_autoscaling_notification" $
        AutoscalingNotificationResource {
              _group_names = TF.Nil
            , _notifications = TF.Nil
            , _topic_arn = TF.Nil
            }

{- | The @aws_autoscaling_policy@ AWS resource.

Provides an AutoScaling Scaling Policy resource. ~> NOTE: You may want to
omit @desired_capacity@ attribute from attached @aws_autoscaling_group@ when
using autoscaling policies. It's good practice to pick either
<https://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/as-manual-scaling.html>
or
<https://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/as-scale-based-on-demand.html>
(policy-based) scaling.
-}
data AutoscalingPolicyResource s = AutoscalingPolicyResource {
      _adjustment_type        :: !(TF.Attr s Text)
    {- ^ (Optional) Specifies whether the adjustment is an absolute number or a percentage of the current capacity. Valid values are @ChangeInCapacity@ , @ExactCapacity@ , and @PercentChangeInCapacity@ . -}
    , _autoscaling_group_name :: !(TF.Attr s Text)
    {- ^ (Required) The name of the autoscaling group. -}
    , _name                   :: !(TF.Attr s Text)
    {- ^ (Required) The name of the policy. -}
    , _policy_type            :: !(TF.Attr s Text)
    {- ^ (Optional) The policy type, either "SimpleScaling", "StepScaling" or "TargetTrackingScaling". If this value isn't provided, AWS will default to "SimpleScaling." -}
    } deriving (Show, Eq)

instance TF.ToHCL (AutoscalingPolicyResource s) where
    toHCL AutoscalingPolicyResource{..} = TF.inline $ catMaybes
        [ TF.assign "adjustment_type" <$> TF.attribute _adjustment_type
        , TF.assign "autoscaling_group_name" <$> TF.attribute _autoscaling_group_name
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "policy_type" <$> TF.attribute _policy_type
        ]

instance P.HasAdjustmentType (AutoscalingPolicyResource s) (TF.Attr s Text) where
    adjustmentType =
        lens (_adjustment_type :: AutoscalingPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _adjustment_type = a } :: AutoscalingPolicyResource s)

instance P.HasAutoscalingGroupName (AutoscalingPolicyResource s) (TF.Attr s Text) where
    autoscalingGroupName =
        lens (_autoscaling_group_name :: AutoscalingPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _autoscaling_group_name = a } :: AutoscalingPolicyResource s)

instance P.HasName (AutoscalingPolicyResource s) (TF.Attr s Text) where
    name =
        lens (_name :: AutoscalingPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: AutoscalingPolicyResource s)

instance P.HasPolicyType (AutoscalingPolicyResource s) (TF.Attr s Text) where
    policyType =
        lens (_policy_type :: AutoscalingPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _policy_type = a } :: AutoscalingPolicyResource s)

instance P.HasComputedAdjustmentType (AutoscalingPolicyResource s) s (TF.Attr s Text) where
    computedAdjustmentType x = TF.compute (TF.refKey x) "adjustment_type"

instance P.HasComputedArn (AutoscalingPolicyResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedAutoscalingGroupName (AutoscalingPolicyResource s) s (TF.Attr s Text) where
    computedAutoscalingGroupName x = TF.compute (TF.refKey x) "autoscaling_group_name"

instance P.HasComputedName (AutoscalingPolicyResource s) s (TF.Attr s Text) where
    computedName x = TF.compute (TF.refKey x) "name"

instance P.HasComputedPolicyType (AutoscalingPolicyResource s) s (TF.Attr s Text) where
    computedPolicyType x = TF.compute (TF.refKey x) "policy_type"

autoscalingPolicyResource :: TF.Schema TF.Resource P.AWS (AutoscalingPolicyResource s)
autoscalingPolicyResource =
    TF.newResource "aws_autoscaling_policy" $
        AutoscalingPolicyResource {
              _adjustment_type = TF.Nil
            , _autoscaling_group_name = TF.Nil
            , _name = TF.Nil
            , _policy_type = TF.Nil
            }

{- | The @aws_autoscaling_schedule@ AWS resource.

Provides an AutoScaling Schedule resource.
-}
data AutoscalingScheduleResource s = AutoscalingScheduleResource {
      _autoscaling_group_name :: !(TF.Attr s Text)
    {- ^ (Required) The name or Amazon Resource Name (ARN) of the Auto Scaling group. -}
    , _desired_capacity       :: !(TF.Attr s Text)
    {- ^ (Optional) The number of EC2 instances that should be running in the group. Default 0.  Set to -1 if you don't want to change the desired capacity at the scheduled time. -}
    , _end_time               :: !(TF.Attr s Text)
    {- ^ (Optional) The time for this action to end, in "YYYY-MM-DDThh:mm:ssZ" format in UTC/GMT only (for example, 2014-06-01T00:00:00Z ). If you try to schedule your action in the past, Auto Scaling returns an error message. -}
    , _max_size               :: !(TF.Attr s Text)
    {- ^ (Optional) The maximum size for the Auto Scaling group. Default 0. Set to -1 if you don't want to change the maximum size at the scheduled time. -}
    , _min_size               :: !(TF.Attr s Text)
    {- ^ (Optional) The minimum size for the Auto Scaling group. Default 0. Set to -1 if you don't want to change the minimum size at the scheduled time. -}
    , _recurrence             :: !(TF.Attr s Text)
    {- ^ (Optional) The time when recurring future actions will start. Start time is specified by the user following the Unix cron syntax format. -}
    , _scheduled_action_name  :: !(TF.Attr s Text)
    {- ^ (Required) The name of this scaling action. -}
    , _start_time             :: !(TF.Attr s Text)
    {- ^ (Optional) The time for this action to start, in "YYYY-MM-DDThh:mm:ssZ" format in UTC/GMT only (for example, 2014-06-01T00:00:00Z ). If you try to schedule your action in the past, Auto Scaling returns an error message. -}
    } deriving (Show, Eq)

instance TF.ToHCL (AutoscalingScheduleResource s) where
    toHCL AutoscalingScheduleResource{..} = TF.inline $ catMaybes
        [ TF.assign "autoscaling_group_name" <$> TF.attribute _autoscaling_group_name
        , TF.assign "desired_capacity" <$> TF.attribute _desired_capacity
        , TF.assign "end_time" <$> TF.attribute _end_time
        , TF.assign "max_size" <$> TF.attribute _max_size
        , TF.assign "min_size" <$> TF.attribute _min_size
        , TF.assign "recurrence" <$> TF.attribute _recurrence
        , TF.assign "scheduled_action_name" <$> TF.attribute _scheduled_action_name
        , TF.assign "start_time" <$> TF.attribute _start_time
        ]

instance P.HasAutoscalingGroupName (AutoscalingScheduleResource s) (TF.Attr s Text) where
    autoscalingGroupName =
        lens (_autoscaling_group_name :: AutoscalingScheduleResource s -> TF.Attr s Text)
             (\s a -> s { _autoscaling_group_name = a } :: AutoscalingScheduleResource s)

instance P.HasDesiredCapacity (AutoscalingScheduleResource s) (TF.Attr s Text) where
    desiredCapacity =
        lens (_desired_capacity :: AutoscalingScheduleResource s -> TF.Attr s Text)
             (\s a -> s { _desired_capacity = a } :: AutoscalingScheduleResource s)

instance P.HasEndTime (AutoscalingScheduleResource s) (TF.Attr s Text) where
    endTime =
        lens (_end_time :: AutoscalingScheduleResource s -> TF.Attr s Text)
             (\s a -> s { _end_time = a } :: AutoscalingScheduleResource s)

instance P.HasMaxSize (AutoscalingScheduleResource s) (TF.Attr s Text) where
    maxSize =
        lens (_max_size :: AutoscalingScheduleResource s -> TF.Attr s Text)
             (\s a -> s { _max_size = a } :: AutoscalingScheduleResource s)

instance P.HasMinSize (AutoscalingScheduleResource s) (TF.Attr s Text) where
    minSize =
        lens (_min_size :: AutoscalingScheduleResource s -> TF.Attr s Text)
             (\s a -> s { _min_size = a } :: AutoscalingScheduleResource s)

instance P.HasRecurrence (AutoscalingScheduleResource s) (TF.Attr s Text) where
    recurrence =
        lens (_recurrence :: AutoscalingScheduleResource s -> TF.Attr s Text)
             (\s a -> s { _recurrence = a } :: AutoscalingScheduleResource s)

instance P.HasScheduledActionName (AutoscalingScheduleResource s) (TF.Attr s Text) where
    scheduledActionName =
        lens (_scheduled_action_name :: AutoscalingScheduleResource s -> TF.Attr s Text)
             (\s a -> s { _scheduled_action_name = a } :: AutoscalingScheduleResource s)

instance P.HasStartTime (AutoscalingScheduleResource s) (TF.Attr s Text) where
    startTime =
        lens (_start_time :: AutoscalingScheduleResource s -> TF.Attr s Text)
             (\s a -> s { _start_time = a } :: AutoscalingScheduleResource s)

instance P.HasComputedArn (AutoscalingScheduleResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedAutoscalingGroupName (AutoscalingScheduleResource s) s (TF.Attr s Text) where
    computedAutoscalingGroupName =
        (_autoscaling_group_name :: AutoscalingScheduleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDesiredCapacity (AutoscalingScheduleResource s) s (TF.Attr s Text) where
    computedDesiredCapacity =
        (_desired_capacity :: AutoscalingScheduleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEndTime (AutoscalingScheduleResource s) s (TF.Attr s Text) where
    computedEndTime =
        (_end_time :: AutoscalingScheduleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedMaxSize (AutoscalingScheduleResource s) s (TF.Attr s Text) where
    computedMaxSize =
        (_max_size :: AutoscalingScheduleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedMinSize (AutoscalingScheduleResource s) s (TF.Attr s Text) where
    computedMinSize =
        (_min_size :: AutoscalingScheduleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRecurrence (AutoscalingScheduleResource s) s (TF.Attr s Text) where
    computedRecurrence =
        (_recurrence :: AutoscalingScheduleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedScheduledActionName (AutoscalingScheduleResource s) s (TF.Attr s Text) where
    computedScheduledActionName =
        (_scheduled_action_name :: AutoscalingScheduleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedStartTime (AutoscalingScheduleResource s) s (TF.Attr s Text) where
    computedStartTime =
        (_start_time :: AutoscalingScheduleResource s -> TF.Attr s Text)
            . TF.refValue

autoscalingScheduleResource :: TF.Schema TF.Resource P.AWS (AutoscalingScheduleResource s)
autoscalingScheduleResource =
    TF.newResource "aws_autoscaling_schedule" $
        AutoscalingScheduleResource {
              _autoscaling_group_name = TF.Nil
            , _desired_capacity = TF.Nil
            , _end_time = TF.Nil
            , _max_size = TF.Nil
            , _min_size = TF.Nil
            , _recurrence = TF.Nil
            , _scheduled_action_name = TF.Nil
            , _start_time = TF.Nil
            }

{- | The @aws_batch_compute_environment@ AWS resource.

Creates a AWS Batch compute environment. Compute environments contain the
Amazon ECS container instances that are used to run containerized batch
jobs. For information about AWS Batch, see
<http://docs.aws.amazon.com/batch/latest/userguide/what-is-batch.html> . For
information about compute environment, see
<http://docs.aws.amazon.com/batch/latest/userguide/compute_environments.html>
. ~> Note: To prevent a race condition during environment deletion, make
sure to set @depends_on@ to the related @aws_iam_role_policy_attachment@ ;
otherwise, the policy may be destroyed too soon and the compute environment
will then get stuck in the @DELETING@ state, see
<http://docs.aws.amazon.com/batch/latest/userguide/troubleshooting.html> .
-}
data BatchComputeEnvironmentResource s = BatchComputeEnvironmentResource {
      _compute_environment_name :: !(TF.Attr s Text)
    {- ^ (Required) The name for your compute environment. Up to 128 letters (uppercase and lowercase), numbers, and underscores are allowed. -}
    , _compute_resources        :: !(TF.Attr s Text)
    {- ^ (Optional) Details of the compute resources managed by the compute environment. This parameter is required for managed compute environments. See details below. -}
    , _service_role             :: !(TF.Attr s Text)
    {- ^ (Required) The full Amazon Resource Name (ARN) of the IAM role that allows AWS Batch to make calls to other AWS services on your behalf. -}
    , _state                    :: !(TF.Attr s Text)
    {- ^ (Optional) The state of the compute environment. If the state is @ENABLED@ , then the compute environment accepts jobs from a queue and can scale out automatically based on queues. Valid items are @ENABLED@ or @DISABLED@ . Defaults to @ENABLED@ . -}
    , _type'                    :: !(TF.Attr s Text)
    {- ^ (Required) The type of the compute environment. Valid items are @MANAGED@ or @UNMANAGED@ . -}
    } deriving (Show, Eq)

instance TF.ToHCL (BatchComputeEnvironmentResource s) where
    toHCL BatchComputeEnvironmentResource{..} = TF.inline $ catMaybes
        [ TF.assign "compute_environment_name" <$> TF.attribute _compute_environment_name
        , TF.assign "compute_resources" <$> TF.attribute _compute_resources
        , TF.assign "service_role" <$> TF.attribute _service_role
        , TF.assign "state" <$> TF.attribute _state
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance P.HasComputeEnvironmentName (BatchComputeEnvironmentResource s) (TF.Attr s Text) where
    computeEnvironmentName =
        lens (_compute_environment_name :: BatchComputeEnvironmentResource s -> TF.Attr s Text)
             (\s a -> s { _compute_environment_name = a } :: BatchComputeEnvironmentResource s)

instance P.HasComputeResources (BatchComputeEnvironmentResource s) (TF.Attr s Text) where
    computeResources =
        lens (_compute_resources :: BatchComputeEnvironmentResource s -> TF.Attr s Text)
             (\s a -> s { _compute_resources = a } :: BatchComputeEnvironmentResource s)

instance P.HasServiceRole (BatchComputeEnvironmentResource s) (TF.Attr s Text) where
    serviceRole =
        lens (_service_role :: BatchComputeEnvironmentResource s -> TF.Attr s Text)
             (\s a -> s { _service_role = a } :: BatchComputeEnvironmentResource s)

instance P.HasState (BatchComputeEnvironmentResource s) (TF.Attr s Text) where
    state =
        lens (_state :: BatchComputeEnvironmentResource s -> TF.Attr s Text)
             (\s a -> s { _state = a } :: BatchComputeEnvironmentResource s)

instance P.HasType' (BatchComputeEnvironmentResource s) (TF.Attr s Text) where
    type' =
        lens (_type' :: BatchComputeEnvironmentResource s -> TF.Attr s Text)
             (\s a -> s { _type' = a } :: BatchComputeEnvironmentResource s)

instance P.HasComputedArn (BatchComputeEnvironmentResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedComputeEnvironmentName (BatchComputeEnvironmentResource s) s (TF.Attr s Text) where
    computedComputeEnvironmentName =
        (_compute_environment_name :: BatchComputeEnvironmentResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedComputeResources (BatchComputeEnvironmentResource s) s (TF.Attr s Text) where
    computedComputeResources =
        (_compute_resources :: BatchComputeEnvironmentResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEcsClusterArn (BatchComputeEnvironmentResource s) s (TF.Attr s Text) where
    computedEcsClusterArn x = TF.compute (TF.refKey x) "ecs_cluster_arn"

instance P.HasComputedServiceRole (BatchComputeEnvironmentResource s) s (TF.Attr s Text) where
    computedServiceRole =
        (_service_role :: BatchComputeEnvironmentResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedState (BatchComputeEnvironmentResource s) s (TF.Attr s Text) where
    computedState =
        (_state :: BatchComputeEnvironmentResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedStatus (BatchComputeEnvironmentResource s) s (TF.Attr s Text) where
    computedStatus x = TF.compute (TF.refKey x) "status"

instance P.HasComputedStatusReason (BatchComputeEnvironmentResource s) s (TF.Attr s Text) where
    computedStatusReason x = TF.compute (TF.refKey x) "status_reason"

instance P.HasComputedType' (BatchComputeEnvironmentResource s) s (TF.Attr s Text) where
    computedType' =
        (_type' :: BatchComputeEnvironmentResource s -> TF.Attr s Text)
            . TF.refValue

batchComputeEnvironmentResource :: TF.Schema TF.Resource P.AWS (BatchComputeEnvironmentResource s)
batchComputeEnvironmentResource =
    TF.newResource "aws_batch_compute_environment" $
        BatchComputeEnvironmentResource {
              _compute_environment_name = TF.Nil
            , _compute_resources = TF.Nil
            , _service_role = TF.Nil
            , _state = TF.Nil
            , _type' = TF.Nil
            }

{- | The @aws_batch_job_definition@ AWS resource.

Provides a Batch Job Definition resource.
-}
data BatchJobDefinitionResource s = BatchJobDefinitionResource {
      _container_properties :: !(TF.Attr s Text)
    {- ^ (Optional) A valid <http://docs.aws.amazon.com/batch/latest/APIReference/API_RegisterJobDefinition.html> provided as a single valid JSON document. This parameter is required if the @type@ parameter is @container@ . -}
    , _name                 :: !(TF.Attr s Text)
    {- ^ (Required) Specifies the name of the job definition. -}
    , _parameters           :: !(TF.Attr s Text)
    {- ^ (Optional) Specifies the parameter substitution placeholders to set in the job definition. -}
    , _retry_strategy       :: !(TF.Attr s Text)
    {- ^ (Optional) Specifies the retry strategy to use for failed jobs that are submitted with this job definition. Maximum number of @retry_strategy@ is @1@ .  Defined below. -}
    , _type'                :: !(TF.Attr s Text)
    {- ^ (Required) The type of job definition.  Must be @container@ -}
    } deriving (Show, Eq)

instance TF.ToHCL (BatchJobDefinitionResource s) where
    toHCL BatchJobDefinitionResource{..} = TF.inline $ catMaybes
        [ TF.assign "container_properties" <$> TF.attribute _container_properties
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "parameters" <$> TF.attribute _parameters
        , TF.assign "retry_strategy" <$> TF.attribute _retry_strategy
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance P.HasContainerProperties (BatchJobDefinitionResource s) (TF.Attr s Text) where
    containerProperties =
        lens (_container_properties :: BatchJobDefinitionResource s -> TF.Attr s Text)
             (\s a -> s { _container_properties = a } :: BatchJobDefinitionResource s)

instance P.HasName (BatchJobDefinitionResource s) (TF.Attr s Text) where
    name =
        lens (_name :: BatchJobDefinitionResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: BatchJobDefinitionResource s)

instance P.HasParameters (BatchJobDefinitionResource s) (TF.Attr s Text) where
    parameters =
        lens (_parameters :: BatchJobDefinitionResource s -> TF.Attr s Text)
             (\s a -> s { _parameters = a } :: BatchJobDefinitionResource s)

instance P.HasRetryStrategy (BatchJobDefinitionResource s) (TF.Attr s Text) where
    retryStrategy =
        lens (_retry_strategy :: BatchJobDefinitionResource s -> TF.Attr s Text)
             (\s a -> s { _retry_strategy = a } :: BatchJobDefinitionResource s)

instance P.HasType' (BatchJobDefinitionResource s) (TF.Attr s Text) where
    type' =
        lens (_type' :: BatchJobDefinitionResource s -> TF.Attr s Text)
             (\s a -> s { _type' = a } :: BatchJobDefinitionResource s)

instance P.HasComputedArn (BatchJobDefinitionResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedContainerProperties (BatchJobDefinitionResource s) s (TF.Attr s Text) where
    computedContainerProperties =
        (_container_properties :: BatchJobDefinitionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (BatchJobDefinitionResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: BatchJobDefinitionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedParameters (BatchJobDefinitionResource s) s (TF.Attr s Text) where
    computedParameters =
        (_parameters :: BatchJobDefinitionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRetryStrategy (BatchJobDefinitionResource s) s (TF.Attr s Text) where
    computedRetryStrategy =
        (_retry_strategy :: BatchJobDefinitionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRevision (BatchJobDefinitionResource s) s (TF.Attr s Text) where
    computedRevision x = TF.compute (TF.refKey x) "revision"

instance P.HasComputedType' (BatchJobDefinitionResource s) s (TF.Attr s Text) where
    computedType' =
        (_type' :: BatchJobDefinitionResource s -> TF.Attr s Text)
            . TF.refValue

batchJobDefinitionResource :: TF.Schema TF.Resource P.AWS (BatchJobDefinitionResource s)
batchJobDefinitionResource =
    TF.newResource "aws_batch_job_definition" $
        BatchJobDefinitionResource {
              _container_properties = TF.Nil
            , _name = TF.Nil
            , _parameters = TF.Nil
            , _retry_strategy = TF.Nil
            , _type' = TF.Nil
            }

{- | The @aws_batch_job_queue@ AWS resource.

Provides a Batch Job Queue resource.
-}
data BatchJobQueueResource s = BatchJobQueueResource {
      _compute_environments :: !(TF.Attr s Text)
    {- ^ (Required) Specifies the set of compute environments mapped to a job queue and their order.  The position of the compute environments in the list will dictate the order. You can associate up to 3 compute environments with a job queue. -}
    , _name                 :: !(TF.Attr s Text)
    {- ^ (Required) Specifies the name of the job queue. -}
    , _priority             :: !(TF.Attr s Text)
    {- ^ (Required) The priority of the job queue. Job queues with a higher priority are evaluated first when associated with same compute environment. -}
    , _state                :: !(TF.Attr s Text)
    {- ^ (Required) The state of the job queue. Must be one of: @ENABLED@ or @DISABLED@ -}
    } deriving (Show, Eq)

instance TF.ToHCL (BatchJobQueueResource s) where
    toHCL BatchJobQueueResource{..} = TF.inline $ catMaybes
        [ TF.assign "compute_environments" <$> TF.attribute _compute_environments
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "priority" <$> TF.attribute _priority
        , TF.assign "state" <$> TF.attribute _state
        ]

instance P.HasComputeEnvironments (BatchJobQueueResource s) (TF.Attr s Text) where
    computeEnvironments =
        lens (_compute_environments :: BatchJobQueueResource s -> TF.Attr s Text)
             (\s a -> s { _compute_environments = a } :: BatchJobQueueResource s)

instance P.HasName (BatchJobQueueResource s) (TF.Attr s Text) where
    name =
        lens (_name :: BatchJobQueueResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: BatchJobQueueResource s)

instance P.HasPriority (BatchJobQueueResource s) (TF.Attr s Text) where
    priority =
        lens (_priority :: BatchJobQueueResource s -> TF.Attr s Text)
             (\s a -> s { _priority = a } :: BatchJobQueueResource s)

instance P.HasState (BatchJobQueueResource s) (TF.Attr s Text) where
    state =
        lens (_state :: BatchJobQueueResource s -> TF.Attr s Text)
             (\s a -> s { _state = a } :: BatchJobQueueResource s)

instance P.HasComputedArn (BatchJobQueueResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedComputeEnvironments (BatchJobQueueResource s) s (TF.Attr s Text) where
    computedComputeEnvironments =
        (_compute_environments :: BatchJobQueueResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (BatchJobQueueResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: BatchJobQueueResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPriority (BatchJobQueueResource s) s (TF.Attr s Text) where
    computedPriority =
        (_priority :: BatchJobQueueResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedState (BatchJobQueueResource s) s (TF.Attr s Text) where
    computedState =
        (_state :: BatchJobQueueResource s -> TF.Attr s Text)
            . TF.refValue

batchJobQueueResource :: TF.Schema TF.Resource P.AWS (BatchJobQueueResource s)
batchJobQueueResource =
    TF.newResource "aws_batch_job_queue" $
        BatchJobQueueResource {
              _compute_environments = TF.Nil
            , _name = TF.Nil
            , _priority = TF.Nil
            , _state = TF.Nil
            }

{- | The @aws_cloud9_environment_ec2@ AWS resource.

Provides a Cloud9 EC2 Development Environment.
-}
data Cloud9EnvironmentEc2Resource s = Cloud9EnvironmentEc2Resource {
      _automatic_stop_time_minutes :: !(TF.Attr s Text)
    {- ^ (Optional) The number of minutes until the running instance is shut down after the environment has last been used. -}
    , _description                 :: !(TF.Attr s Text)
    {- ^ (Optional) The description of the environment. -}
    , _instance_type               :: !(TF.Attr s Text)
    {- ^ (Required) The type of instance to connect to the environment, e.g. @t2.micro@ . -}
    , _name                        :: !(TF.Attr s Text)
    {- ^ (Required) The name of the environment. -}
    , _owner_arn                   :: !(TF.Attr s Text)
    {- ^ (Optional) The ARN of the environment owner. This can be ARN of any AWS IAM principal. Defaults to the environment's creator. -}
    , _subnet_id                   :: !(TF.Attr s Text)
    {- ^ (Optional) The ID of the subnet in Amazon VPC that AWS Cloud9 will use to communicate with the Amazon EC2 instance. -}
    } deriving (Show, Eq)

instance TF.ToHCL (Cloud9EnvironmentEc2Resource s) where
    toHCL Cloud9EnvironmentEc2Resource{..} = TF.inline $ catMaybes
        [ TF.assign "automatic_stop_time_minutes" <$> TF.attribute _automatic_stop_time_minutes
        , TF.assign "description" <$> TF.attribute _description
        , TF.assign "instance_type" <$> TF.attribute _instance_type
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "owner_arn" <$> TF.attribute _owner_arn
        , TF.assign "subnet_id" <$> TF.attribute _subnet_id
        ]

instance P.HasAutomaticStopTimeMinutes (Cloud9EnvironmentEc2Resource s) (TF.Attr s Text) where
    automaticStopTimeMinutes =
        lens (_automatic_stop_time_minutes :: Cloud9EnvironmentEc2Resource s -> TF.Attr s Text)
             (\s a -> s { _automatic_stop_time_minutes = a } :: Cloud9EnvironmentEc2Resource s)

instance P.HasDescription (Cloud9EnvironmentEc2Resource s) (TF.Attr s Text) where
    description =
        lens (_description :: Cloud9EnvironmentEc2Resource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: Cloud9EnvironmentEc2Resource s)

instance P.HasInstanceType (Cloud9EnvironmentEc2Resource s) (TF.Attr s Text) where
    instanceType =
        lens (_instance_type :: Cloud9EnvironmentEc2Resource s -> TF.Attr s Text)
             (\s a -> s { _instance_type = a } :: Cloud9EnvironmentEc2Resource s)

instance P.HasName (Cloud9EnvironmentEc2Resource s) (TF.Attr s Text) where
    name =
        lens (_name :: Cloud9EnvironmentEc2Resource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: Cloud9EnvironmentEc2Resource s)

instance P.HasOwnerArn (Cloud9EnvironmentEc2Resource s) (TF.Attr s Text) where
    ownerArn =
        lens (_owner_arn :: Cloud9EnvironmentEc2Resource s -> TF.Attr s Text)
             (\s a -> s { _owner_arn = a } :: Cloud9EnvironmentEc2Resource s)

instance P.HasSubnetId (Cloud9EnvironmentEc2Resource s) (TF.Attr s Text) where
    subnetId =
        lens (_subnet_id :: Cloud9EnvironmentEc2Resource s -> TF.Attr s Text)
             (\s a -> s { _subnet_id = a } :: Cloud9EnvironmentEc2Resource s)

instance P.HasComputedArn (Cloud9EnvironmentEc2Resource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedAutomaticStopTimeMinutes (Cloud9EnvironmentEc2Resource s) s (TF.Attr s Text) where
    computedAutomaticStopTimeMinutes =
        (_automatic_stop_time_minutes :: Cloud9EnvironmentEc2Resource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDescription (Cloud9EnvironmentEc2Resource s) s (TF.Attr s Text) where
    computedDescription =
        (_description :: Cloud9EnvironmentEc2Resource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (Cloud9EnvironmentEc2Resource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedInstanceType (Cloud9EnvironmentEc2Resource s) s (TF.Attr s Text) where
    computedInstanceType =
        (_instance_type :: Cloud9EnvironmentEc2Resource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (Cloud9EnvironmentEc2Resource s) s (TF.Attr s Text) where
    computedName =
        (_name :: Cloud9EnvironmentEc2Resource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedOwnerArn (Cloud9EnvironmentEc2Resource s) s (TF.Attr s Text) where
    computedOwnerArn =
        (_owner_arn :: Cloud9EnvironmentEc2Resource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSubnetId (Cloud9EnvironmentEc2Resource s) s (TF.Attr s Text) where
    computedSubnetId =
        (_subnet_id :: Cloud9EnvironmentEc2Resource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedType' (Cloud9EnvironmentEc2Resource s) s (TF.Attr s Text) where
    computedType' x = TF.compute (TF.refKey x) "type"

cloud9EnvironmentEc2Resource :: TF.Schema TF.Resource P.AWS (Cloud9EnvironmentEc2Resource s)
cloud9EnvironmentEc2Resource =
    TF.newResource "aws_cloud9_environment_ec2" $
        Cloud9EnvironmentEc2Resource {
              _automatic_stop_time_minutes = TF.Nil
            , _description = TF.Nil
            , _instance_type = TF.Nil
            , _name = TF.Nil
            , _owner_arn = TF.Nil
            , _subnet_id = TF.Nil
            }

{- | The @aws_cloudformation_stack@ AWS resource.

Provides a CloudFormation Stack resource.
-}
data CloudformationStackResource s = CloudformationStackResource {
      _capabilities       :: !(TF.Attr s Text)
    {- ^ (Optional) A list of capabilities. Valid values: @CAPABILITY_IAM@ or @CAPABILITY_NAMED_IAM@ -}
    , _disable_rollback   :: !(TF.Attr s Text)
    {- ^ (Optional) Set to true to disable rollback of the stack if stack creation failed. Conflicts with @on_failure@ . -}
    , _iam_role_arn       :: !(TF.Attr s Text)
    {- ^ (Optional) The ARN of an IAM role that AWS CloudFormation assumes to create the stack. If you don't specify a value, AWS CloudFormation uses the role that was previously associated with the stack. If no role is available, AWS CloudFormation uses a temporary session that is generated from your user credentials. -}
    , _name               :: !(TF.Attr s Text)
    {- ^ (Required) Stack name. -}
    , _notification_arns  :: !(TF.Attr s Text)
    {- ^ (Optional) A list of SNS topic ARNs to publish stack related events. -}
    , _on_failure         :: !(TF.Attr s Text)
    {- ^ (Optional) Action to be taken if stack creation fails. This must be one of: @DO_NOTHING@ , @ROLLBACK@ , or @DELETE@ . Conflicts with @disable_rollback@ . -}
    , _parameters         :: !(TF.Attr s Text)
    {- ^ (Optional) A list of Parameter structures that specify input parameters for the stack. -}
    , _policy_body        :: !(TF.Attr s Text)
    {- ^ (Optional) Structure containing the stack policy body. Conflicts w/ @policy_url@ . -}
    , _policy_url         :: !(TF.Attr s Text)
    {- ^ (Optional) Location of a file containing the stack policy. Conflicts w/ @policy_body@ . -}
    , _tags               :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A list of tags to associate with this stack. -}
    , _template_body      :: !(TF.Attr s Text)
    {- ^ (Optional) Structure containing the template body (max size: 51,200 bytes). -}
    , _template_url       :: !(TF.Attr s Text)
    {- ^ (Optional) Location of a file containing the template body (max size: 460,800 bytes). -}
    , _timeout_in_minutes :: !(TF.Attr s Text)
    {- ^ (Optional) The amount of time that can pass before the stack status becomes @CREATE_FAILED@ . -}
    } deriving (Show, Eq)

instance TF.ToHCL (CloudformationStackResource s) where
    toHCL CloudformationStackResource{..} = TF.inline $ catMaybes
        [ TF.assign "capabilities" <$> TF.attribute _capabilities
        , TF.assign "disable_rollback" <$> TF.attribute _disable_rollback
        , TF.assign "iam_role_arn" <$> TF.attribute _iam_role_arn
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "notification_arns" <$> TF.attribute _notification_arns
        , TF.assign "on_failure" <$> TF.attribute _on_failure
        , TF.assign "parameters" <$> TF.attribute _parameters
        , TF.assign "policy_body" <$> TF.attribute _policy_body
        , TF.assign "policy_url" <$> TF.attribute _policy_url
        , TF.assign "tags" <$> TF.attribute _tags
        , TF.assign "template_body" <$> TF.attribute _template_body
        , TF.assign "template_url" <$> TF.attribute _template_url
        , TF.assign "timeout_in_minutes" <$> TF.attribute _timeout_in_minutes
        ]

instance P.HasCapabilities (CloudformationStackResource s) (TF.Attr s Text) where
    capabilities =
        lens (_capabilities :: CloudformationStackResource s -> TF.Attr s Text)
             (\s a -> s { _capabilities = a } :: CloudformationStackResource s)

instance P.HasDisableRollback (CloudformationStackResource s) (TF.Attr s Text) where
    disableRollback =
        lens (_disable_rollback :: CloudformationStackResource s -> TF.Attr s Text)
             (\s a -> s { _disable_rollback = a } :: CloudformationStackResource s)

instance P.HasIamRoleArn (CloudformationStackResource s) (TF.Attr s Text) where
    iamRoleArn =
        lens (_iam_role_arn :: CloudformationStackResource s -> TF.Attr s Text)
             (\s a -> s { _iam_role_arn = a } :: CloudformationStackResource s)

instance P.HasName (CloudformationStackResource s) (TF.Attr s Text) where
    name =
        lens (_name :: CloudformationStackResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: CloudformationStackResource s)

instance P.HasNotificationArns (CloudformationStackResource s) (TF.Attr s Text) where
    notificationArns =
        lens (_notification_arns :: CloudformationStackResource s -> TF.Attr s Text)
             (\s a -> s { _notification_arns = a } :: CloudformationStackResource s)

instance P.HasOnFailure (CloudformationStackResource s) (TF.Attr s Text) where
    onFailure =
        lens (_on_failure :: CloudformationStackResource s -> TF.Attr s Text)
             (\s a -> s { _on_failure = a } :: CloudformationStackResource s)

instance P.HasParameters (CloudformationStackResource s) (TF.Attr s Text) where
    parameters =
        lens (_parameters :: CloudformationStackResource s -> TF.Attr s Text)
             (\s a -> s { _parameters = a } :: CloudformationStackResource s)

instance P.HasPolicyBody (CloudformationStackResource s) (TF.Attr s Text) where
    policyBody =
        lens (_policy_body :: CloudformationStackResource s -> TF.Attr s Text)
             (\s a -> s { _policy_body = a } :: CloudformationStackResource s)

instance P.HasPolicyUrl (CloudformationStackResource s) (TF.Attr s Text) where
    policyUrl =
        lens (_policy_url :: CloudformationStackResource s -> TF.Attr s Text)
             (\s a -> s { _policy_url = a } :: CloudformationStackResource s)

instance P.HasTags (CloudformationStackResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: CloudformationStackResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: CloudformationStackResource s)

instance P.HasTemplateBody (CloudformationStackResource s) (TF.Attr s Text) where
    templateBody =
        lens (_template_body :: CloudformationStackResource s -> TF.Attr s Text)
             (\s a -> s { _template_body = a } :: CloudformationStackResource s)

instance P.HasTemplateUrl (CloudformationStackResource s) (TF.Attr s Text) where
    templateUrl =
        lens (_template_url :: CloudformationStackResource s -> TF.Attr s Text)
             (\s a -> s { _template_url = a } :: CloudformationStackResource s)

instance P.HasTimeoutInMinutes (CloudformationStackResource s) (TF.Attr s Text) where
    timeoutInMinutes =
        lens (_timeout_in_minutes :: CloudformationStackResource s -> TF.Attr s Text)
             (\s a -> s { _timeout_in_minutes = a } :: CloudformationStackResource s)

instance P.HasComputedCapabilities (CloudformationStackResource s) s (TF.Attr s Text) where
    computedCapabilities =
        (_capabilities :: CloudformationStackResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDisableRollback (CloudformationStackResource s) s (TF.Attr s Text) where
    computedDisableRollback =
        (_disable_rollback :: CloudformationStackResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedIamRoleArn (CloudformationStackResource s) s (TF.Attr s Text) where
    computedIamRoleArn =
        (_iam_role_arn :: CloudformationStackResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (CloudformationStackResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (CloudformationStackResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: CloudformationStackResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedNotificationArns (CloudformationStackResource s) s (TF.Attr s Text) where
    computedNotificationArns =
        (_notification_arns :: CloudformationStackResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedOnFailure (CloudformationStackResource s) s (TF.Attr s Text) where
    computedOnFailure =
        (_on_failure :: CloudformationStackResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedOutputs (CloudformationStackResource s) s (TF.Attr s Text) where
    computedOutputs x = TF.compute (TF.refKey x) "outputs"

instance P.HasComputedParameters (CloudformationStackResource s) s (TF.Attr s Text) where
    computedParameters =
        (_parameters :: CloudformationStackResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPolicyBody (CloudformationStackResource s) s (TF.Attr s Text) where
    computedPolicyBody =
        (_policy_body :: CloudformationStackResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPolicyUrl (CloudformationStackResource s) s (TF.Attr s Text) where
    computedPolicyUrl =
        (_policy_url :: CloudformationStackResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (CloudformationStackResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: CloudformationStackResource s -> TF.Attr s P.Tags)
            . TF.refValue

instance P.HasComputedTemplateBody (CloudformationStackResource s) s (TF.Attr s Text) where
    computedTemplateBody =
        (_template_body :: CloudformationStackResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTemplateUrl (CloudformationStackResource s) s (TF.Attr s Text) where
    computedTemplateUrl =
        (_template_url :: CloudformationStackResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTimeoutInMinutes (CloudformationStackResource s) s (TF.Attr s Text) where
    computedTimeoutInMinutes =
        (_timeout_in_minutes :: CloudformationStackResource s -> TF.Attr s Text)
            . TF.refValue

cloudformationStackResource :: TF.Schema TF.Resource P.AWS (CloudformationStackResource s)
cloudformationStackResource =
    TF.newResource "aws_cloudformation_stack" $
        CloudformationStackResource {
              _capabilities = TF.Nil
            , _disable_rollback = TF.Nil
            , _iam_role_arn = TF.Nil
            , _name = TF.Nil
            , _notification_arns = TF.Nil
            , _on_failure = TF.Nil
            , _parameters = TF.Nil
            , _policy_body = TF.Nil
            , _policy_url = TF.Nil
            , _tags = TF.Nil
            , _template_body = TF.Nil
            , _template_url = TF.Nil
            , _timeout_in_minutes = TF.Nil
            }

{- | The @aws_cloudfront_distribution@ AWS resource.

Creates an Amazon CloudFront web distribution. For information about
CloudFront distributions, see the
<http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Introduction.html>
. For specific information about creating CloudFront web distributions, see
the
<http://docs.aws.amazon.com/AmazonCloudFront/latest/APIReference/CreateDistribution.html>
page in the Amazon CloudFront API Reference. ~> NOTE: CloudFront
distributions take about 15 minutes to a deployed state after creation or
modification. During this time, deletes to resources will be blocked. If you
need to delete a distribution that is enabled and you do not want to wait,
you need to use the @retain_on_delete@ flag.
-}
data CloudfrontDistributionResource s = CloudfrontDistributionResource {
      _aliases                :: !(TF.Attr s Text)
    {- ^ (Optional) - Extra CNAMEs (alternate domain names), if any, for this distribution. -}
    , _cache_behavior         :: !(TF.Attr s Text)
    {- ^ (Optional) - A <#cache-behavior-arguments> resource for this distribution (multiples allowed). -}
    , _comment                :: !(TF.Attr s Text)
    {- ^ (Optional) - Any comments you want to include about the distribution. -}
    , _custom_error_response  :: !(TF.Attr s Text)
    {- ^ (Optional) - One or more <#custom-error-response-arguments> elements (multiples allowed). -}
    , _default_cache_behavior :: !(TF.Attr s Text)
    {- ^ (Required) - The <#default-cache-behavior-arguments> for this distribution (maximum one). -}
    , _default_root_object    :: !(TF.Attr s Text)
    {- ^ (Optional) - The object that you want CloudFront to return (for example, index.html) when an end user requests the root URL. -}
    , _enabled                :: !(TF.Attr s P.Bool)
    {- ^ (Required) - Whether the distribution is enabled to accept end user requests for content. -}
    , _http_version           :: !(TF.Attr s Text)
    {- ^ (Optional) - The maximum HTTP version to support on the distribution. Allowed values are @http1.1@ and @http2@ . The default is @http2@ . -}
    , _is_ipv6_enabled        :: !(TF.Attr s P.Bool)
    {- ^ (Optional) - Whether the IPv6 is enabled for the distribution. -}
    , _logging_config         :: !(TF.Attr s Text)
    {- ^ (Optional) - The <#logging-config-arguments> that controls how logs are written to your distribution (maximum one). -}
    , _origin                 :: !(TF.Attr s Text)
    {- ^ (Required) - One or more <#origin-arguments> for this distribution (multiples allowed). -}
    , _price_class            :: !(TF.Attr s Text)
    {- ^ (Optional) - The price class for this distribution. One of @PriceClass_All@ , @PriceClass_200@ , @PriceClass_100@ -}
    , _restrictions           :: !(TF.Attr s Text)
    {- ^ (Required) - The <#restrictions-arguments> for this distribution (maximum one). -}
    , _retain_on_delete       :: !(TF.Attr s Text)
    {- ^ (Optional) - Disables the distribution instead of deleting it when destroying the resource through Terraform. If this is set, the distribution needs to be deleted manually afterwards. Default: @false@ . -}
    , _tags                   :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    , _viewer_certificate     :: !(TF.Attr s Text)
    {- ^ (Required) - The <#viewer-certificate-arguments> for this distribution (maximum one). -}
    , _web_acl_id             :: !(TF.Attr s Text)
    {- ^ (Optional) - If you're using AWS WAF to filter CloudFront requests, the Id of the AWS WAF web ACL that is associated with the distribution. -}
    } deriving (Show, Eq)

instance TF.ToHCL (CloudfrontDistributionResource s) where
    toHCL CloudfrontDistributionResource{..} = TF.inline $ catMaybes
        [ TF.assign "aliases" <$> TF.attribute _aliases
        , TF.assign "cache_behavior" <$> TF.attribute _cache_behavior
        , TF.assign "comment" <$> TF.attribute _comment
        , TF.assign "custom_error_response" <$> TF.attribute _custom_error_response
        , TF.assign "default_cache_behavior" <$> TF.attribute _default_cache_behavior
        , TF.assign "default_root_object" <$> TF.attribute _default_root_object
        , TF.assign "enabled" <$> TF.attribute _enabled
        , TF.assign "http_version" <$> TF.attribute _http_version
        , TF.assign "is_ipv6_enabled" <$> TF.attribute _is_ipv6_enabled
        , TF.assign "logging_config" <$> TF.attribute _logging_config
        , TF.assign "origin" <$> TF.attribute _origin
        , TF.assign "price_class" <$> TF.attribute _price_class
        , TF.assign "restrictions" <$> TF.attribute _restrictions
        , TF.assign "retain_on_delete" <$> TF.attribute _retain_on_delete
        , TF.assign "tags" <$> TF.attribute _tags
        , TF.assign "viewer_certificate" <$> TF.attribute _viewer_certificate
        , TF.assign "web_acl_id" <$> TF.attribute _web_acl_id
        ]

instance P.HasAliases (CloudfrontDistributionResource s) (TF.Attr s Text) where
    aliases =
        lens (_aliases :: CloudfrontDistributionResource s -> TF.Attr s Text)
             (\s a -> s { _aliases = a } :: CloudfrontDistributionResource s)

instance P.HasCacheBehavior (CloudfrontDistributionResource s) (TF.Attr s Text) where
    cacheBehavior =
        lens (_cache_behavior :: CloudfrontDistributionResource s -> TF.Attr s Text)
             (\s a -> s { _cache_behavior = a } :: CloudfrontDistributionResource s)

instance P.HasComment (CloudfrontDistributionResource s) (TF.Attr s Text) where
    comment =
        lens (_comment :: CloudfrontDistributionResource s -> TF.Attr s Text)
             (\s a -> s { _comment = a } :: CloudfrontDistributionResource s)

instance P.HasCustomErrorResponse (CloudfrontDistributionResource s) (TF.Attr s Text) where
    customErrorResponse =
        lens (_custom_error_response :: CloudfrontDistributionResource s -> TF.Attr s Text)
             (\s a -> s { _custom_error_response = a } :: CloudfrontDistributionResource s)

instance P.HasDefaultCacheBehavior (CloudfrontDistributionResource s) (TF.Attr s Text) where
    defaultCacheBehavior =
        lens (_default_cache_behavior :: CloudfrontDistributionResource s -> TF.Attr s Text)
             (\s a -> s { _default_cache_behavior = a } :: CloudfrontDistributionResource s)

instance P.HasDefaultRootObject (CloudfrontDistributionResource s) (TF.Attr s Text) where
    defaultRootObject =
        lens (_default_root_object :: CloudfrontDistributionResource s -> TF.Attr s Text)
             (\s a -> s { _default_root_object = a } :: CloudfrontDistributionResource s)

instance P.HasEnabled (CloudfrontDistributionResource s) (TF.Attr s P.Bool) where
    enabled =
        lens (_enabled :: CloudfrontDistributionResource s -> TF.Attr s P.Bool)
             (\s a -> s { _enabled = a } :: CloudfrontDistributionResource s)

instance P.HasHttpVersion (CloudfrontDistributionResource s) (TF.Attr s Text) where
    httpVersion =
        lens (_http_version :: CloudfrontDistributionResource s -> TF.Attr s Text)
             (\s a -> s { _http_version = a } :: CloudfrontDistributionResource s)

instance P.HasIsIpv6Enabled (CloudfrontDistributionResource s) (TF.Attr s P.Bool) where
    isIpv6Enabled =
        lens (_is_ipv6_enabled :: CloudfrontDistributionResource s -> TF.Attr s P.Bool)
             (\s a -> s { _is_ipv6_enabled = a } :: CloudfrontDistributionResource s)

instance P.HasLoggingConfig (CloudfrontDistributionResource s) (TF.Attr s Text) where
    loggingConfig =
        lens (_logging_config :: CloudfrontDistributionResource s -> TF.Attr s Text)
             (\s a -> s { _logging_config = a } :: CloudfrontDistributionResource s)

instance P.HasOrigin (CloudfrontDistributionResource s) (TF.Attr s Text) where
    origin =
        lens (_origin :: CloudfrontDistributionResource s -> TF.Attr s Text)
             (\s a -> s { _origin = a } :: CloudfrontDistributionResource s)

instance P.HasPriceClass (CloudfrontDistributionResource s) (TF.Attr s Text) where
    priceClass =
        lens (_price_class :: CloudfrontDistributionResource s -> TF.Attr s Text)
             (\s a -> s { _price_class = a } :: CloudfrontDistributionResource s)

instance P.HasRestrictions (CloudfrontDistributionResource s) (TF.Attr s Text) where
    restrictions =
        lens (_restrictions :: CloudfrontDistributionResource s -> TF.Attr s Text)
             (\s a -> s { _restrictions = a } :: CloudfrontDistributionResource s)

instance P.HasRetainOnDelete (CloudfrontDistributionResource s) (TF.Attr s Text) where
    retainOnDelete =
        lens (_retain_on_delete :: CloudfrontDistributionResource s -> TF.Attr s Text)
             (\s a -> s { _retain_on_delete = a } :: CloudfrontDistributionResource s)

instance P.HasTags (CloudfrontDistributionResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: CloudfrontDistributionResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: CloudfrontDistributionResource s)

instance P.HasViewerCertificate (CloudfrontDistributionResource s) (TF.Attr s Text) where
    viewerCertificate =
        lens (_viewer_certificate :: CloudfrontDistributionResource s -> TF.Attr s Text)
             (\s a -> s { _viewer_certificate = a } :: CloudfrontDistributionResource s)

instance P.HasWebAclId (CloudfrontDistributionResource s) (TF.Attr s Text) where
    webAclId =
        lens (_web_acl_id :: CloudfrontDistributionResource s -> TF.Attr s Text)
             (\s a -> s { _web_acl_id = a } :: CloudfrontDistributionResource s)

instance P.HasComputedActiveTrustedSigners (CloudfrontDistributionResource s) s (TF.Attr s Text) where
    computedActiveTrustedSigners x = TF.compute (TF.refKey x) "active_trusted_signers"

instance P.HasComputedAliases (CloudfrontDistributionResource s) s (TF.Attr s Text) where
    computedAliases =
        (_aliases :: CloudfrontDistributionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedArn (CloudfrontDistributionResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedCacheBehavior (CloudfrontDistributionResource s) s (TF.Attr s Text) where
    computedCacheBehavior =
        (_cache_behavior :: CloudfrontDistributionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCallerReference (CloudfrontDistributionResource s) s (TF.Attr s Text) where
    computedCallerReference x = TF.compute (TF.refKey x) "caller_reference"

instance P.HasComputedComment (CloudfrontDistributionResource s) s (TF.Attr s Text) where
    computedComment =
        (_comment :: CloudfrontDistributionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCustomErrorResponse (CloudfrontDistributionResource s) s (TF.Attr s Text) where
    computedCustomErrorResponse =
        (_custom_error_response :: CloudfrontDistributionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDefaultCacheBehavior (CloudfrontDistributionResource s) s (TF.Attr s Text) where
    computedDefaultCacheBehavior =
        (_default_cache_behavior :: CloudfrontDistributionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDefaultRootObject (CloudfrontDistributionResource s) s (TF.Attr s Text) where
    computedDefaultRootObject =
        (_default_root_object :: CloudfrontDistributionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDomainName (CloudfrontDistributionResource s) s (TF.Attr s Text) where
    computedDomainName x = TF.compute (TF.refKey x) "domain_name"

instance P.HasComputedEnabled (CloudfrontDistributionResource s) s (TF.Attr s P.Bool) where
    computedEnabled =
        (_enabled :: CloudfrontDistributionResource s -> TF.Attr s P.Bool)
            . TF.refValue

instance P.HasComputedEtag (CloudfrontDistributionResource s) s (TF.Attr s Text) where
    computedEtag x = TF.compute (TF.refKey x) "etag"

instance P.HasComputedHostedZoneId (CloudfrontDistributionResource s) s (TF.Attr s Text) where
    computedHostedZoneId x = TF.compute (TF.refKey x) "hosted_zone_id"

instance P.HasComputedHttpVersion (CloudfrontDistributionResource s) s (TF.Attr s Text) where
    computedHttpVersion =
        (_http_version :: CloudfrontDistributionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (CloudfrontDistributionResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedInProgressValidationBatches (CloudfrontDistributionResource s) s (TF.Attr s Text) where
    computedInProgressValidationBatches x = TF.compute (TF.refKey x) "in_progress_validation_batches"

instance P.HasComputedIsIpv6Enabled (CloudfrontDistributionResource s) s (TF.Attr s P.Bool) where
    computedIsIpv6Enabled =
        (_is_ipv6_enabled :: CloudfrontDistributionResource s -> TF.Attr s P.Bool)
            . TF.refValue

instance P.HasComputedLastModifiedTime (CloudfrontDistributionResource s) s (TF.Attr s Text) where
    computedLastModifiedTime x = TF.compute (TF.refKey x) "last_modified_time"

instance P.HasComputedLoggingConfig (CloudfrontDistributionResource s) s (TF.Attr s Text) where
    computedLoggingConfig =
        (_logging_config :: CloudfrontDistributionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedOrigin (CloudfrontDistributionResource s) s (TF.Attr s Text) where
    computedOrigin =
        (_origin :: CloudfrontDistributionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPriceClass (CloudfrontDistributionResource s) s (TF.Attr s Text) where
    computedPriceClass =
        (_price_class :: CloudfrontDistributionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRestrictions (CloudfrontDistributionResource s) s (TF.Attr s Text) where
    computedRestrictions =
        (_restrictions :: CloudfrontDistributionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRetainOnDelete (CloudfrontDistributionResource s) s (TF.Attr s Text) where
    computedRetainOnDelete =
        (_retain_on_delete :: CloudfrontDistributionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedStatus (CloudfrontDistributionResource s) s (TF.Attr s Text) where
    computedStatus x = TF.compute (TF.refKey x) "status"

instance P.HasComputedTags (CloudfrontDistributionResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: CloudfrontDistributionResource s -> TF.Attr s P.Tags)
            . TF.refValue

instance P.HasComputedViewerCertificate (CloudfrontDistributionResource s) s (TF.Attr s Text) where
    computedViewerCertificate =
        (_viewer_certificate :: CloudfrontDistributionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedWebAclId (CloudfrontDistributionResource s) s (TF.Attr s Text) where
    computedWebAclId =
        (_web_acl_id :: CloudfrontDistributionResource s -> TF.Attr s Text)
            . TF.refValue

cloudfrontDistributionResource :: TF.Schema TF.Resource P.AWS (CloudfrontDistributionResource s)
cloudfrontDistributionResource =
    TF.newResource "aws_cloudfront_distribution" $
        CloudfrontDistributionResource {
              _aliases = TF.Nil
            , _cache_behavior = TF.Nil
            , _comment = TF.Nil
            , _custom_error_response = TF.Nil
            , _default_cache_behavior = TF.Nil
            , _default_root_object = TF.Nil
            , _enabled = TF.Nil
            , _http_version = TF.Nil
            , _is_ipv6_enabled = TF.Nil
            , _logging_config = TF.Nil
            , _origin = TF.Nil
            , _price_class = TF.Nil
            , _restrictions = TF.Nil
            , _retain_on_delete = TF.Nil
            , _tags = TF.Nil
            , _viewer_certificate = TF.Nil
            , _web_acl_id = TF.Nil
            }

{- | The @aws_cloudfront_origin_access_identity@ AWS resource.

Creates an Amazon CloudFront origin access identity. For information about
CloudFront distributions, see the
<http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Introduction.html>
. For more information on generating origin access identities, see
<http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-restricting-access-to-s3.html>
.
-}
data CloudfrontOriginAccessIdentityResource s = CloudfrontOriginAccessIdentityResource {
      _comment :: !(TF.Attr s Text)
    {- ^ (Optional) - An optional comment for the origin access identity. -}
    } deriving (Show, Eq)

instance TF.ToHCL (CloudfrontOriginAccessIdentityResource s) where
    toHCL CloudfrontOriginAccessIdentityResource{..} = TF.inline $ catMaybes
        [ TF.assign "comment" <$> TF.attribute _comment
        ]

instance P.HasComment (CloudfrontOriginAccessIdentityResource s) (TF.Attr s Text) where
    comment =
        lens (_comment :: CloudfrontOriginAccessIdentityResource s -> TF.Attr s Text)
             (\s a -> s { _comment = a } :: CloudfrontOriginAccessIdentityResource s)

instance P.HasComputedCallerReference (CloudfrontOriginAccessIdentityResource s) s (TF.Attr s Text) where
    computedCallerReference x = TF.compute (TF.refKey x) "caller_reference"

instance P.HasComputedCloudfrontAccessIdentityPath (CloudfrontOriginAccessIdentityResource s) s (TF.Attr s Text) where
    computedCloudfrontAccessIdentityPath x = TF.compute (TF.refKey x) "cloudfront_access_identity_path"

instance P.HasComputedComment (CloudfrontOriginAccessIdentityResource s) s (TF.Attr s Text) where
    computedComment =
        (_comment :: CloudfrontOriginAccessIdentityResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEtag (CloudfrontOriginAccessIdentityResource s) s (TF.Attr s Text) where
    computedEtag x = TF.compute (TF.refKey x) "etag"

instance P.HasComputedIamArn (CloudfrontOriginAccessIdentityResource s) s (TF.Attr s Text) where
    computedIamArn x = TF.compute (TF.refKey x) "iam_arn"

instance P.HasComputedId (CloudfrontOriginAccessIdentityResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedS3CanonicalUserId (CloudfrontOriginAccessIdentityResource s) s (TF.Attr s Text) where
    computedS3CanonicalUserId x = TF.compute (TF.refKey x) "s3_canonical_user_id"

cloudfrontOriginAccessIdentityResource :: TF.Schema TF.Resource P.AWS (CloudfrontOriginAccessIdentityResource s)
cloudfrontOriginAccessIdentityResource =
    TF.newResource "aws_cloudfront_origin_access_identity" $
        CloudfrontOriginAccessIdentityResource {
              _comment = TF.Nil
            }

{- | The @aws_cloudtrail@ AWS resource.

Provides a CloudTrail resource.
-}
data CloudtrailResource s = CloudtrailResource {
      _cloud_watch_logs_group_arn    :: !(TF.Attr s Text)
    {- ^ (Optional) Specifies a log group name using an Amazon Resource Name (ARN), that represents the log group to which CloudTrail logs will be delivered. -}
    , _cloud_watch_logs_role_arn     :: !(TF.Attr s Text)
    {- ^ (Optional) Specifies the role for the CloudWatch Logs endpoint to assume to write to a users log group. -}
    , _enable_log_file_validation    :: !(TF.Attr s P.Bool)
    {- ^ (Optional) Specifies whether log file integrity validation is enabled. Defaults to @false@ . -}
    , _enable_logging                :: !(TF.Attr s P.Bool)
    {- ^ (Optional) Enables logging for the trail. Defaults to @true@ . Setting this to @false@ will pause logging. -}
    , _include_global_service_events :: !(TF.Attr s Text)
    {- ^ (Optional) Specifies whether the trail is publishing events from global services such as IAM to the log files. Defaults to @true@ . -}
    , _is_multi_region_trail         :: !(TF.Attr s Text)
    {- ^ (Optional) Specifies whether the trail is created in the current region or in all regions. Defaults to @false@ . -}
    , _kms_key_id                    :: !(TF.Attr s Text)
    {- ^ (Optional) Specifies the KMS key ARN to use to encrypt the logs delivered by CloudTrail. -}
    , _name                          :: !(TF.Attr s Text)
    {- ^ (Required) Specifies the name of the trail. -}
    , _s3_bucket_name                :: !(TF.Attr s Text)
    {- ^ (Required) Specifies the name of the S3 bucket designated for publishing log files. -}
    , _s3_key_prefix                 :: !(TF.Attr s Text)
    {- ^ (Optional) Specifies the S3 key prefix that precedes the name of the bucket you have designated for log file delivery. -}
    , _sns_topic_name                :: !(TF.Attr s Text)
    {- ^ (Optional) Specifies the name of the Amazon SNS topic defined for notification of log file delivery. -}
    , _tags                          :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the trail -}
    } deriving (Show, Eq)

instance TF.ToHCL (CloudtrailResource s) where
    toHCL CloudtrailResource{..} = TF.inline $ catMaybes
        [ TF.assign "cloud_watch_logs_group_arn" <$> TF.attribute _cloud_watch_logs_group_arn
        , TF.assign "cloud_watch_logs_role_arn" <$> TF.attribute _cloud_watch_logs_role_arn
        , TF.assign "enable_log_file_validation" <$> TF.attribute _enable_log_file_validation
        , TF.assign "enable_logging" <$> TF.attribute _enable_logging
        , TF.assign "include_global_service_events" <$> TF.attribute _include_global_service_events
        , TF.assign "is_multi_region_trail" <$> TF.attribute _is_multi_region_trail
        , TF.assign "kms_key_id" <$> TF.attribute _kms_key_id
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "s3_bucket_name" <$> TF.attribute _s3_bucket_name
        , TF.assign "s3_key_prefix" <$> TF.attribute _s3_key_prefix
        , TF.assign "sns_topic_name" <$> TF.attribute _sns_topic_name
        , TF.assign "tags" <$> TF.attribute _tags
        ]

instance P.HasCloudWatchLogsGroupArn (CloudtrailResource s) (TF.Attr s Text) where
    cloudWatchLogsGroupArn =
        lens (_cloud_watch_logs_group_arn :: CloudtrailResource s -> TF.Attr s Text)
             (\s a -> s { _cloud_watch_logs_group_arn = a } :: CloudtrailResource s)

instance P.HasCloudWatchLogsRoleArn (CloudtrailResource s) (TF.Attr s Text) where
    cloudWatchLogsRoleArn =
        lens (_cloud_watch_logs_role_arn :: CloudtrailResource s -> TF.Attr s Text)
             (\s a -> s { _cloud_watch_logs_role_arn = a } :: CloudtrailResource s)

instance P.HasEnableLogFileValidation (CloudtrailResource s) (TF.Attr s P.Bool) where
    enableLogFileValidation =
        lens (_enable_log_file_validation :: CloudtrailResource s -> TF.Attr s P.Bool)
             (\s a -> s { _enable_log_file_validation = a } :: CloudtrailResource s)

instance P.HasEnableLogging (CloudtrailResource s) (TF.Attr s P.Bool) where
    enableLogging =
        lens (_enable_logging :: CloudtrailResource s -> TF.Attr s P.Bool)
             (\s a -> s { _enable_logging = a } :: CloudtrailResource s)

instance P.HasIncludeGlobalServiceEvents (CloudtrailResource s) (TF.Attr s Text) where
    includeGlobalServiceEvents =
        lens (_include_global_service_events :: CloudtrailResource s -> TF.Attr s Text)
             (\s a -> s { _include_global_service_events = a } :: CloudtrailResource s)

instance P.HasIsMultiRegionTrail (CloudtrailResource s) (TF.Attr s Text) where
    isMultiRegionTrail =
        lens (_is_multi_region_trail :: CloudtrailResource s -> TF.Attr s Text)
             (\s a -> s { _is_multi_region_trail = a } :: CloudtrailResource s)

instance P.HasKmsKeyId (CloudtrailResource s) (TF.Attr s Text) where
    kmsKeyId =
        lens (_kms_key_id :: CloudtrailResource s -> TF.Attr s Text)
             (\s a -> s { _kms_key_id = a } :: CloudtrailResource s)

instance P.HasName (CloudtrailResource s) (TF.Attr s Text) where
    name =
        lens (_name :: CloudtrailResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: CloudtrailResource s)

instance P.HasS3BucketName (CloudtrailResource s) (TF.Attr s Text) where
    s3BucketName =
        lens (_s3_bucket_name :: CloudtrailResource s -> TF.Attr s Text)
             (\s a -> s { _s3_bucket_name = a } :: CloudtrailResource s)

instance P.HasS3KeyPrefix (CloudtrailResource s) (TF.Attr s Text) where
    s3KeyPrefix =
        lens (_s3_key_prefix :: CloudtrailResource s -> TF.Attr s Text)
             (\s a -> s { _s3_key_prefix = a } :: CloudtrailResource s)

instance P.HasSnsTopicName (CloudtrailResource s) (TF.Attr s Text) where
    snsTopicName =
        lens (_sns_topic_name :: CloudtrailResource s -> TF.Attr s Text)
             (\s a -> s { _sns_topic_name = a } :: CloudtrailResource s)

instance P.HasTags (CloudtrailResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: CloudtrailResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: CloudtrailResource s)

instance P.HasComputedArn (CloudtrailResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedCloudWatchLogsGroupArn (CloudtrailResource s) s (TF.Attr s Text) where
    computedCloudWatchLogsGroupArn =
        (_cloud_watch_logs_group_arn :: CloudtrailResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCloudWatchLogsRoleArn (CloudtrailResource s) s (TF.Attr s Text) where
    computedCloudWatchLogsRoleArn =
        (_cloud_watch_logs_role_arn :: CloudtrailResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEnableLogFileValidation (CloudtrailResource s) s (TF.Attr s P.Bool) where
    computedEnableLogFileValidation =
        (_enable_log_file_validation :: CloudtrailResource s -> TF.Attr s P.Bool)
            . TF.refValue

instance P.HasComputedEnableLogging (CloudtrailResource s) s (TF.Attr s P.Bool) where
    computedEnableLogging =
        (_enable_logging :: CloudtrailResource s -> TF.Attr s P.Bool)
            . TF.refValue

instance P.HasComputedHomeRegion (CloudtrailResource s) s (TF.Attr s P.Region) where
    computedHomeRegion x = TF.compute (TF.refKey x) "home_region"

instance P.HasComputedId (CloudtrailResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedIncludeGlobalServiceEvents (CloudtrailResource s) s (TF.Attr s Text) where
    computedIncludeGlobalServiceEvents =
        (_include_global_service_events :: CloudtrailResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedIsMultiRegionTrail (CloudtrailResource s) s (TF.Attr s Text) where
    computedIsMultiRegionTrail =
        (_is_multi_region_trail :: CloudtrailResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedKmsKeyId (CloudtrailResource s) s (TF.Attr s Text) where
    computedKmsKeyId =
        (_kms_key_id :: CloudtrailResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (CloudtrailResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: CloudtrailResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedS3BucketName (CloudtrailResource s) s (TF.Attr s Text) where
    computedS3BucketName =
        (_s3_bucket_name :: CloudtrailResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedS3KeyPrefix (CloudtrailResource s) s (TF.Attr s Text) where
    computedS3KeyPrefix =
        (_s3_key_prefix :: CloudtrailResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSnsTopicName (CloudtrailResource s) s (TF.Attr s Text) where
    computedSnsTopicName =
        (_sns_topic_name :: CloudtrailResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (CloudtrailResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: CloudtrailResource s -> TF.Attr s P.Tags)
            . TF.refValue

cloudtrailResource :: TF.Schema TF.Resource P.AWS (CloudtrailResource s)
cloudtrailResource =
    TF.newResource "aws_cloudtrail" $
        CloudtrailResource {
              _cloud_watch_logs_group_arn = TF.Nil
            , _cloud_watch_logs_role_arn = TF.Nil
            , _enable_log_file_validation = TF.Nil
            , _enable_logging = TF.Nil
            , _include_global_service_events = TF.Nil
            , _is_multi_region_trail = TF.Nil
            , _kms_key_id = TF.Nil
            , _name = TF.Nil
            , _s3_bucket_name = TF.Nil
            , _s3_key_prefix = TF.Nil
            , _sns_topic_name = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_cloudwatch_dashboard@ AWS resource.

Provides a CloudWatch Dashboard resource.
-}
data CloudwatchDashboardResource s = CloudwatchDashboardResource {
      _dashboard_body :: !(TF.Attr s Text)
    {- ^ (Required) The detailed information about the dashboard, including what widgets are included and their location on the dashboard. You can read more about the body structure in the <https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/CloudWatch-Dashboard-Body-Structure.html> . -}
    , _dashboard_name :: !(TF.Attr s Text)
    {- ^ (Required) The name of the dashboard. -}
    } deriving (Show, Eq)

instance TF.ToHCL (CloudwatchDashboardResource s) where
    toHCL CloudwatchDashboardResource{..} = TF.inline $ catMaybes
        [ TF.assign "dashboard_body" <$> TF.attribute _dashboard_body
        , TF.assign "dashboard_name" <$> TF.attribute _dashboard_name
        ]

instance P.HasDashboardBody (CloudwatchDashboardResource s) (TF.Attr s Text) where
    dashboardBody =
        lens (_dashboard_body :: CloudwatchDashboardResource s -> TF.Attr s Text)
             (\s a -> s { _dashboard_body = a } :: CloudwatchDashboardResource s)

instance P.HasDashboardName (CloudwatchDashboardResource s) (TF.Attr s Text) where
    dashboardName =
        lens (_dashboard_name :: CloudwatchDashboardResource s -> TF.Attr s Text)
             (\s a -> s { _dashboard_name = a } :: CloudwatchDashboardResource s)

instance P.HasComputedDashboardArn (CloudwatchDashboardResource s) s (TF.Attr s Text) where
    computedDashboardArn x = TF.compute (TF.refKey x) "dashboard_arn"

instance P.HasComputedDashboardBody (CloudwatchDashboardResource s) s (TF.Attr s Text) where
    computedDashboardBody =
        (_dashboard_body :: CloudwatchDashboardResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDashboardName (CloudwatchDashboardResource s) s (TF.Attr s Text) where
    computedDashboardName =
        (_dashboard_name :: CloudwatchDashboardResource s -> TF.Attr s Text)
            . TF.refValue

cloudwatchDashboardResource :: TF.Schema TF.Resource P.AWS (CloudwatchDashboardResource s)
cloudwatchDashboardResource =
    TF.newResource "aws_cloudwatch_dashboard" $
        CloudwatchDashboardResource {
              _dashboard_body = TF.Nil
            , _dashboard_name = TF.Nil
            }

{- | The @aws_cloudwatch_event_permission@ AWS resource.

Provides a resource to create a CloudWatch Events permission to support
cross-account events in the current account default event bus.
-}
data CloudwatchEventPermissionResource s = CloudwatchEventPermissionResource {
      _action       :: !(TF.Attr s Text)
    {- ^ (Optional) The action that you are enabling the other account to perform. Defaults to @events:PutEvents@ . -}
    , _principal    :: !(TF.Attr s Text)
    {- ^ (Required) The 12-digit AWS account ID that you are permitting to put events to your default event bus. Specify @*@ to permit any account to put events to your default event bus. -}
    , _statement_id :: !(TF.Attr s Text)
    {- ^ (Required) An identifier string for the external account that you are granting permissions to. -}
    } deriving (Show, Eq)

instance TF.ToHCL (CloudwatchEventPermissionResource s) where
    toHCL CloudwatchEventPermissionResource{..} = TF.inline $ catMaybes
        [ TF.assign "action" <$> TF.attribute _action
        , TF.assign "principal" <$> TF.attribute _principal
        , TF.assign "statement_id" <$> TF.attribute _statement_id
        ]

instance P.HasAction (CloudwatchEventPermissionResource s) (TF.Attr s Text) where
    action =
        lens (_action :: CloudwatchEventPermissionResource s -> TF.Attr s Text)
             (\s a -> s { _action = a } :: CloudwatchEventPermissionResource s)

instance P.HasPrincipal (CloudwatchEventPermissionResource s) (TF.Attr s Text) where
    principal =
        lens (_principal :: CloudwatchEventPermissionResource s -> TF.Attr s Text)
             (\s a -> s { _principal = a } :: CloudwatchEventPermissionResource s)

instance P.HasStatementId (CloudwatchEventPermissionResource s) (TF.Attr s Text) where
    statementId =
        lens (_statement_id :: CloudwatchEventPermissionResource s -> TF.Attr s Text)
             (\s a -> s { _statement_id = a } :: CloudwatchEventPermissionResource s)

instance P.HasComputedAction (CloudwatchEventPermissionResource s) s (TF.Attr s Text) where
    computedAction =
        (_action :: CloudwatchEventPermissionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (CloudwatchEventPermissionResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedPrincipal (CloudwatchEventPermissionResource s) s (TF.Attr s Text) where
    computedPrincipal =
        (_principal :: CloudwatchEventPermissionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedStatementId (CloudwatchEventPermissionResource s) s (TF.Attr s Text) where
    computedStatementId =
        (_statement_id :: CloudwatchEventPermissionResource s -> TF.Attr s Text)
            . TF.refValue

cloudwatchEventPermissionResource :: TF.Schema TF.Resource P.AWS (CloudwatchEventPermissionResource s)
cloudwatchEventPermissionResource =
    TF.newResource "aws_cloudwatch_event_permission" $
        CloudwatchEventPermissionResource {
              _action = TF.Nil
            , _principal = TF.Nil
            , _statement_id = TF.Nil
            }

{- | The @aws_cloudwatch_event_rule@ AWS resource.

Provides a CloudWatch Event Rule resource.
-}
data CloudwatchEventRuleResource s = CloudwatchEventRuleResource {
      _description         :: !(TF.Attr s Text)
    {- ^ (Optional) The description of the rule. -}
    , _event_pattern       :: !(TF.Attr s Text)
    {- ^ (Required, if @schedule_expression@ isn't specified) Event pattern described a JSON object. See full documentation of <http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/CloudWatchEventsandEventPatterns.html> for details. -}
    , _is_enabled          :: !(TF.Attr s P.Bool)
    {- ^ (Optional) Whether the rule should be enabled (defaults to @true@ ). -}
    , _name                :: !(TF.Attr s Text)
    {- ^ (Required) The rule's name. -}
    , _role_arn            :: !(TF.Attr s Text)
    {- ^ (Optional) The Amazon Resource Name (ARN) associated with the role that is used for target invocation. -}
    , _schedule_expression :: !(TF.Attr s Text)
    {- ^ (Required, if @event_pattern@ isn't specified) The scheduling expression. For example, @cron(0 20 * * ? *)@ or @rate(5 minutes)@ . -}
    } deriving (Show, Eq)

instance TF.ToHCL (CloudwatchEventRuleResource s) where
    toHCL CloudwatchEventRuleResource{..} = TF.inline $ catMaybes
        [ TF.assign "description" <$> TF.attribute _description
        , TF.assign "event_pattern" <$> TF.attribute _event_pattern
        , TF.assign "is_enabled" <$> TF.attribute _is_enabled
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "role_arn" <$> TF.attribute _role_arn
        , TF.assign "schedule_expression" <$> TF.attribute _schedule_expression
        ]

instance P.HasDescription (CloudwatchEventRuleResource s) (TF.Attr s Text) where
    description =
        lens (_description :: CloudwatchEventRuleResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: CloudwatchEventRuleResource s)

instance P.HasEventPattern (CloudwatchEventRuleResource s) (TF.Attr s Text) where
    eventPattern =
        lens (_event_pattern :: CloudwatchEventRuleResource s -> TF.Attr s Text)
             (\s a -> s { _event_pattern = a } :: CloudwatchEventRuleResource s)

instance P.HasIsEnabled (CloudwatchEventRuleResource s) (TF.Attr s P.Bool) where
    isEnabled =
        lens (_is_enabled :: CloudwatchEventRuleResource s -> TF.Attr s P.Bool)
             (\s a -> s { _is_enabled = a } :: CloudwatchEventRuleResource s)

instance P.HasName (CloudwatchEventRuleResource s) (TF.Attr s Text) where
    name =
        lens (_name :: CloudwatchEventRuleResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: CloudwatchEventRuleResource s)

instance P.HasRoleArn (CloudwatchEventRuleResource s) (TF.Attr s Text) where
    roleArn =
        lens (_role_arn :: CloudwatchEventRuleResource s -> TF.Attr s Text)
             (\s a -> s { _role_arn = a } :: CloudwatchEventRuleResource s)

instance P.HasScheduleExpression (CloudwatchEventRuleResource s) (TF.Attr s Text) where
    scheduleExpression =
        lens (_schedule_expression :: CloudwatchEventRuleResource s -> TF.Attr s Text)
             (\s a -> s { _schedule_expression = a } :: CloudwatchEventRuleResource s)

instance P.HasComputedArn (CloudwatchEventRuleResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedDescription (CloudwatchEventRuleResource s) s (TF.Attr s Text) where
    computedDescription =
        (_description :: CloudwatchEventRuleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEventPattern (CloudwatchEventRuleResource s) s (TF.Attr s Text) where
    computedEventPattern =
        (_event_pattern :: CloudwatchEventRuleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedIsEnabled (CloudwatchEventRuleResource s) s (TF.Attr s P.Bool) where
    computedIsEnabled =
        (_is_enabled :: CloudwatchEventRuleResource s -> TF.Attr s P.Bool)
            . TF.refValue

instance P.HasComputedName (CloudwatchEventRuleResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: CloudwatchEventRuleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRoleArn (CloudwatchEventRuleResource s) s (TF.Attr s Text) where
    computedRoleArn =
        (_role_arn :: CloudwatchEventRuleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedScheduleExpression (CloudwatchEventRuleResource s) s (TF.Attr s Text) where
    computedScheduleExpression =
        (_schedule_expression :: CloudwatchEventRuleResource s -> TF.Attr s Text)
            . TF.refValue

cloudwatchEventRuleResource :: TF.Schema TF.Resource P.AWS (CloudwatchEventRuleResource s)
cloudwatchEventRuleResource =
    TF.newResource "aws_cloudwatch_event_rule" $
        CloudwatchEventRuleResource {
              _description = TF.Nil
            , _event_pattern = TF.Nil
            , _is_enabled = TF.Nil
            , _name = TF.Nil
            , _role_arn = TF.Nil
            , _schedule_expression = TF.Nil
            }

{- | The @aws_cloudwatch_event_target@ AWS resource.

Provides a CloudWatch Event Target resource.
-}
data CloudwatchEventTargetResource s = CloudwatchEventTargetResource {
      _arn                 :: !(TF.Attr s Text)
    {- ^ (Required) The Amazon Resource Name (ARN) associated of the target. -}
    , _ecs_target          :: !(TF.Attr s Text)
    {- ^ (Optional) Parameters used when you are using the rule to invoke Amazon ECS Task. Documented below. A maximum of 1 are allowed. -}
    , _input               :: !(TF.Attr s Text)
    {- ^ (Optional) Valid JSON text passed to the target. -}
    , _input_path          :: !(TF.Attr s Text)
    {- ^ (Optional) The value of the <http://goessner.net/articles/JsonPath/> that is used for extracting part of the matched event when passing it to the target. -}
    , _input_transformer   :: !(TF.Attr s Text)
    {- ^ (Optional) Parameters used when you are providing a custom input to a target based on certain event data. -}
    , _role_arn            :: !(TF.Attr s Text)
    {- ^ (Optional) The Amazon Resource Name (ARN) of the IAM role to be used for this target when the rule is triggered. Required if @ecs_target@ is used. -}
    , _rule                :: !(TF.Attr s Text)
    {- ^ (Required) The name of the rule you want to add targets to. -}
    , _run_command_targets :: !(TF.Attr s Text)
    {- ^ (Optional) Parameters used when you are using the rule to invoke Amazon EC2 Run Command. Documented below. A maximum of 5 are allowed. -}
    , _target_id           :: !(TF.Attr s Text)
    {- ^ (Optional) The unique target assignment ID.  If missing, will generate a random, unique id. -}
    } deriving (Show, Eq)

instance TF.ToHCL (CloudwatchEventTargetResource s) where
    toHCL CloudwatchEventTargetResource{..} = TF.inline $ catMaybes
        [ TF.assign "arn" <$> TF.attribute _arn
        , TF.assign "ecs_target" <$> TF.attribute _ecs_target
        , TF.assign "input" <$> TF.attribute _input
        , TF.assign "input_path" <$> TF.attribute _input_path
        , TF.assign "input_transformer" <$> TF.attribute _input_transformer
        , TF.assign "role_arn" <$> TF.attribute _role_arn
        , TF.assign "rule" <$> TF.attribute _rule
        , TF.assign "run_command_targets" <$> TF.attribute _run_command_targets
        , TF.assign "target_id" <$> TF.attribute _target_id
        ]

instance P.HasArn (CloudwatchEventTargetResource s) (TF.Attr s Text) where
    arn =
        lens (_arn :: CloudwatchEventTargetResource s -> TF.Attr s Text)
             (\s a -> s { _arn = a } :: CloudwatchEventTargetResource s)

instance P.HasEcsTarget (CloudwatchEventTargetResource s) (TF.Attr s Text) where
    ecsTarget =
        lens (_ecs_target :: CloudwatchEventTargetResource s -> TF.Attr s Text)
             (\s a -> s { _ecs_target = a } :: CloudwatchEventTargetResource s)

instance P.HasInput (CloudwatchEventTargetResource s) (TF.Attr s Text) where
    input =
        lens (_input :: CloudwatchEventTargetResource s -> TF.Attr s Text)
             (\s a -> s { _input = a } :: CloudwatchEventTargetResource s)

instance P.HasInputPath (CloudwatchEventTargetResource s) (TF.Attr s Text) where
    inputPath =
        lens (_input_path :: CloudwatchEventTargetResource s -> TF.Attr s Text)
             (\s a -> s { _input_path = a } :: CloudwatchEventTargetResource s)

instance P.HasInputTransformer (CloudwatchEventTargetResource s) (TF.Attr s Text) where
    inputTransformer =
        lens (_input_transformer :: CloudwatchEventTargetResource s -> TF.Attr s Text)
             (\s a -> s { _input_transformer = a } :: CloudwatchEventTargetResource s)

instance P.HasRoleArn (CloudwatchEventTargetResource s) (TF.Attr s Text) where
    roleArn =
        lens (_role_arn :: CloudwatchEventTargetResource s -> TF.Attr s Text)
             (\s a -> s { _role_arn = a } :: CloudwatchEventTargetResource s)

instance P.HasRule (CloudwatchEventTargetResource s) (TF.Attr s Text) where
    rule =
        lens (_rule :: CloudwatchEventTargetResource s -> TF.Attr s Text)
             (\s a -> s { _rule = a } :: CloudwatchEventTargetResource s)

instance P.HasRunCommandTargets (CloudwatchEventTargetResource s) (TF.Attr s Text) where
    runCommandTargets =
        lens (_run_command_targets :: CloudwatchEventTargetResource s -> TF.Attr s Text)
             (\s a -> s { _run_command_targets = a } :: CloudwatchEventTargetResource s)

instance P.HasTargetId (CloudwatchEventTargetResource s) (TF.Attr s Text) where
    targetId =
        lens (_target_id :: CloudwatchEventTargetResource s -> TF.Attr s Text)
             (\s a -> s { _target_id = a } :: CloudwatchEventTargetResource s)

instance P.HasComputedArn (CloudwatchEventTargetResource s) s (TF.Attr s Text) where
    computedArn =
        (_arn :: CloudwatchEventTargetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEcsTarget (CloudwatchEventTargetResource s) s (TF.Attr s Text) where
    computedEcsTarget =
        (_ecs_target :: CloudwatchEventTargetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedInput (CloudwatchEventTargetResource s) s (TF.Attr s Text) where
    computedInput =
        (_input :: CloudwatchEventTargetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedInputPath (CloudwatchEventTargetResource s) s (TF.Attr s Text) where
    computedInputPath =
        (_input_path :: CloudwatchEventTargetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedInputTransformer (CloudwatchEventTargetResource s) s (TF.Attr s Text) where
    computedInputTransformer =
        (_input_transformer :: CloudwatchEventTargetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRoleArn (CloudwatchEventTargetResource s) s (TF.Attr s Text) where
    computedRoleArn =
        (_role_arn :: CloudwatchEventTargetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRule (CloudwatchEventTargetResource s) s (TF.Attr s Text) where
    computedRule =
        (_rule :: CloudwatchEventTargetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRunCommandTargets (CloudwatchEventTargetResource s) s (TF.Attr s Text) where
    computedRunCommandTargets =
        (_run_command_targets :: CloudwatchEventTargetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTargetId (CloudwatchEventTargetResource s) s (TF.Attr s Text) where
    computedTargetId =
        (_target_id :: CloudwatchEventTargetResource s -> TF.Attr s Text)
            . TF.refValue

cloudwatchEventTargetResource :: TF.Schema TF.Resource P.AWS (CloudwatchEventTargetResource s)
cloudwatchEventTargetResource =
    TF.newResource "aws_cloudwatch_event_target" $
        CloudwatchEventTargetResource {
              _arn = TF.Nil
            , _ecs_target = TF.Nil
            , _input = TF.Nil
            , _input_path = TF.Nil
            , _input_transformer = TF.Nil
            , _role_arn = TF.Nil
            , _rule = TF.Nil
            , _run_command_targets = TF.Nil
            , _target_id = TF.Nil
            }

{- | The @aws_cloudwatch_log_destination_policy@ AWS resource.

Provides a CloudWatch Logs destination policy resource.
-}
data CloudwatchLogDestinationPolicyResource s = CloudwatchLogDestinationPolicyResource {
      _access_policy    :: !(TF.Attr s Text)
    {- ^ (Required) The policy document. This is a JSON formatted string. -}
    , _destination_name :: !(TF.Attr s Text)
    {- ^ (Required) A name for the subscription filter -}
    } deriving (Show, Eq)

instance TF.ToHCL (CloudwatchLogDestinationPolicyResource s) where
    toHCL CloudwatchLogDestinationPolicyResource{..} = TF.inline $ catMaybes
        [ TF.assign "access_policy" <$> TF.attribute _access_policy
        , TF.assign "destination_name" <$> TF.attribute _destination_name
        ]

instance P.HasAccessPolicy (CloudwatchLogDestinationPolicyResource s) (TF.Attr s Text) where
    accessPolicy =
        lens (_access_policy :: CloudwatchLogDestinationPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _access_policy = a } :: CloudwatchLogDestinationPolicyResource s)

instance P.HasDestinationName (CloudwatchLogDestinationPolicyResource s) (TF.Attr s Text) where
    destinationName =
        lens (_destination_name :: CloudwatchLogDestinationPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _destination_name = a } :: CloudwatchLogDestinationPolicyResource s)

instance P.HasComputedAccessPolicy (CloudwatchLogDestinationPolicyResource s) s (TF.Attr s Text) where
    computedAccessPolicy =
        (_access_policy :: CloudwatchLogDestinationPolicyResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDestinationName (CloudwatchLogDestinationPolicyResource s) s (TF.Attr s Text) where
    computedDestinationName =
        (_destination_name :: CloudwatchLogDestinationPolicyResource s -> TF.Attr s Text)
            . TF.refValue

cloudwatchLogDestinationPolicyResource :: TF.Schema TF.Resource P.AWS (CloudwatchLogDestinationPolicyResource s)
cloudwatchLogDestinationPolicyResource =
    TF.newResource "aws_cloudwatch_log_destination_policy" $
        CloudwatchLogDestinationPolicyResource {
              _access_policy = TF.Nil
            , _destination_name = TF.Nil
            }

{- | The @aws_cloudwatch_log_destination@ AWS resource.

Provides a CloudWatch Logs destination resource.
-}
data CloudwatchLogDestinationResource s = CloudwatchLogDestinationResource {
      _name       :: !(TF.Attr s Text)
    {- ^ (Required) A name for the log destination -}
    , _role_arn   :: !(TF.Attr s Text)
    {- ^ (Required) The ARN of an IAM role that grants Amazon CloudWatch Logs permissions to put data into the target -}
    , _target_arn :: !(TF.Attr s Text)
    {- ^ (Required) The ARN of the target Amazon Kinesis stream or Amazon Lambda resource for the destination -}
    } deriving (Show, Eq)

instance TF.ToHCL (CloudwatchLogDestinationResource s) where
    toHCL CloudwatchLogDestinationResource{..} = TF.inline $ catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "role_arn" <$> TF.attribute _role_arn
        , TF.assign "target_arn" <$> TF.attribute _target_arn
        ]

instance P.HasName (CloudwatchLogDestinationResource s) (TF.Attr s Text) where
    name =
        lens (_name :: CloudwatchLogDestinationResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: CloudwatchLogDestinationResource s)

instance P.HasRoleArn (CloudwatchLogDestinationResource s) (TF.Attr s Text) where
    roleArn =
        lens (_role_arn :: CloudwatchLogDestinationResource s -> TF.Attr s Text)
             (\s a -> s { _role_arn = a } :: CloudwatchLogDestinationResource s)

instance P.HasTargetArn (CloudwatchLogDestinationResource s) (TF.Attr s Text) where
    targetArn =
        lens (_target_arn :: CloudwatchLogDestinationResource s -> TF.Attr s Text)
             (\s a -> s { _target_arn = a } :: CloudwatchLogDestinationResource s)

instance P.HasComputedArn (CloudwatchLogDestinationResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedName (CloudwatchLogDestinationResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: CloudwatchLogDestinationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRoleArn (CloudwatchLogDestinationResource s) s (TF.Attr s Text) where
    computedRoleArn =
        (_role_arn :: CloudwatchLogDestinationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTargetArn (CloudwatchLogDestinationResource s) s (TF.Attr s Text) where
    computedTargetArn =
        (_target_arn :: CloudwatchLogDestinationResource s -> TF.Attr s Text)
            . TF.refValue

cloudwatchLogDestinationResource :: TF.Schema TF.Resource P.AWS (CloudwatchLogDestinationResource s)
cloudwatchLogDestinationResource =
    TF.newResource "aws_cloudwatch_log_destination" $
        CloudwatchLogDestinationResource {
              _name = TF.Nil
            , _role_arn = TF.Nil
            , _target_arn = TF.Nil
            }

{- | The @aws_cloudwatch_log_group@ AWS resource.

Provides a CloudWatch Log Group resource.
-}
data CloudwatchLogGroupResource s = CloudwatchLogGroupResource {
      _kms_key_id        :: !(TF.Attr s Text)
    {- ^ (Optional) The ARN of the KMS Key to use when encrypting log data. Please note, after the AWS KMS CMK is disassociated from the log group, AWS CloudWatch Logs stops encrypting newly ingested data for the log group. All previously ingested data remains encrypted, and AWS CloudWatch Logs requires permissions for the CMK whenever the encrypted data is requested. -}
    , _name              :: !(TF.Attr s Text)
    {- ^ (Optional, Forces new resource) The name of the log group. If omitted, Terraform will assign a random, unique name. -}
    , _name_prefix       :: !(TF.Attr s Text)
    {- ^ (Optional, Forces new resource) Creates a unique name beginning with the specified prefix. Conflicts with @name@ . -}
    , _retention_in_days :: !(TF.Attr s Text)
    {- ^ (Optional) Specifies the number of days you want to retain log events in the specified log group. -}
    , _tags              :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    } deriving (Show, Eq)

instance TF.ToHCL (CloudwatchLogGroupResource s) where
    toHCL CloudwatchLogGroupResource{..} = TF.inline $ catMaybes
        [ TF.assign "kms_key_id" <$> TF.attribute _kms_key_id
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "name_prefix" <$> TF.attribute _name_prefix
        , TF.assign "retention_in_days" <$> TF.attribute _retention_in_days
        , TF.assign "tags" <$> TF.attribute _tags
        ]

instance P.HasKmsKeyId (CloudwatchLogGroupResource s) (TF.Attr s Text) where
    kmsKeyId =
        lens (_kms_key_id :: CloudwatchLogGroupResource s -> TF.Attr s Text)
             (\s a -> s { _kms_key_id = a } :: CloudwatchLogGroupResource s)

instance P.HasName (CloudwatchLogGroupResource s) (TF.Attr s Text) where
    name =
        lens (_name :: CloudwatchLogGroupResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: CloudwatchLogGroupResource s)

instance P.HasNamePrefix (CloudwatchLogGroupResource s) (TF.Attr s Text) where
    namePrefix =
        lens (_name_prefix :: CloudwatchLogGroupResource s -> TF.Attr s Text)
             (\s a -> s { _name_prefix = a } :: CloudwatchLogGroupResource s)

instance P.HasRetentionInDays (CloudwatchLogGroupResource s) (TF.Attr s Text) where
    retentionInDays =
        lens (_retention_in_days :: CloudwatchLogGroupResource s -> TF.Attr s Text)
             (\s a -> s { _retention_in_days = a } :: CloudwatchLogGroupResource s)

instance P.HasTags (CloudwatchLogGroupResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: CloudwatchLogGroupResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: CloudwatchLogGroupResource s)

instance P.HasComputedArn (CloudwatchLogGroupResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedKmsKeyId (CloudwatchLogGroupResource s) s (TF.Attr s Text) where
    computedKmsKeyId =
        (_kms_key_id :: CloudwatchLogGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (CloudwatchLogGroupResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: CloudwatchLogGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedNamePrefix (CloudwatchLogGroupResource s) s (TF.Attr s Text) where
    computedNamePrefix =
        (_name_prefix :: CloudwatchLogGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRetentionInDays (CloudwatchLogGroupResource s) s (TF.Attr s Text) where
    computedRetentionInDays =
        (_retention_in_days :: CloudwatchLogGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (CloudwatchLogGroupResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: CloudwatchLogGroupResource s -> TF.Attr s P.Tags)
            . TF.refValue

cloudwatchLogGroupResource :: TF.Schema TF.Resource P.AWS (CloudwatchLogGroupResource s)
cloudwatchLogGroupResource =
    TF.newResource "aws_cloudwatch_log_group" $
        CloudwatchLogGroupResource {
              _kms_key_id = TF.Nil
            , _name = TF.Nil
            , _name_prefix = TF.Nil
            , _retention_in_days = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_cloudwatch_log_metric_filter@ AWS resource.

Provides a CloudWatch Log Metric Filter resource.
-}
data CloudwatchLogMetricFilterResource s = CloudwatchLogMetricFilterResource {
      _log_group_name        :: !(TF.Attr s Text)
    {- ^ (Required) The name of the log group to associate the metric filter with. -}
    , _metric_transformation :: !(TF.Attr s Text)
    {- ^ (Required) A block defining collection of information needed to define how metric data gets emitted. See below. -}
    , _name                  :: !(TF.Attr s Text)
    {- ^ (Required) A name for the metric filter. -}
    , _pattern               :: !(TF.Attr s Text)
    {- ^ (Required) A valid <https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/FilterAndPatternSyntax.html> for extracting metric data out of ingested log events. -}
    } deriving (Show, Eq)

instance TF.ToHCL (CloudwatchLogMetricFilterResource s) where
    toHCL CloudwatchLogMetricFilterResource{..} = TF.inline $ catMaybes
        [ TF.assign "log_group_name" <$> TF.attribute _log_group_name
        , TF.assign "metric_transformation" <$> TF.attribute _metric_transformation
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "pattern" <$> TF.attribute _pattern
        ]

instance P.HasLogGroupName (CloudwatchLogMetricFilterResource s) (TF.Attr s Text) where
    logGroupName =
        lens (_log_group_name :: CloudwatchLogMetricFilterResource s -> TF.Attr s Text)
             (\s a -> s { _log_group_name = a } :: CloudwatchLogMetricFilterResource s)

instance P.HasMetricTransformation (CloudwatchLogMetricFilterResource s) (TF.Attr s Text) where
    metricTransformation =
        lens (_metric_transformation :: CloudwatchLogMetricFilterResource s -> TF.Attr s Text)
             (\s a -> s { _metric_transformation = a } :: CloudwatchLogMetricFilterResource s)

instance P.HasName (CloudwatchLogMetricFilterResource s) (TF.Attr s Text) where
    name =
        lens (_name :: CloudwatchLogMetricFilterResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: CloudwatchLogMetricFilterResource s)

instance P.HasPattern (CloudwatchLogMetricFilterResource s) (TF.Attr s Text) where
    pattern =
        lens (_pattern :: CloudwatchLogMetricFilterResource s -> TF.Attr s Text)
             (\s a -> s { _pattern = a } :: CloudwatchLogMetricFilterResource s)

instance P.HasComputedId (CloudwatchLogMetricFilterResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedLogGroupName (CloudwatchLogMetricFilterResource s) s (TF.Attr s Text) where
    computedLogGroupName =
        (_log_group_name :: CloudwatchLogMetricFilterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedMetricTransformation (CloudwatchLogMetricFilterResource s) s (TF.Attr s Text) where
    computedMetricTransformation =
        (_metric_transformation :: CloudwatchLogMetricFilterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (CloudwatchLogMetricFilterResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: CloudwatchLogMetricFilterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPattern (CloudwatchLogMetricFilterResource s) s (TF.Attr s Text) where
    computedPattern =
        (_pattern :: CloudwatchLogMetricFilterResource s -> TF.Attr s Text)
            . TF.refValue

cloudwatchLogMetricFilterResource :: TF.Schema TF.Resource P.AWS (CloudwatchLogMetricFilterResource s)
cloudwatchLogMetricFilterResource =
    TF.newResource "aws_cloudwatch_log_metric_filter" $
        CloudwatchLogMetricFilterResource {
              _log_group_name = TF.Nil
            , _metric_transformation = TF.Nil
            , _name = TF.Nil
            , _pattern = TF.Nil
            }

{- | The @aws_cloudwatch_log_resource_policy@ AWS resource.

Provides a resource to manage a CloudWatch log resource policy.
-}
data CloudwatchLogResourcePolicyResource s = CloudwatchLogResourcePolicyResource {
      _policy_document :: !(TF.Attr s Text)
    {- ^ (Required) Details of the resource policy, including the identity of the principal that is enabled to put logs to this account. This is formatted as a JSON string. Maximum length of 5120 characters. -}
    , _policy_name     :: !(TF.Attr s Text)
    {- ^ (Required) Name of the resource policy. -}
    } deriving (Show, Eq)

instance TF.ToHCL (CloudwatchLogResourcePolicyResource s) where
    toHCL CloudwatchLogResourcePolicyResource{..} = TF.inline $ catMaybes
        [ TF.assign "policy_document" <$> TF.attribute _policy_document
        , TF.assign "policy_name" <$> TF.attribute _policy_name
        ]

instance P.HasPolicyDocument (CloudwatchLogResourcePolicyResource s) (TF.Attr s Text) where
    policyDocument =
        lens (_policy_document :: CloudwatchLogResourcePolicyResource s -> TF.Attr s Text)
             (\s a -> s { _policy_document = a } :: CloudwatchLogResourcePolicyResource s)

instance P.HasPolicyName (CloudwatchLogResourcePolicyResource s) (TF.Attr s Text) where
    policyName =
        lens (_policy_name :: CloudwatchLogResourcePolicyResource s -> TF.Attr s Text)
             (\s a -> s { _policy_name = a } :: CloudwatchLogResourcePolicyResource s)

instance P.HasComputedId (CloudwatchLogResourcePolicyResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedPolicyDocument (CloudwatchLogResourcePolicyResource s) s (TF.Attr s Text) where
    computedPolicyDocument =
        (_policy_document :: CloudwatchLogResourcePolicyResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPolicyName (CloudwatchLogResourcePolicyResource s) s (TF.Attr s Text) where
    computedPolicyName =
        (_policy_name :: CloudwatchLogResourcePolicyResource s -> TF.Attr s Text)
            . TF.refValue

cloudwatchLogResourcePolicyResource :: TF.Schema TF.Resource P.AWS (CloudwatchLogResourcePolicyResource s)
cloudwatchLogResourcePolicyResource =
    TF.newResource "aws_cloudwatch_log_resource_policy" $
        CloudwatchLogResourcePolicyResource {
              _policy_document = TF.Nil
            , _policy_name = TF.Nil
            }

{- | The @aws_cloudwatch_log_stream@ AWS resource.

Provides a CloudWatch Log Stream resource.
-}
data CloudwatchLogStreamResource s = CloudwatchLogStreamResource {
      _log_group_name :: !(TF.Attr s Text)
    {- ^ (Required) The name of the log group under which the log stream is to be created. -}
    , _name           :: !(TF.Attr s Text)
    {- ^ (Required) The name of the log stream. Must not be longer than 512 characters and must not contain @:@ -}
    } deriving (Show, Eq)

instance TF.ToHCL (CloudwatchLogStreamResource s) where
    toHCL CloudwatchLogStreamResource{..} = TF.inline $ catMaybes
        [ TF.assign "log_group_name" <$> TF.attribute _log_group_name
        , TF.assign "name" <$> TF.attribute _name
        ]

instance P.HasLogGroupName (CloudwatchLogStreamResource s) (TF.Attr s Text) where
    logGroupName =
        lens (_log_group_name :: CloudwatchLogStreamResource s -> TF.Attr s Text)
             (\s a -> s { _log_group_name = a } :: CloudwatchLogStreamResource s)

instance P.HasName (CloudwatchLogStreamResource s) (TF.Attr s Text) where
    name =
        lens (_name :: CloudwatchLogStreamResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: CloudwatchLogStreamResource s)

instance P.HasComputedArn (CloudwatchLogStreamResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedLogGroupName (CloudwatchLogStreamResource s) s (TF.Attr s Text) where
    computedLogGroupName =
        (_log_group_name :: CloudwatchLogStreamResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (CloudwatchLogStreamResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: CloudwatchLogStreamResource s -> TF.Attr s Text)
            . TF.refValue

cloudwatchLogStreamResource :: TF.Schema TF.Resource P.AWS (CloudwatchLogStreamResource s)
cloudwatchLogStreamResource =
    TF.newResource "aws_cloudwatch_log_stream" $
        CloudwatchLogStreamResource {
              _log_group_name = TF.Nil
            , _name = TF.Nil
            }

{- | The @aws_cloudwatch_log_subscription_filter@ AWS resource.

Provides a CloudWatch Logs subscription filter resource.
-}
data CloudwatchLogSubscriptionFilterResource s = CloudwatchLogSubscriptionFilterResource {
      _destination_arn :: !(TF.Attr s Text)
    {- ^ (Required) The ARN of the destination to deliver matching log events to. Kinesis stream or Lambda function ARN. -}
    , _distribution    :: !(TF.Attr s Text)
    {- ^ (Optional) The method used to distribute log data to the destination. By default log data is grouped by log stream, but the grouping can be set to random for a more even distribution. This property is only applicable when the destination is an Amazon Kinesis stream. Valid values are "Random" and "ByLogStream". -}
    , _filter_pattern  :: !(TF.Attr s Text)
    {- ^ (Required) A valid CloudWatch Logs filter pattern for subscribing to a filtered stream of log events. -}
    , _log_group_name  :: !(TF.Attr s Text)
    {- ^ (Required) The name of the log group to associate the subscription filter with -}
    , _name            :: !(TF.Attr s Text)
    {- ^ (Required) A name for the subscription filter -}
    , _role_arn        :: !(TF.Attr s Text)
    {- ^ (Optional) The ARN of an IAM role that grants Amazon CloudWatch Logs permissions to deliver ingested log events to the destination. If you use Lambda as a destination, you should skip this argument and use @aws_lambda_permission@ resource for granting access from CloudWatch logs to the destination Lambda function. -}
    } deriving (Show, Eq)

instance TF.ToHCL (CloudwatchLogSubscriptionFilterResource s) where
    toHCL CloudwatchLogSubscriptionFilterResource{..} = TF.inline $ catMaybes
        [ TF.assign "destination_arn" <$> TF.attribute _destination_arn
        , TF.assign "distribution" <$> TF.attribute _distribution
        , TF.assign "filter_pattern" <$> TF.attribute _filter_pattern
        , TF.assign "log_group_name" <$> TF.attribute _log_group_name
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "role_arn" <$> TF.attribute _role_arn
        ]

instance P.HasDestinationArn (CloudwatchLogSubscriptionFilterResource s) (TF.Attr s Text) where
    destinationArn =
        lens (_destination_arn :: CloudwatchLogSubscriptionFilterResource s -> TF.Attr s Text)
             (\s a -> s { _destination_arn = a } :: CloudwatchLogSubscriptionFilterResource s)

instance P.HasDistribution (CloudwatchLogSubscriptionFilterResource s) (TF.Attr s Text) where
    distribution =
        lens (_distribution :: CloudwatchLogSubscriptionFilterResource s -> TF.Attr s Text)
             (\s a -> s { _distribution = a } :: CloudwatchLogSubscriptionFilterResource s)

instance P.HasFilterPattern (CloudwatchLogSubscriptionFilterResource s) (TF.Attr s Text) where
    filterPattern =
        lens (_filter_pattern :: CloudwatchLogSubscriptionFilterResource s -> TF.Attr s Text)
             (\s a -> s { _filter_pattern = a } :: CloudwatchLogSubscriptionFilterResource s)

instance P.HasLogGroupName (CloudwatchLogSubscriptionFilterResource s) (TF.Attr s Text) where
    logGroupName =
        lens (_log_group_name :: CloudwatchLogSubscriptionFilterResource s -> TF.Attr s Text)
             (\s a -> s { _log_group_name = a } :: CloudwatchLogSubscriptionFilterResource s)

instance P.HasName (CloudwatchLogSubscriptionFilterResource s) (TF.Attr s Text) where
    name =
        lens (_name :: CloudwatchLogSubscriptionFilterResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: CloudwatchLogSubscriptionFilterResource s)

instance P.HasRoleArn (CloudwatchLogSubscriptionFilterResource s) (TF.Attr s Text) where
    roleArn =
        lens (_role_arn :: CloudwatchLogSubscriptionFilterResource s -> TF.Attr s Text)
             (\s a -> s { _role_arn = a } :: CloudwatchLogSubscriptionFilterResource s)

instance P.HasComputedDestinationArn (CloudwatchLogSubscriptionFilterResource s) s (TF.Attr s Text) where
    computedDestinationArn =
        (_destination_arn :: CloudwatchLogSubscriptionFilterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDistribution (CloudwatchLogSubscriptionFilterResource s) s (TF.Attr s Text) where
    computedDistribution =
        (_distribution :: CloudwatchLogSubscriptionFilterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedFilterPattern (CloudwatchLogSubscriptionFilterResource s) s (TF.Attr s Text) where
    computedFilterPattern =
        (_filter_pattern :: CloudwatchLogSubscriptionFilterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedLogGroupName (CloudwatchLogSubscriptionFilterResource s) s (TF.Attr s Text) where
    computedLogGroupName =
        (_log_group_name :: CloudwatchLogSubscriptionFilterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (CloudwatchLogSubscriptionFilterResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: CloudwatchLogSubscriptionFilterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRoleArn (CloudwatchLogSubscriptionFilterResource s) s (TF.Attr s Text) where
    computedRoleArn =
        (_role_arn :: CloudwatchLogSubscriptionFilterResource s -> TF.Attr s Text)
            . TF.refValue

cloudwatchLogSubscriptionFilterResource :: TF.Schema TF.Resource P.AWS (CloudwatchLogSubscriptionFilterResource s)
cloudwatchLogSubscriptionFilterResource =
    TF.newResource "aws_cloudwatch_log_subscription_filter" $
        CloudwatchLogSubscriptionFilterResource {
              _destination_arn = TF.Nil
            , _distribution = TF.Nil
            , _filter_pattern = TF.Nil
            , _log_group_name = TF.Nil
            , _name = TF.Nil
            , _role_arn = TF.Nil
            }

{- | The @aws_cloudwatch_metric_alarm@ AWS resource.

Provides a CloudWatch Metric Alarm resource.
-}
data CloudwatchMetricAlarmResource s = CloudwatchMetricAlarmResource {
      _actions_enabled                       :: !(TF.Attr s P.Bool)
    {- ^ (Optional) Indicates whether or not actions should be executed during any changes to the alarm's state. Defaults to @true@ . -}
    , _alarm_actions                         :: !(TF.Attr s Text)
    {- ^ (Optional) The list of actions to execute when this alarm transitions into an ALARM state from any other state. Each action is specified as an Amazon Resource Number (ARN). -}
    , _alarm_description                     :: !(TF.Attr s Text)
    {- ^ (Optional) The description for the alarm. -}
    , _alarm_name                            :: !(TF.Attr s Text)
    {- ^ (Required) The descriptive name for the alarm. This name must be unique within the user's AWS account -}
    , _comparison_operator                   :: !(TF.Attr s Text)
    {- ^ (Required) The arithmetic operation to use when comparing the specified Statistic and Threshold. The specified Statistic value is used as the first operand. Either of the following is supported: @GreaterThanOrEqualToThreshold@ , @GreaterThanThreshold@ , @LessThanThreshold@ , @LessThanOrEqualToThreshold@ . -}
    , _datapoints_to_alarm                   :: !(TF.Attr s Text)
    {- ^ (Optional) The number of datapoints that must be breaching to trigger the alarm. -}
    , _dimensions                            :: !(TF.Attr s Text)
    {- ^ (Optional) The dimensions for the alarm's associated metric.  For the list of available dimensions see the AWS documentation <http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/CW_Support_For_AWS.html> . -}
    , _evaluate_low_sample_count_percentiles :: !(TF.Attr s Text)
    {- ^ (Optional) Used only for alarms based on percentiles. If you specify @ignore@ , the alarm state will not change during periods with too few data points to be statistically significant. If you specify @evaluate@ or omit this parameter, the alarm will always be evaluated and possibly change state no matter how many data points are available. The following values are supported: @ignore@ , and @evaluate@ . -}
    , _evaluation_periods                    :: !(TF.Attr s Text)
    {- ^ (Required) The number of periods over which data is compared to the specified threshold. -}
    , _extended_statistic                    :: !(TF.Attr s Text)
    {- ^ (Optional) The percentile statistic for the metric associated with the alarm. Specify a value between p0.0 and p100. -}
    , _insufficient_data_actions             :: !(TF.Attr s Text)
    {- ^ (Optional) The list of actions to execute when this alarm transitions into an INSUFFICIENT_DATA state from any other state. Each action is specified as an Amazon Resource Number (ARN). -}
    , _metric_name                           :: !(TF.Attr s Text)
    {- ^ (Required) The name for the alarm's associated metric. See docs for <https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/CW_Support_For_AWS.html> . -}
    , _namespace                             :: !(TF.Attr s Text)
    {- ^ (Required) The namespace for the alarm's associated metric. See docs for the <https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/aws-namespaces.html> . See docs for <https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/CW_Support_For_AWS.html> . -}
    , _ok_actions                            :: !(TF.Attr s Text)
    {- ^ (Optional) The list of actions to execute when this alarm transitions into an OK state from any other state. Each action is specified as an Amazon Resource Number (ARN). -}
    , _period                                :: !(TF.Attr s Text)
    {- ^ (Required) The period in seconds over which the specified @statistic@ is applied. -}
    , _statistic                             :: !(TF.Attr s Text)
    {- ^ (Optional) The statistic to apply to the alarm's associated metric. Either of the following is supported: @SampleCount@ , @Average@ , @Sum@ , @Minimum@ , @Maximum@ -}
    , _threshold                             :: !(TF.Attr s Text)
    {- ^ (Required) The value against which the specified statistic is compared. -}
    , _treat_missing_data                    :: !(TF.Attr s Text)
    {- ^ (Optional) Sets how this alarm is to handle missing data points. The following values are supported: @missing@ , @ignore@ , @breaching@ and @notBreaching@ . Defaults to @missing@ . -}
    , _unit                                  :: !(TF.Attr s Text)
    {- ^ (Optional) The unit for the alarm's associated metric. -}
    } deriving (Show, Eq)

instance TF.ToHCL (CloudwatchMetricAlarmResource s) where
    toHCL CloudwatchMetricAlarmResource{..} = TF.inline $ catMaybes
        [ TF.assign "actions_enabled" <$> TF.attribute _actions_enabled
        , TF.assign "alarm_actions" <$> TF.attribute _alarm_actions
        , TF.assign "alarm_description" <$> TF.attribute _alarm_description
        , TF.assign "alarm_name" <$> TF.attribute _alarm_name
        , TF.assign "comparison_operator" <$> TF.attribute _comparison_operator
        , TF.assign "datapoints_to_alarm" <$> TF.attribute _datapoints_to_alarm
        , TF.assign "dimensions" <$> TF.attribute _dimensions
        , TF.assign "evaluate_low_sample_count_percentiles" <$> TF.attribute _evaluate_low_sample_count_percentiles
        , TF.assign "evaluation_periods" <$> TF.attribute _evaluation_periods
        , TF.assign "extended_statistic" <$> TF.attribute _extended_statistic
        , TF.assign "insufficient_data_actions" <$> TF.attribute _insufficient_data_actions
        , TF.assign "metric_name" <$> TF.attribute _metric_name
        , TF.assign "namespace" <$> TF.attribute _namespace
        , TF.assign "ok_actions" <$> TF.attribute _ok_actions
        , TF.assign "period" <$> TF.attribute _period
        , TF.assign "statistic" <$> TF.attribute _statistic
        , TF.assign "threshold" <$> TF.attribute _threshold
        , TF.assign "treat_missing_data" <$> TF.attribute _treat_missing_data
        , TF.assign "unit" <$> TF.attribute _unit
        ]

instance P.HasActionsEnabled (CloudwatchMetricAlarmResource s) (TF.Attr s P.Bool) where
    actionsEnabled =
        lens (_actions_enabled :: CloudwatchMetricAlarmResource s -> TF.Attr s P.Bool)
             (\s a -> s { _actions_enabled = a } :: CloudwatchMetricAlarmResource s)

instance P.HasAlarmActions (CloudwatchMetricAlarmResource s) (TF.Attr s Text) where
    alarmActions =
        lens (_alarm_actions :: CloudwatchMetricAlarmResource s -> TF.Attr s Text)
             (\s a -> s { _alarm_actions = a } :: CloudwatchMetricAlarmResource s)

instance P.HasAlarmDescription (CloudwatchMetricAlarmResource s) (TF.Attr s Text) where
    alarmDescription =
        lens (_alarm_description :: CloudwatchMetricAlarmResource s -> TF.Attr s Text)
             (\s a -> s { _alarm_description = a } :: CloudwatchMetricAlarmResource s)

instance P.HasAlarmName (CloudwatchMetricAlarmResource s) (TF.Attr s Text) where
    alarmName =
        lens (_alarm_name :: CloudwatchMetricAlarmResource s -> TF.Attr s Text)
             (\s a -> s { _alarm_name = a } :: CloudwatchMetricAlarmResource s)

instance P.HasComparisonOperator (CloudwatchMetricAlarmResource s) (TF.Attr s Text) where
    comparisonOperator =
        lens (_comparison_operator :: CloudwatchMetricAlarmResource s -> TF.Attr s Text)
             (\s a -> s { _comparison_operator = a } :: CloudwatchMetricAlarmResource s)

instance P.HasDatapointsToAlarm (CloudwatchMetricAlarmResource s) (TF.Attr s Text) where
    datapointsToAlarm =
        lens (_datapoints_to_alarm :: CloudwatchMetricAlarmResource s -> TF.Attr s Text)
             (\s a -> s { _datapoints_to_alarm = a } :: CloudwatchMetricAlarmResource s)

instance P.HasDimensions (CloudwatchMetricAlarmResource s) (TF.Attr s Text) where
    dimensions =
        lens (_dimensions :: CloudwatchMetricAlarmResource s -> TF.Attr s Text)
             (\s a -> s { _dimensions = a } :: CloudwatchMetricAlarmResource s)

instance P.HasEvaluateLowSampleCountPercentiles (CloudwatchMetricAlarmResource s) (TF.Attr s Text) where
    evaluateLowSampleCountPercentiles =
        lens (_evaluate_low_sample_count_percentiles :: CloudwatchMetricAlarmResource s -> TF.Attr s Text)
             (\s a -> s { _evaluate_low_sample_count_percentiles = a } :: CloudwatchMetricAlarmResource s)

instance P.HasEvaluationPeriods (CloudwatchMetricAlarmResource s) (TF.Attr s Text) where
    evaluationPeriods =
        lens (_evaluation_periods :: CloudwatchMetricAlarmResource s -> TF.Attr s Text)
             (\s a -> s { _evaluation_periods = a } :: CloudwatchMetricAlarmResource s)

instance P.HasExtendedStatistic (CloudwatchMetricAlarmResource s) (TF.Attr s Text) where
    extendedStatistic =
        lens (_extended_statistic :: CloudwatchMetricAlarmResource s -> TF.Attr s Text)
             (\s a -> s { _extended_statistic = a } :: CloudwatchMetricAlarmResource s)

instance P.HasInsufficientDataActions (CloudwatchMetricAlarmResource s) (TF.Attr s Text) where
    insufficientDataActions =
        lens (_insufficient_data_actions :: CloudwatchMetricAlarmResource s -> TF.Attr s Text)
             (\s a -> s { _insufficient_data_actions = a } :: CloudwatchMetricAlarmResource s)

instance P.HasMetricName (CloudwatchMetricAlarmResource s) (TF.Attr s Text) where
    metricName =
        lens (_metric_name :: CloudwatchMetricAlarmResource s -> TF.Attr s Text)
             (\s a -> s { _metric_name = a } :: CloudwatchMetricAlarmResource s)

instance P.HasNamespace (CloudwatchMetricAlarmResource s) (TF.Attr s Text) where
    namespace =
        lens (_namespace :: CloudwatchMetricAlarmResource s -> TF.Attr s Text)
             (\s a -> s { _namespace = a } :: CloudwatchMetricAlarmResource s)

instance P.HasOkActions (CloudwatchMetricAlarmResource s) (TF.Attr s Text) where
    okActions =
        lens (_ok_actions :: CloudwatchMetricAlarmResource s -> TF.Attr s Text)
             (\s a -> s { _ok_actions = a } :: CloudwatchMetricAlarmResource s)

instance P.HasPeriod (CloudwatchMetricAlarmResource s) (TF.Attr s Text) where
    period =
        lens (_period :: CloudwatchMetricAlarmResource s -> TF.Attr s Text)
             (\s a -> s { _period = a } :: CloudwatchMetricAlarmResource s)

instance P.HasStatistic (CloudwatchMetricAlarmResource s) (TF.Attr s Text) where
    statistic =
        lens (_statistic :: CloudwatchMetricAlarmResource s -> TF.Attr s Text)
             (\s a -> s { _statistic = a } :: CloudwatchMetricAlarmResource s)

instance P.HasThreshold (CloudwatchMetricAlarmResource s) (TF.Attr s Text) where
    threshold =
        lens (_threshold :: CloudwatchMetricAlarmResource s -> TF.Attr s Text)
             (\s a -> s { _threshold = a } :: CloudwatchMetricAlarmResource s)

instance P.HasTreatMissingData (CloudwatchMetricAlarmResource s) (TF.Attr s Text) where
    treatMissingData =
        lens (_treat_missing_data :: CloudwatchMetricAlarmResource s -> TF.Attr s Text)
             (\s a -> s { _treat_missing_data = a } :: CloudwatchMetricAlarmResource s)

instance P.HasUnit (CloudwatchMetricAlarmResource s) (TF.Attr s Text) where
    unit =
        lens (_unit :: CloudwatchMetricAlarmResource s -> TF.Attr s Text)
             (\s a -> s { _unit = a } :: CloudwatchMetricAlarmResource s)

instance P.HasComputedActionsEnabled (CloudwatchMetricAlarmResource s) s (TF.Attr s P.Bool) where
    computedActionsEnabled =
        (_actions_enabled :: CloudwatchMetricAlarmResource s -> TF.Attr s P.Bool)
            . TF.refValue

instance P.HasComputedAlarmActions (CloudwatchMetricAlarmResource s) s (TF.Attr s Text) where
    computedAlarmActions =
        (_alarm_actions :: CloudwatchMetricAlarmResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAlarmDescription (CloudwatchMetricAlarmResource s) s (TF.Attr s Text) where
    computedAlarmDescription =
        (_alarm_description :: CloudwatchMetricAlarmResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAlarmName (CloudwatchMetricAlarmResource s) s (TF.Attr s Text) where
    computedAlarmName =
        (_alarm_name :: CloudwatchMetricAlarmResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedComparisonOperator (CloudwatchMetricAlarmResource s) s (TF.Attr s Text) where
    computedComparisonOperator =
        (_comparison_operator :: CloudwatchMetricAlarmResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDatapointsToAlarm (CloudwatchMetricAlarmResource s) s (TF.Attr s Text) where
    computedDatapointsToAlarm =
        (_datapoints_to_alarm :: CloudwatchMetricAlarmResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDimensions (CloudwatchMetricAlarmResource s) s (TF.Attr s Text) where
    computedDimensions =
        (_dimensions :: CloudwatchMetricAlarmResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEvaluateLowSampleCountPercentiles (CloudwatchMetricAlarmResource s) s (TF.Attr s Text) where
    computedEvaluateLowSampleCountPercentiles =
        (_evaluate_low_sample_count_percentiles :: CloudwatchMetricAlarmResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEvaluationPeriods (CloudwatchMetricAlarmResource s) s (TF.Attr s Text) where
    computedEvaluationPeriods =
        (_evaluation_periods :: CloudwatchMetricAlarmResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedExtendedStatistic (CloudwatchMetricAlarmResource s) s (TF.Attr s Text) where
    computedExtendedStatistic =
        (_extended_statistic :: CloudwatchMetricAlarmResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (CloudwatchMetricAlarmResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedInsufficientDataActions (CloudwatchMetricAlarmResource s) s (TF.Attr s Text) where
    computedInsufficientDataActions =
        (_insufficient_data_actions :: CloudwatchMetricAlarmResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedMetricName (CloudwatchMetricAlarmResource s) s (TF.Attr s Text) where
    computedMetricName =
        (_metric_name :: CloudwatchMetricAlarmResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedNamespace (CloudwatchMetricAlarmResource s) s (TF.Attr s Text) where
    computedNamespace =
        (_namespace :: CloudwatchMetricAlarmResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedOkActions (CloudwatchMetricAlarmResource s) s (TF.Attr s Text) where
    computedOkActions =
        (_ok_actions :: CloudwatchMetricAlarmResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPeriod (CloudwatchMetricAlarmResource s) s (TF.Attr s Text) where
    computedPeriod =
        (_period :: CloudwatchMetricAlarmResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedStatistic (CloudwatchMetricAlarmResource s) s (TF.Attr s Text) where
    computedStatistic =
        (_statistic :: CloudwatchMetricAlarmResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedThreshold (CloudwatchMetricAlarmResource s) s (TF.Attr s Text) where
    computedThreshold =
        (_threshold :: CloudwatchMetricAlarmResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTreatMissingData (CloudwatchMetricAlarmResource s) s (TF.Attr s Text) where
    computedTreatMissingData =
        (_treat_missing_data :: CloudwatchMetricAlarmResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedUnit (CloudwatchMetricAlarmResource s) s (TF.Attr s Text) where
    computedUnit =
        (_unit :: CloudwatchMetricAlarmResource s -> TF.Attr s Text)
            . TF.refValue

cloudwatchMetricAlarmResource :: TF.Schema TF.Resource P.AWS (CloudwatchMetricAlarmResource s)
cloudwatchMetricAlarmResource =
    TF.newResource "aws_cloudwatch_metric_alarm" $
        CloudwatchMetricAlarmResource {
              _actions_enabled = TF.Nil
            , _alarm_actions = TF.Nil
            , _alarm_description = TF.Nil
            , _alarm_name = TF.Nil
            , _comparison_operator = TF.Nil
            , _datapoints_to_alarm = TF.Nil
            , _dimensions = TF.Nil
            , _evaluate_low_sample_count_percentiles = TF.Nil
            , _evaluation_periods = TF.Nil
            , _extended_statistic = TF.Nil
            , _insufficient_data_actions = TF.Nil
            , _metric_name = TF.Nil
            , _namespace = TF.Nil
            , _ok_actions = TF.Nil
            , _period = TF.Nil
            , _statistic = TF.Nil
            , _threshold = TF.Nil
            , _treat_missing_data = TF.Nil
            , _unit = TF.Nil
            }

{- | The @aws_codebuild_project@ AWS resource.

Provides a CodeBuild Project resource.
-}
data CodebuildProjectResource s = CodebuildProjectResource {
      _artifacts      :: !(TF.Attr s Text)
    {- ^ (Required) Information about the project's build output artifacts. Artifact blocks are documented below. -}
    , _build_timeout  :: !(TF.Attr s Text)
    {- ^ (Optional) How long in minutes, from 5 to 480 (8 hours), for AWS CodeBuild to wait until timing out any related build that does not get marked as completed. The default is 60 minutes. -}
    , _description    :: !(TF.Attr s Text)
    {- ^ (Optional) A short description of the project. -}
    , _encryption_key :: !(TF.Attr s Text)
    {- ^ (Optional) The AWS Key Management Service (AWS KMS) customer master key (CMK) to be used for encrypting the build project's build output artifacts. -}
    , _environment    :: !(TF.Attr s Text)
    {- ^ (Required) Information about the project's build environment. Environment blocks are documented below. -}
    , _name           :: !(TF.Attr s Text)
    {- ^ (Required) The projects name. -}
    , _service_role   :: !(TF.Attr s Text)
    {- ^ (Optional) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that enables AWS CodeBuild to interact with dependent AWS services on behalf of the AWS account. -}
    , _source         :: !(TF.Attr s Text)
    {- ^ (Required) Information about the project's input source code. Source blocks are documented below. -}
    , _tags           :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    } deriving (Show, Eq)

instance TF.ToHCL (CodebuildProjectResource s) where
    toHCL CodebuildProjectResource{..} = TF.inline $ catMaybes
        [ TF.assign "artifacts" <$> TF.attribute _artifacts
        , TF.assign "build_timeout" <$> TF.attribute _build_timeout
        , TF.assign "description" <$> TF.attribute _description
        , TF.assign "encryption_key" <$> TF.attribute _encryption_key
        , TF.assign "environment" <$> TF.attribute _environment
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "service_role" <$> TF.attribute _service_role
        , TF.assign "source" <$> TF.attribute _source
        , TF.assign "tags" <$> TF.attribute _tags
        ]

instance P.HasArtifacts (CodebuildProjectResource s) (TF.Attr s Text) where
    artifacts =
        lens (_artifacts :: CodebuildProjectResource s -> TF.Attr s Text)
             (\s a -> s { _artifacts = a } :: CodebuildProjectResource s)

instance P.HasBuildTimeout (CodebuildProjectResource s) (TF.Attr s Text) where
    buildTimeout =
        lens (_build_timeout :: CodebuildProjectResource s -> TF.Attr s Text)
             (\s a -> s { _build_timeout = a } :: CodebuildProjectResource s)

instance P.HasDescription (CodebuildProjectResource s) (TF.Attr s Text) where
    description =
        lens (_description :: CodebuildProjectResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: CodebuildProjectResource s)

instance P.HasEncryptionKey (CodebuildProjectResource s) (TF.Attr s Text) where
    encryptionKey =
        lens (_encryption_key :: CodebuildProjectResource s -> TF.Attr s Text)
             (\s a -> s { _encryption_key = a } :: CodebuildProjectResource s)

instance P.HasEnvironment (CodebuildProjectResource s) (TF.Attr s Text) where
    environment =
        lens (_environment :: CodebuildProjectResource s -> TF.Attr s Text)
             (\s a -> s { _environment = a } :: CodebuildProjectResource s)

instance P.HasName (CodebuildProjectResource s) (TF.Attr s Text) where
    name =
        lens (_name :: CodebuildProjectResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: CodebuildProjectResource s)

instance P.HasServiceRole (CodebuildProjectResource s) (TF.Attr s Text) where
    serviceRole =
        lens (_service_role :: CodebuildProjectResource s -> TF.Attr s Text)
             (\s a -> s { _service_role = a } :: CodebuildProjectResource s)

instance P.HasSource (CodebuildProjectResource s) (TF.Attr s Text) where
    source =
        lens (_source :: CodebuildProjectResource s -> TF.Attr s Text)
             (\s a -> s { _source = a } :: CodebuildProjectResource s)

instance P.HasTags (CodebuildProjectResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: CodebuildProjectResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: CodebuildProjectResource s)

instance P.HasComputedArtifacts (CodebuildProjectResource s) s (TF.Attr s Text) where
    computedArtifacts =
        (_artifacts :: CodebuildProjectResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedBuildTimeout (CodebuildProjectResource s) s (TF.Attr s Text) where
    computedBuildTimeout =
        (_build_timeout :: CodebuildProjectResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDescription (CodebuildProjectResource s) s (TF.Attr s Text) where
    computedDescription x = TF.compute (TF.refKey x) "description"

instance P.HasComputedEncryptionKey (CodebuildProjectResource s) s (TF.Attr s Text) where
    computedEncryptionKey x = TF.compute (TF.refKey x) "encryption_key"

instance P.HasComputedEnvironment (CodebuildProjectResource s) s (TF.Attr s Text) where
    computedEnvironment =
        (_environment :: CodebuildProjectResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (CodebuildProjectResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (CodebuildProjectResource s) s (TF.Attr s Text) where
    computedName x = TF.compute (TF.refKey x) "name"

instance P.HasComputedServiceRole (CodebuildProjectResource s) s (TF.Attr s Text) where
    computedServiceRole x = TF.compute (TF.refKey x) "service_role"

instance P.HasComputedSource (CodebuildProjectResource s) s (TF.Attr s Text) where
    computedSource =
        (_source :: CodebuildProjectResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (CodebuildProjectResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: CodebuildProjectResource s -> TF.Attr s P.Tags)
            . TF.refValue

codebuildProjectResource :: TF.Schema TF.Resource P.AWS (CodebuildProjectResource s)
codebuildProjectResource =
    TF.newResource "aws_codebuild_project" $
        CodebuildProjectResource {
              _artifacts = TF.Nil
            , _build_timeout = TF.Nil
            , _description = TF.Nil
            , _encryption_key = TF.Nil
            , _environment = TF.Nil
            , _name = TF.Nil
            , _service_role = TF.Nil
            , _source = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_codecommit_repository@ AWS resource.

Provides a CodeCommit Repository Resource. ~> NOTE on CodeCommit
Availability : The CodeCommit is not yet rolled out in all regions -
available regions are listed
<https://docs.aws.amazon.com/general/latest/gr/rande.html#codecommit_region>
.
-}
data CodecommitRepositoryResource s = CodecommitRepositoryResource {
      _default_branch  :: !(TF.Attr s Text)
    {- ^ (Optional) The default branch of the repository. The branch specified here needs to exist. -}
    , _description     :: !(TF.Attr s Text)
    {- ^ (Optional) The description of the repository. This needs to be less than 1000 characters -}
    , _repository_name :: !(TF.Attr s Text)
    {- ^ (Required) The name for the repository. This needs to be less than 100 characters. -}
    } deriving (Show, Eq)

instance TF.ToHCL (CodecommitRepositoryResource s) where
    toHCL CodecommitRepositoryResource{..} = TF.inline $ catMaybes
        [ TF.assign "default_branch" <$> TF.attribute _default_branch
        , TF.assign "description" <$> TF.attribute _description
        , TF.assign "repository_name" <$> TF.attribute _repository_name
        ]

instance P.HasDefaultBranch (CodecommitRepositoryResource s) (TF.Attr s Text) where
    defaultBranch =
        lens (_default_branch :: CodecommitRepositoryResource s -> TF.Attr s Text)
             (\s a -> s { _default_branch = a } :: CodecommitRepositoryResource s)

instance P.HasDescription (CodecommitRepositoryResource s) (TF.Attr s Text) where
    description =
        lens (_description :: CodecommitRepositoryResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: CodecommitRepositoryResource s)

instance P.HasRepositoryName (CodecommitRepositoryResource s) (TF.Attr s Text) where
    repositoryName =
        lens (_repository_name :: CodecommitRepositoryResource s -> TF.Attr s Text)
             (\s a -> s { _repository_name = a } :: CodecommitRepositoryResource s)

instance P.HasComputedArn (CodecommitRepositoryResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedCloneUrlHttp (CodecommitRepositoryResource s) s (TF.Attr s Text) where
    computedCloneUrlHttp x = TF.compute (TF.refKey x) "clone_url_http"

instance P.HasComputedCloneUrlSsh (CodecommitRepositoryResource s) s (TF.Attr s Text) where
    computedCloneUrlSsh x = TF.compute (TF.refKey x) "clone_url_ssh"

instance P.HasComputedDefaultBranch (CodecommitRepositoryResource s) s (TF.Attr s Text) where
    computedDefaultBranch =
        (_default_branch :: CodecommitRepositoryResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDescription (CodecommitRepositoryResource s) s (TF.Attr s Text) where
    computedDescription =
        (_description :: CodecommitRepositoryResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRepositoryId (CodecommitRepositoryResource s) s (TF.Attr s Text) where
    computedRepositoryId x = TF.compute (TF.refKey x) "repository_id"

instance P.HasComputedRepositoryName (CodecommitRepositoryResource s) s (TF.Attr s Text) where
    computedRepositoryName =
        (_repository_name :: CodecommitRepositoryResource s -> TF.Attr s Text)
            . TF.refValue

codecommitRepositoryResource :: TF.Schema TF.Resource P.AWS (CodecommitRepositoryResource s)
codecommitRepositoryResource =
    TF.newResource "aws_codecommit_repository" $
        CodecommitRepositoryResource {
              _default_branch = TF.Nil
            , _description = TF.Nil
            , _repository_name = TF.Nil
            }

{- | The @aws_codecommit_trigger@ AWS resource.

Provides a CodeCommit Trigger Resource. ~> NOTE on CodeCommit : The
CodeCommit is not yet rolled out in all regions - available regions are
listed
<https://docs.aws.amazon.com/general/latest/gr/rande.html#codecommit_region>
.
-}
data CodecommitTriggerResource s = CodecommitTriggerResource {
      _branches        :: !(TF.Attr s Text)
    {- ^ (Optional) The branches that will be included in the trigger configuration. If no branches are specified, the trigger will apply to all branches. -}
    , _custom_data     :: !(TF.Attr s Text)
    {- ^ (Optional) Any custom data associated with the trigger that will be included in the information sent to the target of the trigger. -}
    , _destination_arn :: !(TF.Attr s Text)
    {- ^ (Required) The ARN of the resource that is the target for a trigger. For example, the ARN of a topic in Amazon Simple Notification Service (SNS). -}
    , _events          :: !(TF.Attr s Text)
    {- ^ (Required) The repository events that will cause the trigger to run actions in another service, such as sending a notification through Amazon Simple Notification Service (SNS). If no events are specified, the trigger will run for all repository events. Event types include: @all@ , @updateReference@ , @createReference@ , @deleteReference@ . -}
    , _name            :: !(TF.Attr s Text)
    {- ^ (Required) The name of the trigger. -}
    , _repository_name :: !(TF.Attr s Text)
    {- ^ (Required) The name for the repository. This needs to be less than 100 characters. -}
    } deriving (Show, Eq)

instance TF.ToHCL (CodecommitTriggerResource s) where
    toHCL CodecommitTriggerResource{..} = TF.inline $ catMaybes
        [ TF.assign "branches" <$> TF.attribute _branches
        , TF.assign "custom_data" <$> TF.attribute _custom_data
        , TF.assign "destination_arn" <$> TF.attribute _destination_arn
        , TF.assign "events" <$> TF.attribute _events
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "repository_name" <$> TF.attribute _repository_name
        ]

instance P.HasBranches (CodecommitTriggerResource s) (TF.Attr s Text) where
    branches =
        lens (_branches :: CodecommitTriggerResource s -> TF.Attr s Text)
             (\s a -> s { _branches = a } :: CodecommitTriggerResource s)

instance P.HasCustomData (CodecommitTriggerResource s) (TF.Attr s Text) where
    customData =
        lens (_custom_data :: CodecommitTriggerResource s -> TF.Attr s Text)
             (\s a -> s { _custom_data = a } :: CodecommitTriggerResource s)

instance P.HasDestinationArn (CodecommitTriggerResource s) (TF.Attr s Text) where
    destinationArn =
        lens (_destination_arn :: CodecommitTriggerResource s -> TF.Attr s Text)
             (\s a -> s { _destination_arn = a } :: CodecommitTriggerResource s)

instance P.HasEvents (CodecommitTriggerResource s) (TF.Attr s Text) where
    events =
        lens (_events :: CodecommitTriggerResource s -> TF.Attr s Text)
             (\s a -> s { _events = a } :: CodecommitTriggerResource s)

instance P.HasName (CodecommitTriggerResource s) (TF.Attr s Text) where
    name =
        lens (_name :: CodecommitTriggerResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: CodecommitTriggerResource s)

instance P.HasRepositoryName (CodecommitTriggerResource s) (TF.Attr s Text) where
    repositoryName =
        lens (_repository_name :: CodecommitTriggerResource s -> TF.Attr s Text)
             (\s a -> s { _repository_name = a } :: CodecommitTriggerResource s)

instance P.HasComputedBranches (CodecommitTriggerResource s) s (TF.Attr s Text) where
    computedBranches =
        (_branches :: CodecommitTriggerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCustomData (CodecommitTriggerResource s) s (TF.Attr s Text) where
    computedCustomData =
        (_custom_data :: CodecommitTriggerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDestinationArn (CodecommitTriggerResource s) s (TF.Attr s Text) where
    computedDestinationArn =
        (_destination_arn :: CodecommitTriggerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEvents (CodecommitTriggerResource s) s (TF.Attr s Text) where
    computedEvents =
        (_events :: CodecommitTriggerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (CodecommitTriggerResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: CodecommitTriggerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRepositoryName (CodecommitTriggerResource s) s (TF.Attr s Text) where
    computedRepositoryName =
        (_repository_name :: CodecommitTriggerResource s -> TF.Attr s Text)
            . TF.refValue

codecommitTriggerResource :: TF.Schema TF.Resource P.AWS (CodecommitTriggerResource s)
codecommitTriggerResource =
    TF.newResource "aws_codecommit_trigger" $
        CodecommitTriggerResource {
              _branches = TF.Nil
            , _custom_data = TF.Nil
            , _destination_arn = TF.Nil
            , _events = TF.Nil
            , _name = TF.Nil
            , _repository_name = TF.Nil
            }

{- | The @aws_codedeploy_app@ AWS resource.

Provides a CodeDeploy application to be used as a basis for deployments
-}
data CodedeployAppResource s = CodedeployAppResource {
      _name :: !(TF.Attr s Text)
    {- ^ (Required) The name of the application. -}
    } deriving (Show, Eq)

instance TF.ToHCL (CodedeployAppResource s) where
    toHCL CodedeployAppResource{..} = TF.inline $ catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        ]

instance P.HasName (CodedeployAppResource s) (TF.Attr s Text) where
    name =
        lens (_name :: CodedeployAppResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: CodedeployAppResource s)

instance P.HasComputedId (CodedeployAppResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (CodedeployAppResource s) s (TF.Attr s Text) where
    computedName x = TF.compute (TF.refKey x) "name"

codedeployAppResource :: TF.Schema TF.Resource P.AWS (CodedeployAppResource s)
codedeployAppResource =
    TF.newResource "aws_codedeploy_app" $
        CodedeployAppResource {
              _name = TF.Nil
            }

{- | The @aws_codedeploy_deployment_config@ AWS resource.

Provides a CodeDeploy deployment config for an application
-}
data CodedeployDeploymentConfigResource s = CodedeployDeploymentConfigResource {
      _deployment_config_name :: !(TF.Attr s Text)
    {- ^ (Required) The name of the deployment config. -}
    , _minimum_healthy_hosts  :: !(TF.Attr s Text)
    {- ^ (Optional) A minimum_healthy_hosts block. Minimum Healthy Hosts are documented below. -}
    } deriving (Show, Eq)

instance TF.ToHCL (CodedeployDeploymentConfigResource s) where
    toHCL CodedeployDeploymentConfigResource{..} = TF.inline $ catMaybes
        [ TF.assign "deployment_config_name" <$> TF.attribute _deployment_config_name
        , TF.assign "minimum_healthy_hosts" <$> TF.attribute _minimum_healthy_hosts
        ]

instance P.HasDeploymentConfigName (CodedeployDeploymentConfigResource s) (TF.Attr s Text) where
    deploymentConfigName =
        lens (_deployment_config_name :: CodedeployDeploymentConfigResource s -> TF.Attr s Text)
             (\s a -> s { _deployment_config_name = a } :: CodedeployDeploymentConfigResource s)

instance P.HasMinimumHealthyHosts (CodedeployDeploymentConfigResource s) (TF.Attr s Text) where
    minimumHealthyHosts =
        lens (_minimum_healthy_hosts :: CodedeployDeploymentConfigResource s -> TF.Attr s Text)
             (\s a -> s { _minimum_healthy_hosts = a } :: CodedeployDeploymentConfigResource s)

instance P.HasComputedDeploymentConfigId (CodedeployDeploymentConfigResource s) s (TF.Attr s Text) where
    computedDeploymentConfigId x = TF.compute (TF.refKey x) "deployment_config_id"

instance P.HasComputedDeploymentConfigName (CodedeployDeploymentConfigResource s) s (TF.Attr s Text) where
    computedDeploymentConfigName =
        (_deployment_config_name :: CodedeployDeploymentConfigResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (CodedeployDeploymentConfigResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedMinimumHealthyHosts (CodedeployDeploymentConfigResource s) s (TF.Attr s Text) where
    computedMinimumHealthyHosts =
        (_minimum_healthy_hosts :: CodedeployDeploymentConfigResource s -> TF.Attr s Text)
            . TF.refValue

codedeployDeploymentConfigResource :: TF.Schema TF.Resource P.AWS (CodedeployDeploymentConfigResource s)
codedeployDeploymentConfigResource =
    TF.newResource "aws_codedeploy_deployment_config" $
        CodedeployDeploymentConfigResource {
              _deployment_config_name = TF.Nil
            , _minimum_healthy_hosts = TF.Nil
            }

{- | The @aws_codedeploy_deployment_group@ AWS resource.

Provides a CodeDeploy Deployment Group for a CodeDeploy Application
-}
data CodedeployDeploymentGroupResource s = CodedeployDeploymentGroupResource {
      _alarm_configuration             :: !(TF.Attr s Text)
    {- ^ (Optional) Information about alarms associated with the deployment group (documented below). -}
    , _app_name                        :: !(TF.Attr s Text)
    {- ^ (Required) The name of the application. -}
    , _auto_rollback_configuration     :: !(TF.Attr s Text)
    {- ^ (Optional) The automatic rollback configuration associated with the deployment group (documented below). -}
    , _autoscaling_groups              :: !(TF.Attr s Text)
    {- ^ (Optional) Autoscaling groups associated with the deployment group. -}
    , _blue_green_deployment_config    :: !(TF.Attr s Text)
    {- ^ (Optional) Information about blue/green deployment options for a deployment group (documented below). -}
    , _deployment_config_name          :: !(TF.Attr s Text)
    {- ^ (Optional) The name of the group's deployment config. The default is "CodeDeployDefault.OneAtATime". -}
    , _deployment_group_name           :: !(TF.Attr s Text)
    {- ^ (Required) The name of the deployment group. -}
    , _deployment_style                :: !(TF.Attr s Text)
    {- ^ (Optional) Information about the type of deployment, either in-place or blue/green, you want to run and whether to route deployment traffic behind a load balancer (documented below). -}
    , _ec2_tag_filter                  :: !(TF.Attr s Text)
    {- ^ (Optional) Tag filters associated with the group. See the AWS docs for details. -}
    , _load_balancer_info              :: !(TF.Attr s Text)
    {- ^ (Optional) Information about the load balancer to use in a blue/green deployment (documented below). -}
    , _on_premises_instance_tag_filter :: !(TF.Attr s Text)
    {- ^ (Optional) On premise tag filters associated with the group. See the AWS docs for details. -}
    , _service_role_arn                :: !(TF.Attr s Text)
    {- ^ (Required) The service role ARN that allows deployments. -}
    , _trigger_configuration           :: !(TF.Attr s Text)
    {- ^ (Optional) Trigger Configurations for the deployment group (documented below). -}
    } deriving (Show, Eq)

instance TF.ToHCL (CodedeployDeploymentGroupResource s) where
    toHCL CodedeployDeploymentGroupResource{..} = TF.inline $ catMaybes
        [ TF.assign "alarm_configuration" <$> TF.attribute _alarm_configuration
        , TF.assign "app_name" <$> TF.attribute _app_name
        , TF.assign "auto_rollback_configuration" <$> TF.attribute _auto_rollback_configuration
        , TF.assign "autoscaling_groups" <$> TF.attribute _autoscaling_groups
        , TF.assign "blue_green_deployment_config" <$> TF.attribute _blue_green_deployment_config
        , TF.assign "deployment_config_name" <$> TF.attribute _deployment_config_name
        , TF.assign "deployment_group_name" <$> TF.attribute _deployment_group_name
        , TF.assign "deployment_style" <$> TF.attribute _deployment_style
        , TF.assign "ec2_tag_filter" <$> TF.attribute _ec2_tag_filter
        , TF.assign "load_balancer_info" <$> TF.attribute _load_balancer_info
        , TF.assign "on_premises_instance_tag_filter" <$> TF.attribute _on_premises_instance_tag_filter
        , TF.assign "service_role_arn" <$> TF.attribute _service_role_arn
        , TF.assign "trigger_configuration" <$> TF.attribute _trigger_configuration
        ]

instance P.HasAlarmConfiguration (CodedeployDeploymentGroupResource s) (TF.Attr s Text) where
    alarmConfiguration =
        lens (_alarm_configuration :: CodedeployDeploymentGroupResource s -> TF.Attr s Text)
             (\s a -> s { _alarm_configuration = a } :: CodedeployDeploymentGroupResource s)

instance P.HasAppName (CodedeployDeploymentGroupResource s) (TF.Attr s Text) where
    appName =
        lens (_app_name :: CodedeployDeploymentGroupResource s -> TF.Attr s Text)
             (\s a -> s { _app_name = a } :: CodedeployDeploymentGroupResource s)

instance P.HasAutoRollbackConfiguration (CodedeployDeploymentGroupResource s) (TF.Attr s Text) where
    autoRollbackConfiguration =
        lens (_auto_rollback_configuration :: CodedeployDeploymentGroupResource s -> TF.Attr s Text)
             (\s a -> s { _auto_rollback_configuration = a } :: CodedeployDeploymentGroupResource s)

instance P.HasAutoscalingGroups (CodedeployDeploymentGroupResource s) (TF.Attr s Text) where
    autoscalingGroups =
        lens (_autoscaling_groups :: CodedeployDeploymentGroupResource s -> TF.Attr s Text)
             (\s a -> s { _autoscaling_groups = a } :: CodedeployDeploymentGroupResource s)

instance P.HasBlueGreenDeploymentConfig (CodedeployDeploymentGroupResource s) (TF.Attr s Text) where
    blueGreenDeploymentConfig =
        lens (_blue_green_deployment_config :: CodedeployDeploymentGroupResource s -> TF.Attr s Text)
             (\s a -> s { _blue_green_deployment_config = a } :: CodedeployDeploymentGroupResource s)

instance P.HasDeploymentConfigName (CodedeployDeploymentGroupResource s) (TF.Attr s Text) where
    deploymentConfigName =
        lens (_deployment_config_name :: CodedeployDeploymentGroupResource s -> TF.Attr s Text)
             (\s a -> s { _deployment_config_name = a } :: CodedeployDeploymentGroupResource s)

instance P.HasDeploymentGroupName (CodedeployDeploymentGroupResource s) (TF.Attr s Text) where
    deploymentGroupName =
        lens (_deployment_group_name :: CodedeployDeploymentGroupResource s -> TF.Attr s Text)
             (\s a -> s { _deployment_group_name = a } :: CodedeployDeploymentGroupResource s)

instance P.HasDeploymentStyle (CodedeployDeploymentGroupResource s) (TF.Attr s Text) where
    deploymentStyle =
        lens (_deployment_style :: CodedeployDeploymentGroupResource s -> TF.Attr s Text)
             (\s a -> s { _deployment_style = a } :: CodedeployDeploymentGroupResource s)

instance P.HasEc2TagFilter (CodedeployDeploymentGroupResource s) (TF.Attr s Text) where
    ec2TagFilter =
        lens (_ec2_tag_filter :: CodedeployDeploymentGroupResource s -> TF.Attr s Text)
             (\s a -> s { _ec2_tag_filter = a } :: CodedeployDeploymentGroupResource s)

instance P.HasLoadBalancerInfo (CodedeployDeploymentGroupResource s) (TF.Attr s Text) where
    loadBalancerInfo =
        lens (_load_balancer_info :: CodedeployDeploymentGroupResource s -> TF.Attr s Text)
             (\s a -> s { _load_balancer_info = a } :: CodedeployDeploymentGroupResource s)

instance P.HasOnPremisesInstanceTagFilter (CodedeployDeploymentGroupResource s) (TF.Attr s Text) where
    onPremisesInstanceTagFilter =
        lens (_on_premises_instance_tag_filter :: CodedeployDeploymentGroupResource s -> TF.Attr s Text)
             (\s a -> s { _on_premises_instance_tag_filter = a } :: CodedeployDeploymentGroupResource s)

instance P.HasServiceRoleArn (CodedeployDeploymentGroupResource s) (TF.Attr s Text) where
    serviceRoleArn =
        lens (_service_role_arn :: CodedeployDeploymentGroupResource s -> TF.Attr s Text)
             (\s a -> s { _service_role_arn = a } :: CodedeployDeploymentGroupResource s)

instance P.HasTriggerConfiguration (CodedeployDeploymentGroupResource s) (TF.Attr s Text) where
    triggerConfiguration =
        lens (_trigger_configuration :: CodedeployDeploymentGroupResource s -> TF.Attr s Text)
             (\s a -> s { _trigger_configuration = a } :: CodedeployDeploymentGroupResource s)

instance P.HasComputedAlarmConfiguration (CodedeployDeploymentGroupResource s) s (TF.Attr s Text) where
    computedAlarmConfiguration =
        (_alarm_configuration :: CodedeployDeploymentGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAppName (CodedeployDeploymentGroupResource s) s (TF.Attr s Text) where
    computedAppName x = TF.compute (TF.refKey x) "app_name"

instance P.HasComputedAutoRollbackConfiguration (CodedeployDeploymentGroupResource s) s (TF.Attr s Text) where
    computedAutoRollbackConfiguration =
        (_auto_rollback_configuration :: CodedeployDeploymentGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAutoscalingGroups (CodedeployDeploymentGroupResource s) s (TF.Attr s Text) where
    computedAutoscalingGroups x = TF.compute (TF.refKey x) "autoscaling_groups"

instance P.HasComputedBlueGreenDeploymentConfig (CodedeployDeploymentGroupResource s) s (TF.Attr s Text) where
    computedBlueGreenDeploymentConfig =
        (_blue_green_deployment_config :: CodedeployDeploymentGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDeploymentConfigName (CodedeployDeploymentGroupResource s) s (TF.Attr s Text) where
    computedDeploymentConfigName x = TF.compute (TF.refKey x) "deployment_config_name"

instance P.HasComputedDeploymentGroupName (CodedeployDeploymentGroupResource s) s (TF.Attr s Text) where
    computedDeploymentGroupName x = TF.compute (TF.refKey x) "deployment_group_name"

instance P.HasComputedDeploymentStyle (CodedeployDeploymentGroupResource s) s (TF.Attr s Text) where
    computedDeploymentStyle =
        (_deployment_style :: CodedeployDeploymentGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEc2TagFilter (CodedeployDeploymentGroupResource s) s (TF.Attr s Text) where
    computedEc2TagFilter =
        (_ec2_tag_filter :: CodedeployDeploymentGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (CodedeployDeploymentGroupResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedLoadBalancerInfo (CodedeployDeploymentGroupResource s) s (TF.Attr s Text) where
    computedLoadBalancerInfo =
        (_load_balancer_info :: CodedeployDeploymentGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedOnPremisesInstanceTagFilter (CodedeployDeploymentGroupResource s) s (TF.Attr s Text) where
    computedOnPremisesInstanceTagFilter =
        (_on_premises_instance_tag_filter :: CodedeployDeploymentGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedServiceRoleArn (CodedeployDeploymentGroupResource s) s (TF.Attr s Text) where
    computedServiceRoleArn x = TF.compute (TF.refKey x) "service_role_arn"

instance P.HasComputedTriggerConfiguration (CodedeployDeploymentGroupResource s) s (TF.Attr s Text) where
    computedTriggerConfiguration =
        (_trigger_configuration :: CodedeployDeploymentGroupResource s -> TF.Attr s Text)
            . TF.refValue

codedeployDeploymentGroupResource :: TF.Schema TF.Resource P.AWS (CodedeployDeploymentGroupResource s)
codedeployDeploymentGroupResource =
    TF.newResource "aws_codedeploy_deployment_group" $
        CodedeployDeploymentGroupResource {
              _alarm_configuration = TF.Nil
            , _app_name = TF.Nil
            , _auto_rollback_configuration = TF.Nil
            , _autoscaling_groups = TF.Nil
            , _blue_green_deployment_config = TF.Nil
            , _deployment_config_name = TF.Nil
            , _deployment_group_name = TF.Nil
            , _deployment_style = TF.Nil
            , _ec2_tag_filter = TF.Nil
            , _load_balancer_info = TF.Nil
            , _on_premises_instance_tag_filter = TF.Nil
            , _service_role_arn = TF.Nil
            , _trigger_configuration = TF.Nil
            }

{- | The @aws_codepipeline@ AWS resource.

Provides a CodePipeline. ~> NOTE on @aws_codepipeline@ : - the
@GITHUB_TOKEN@ environment variable must be set if the GitHub provider is
specified.
-}
data CodepipelineResource s = CodepipelineResource {
      _artifact_store :: !(TF.Attr s Text)
    {- ^ (Required) An artifact_store block. Artifact stores are documented below. -}
    , _name           :: !(TF.Attr s Text)
    {- ^ (Required) The name of the pipeline. -}
    , _role_arn       :: !(TF.Attr s Text)
    {- ^ (Required) A service role Amazon Resource Name (ARN) that grants AWS CodePipeline permission to make calls to AWS services on your behalf. -}
    , _stage          :: !(TF.Attr s Text)
    {- ^ (Required) A stage block. Stages are documented below. -}
    } deriving (Show, Eq)

instance TF.ToHCL (CodepipelineResource s) where
    toHCL CodepipelineResource{..} = TF.inline $ catMaybes
        [ TF.assign "artifact_store" <$> TF.attribute _artifact_store
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "role_arn" <$> TF.attribute _role_arn
        , TF.assign "stage" <$> TF.attribute _stage
        ]

instance P.HasArtifactStore (CodepipelineResource s) (TF.Attr s Text) where
    artifactStore =
        lens (_artifact_store :: CodepipelineResource s -> TF.Attr s Text)
             (\s a -> s { _artifact_store = a } :: CodepipelineResource s)

instance P.HasName (CodepipelineResource s) (TF.Attr s Text) where
    name =
        lens (_name :: CodepipelineResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: CodepipelineResource s)

instance P.HasRoleArn (CodepipelineResource s) (TF.Attr s Text) where
    roleArn =
        lens (_role_arn :: CodepipelineResource s -> TF.Attr s Text)
             (\s a -> s { _role_arn = a } :: CodepipelineResource s)

instance P.HasStage (CodepipelineResource s) (TF.Attr s Text) where
    stage =
        lens (_stage :: CodepipelineResource s -> TF.Attr s Text)
             (\s a -> s { _stage = a } :: CodepipelineResource s)

instance P.HasComputedArn (CodepipelineResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedArtifactStore (CodepipelineResource s) s (TF.Attr s Text) where
    computedArtifactStore =
        (_artifact_store :: CodepipelineResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (CodepipelineResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (CodepipelineResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: CodepipelineResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRoleArn (CodepipelineResource s) s (TF.Attr s Text) where
    computedRoleArn =
        (_role_arn :: CodepipelineResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedStage (CodepipelineResource s) s (TF.Attr s Text) where
    computedStage =
        (_stage :: CodepipelineResource s -> TF.Attr s Text)
            . TF.refValue

codepipelineResource :: TF.Schema TF.Resource P.AWS (CodepipelineResource s)
codepipelineResource =
    TF.newResource "aws_codepipeline" $
        CodepipelineResource {
              _artifact_store = TF.Nil
            , _name = TF.Nil
            , _role_arn = TF.Nil
            , _stage = TF.Nil
            }

{- | The @aws_cognito_identity_pool@ AWS resource.

Provides an AWS Cognito Identity Pool.
-}
data CognitoIdentityPoolResource s = CognitoIdentityPoolResource {
      _allow_unauthenticated_identities :: !(TF.Attr s Text)
    {- ^ (Required) - Whether the identity pool supports unauthenticated logins or not. -}
    , _cognito_identity_providers       :: !(TF.Attr s Text)
    {- ^ (Optional) - An array of <#cognito-identity-providers> and their client IDs. -}
    , _developer_provider_name          :: !(TF.Attr s Text)
    {- ^ (Optional) - The "domain" by which Cognito will refer to your users. This name acts as a placeholder that allows your backend and the Cognito service to communicate about the developer provider. -}
    , _identity_pool_name               :: !(TF.Attr s Text)
    {- ^ (Required) - The Cognito Identity Pool name. -}
    , _openid_connect_provider_arns     :: !(TF.Attr s Text)
    {- ^ (Optional) - A list of OpendID Connect provider ARNs. -}
    , _saml_provider_arns               :: !(TF.Attr s Text)
    {- ^ (Optional) - An array of Amazon Resource Names (ARNs) of the SAML provider for your identity. -}
    , _supported_login_providers        :: !(TF.Attr s Text)
    {- ^ (Optional) - Key-Value pairs mapping provider names to provider app IDs. -}
    } deriving (Show, Eq)

instance TF.ToHCL (CognitoIdentityPoolResource s) where
    toHCL CognitoIdentityPoolResource{..} = TF.inline $ catMaybes
        [ TF.assign "allow_unauthenticated_identities" <$> TF.attribute _allow_unauthenticated_identities
        , TF.assign "cognito_identity_providers" <$> TF.attribute _cognito_identity_providers
        , TF.assign "developer_provider_name" <$> TF.attribute _developer_provider_name
        , TF.assign "identity_pool_name" <$> TF.attribute _identity_pool_name
        , TF.assign "openid_connect_provider_arns" <$> TF.attribute _openid_connect_provider_arns
        , TF.assign "saml_provider_arns" <$> TF.attribute _saml_provider_arns
        , TF.assign "supported_login_providers" <$> TF.attribute _supported_login_providers
        ]

instance P.HasAllowUnauthenticatedIdentities (CognitoIdentityPoolResource s) (TF.Attr s Text) where
    allowUnauthenticatedIdentities =
        lens (_allow_unauthenticated_identities :: CognitoIdentityPoolResource s -> TF.Attr s Text)
             (\s a -> s { _allow_unauthenticated_identities = a } :: CognitoIdentityPoolResource s)

instance P.HasCognitoIdentityProviders (CognitoIdentityPoolResource s) (TF.Attr s Text) where
    cognitoIdentityProviders =
        lens (_cognito_identity_providers :: CognitoIdentityPoolResource s -> TF.Attr s Text)
             (\s a -> s { _cognito_identity_providers = a } :: CognitoIdentityPoolResource s)

instance P.HasDeveloperProviderName (CognitoIdentityPoolResource s) (TF.Attr s Text) where
    developerProviderName =
        lens (_developer_provider_name :: CognitoIdentityPoolResource s -> TF.Attr s Text)
             (\s a -> s { _developer_provider_name = a } :: CognitoIdentityPoolResource s)

instance P.HasIdentityPoolName (CognitoIdentityPoolResource s) (TF.Attr s Text) where
    identityPoolName =
        lens (_identity_pool_name :: CognitoIdentityPoolResource s -> TF.Attr s Text)
             (\s a -> s { _identity_pool_name = a } :: CognitoIdentityPoolResource s)

instance P.HasOpenidConnectProviderArns (CognitoIdentityPoolResource s) (TF.Attr s Text) where
    openidConnectProviderArns =
        lens (_openid_connect_provider_arns :: CognitoIdentityPoolResource s -> TF.Attr s Text)
             (\s a -> s { _openid_connect_provider_arns = a } :: CognitoIdentityPoolResource s)

instance P.HasSamlProviderArns (CognitoIdentityPoolResource s) (TF.Attr s Text) where
    samlProviderArns =
        lens (_saml_provider_arns :: CognitoIdentityPoolResource s -> TF.Attr s Text)
             (\s a -> s { _saml_provider_arns = a } :: CognitoIdentityPoolResource s)

instance P.HasSupportedLoginProviders (CognitoIdentityPoolResource s) (TF.Attr s Text) where
    supportedLoginProviders =
        lens (_supported_login_providers :: CognitoIdentityPoolResource s -> TF.Attr s Text)
             (\s a -> s { _supported_login_providers = a } :: CognitoIdentityPoolResource s)

instance P.HasComputedAllowUnauthenticatedIdentities (CognitoIdentityPoolResource s) s (TF.Attr s Text) where
    computedAllowUnauthenticatedIdentities =
        (_allow_unauthenticated_identities :: CognitoIdentityPoolResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCognitoIdentityProviders (CognitoIdentityPoolResource s) s (TF.Attr s Text) where
    computedCognitoIdentityProviders =
        (_cognito_identity_providers :: CognitoIdentityPoolResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDeveloperProviderName (CognitoIdentityPoolResource s) s (TF.Attr s Text) where
    computedDeveloperProviderName =
        (_developer_provider_name :: CognitoIdentityPoolResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (CognitoIdentityPoolResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedIdentityPoolName (CognitoIdentityPoolResource s) s (TF.Attr s Text) where
    computedIdentityPoolName =
        (_identity_pool_name :: CognitoIdentityPoolResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedOpenidConnectProviderArns (CognitoIdentityPoolResource s) s (TF.Attr s Text) where
    computedOpenidConnectProviderArns =
        (_openid_connect_provider_arns :: CognitoIdentityPoolResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSamlProviderArns (CognitoIdentityPoolResource s) s (TF.Attr s Text) where
    computedSamlProviderArns =
        (_saml_provider_arns :: CognitoIdentityPoolResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSupportedLoginProviders (CognitoIdentityPoolResource s) s (TF.Attr s Text) where
    computedSupportedLoginProviders =
        (_supported_login_providers :: CognitoIdentityPoolResource s -> TF.Attr s Text)
            . TF.refValue

cognitoIdentityPoolResource :: TF.Schema TF.Resource P.AWS (CognitoIdentityPoolResource s)
cognitoIdentityPoolResource =
    TF.newResource "aws_cognito_identity_pool" $
        CognitoIdentityPoolResource {
              _allow_unauthenticated_identities = TF.Nil
            , _cognito_identity_providers = TF.Nil
            , _developer_provider_name = TF.Nil
            , _identity_pool_name = TF.Nil
            , _openid_connect_provider_arns = TF.Nil
            , _saml_provider_arns = TF.Nil
            , _supported_login_providers = TF.Nil
            }

{- | The @aws_cognito_identity_pool_roles_attachment@ AWS resource.

Provides an AWS Cognito Identity Pool Roles Attachment.
-}
data CognitoIdentityPoolRolesAttachmentResource s = CognitoIdentityPoolRolesAttachmentResource {
      _identity_pool_id :: !(TF.Attr s Text)
    {- ^ (Required) - An identity pool ID in the format REGION:GUID. -}
    , _role_mapping     :: !(TF.Attr s Text)
    {- ^ (Optional) - A List of <#role-mappings> . -}
    , _roles            :: !(TF.Attr s Text)
    {- ^ (Required) - The map of roles associated with this pool. For a given role, the key will be either "authenticated" or "unauthenticated" and the value will be the Role ARN. -}
    } deriving (Show, Eq)

instance TF.ToHCL (CognitoIdentityPoolRolesAttachmentResource s) where
    toHCL CognitoIdentityPoolRolesAttachmentResource{..} = TF.inline $ catMaybes
        [ TF.assign "identity_pool_id" <$> TF.attribute _identity_pool_id
        , TF.assign "role_mapping" <$> TF.attribute _role_mapping
        , TF.assign "roles" <$> TF.attribute _roles
        ]

instance P.HasIdentityPoolId (CognitoIdentityPoolRolesAttachmentResource s) (TF.Attr s Text) where
    identityPoolId =
        lens (_identity_pool_id :: CognitoIdentityPoolRolesAttachmentResource s -> TF.Attr s Text)
             (\s a -> s { _identity_pool_id = a } :: CognitoIdentityPoolRolesAttachmentResource s)

instance P.HasRoleMapping (CognitoIdentityPoolRolesAttachmentResource s) (TF.Attr s Text) where
    roleMapping =
        lens (_role_mapping :: CognitoIdentityPoolRolesAttachmentResource s -> TF.Attr s Text)
             (\s a -> s { _role_mapping = a } :: CognitoIdentityPoolRolesAttachmentResource s)

instance P.HasRoles (CognitoIdentityPoolRolesAttachmentResource s) (TF.Attr s Text) where
    roles =
        lens (_roles :: CognitoIdentityPoolRolesAttachmentResource s -> TF.Attr s Text)
             (\s a -> s { _roles = a } :: CognitoIdentityPoolRolesAttachmentResource s)

instance P.HasComputedId (CognitoIdentityPoolRolesAttachmentResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedIdentityPoolId (CognitoIdentityPoolRolesAttachmentResource s) s (TF.Attr s Text) where
    computedIdentityPoolId x = TF.compute (TF.refKey x) "identity_pool_id"

instance P.HasComputedRoleMapping (CognitoIdentityPoolRolesAttachmentResource s) s (TF.Attr s Text) where
    computedRoleMapping x = TF.compute (TF.refKey x) "role_mapping"

instance P.HasComputedRoles (CognitoIdentityPoolRolesAttachmentResource s) s (TF.Attr s Text) where
    computedRoles x = TF.compute (TF.refKey x) "roles"

cognitoIdentityPoolRolesAttachmentResource :: TF.Schema TF.Resource P.AWS (CognitoIdentityPoolRolesAttachmentResource s)
cognitoIdentityPoolRolesAttachmentResource =
    TF.newResource "aws_cognito_identity_pool_roles_attachment" $
        CognitoIdentityPoolRolesAttachmentResource {
              _identity_pool_id = TF.Nil
            , _role_mapping = TF.Nil
            , _roles = TF.Nil
            }

{- | The @aws_cognito_user_group@ AWS resource.

Provides a Cognito User Group resource.
-}
data CognitoUserGroupResource s = CognitoUserGroupResource {
      _description  :: !(TF.Attr s Text)
    {- ^ (Optional) The description of the user group. -}
    , _name         :: !(TF.Attr s Text)
    {- ^ (Required) The name of the user group. -}
    , _precedence   :: !(TF.Attr s Text)
    {- ^ (Optional) The precedence of the user group. -}
    , _role_arn     :: !(TF.Attr s Text)
    {- ^ (Optional) The ARN of the IAM role to be associated with the user group. -}
    , _user_pool_id :: !(TF.Attr s Text)
    {- ^ (Required) The user pool ID. -}
    } deriving (Show, Eq)

instance TF.ToHCL (CognitoUserGroupResource s) where
    toHCL CognitoUserGroupResource{..} = TF.inline $ catMaybes
        [ TF.assign "description" <$> TF.attribute _description
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "precedence" <$> TF.attribute _precedence
        , TF.assign "role_arn" <$> TF.attribute _role_arn
        , TF.assign "user_pool_id" <$> TF.attribute _user_pool_id
        ]

instance P.HasDescription (CognitoUserGroupResource s) (TF.Attr s Text) where
    description =
        lens (_description :: CognitoUserGroupResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: CognitoUserGroupResource s)

instance P.HasName (CognitoUserGroupResource s) (TF.Attr s Text) where
    name =
        lens (_name :: CognitoUserGroupResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: CognitoUserGroupResource s)

instance P.HasPrecedence (CognitoUserGroupResource s) (TF.Attr s Text) where
    precedence =
        lens (_precedence :: CognitoUserGroupResource s -> TF.Attr s Text)
             (\s a -> s { _precedence = a } :: CognitoUserGroupResource s)

instance P.HasRoleArn (CognitoUserGroupResource s) (TF.Attr s Text) where
    roleArn =
        lens (_role_arn :: CognitoUserGroupResource s -> TF.Attr s Text)
             (\s a -> s { _role_arn = a } :: CognitoUserGroupResource s)

instance P.HasUserPoolId (CognitoUserGroupResource s) (TF.Attr s Text) where
    userPoolId =
        lens (_user_pool_id :: CognitoUserGroupResource s -> TF.Attr s Text)
             (\s a -> s { _user_pool_id = a } :: CognitoUserGroupResource s)

instance P.HasComputedDescription (CognitoUserGroupResource s) s (TF.Attr s Text) where
    computedDescription =
        (_description :: CognitoUserGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (CognitoUserGroupResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: CognitoUserGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPrecedence (CognitoUserGroupResource s) s (TF.Attr s Text) where
    computedPrecedence =
        (_precedence :: CognitoUserGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRoleArn (CognitoUserGroupResource s) s (TF.Attr s Text) where
    computedRoleArn =
        (_role_arn :: CognitoUserGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedUserPoolId (CognitoUserGroupResource s) s (TF.Attr s Text) where
    computedUserPoolId =
        (_user_pool_id :: CognitoUserGroupResource s -> TF.Attr s Text)
            . TF.refValue

cognitoUserGroupResource :: TF.Schema TF.Resource P.AWS (CognitoUserGroupResource s)
cognitoUserGroupResource =
    TF.newResource "aws_cognito_user_group" $
        CognitoUserGroupResource {
              _description = TF.Nil
            , _name = TF.Nil
            , _precedence = TF.Nil
            , _role_arn = TF.Nil
            , _user_pool_id = TF.Nil
            }

{- | The @aws_cognito_user_pool_client@ AWS resource.

Provides a Cognito User Pool Client resource.
-}
data CognitoUserPoolClientResource s = CognitoUserPoolClientResource {
      _allowed_oauth_flows                  :: !(TF.Attr s Text)
    {- ^ (Optional) List of allowed OAuth flows (code, implicit, client_credentials). -}
    , _allowed_oauth_flows_user_pool_client :: !(TF.Attr s Text)
    {- ^ (Optional) Whether the client is allowed to follow the OAuth protocol when interacting with Cognito user pools. -}
    , _allowed_oauth_scopes                 :: !(TF.Attr s Text)
    {- ^ (Optional) List of allowed OAuth scopes (phone, email, openid, Cognito). -}
    , _callback_urls                        :: !(TF.Attr s Text)
    {- ^ (Optional) List of allowed callback URLs for the identity providers. -}
    , _default_redirect_uri                 :: !(TF.Attr s Text)
    {- ^ (Optional) The default redirect URI. Must be in the list of callback URLs. -}
    , _explicit_auth_flows                  :: !(TF.Attr s Text)
    {- ^ (Optional) List of authentication flows (ADMIN_NO_SRP_AUTH, CUSTOM_AUTH_FLOW_ONLY). -}
    , _generate_secret                      :: !(TF.Attr s Text)
    {- ^ (Optional) Should an application secret be generated. AWS JavaScript SDK requires this to be false. -}
    , _logout_urls                          :: !(TF.Attr s Text)
    {- ^ (Optional) List of allowed logout URLs for the identity providers. -}
    , _name                                 :: !(TF.Attr s Text)
    {- ^ (Required) The name of the application client. -}
    , _read_attributes                      :: !(TF.Attr s Text)
    {- ^ (Optional) List of user pool attributes the application client can read from. -}
    , _refresh_token_validity               :: !(TF.Attr s Text)
    {- ^ (Optional) The time limit in days refresh tokens are valid for. -}
    , _supported_identity_providers         :: !(TF.Attr s Text)
    {- ^ (Optional) List of provider names for the identity providers that are supported on this client. -}
    , _user_pool_id                         :: !(TF.Attr s Text)
    {- ^ (Required) The user pool the client belongs to. -}
    , _write_attributes                     :: !(TF.Attr s Text)
    {- ^ (Optional) List of user pool attributes the application client can write to. -}
    } deriving (Show, Eq)

instance TF.ToHCL (CognitoUserPoolClientResource s) where
    toHCL CognitoUserPoolClientResource{..} = TF.inline $ catMaybes
        [ TF.assign "allowed_oauth_flows" <$> TF.attribute _allowed_oauth_flows
        , TF.assign "allowed_oauth_flows_user_pool_client" <$> TF.attribute _allowed_oauth_flows_user_pool_client
        , TF.assign "allowed_oauth_scopes" <$> TF.attribute _allowed_oauth_scopes
        , TF.assign "callback_urls" <$> TF.attribute _callback_urls
        , TF.assign "default_redirect_uri" <$> TF.attribute _default_redirect_uri
        , TF.assign "explicit_auth_flows" <$> TF.attribute _explicit_auth_flows
        , TF.assign "generate_secret" <$> TF.attribute _generate_secret
        , TF.assign "logout_urls" <$> TF.attribute _logout_urls
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "read_attributes" <$> TF.attribute _read_attributes
        , TF.assign "refresh_token_validity" <$> TF.attribute _refresh_token_validity
        , TF.assign "supported_identity_providers" <$> TF.attribute _supported_identity_providers
        , TF.assign "user_pool_id" <$> TF.attribute _user_pool_id
        , TF.assign "write_attributes" <$> TF.attribute _write_attributes
        ]

instance P.HasAllowedOauthFlows (CognitoUserPoolClientResource s) (TF.Attr s Text) where
    allowedOauthFlows =
        lens (_allowed_oauth_flows :: CognitoUserPoolClientResource s -> TF.Attr s Text)
             (\s a -> s { _allowed_oauth_flows = a } :: CognitoUserPoolClientResource s)

instance P.HasAllowedOauthFlowsUserPoolClient (CognitoUserPoolClientResource s) (TF.Attr s Text) where
    allowedOauthFlowsUserPoolClient =
        lens (_allowed_oauth_flows_user_pool_client :: CognitoUserPoolClientResource s -> TF.Attr s Text)
             (\s a -> s { _allowed_oauth_flows_user_pool_client = a } :: CognitoUserPoolClientResource s)

instance P.HasAllowedOauthScopes (CognitoUserPoolClientResource s) (TF.Attr s Text) where
    allowedOauthScopes =
        lens (_allowed_oauth_scopes :: CognitoUserPoolClientResource s -> TF.Attr s Text)
             (\s a -> s { _allowed_oauth_scopes = a } :: CognitoUserPoolClientResource s)

instance P.HasCallbackUrls (CognitoUserPoolClientResource s) (TF.Attr s Text) where
    callbackUrls =
        lens (_callback_urls :: CognitoUserPoolClientResource s -> TF.Attr s Text)
             (\s a -> s { _callback_urls = a } :: CognitoUserPoolClientResource s)

instance P.HasDefaultRedirectUri (CognitoUserPoolClientResource s) (TF.Attr s Text) where
    defaultRedirectUri =
        lens (_default_redirect_uri :: CognitoUserPoolClientResource s -> TF.Attr s Text)
             (\s a -> s { _default_redirect_uri = a } :: CognitoUserPoolClientResource s)

instance P.HasExplicitAuthFlows (CognitoUserPoolClientResource s) (TF.Attr s Text) where
    explicitAuthFlows =
        lens (_explicit_auth_flows :: CognitoUserPoolClientResource s -> TF.Attr s Text)
             (\s a -> s { _explicit_auth_flows = a } :: CognitoUserPoolClientResource s)

instance P.HasGenerateSecret (CognitoUserPoolClientResource s) (TF.Attr s Text) where
    generateSecret =
        lens (_generate_secret :: CognitoUserPoolClientResource s -> TF.Attr s Text)
             (\s a -> s { _generate_secret = a } :: CognitoUserPoolClientResource s)

instance P.HasLogoutUrls (CognitoUserPoolClientResource s) (TF.Attr s Text) where
    logoutUrls =
        lens (_logout_urls :: CognitoUserPoolClientResource s -> TF.Attr s Text)
             (\s a -> s { _logout_urls = a } :: CognitoUserPoolClientResource s)

instance P.HasName (CognitoUserPoolClientResource s) (TF.Attr s Text) where
    name =
        lens (_name :: CognitoUserPoolClientResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: CognitoUserPoolClientResource s)

instance P.HasReadAttributes (CognitoUserPoolClientResource s) (TF.Attr s Text) where
    readAttributes =
        lens (_read_attributes :: CognitoUserPoolClientResource s -> TF.Attr s Text)
             (\s a -> s { _read_attributes = a } :: CognitoUserPoolClientResource s)

instance P.HasRefreshTokenValidity (CognitoUserPoolClientResource s) (TF.Attr s Text) where
    refreshTokenValidity =
        lens (_refresh_token_validity :: CognitoUserPoolClientResource s -> TF.Attr s Text)
             (\s a -> s { _refresh_token_validity = a } :: CognitoUserPoolClientResource s)

instance P.HasSupportedIdentityProviders (CognitoUserPoolClientResource s) (TF.Attr s Text) where
    supportedIdentityProviders =
        lens (_supported_identity_providers :: CognitoUserPoolClientResource s -> TF.Attr s Text)
             (\s a -> s { _supported_identity_providers = a } :: CognitoUserPoolClientResource s)

instance P.HasUserPoolId (CognitoUserPoolClientResource s) (TF.Attr s Text) where
    userPoolId =
        lens (_user_pool_id :: CognitoUserPoolClientResource s -> TF.Attr s Text)
             (\s a -> s { _user_pool_id = a } :: CognitoUserPoolClientResource s)

instance P.HasWriteAttributes (CognitoUserPoolClientResource s) (TF.Attr s Text) where
    writeAttributes =
        lens (_write_attributes :: CognitoUserPoolClientResource s -> TF.Attr s Text)
             (\s a -> s { _write_attributes = a } :: CognitoUserPoolClientResource s)

instance P.HasComputedAllowedOauthFlows (CognitoUserPoolClientResource s) s (TF.Attr s Text) where
    computedAllowedOauthFlows =
        (_allowed_oauth_flows :: CognitoUserPoolClientResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAllowedOauthFlowsUserPoolClient (CognitoUserPoolClientResource s) s (TF.Attr s Text) where
    computedAllowedOauthFlowsUserPoolClient =
        (_allowed_oauth_flows_user_pool_client :: CognitoUserPoolClientResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAllowedOauthScopes (CognitoUserPoolClientResource s) s (TF.Attr s Text) where
    computedAllowedOauthScopes =
        (_allowed_oauth_scopes :: CognitoUserPoolClientResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCallbackUrls (CognitoUserPoolClientResource s) s (TF.Attr s Text) where
    computedCallbackUrls =
        (_callback_urls :: CognitoUserPoolClientResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedClientSecret (CognitoUserPoolClientResource s) s (TF.Attr s Text) where
    computedClientSecret x = TF.compute (TF.refKey x) "client_secret"

instance P.HasComputedDefaultRedirectUri (CognitoUserPoolClientResource s) s (TF.Attr s Text) where
    computedDefaultRedirectUri =
        (_default_redirect_uri :: CognitoUserPoolClientResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedExplicitAuthFlows (CognitoUserPoolClientResource s) s (TF.Attr s Text) where
    computedExplicitAuthFlows =
        (_explicit_auth_flows :: CognitoUserPoolClientResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedGenerateSecret (CognitoUserPoolClientResource s) s (TF.Attr s Text) where
    computedGenerateSecret =
        (_generate_secret :: CognitoUserPoolClientResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (CognitoUserPoolClientResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedLogoutUrls (CognitoUserPoolClientResource s) s (TF.Attr s Text) where
    computedLogoutUrls =
        (_logout_urls :: CognitoUserPoolClientResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (CognitoUserPoolClientResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: CognitoUserPoolClientResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedReadAttributes (CognitoUserPoolClientResource s) s (TF.Attr s Text) where
    computedReadAttributes =
        (_read_attributes :: CognitoUserPoolClientResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRefreshTokenValidity (CognitoUserPoolClientResource s) s (TF.Attr s Text) where
    computedRefreshTokenValidity =
        (_refresh_token_validity :: CognitoUserPoolClientResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSupportedIdentityProviders (CognitoUserPoolClientResource s) s (TF.Attr s Text) where
    computedSupportedIdentityProviders =
        (_supported_identity_providers :: CognitoUserPoolClientResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedUserPoolId (CognitoUserPoolClientResource s) s (TF.Attr s Text) where
    computedUserPoolId =
        (_user_pool_id :: CognitoUserPoolClientResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedWriteAttributes (CognitoUserPoolClientResource s) s (TF.Attr s Text) where
    computedWriteAttributes =
        (_write_attributes :: CognitoUserPoolClientResource s -> TF.Attr s Text)
            . TF.refValue

cognitoUserPoolClientResource :: TF.Schema TF.Resource P.AWS (CognitoUserPoolClientResource s)
cognitoUserPoolClientResource =
    TF.newResource "aws_cognito_user_pool_client" $
        CognitoUserPoolClientResource {
              _allowed_oauth_flows = TF.Nil
            , _allowed_oauth_flows_user_pool_client = TF.Nil
            , _allowed_oauth_scopes = TF.Nil
            , _callback_urls = TF.Nil
            , _default_redirect_uri = TF.Nil
            , _explicit_auth_flows = TF.Nil
            , _generate_secret = TF.Nil
            , _logout_urls = TF.Nil
            , _name = TF.Nil
            , _read_attributes = TF.Nil
            , _refresh_token_validity = TF.Nil
            , _supported_identity_providers = TF.Nil
            , _user_pool_id = TF.Nil
            , _write_attributes = TF.Nil
            }

{- | The @aws_cognito_user_pool_domain@ AWS resource.

Provides a Cognito User Pool Domain resource.
-}
data CognitoUserPoolDomainResource s = CognitoUserPoolDomainResource {
      _domain       :: !(TF.Attr s Text)
    {- ^ (Required) The domain string. -}
    , _user_pool_id :: !(TF.Attr s Text)
    {- ^ (Required) The user pool ID. -}
    } deriving (Show, Eq)

instance TF.ToHCL (CognitoUserPoolDomainResource s) where
    toHCL CognitoUserPoolDomainResource{..} = TF.inline $ catMaybes
        [ TF.assign "domain" <$> TF.attribute _domain
        , TF.assign "user_pool_id" <$> TF.attribute _user_pool_id
        ]

instance P.HasDomain (CognitoUserPoolDomainResource s) (TF.Attr s Text) where
    domain =
        lens (_domain :: CognitoUserPoolDomainResource s -> TF.Attr s Text)
             (\s a -> s { _domain = a } :: CognitoUserPoolDomainResource s)

instance P.HasUserPoolId (CognitoUserPoolDomainResource s) (TF.Attr s Text) where
    userPoolId =
        lens (_user_pool_id :: CognitoUserPoolDomainResource s -> TF.Attr s Text)
             (\s a -> s { _user_pool_id = a } :: CognitoUserPoolDomainResource s)

instance P.HasComputedAwsAccountId (CognitoUserPoolDomainResource s) s (TF.Attr s Text) where
    computedAwsAccountId x = TF.compute (TF.refKey x) "aws_account_id"

instance P.HasComputedCloudfrontDistributionArn (CognitoUserPoolDomainResource s) s (TF.Attr s Text) where
    computedCloudfrontDistributionArn x = TF.compute (TF.refKey x) "cloudfront_distribution_arn"

instance P.HasComputedDomain (CognitoUserPoolDomainResource s) s (TF.Attr s Text) where
    computedDomain =
        (_domain :: CognitoUserPoolDomainResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedS3Bucket (CognitoUserPoolDomainResource s) s (TF.Attr s Text) where
    computedS3Bucket x = TF.compute (TF.refKey x) "s3_bucket"

instance P.HasComputedUserPoolId (CognitoUserPoolDomainResource s) s (TF.Attr s Text) where
    computedUserPoolId =
        (_user_pool_id :: CognitoUserPoolDomainResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedVersion (CognitoUserPoolDomainResource s) s (TF.Attr s Text) where
    computedVersion x = TF.compute (TF.refKey x) "version"

cognitoUserPoolDomainResource :: TF.Schema TF.Resource P.AWS (CognitoUserPoolDomainResource s)
cognitoUserPoolDomainResource =
    TF.newResource "aws_cognito_user_pool_domain" $
        CognitoUserPoolDomainResource {
              _domain = TF.Nil
            , _user_pool_id = TF.Nil
            }

{- | The @aws_cognito_user_pool@ AWS resource.

Provides a Cognito User Pool resource.
-}
data CognitoUserPoolResource s = CognitoUserPoolResource {
      _admin_create_user_config      :: !(TF.Attr s Text)
    {- ^ (Optional) - The configuration for <#admin-create-user-config> requests. -}
    , _alias_attributes              :: !(TF.Attr s Text)
    {- ^ (Optional) Attributes supported as an alias for this user pool. Possible values: phone_number, email, or preferred_username. Conflicts with @username_attributes@ . -}
    , _auto_verified_attributes      :: !(TF.Attr s Text)
    {- ^ (Optional) The attributes to be auto-verified. Possible values: email, phone_number. -}
    , _device_configuration          :: !(TF.Attr s Text)
    {- ^ (Optional) - The configuration for the <#device-configuration> . -}
    , _email_configuration           :: !(TF.Attr s Text)
    {- ^ (Optional) - The <#email-configuration> . -}
    , _email_verification_message    :: !(TF.Attr s Text)
    {- ^ (Optional) A string representing the email verification message. Must contain the @{####}@ placeholder. NOTE: - If @email_verification_message@ and @verification_message_template.email_message@ are specified and the values are different, either one is prioritized and updated. -}
    , _email_verification_subject    :: !(TF.Attr s Text)
    {- ^ (Optional) A string representing the email verification subject. NOTE: - If @email_verification_subject@ and @verification_message_template.email_subject@ are specified and the values are different, either one is prioritized and updated. -}
    , _lambda_config                 :: !(TF.Attr s Text)
    {- ^ (Optional) - A container for the AWS <#lambda-configuration> associated with the user pool. -}
    , _mfa_configuration             :: !(TF.Attr s Text)
    {- ^ (Optional, Default: OFF) Set to enable multi-factor authentication. Must be one of the following values (ON, OFF, OPTIONAL) -}
    , _name                          :: !(TF.Attr s Text)
    {- ^ (Required) The name of the user pool. -}
    , _password_policy               :: !(TF.Attr s Text)
    {- ^ (Optional) - A container for information about the <#password-policy> . -}
    , _schema                        :: !(TF.Attr s Text)
    {- ^ (Optional) - A container with the <#schema-attributes> of a user pool. Maximum of 50 attributes. -}
    , _sms_authentication_message    :: !(TF.Attr s Text)
    {- ^ (Optional) A string representing the SMS authentication message. -}
    , _sms_configuration             :: !(TF.Attr s Text)
    {- ^ (Optional) - The <#sms-configuration> . -}
    , _sms_verification_message      :: !(TF.Attr s Text)
    {- ^ (Optional) A string representing the SMS verification message. -}
    , _tags                          :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the User Pool. -}
    , _username_attributes           :: !(TF.Attr s Text)
    {- ^ (Optional) Specifies whether email addresses or phone numbers can be specified as usernames when a user signs up. Conflicts with @alias_attributes@ . -}
    , _verification_message_template :: !(TF.Attr s Text)
    {- ^ (Optional) - The <#verification-message-template> configuration. -}
    } deriving (Show, Eq)

instance TF.ToHCL (CognitoUserPoolResource s) where
    toHCL CognitoUserPoolResource{..} = TF.inline $ catMaybes
        [ TF.assign "admin_create_user_config" <$> TF.attribute _admin_create_user_config
        , TF.assign "alias_attributes" <$> TF.attribute _alias_attributes
        , TF.assign "auto_verified_attributes" <$> TF.attribute _auto_verified_attributes
        , TF.assign "device_configuration" <$> TF.attribute _device_configuration
        , TF.assign "email_configuration" <$> TF.attribute _email_configuration
        , TF.assign "email_verification_message" <$> TF.attribute _email_verification_message
        , TF.assign "email_verification_subject" <$> TF.attribute _email_verification_subject
        , TF.assign "lambda_config" <$> TF.attribute _lambda_config
        , TF.assign "mfa_configuration" <$> TF.attribute _mfa_configuration
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "password_policy" <$> TF.attribute _password_policy
        , TF.assign "schema" <$> TF.attribute _schema
        , TF.assign "sms_authentication_message" <$> TF.attribute _sms_authentication_message
        , TF.assign "sms_configuration" <$> TF.attribute _sms_configuration
        , TF.assign "sms_verification_message" <$> TF.attribute _sms_verification_message
        , TF.assign "tags" <$> TF.attribute _tags
        , TF.assign "username_attributes" <$> TF.attribute _username_attributes
        , TF.assign "verification_message_template" <$> TF.attribute _verification_message_template
        ]

instance P.HasAdminCreateUserConfig (CognitoUserPoolResource s) (TF.Attr s Text) where
    adminCreateUserConfig =
        lens (_admin_create_user_config :: CognitoUserPoolResource s -> TF.Attr s Text)
             (\s a -> s { _admin_create_user_config = a } :: CognitoUserPoolResource s)

instance P.HasAliasAttributes (CognitoUserPoolResource s) (TF.Attr s Text) where
    aliasAttributes =
        lens (_alias_attributes :: CognitoUserPoolResource s -> TF.Attr s Text)
             (\s a -> s { _alias_attributes = a } :: CognitoUserPoolResource s)

instance P.HasAutoVerifiedAttributes (CognitoUserPoolResource s) (TF.Attr s Text) where
    autoVerifiedAttributes =
        lens (_auto_verified_attributes :: CognitoUserPoolResource s -> TF.Attr s Text)
             (\s a -> s { _auto_verified_attributes = a } :: CognitoUserPoolResource s)

instance P.HasDeviceConfiguration (CognitoUserPoolResource s) (TF.Attr s Text) where
    deviceConfiguration =
        lens (_device_configuration :: CognitoUserPoolResource s -> TF.Attr s Text)
             (\s a -> s { _device_configuration = a } :: CognitoUserPoolResource s)

instance P.HasEmailConfiguration (CognitoUserPoolResource s) (TF.Attr s Text) where
    emailConfiguration =
        lens (_email_configuration :: CognitoUserPoolResource s -> TF.Attr s Text)
             (\s a -> s { _email_configuration = a } :: CognitoUserPoolResource s)

instance P.HasEmailVerificationMessage (CognitoUserPoolResource s) (TF.Attr s Text) where
    emailVerificationMessage =
        lens (_email_verification_message :: CognitoUserPoolResource s -> TF.Attr s Text)
             (\s a -> s { _email_verification_message = a } :: CognitoUserPoolResource s)

instance P.HasEmailVerificationSubject (CognitoUserPoolResource s) (TF.Attr s Text) where
    emailVerificationSubject =
        lens (_email_verification_subject :: CognitoUserPoolResource s -> TF.Attr s Text)
             (\s a -> s { _email_verification_subject = a } :: CognitoUserPoolResource s)

instance P.HasLambdaConfig (CognitoUserPoolResource s) (TF.Attr s Text) where
    lambdaConfig =
        lens (_lambda_config :: CognitoUserPoolResource s -> TF.Attr s Text)
             (\s a -> s { _lambda_config = a } :: CognitoUserPoolResource s)

instance P.HasMfaConfiguration (CognitoUserPoolResource s) (TF.Attr s Text) where
    mfaConfiguration =
        lens (_mfa_configuration :: CognitoUserPoolResource s -> TF.Attr s Text)
             (\s a -> s { _mfa_configuration = a } :: CognitoUserPoolResource s)

instance P.HasName (CognitoUserPoolResource s) (TF.Attr s Text) where
    name =
        lens (_name :: CognitoUserPoolResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: CognitoUserPoolResource s)

instance P.HasPasswordPolicy (CognitoUserPoolResource s) (TF.Attr s Text) where
    passwordPolicy =
        lens (_password_policy :: CognitoUserPoolResource s -> TF.Attr s Text)
             (\s a -> s { _password_policy = a } :: CognitoUserPoolResource s)

instance P.HasSchema (CognitoUserPoolResource s) (TF.Attr s Text) where
    schema =
        lens (_schema :: CognitoUserPoolResource s -> TF.Attr s Text)
             (\s a -> s { _schema = a } :: CognitoUserPoolResource s)

instance P.HasSmsAuthenticationMessage (CognitoUserPoolResource s) (TF.Attr s Text) where
    smsAuthenticationMessage =
        lens (_sms_authentication_message :: CognitoUserPoolResource s -> TF.Attr s Text)
             (\s a -> s { _sms_authentication_message = a } :: CognitoUserPoolResource s)

instance P.HasSmsConfiguration (CognitoUserPoolResource s) (TF.Attr s Text) where
    smsConfiguration =
        lens (_sms_configuration :: CognitoUserPoolResource s -> TF.Attr s Text)
             (\s a -> s { _sms_configuration = a } :: CognitoUserPoolResource s)

instance P.HasSmsVerificationMessage (CognitoUserPoolResource s) (TF.Attr s Text) where
    smsVerificationMessage =
        lens (_sms_verification_message :: CognitoUserPoolResource s -> TF.Attr s Text)
             (\s a -> s { _sms_verification_message = a } :: CognitoUserPoolResource s)

instance P.HasTags (CognitoUserPoolResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: CognitoUserPoolResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: CognitoUserPoolResource s)

instance P.HasUsernameAttributes (CognitoUserPoolResource s) (TF.Attr s Text) where
    usernameAttributes =
        lens (_username_attributes :: CognitoUserPoolResource s -> TF.Attr s Text)
             (\s a -> s { _username_attributes = a } :: CognitoUserPoolResource s)

instance P.HasVerificationMessageTemplate (CognitoUserPoolResource s) (TF.Attr s Text) where
    verificationMessageTemplate =
        lens (_verification_message_template :: CognitoUserPoolResource s -> TF.Attr s Text)
             (\s a -> s { _verification_message_template = a } :: CognitoUserPoolResource s)

instance P.HasComputedAdminCreateUserConfig (CognitoUserPoolResource s) s (TF.Attr s Text) where
    computedAdminCreateUserConfig =
        (_admin_create_user_config :: CognitoUserPoolResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAliasAttributes (CognitoUserPoolResource s) s (TF.Attr s Text) where
    computedAliasAttributes =
        (_alias_attributes :: CognitoUserPoolResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedArn (CognitoUserPoolResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedAutoVerifiedAttributes (CognitoUserPoolResource s) s (TF.Attr s Text) where
    computedAutoVerifiedAttributes =
        (_auto_verified_attributes :: CognitoUserPoolResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCreationDate (CognitoUserPoolResource s) s (TF.Attr s Text) where
    computedCreationDate x = TF.compute (TF.refKey x) "creation_date"

instance P.HasComputedDeviceConfiguration (CognitoUserPoolResource s) s (TF.Attr s Text) where
    computedDeviceConfiguration =
        (_device_configuration :: CognitoUserPoolResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEmailConfiguration (CognitoUserPoolResource s) s (TF.Attr s Text) where
    computedEmailConfiguration =
        (_email_configuration :: CognitoUserPoolResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEmailVerificationMessage (CognitoUserPoolResource s) s (TF.Attr s Text) where
    computedEmailVerificationMessage =
        (_email_verification_message :: CognitoUserPoolResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEmailVerificationSubject (CognitoUserPoolResource s) s (TF.Attr s Text) where
    computedEmailVerificationSubject =
        (_email_verification_subject :: CognitoUserPoolResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (CognitoUserPoolResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedLambdaConfig (CognitoUserPoolResource s) s (TF.Attr s Text) where
    computedLambdaConfig =
        (_lambda_config :: CognitoUserPoolResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedLastModifiedDate (CognitoUserPoolResource s) s (TF.Attr s Text) where
    computedLastModifiedDate x = TF.compute (TF.refKey x) "last_modified_date"

instance P.HasComputedMfaConfiguration (CognitoUserPoolResource s) s (TF.Attr s Text) where
    computedMfaConfiguration =
        (_mfa_configuration :: CognitoUserPoolResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (CognitoUserPoolResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: CognitoUserPoolResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPasswordPolicy (CognitoUserPoolResource s) s (TF.Attr s Text) where
    computedPasswordPolicy =
        (_password_policy :: CognitoUserPoolResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSchema (CognitoUserPoolResource s) s (TF.Attr s Text) where
    computedSchema =
        (_schema :: CognitoUserPoolResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSmsAuthenticationMessage (CognitoUserPoolResource s) s (TF.Attr s Text) where
    computedSmsAuthenticationMessage =
        (_sms_authentication_message :: CognitoUserPoolResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSmsConfiguration (CognitoUserPoolResource s) s (TF.Attr s Text) where
    computedSmsConfiguration =
        (_sms_configuration :: CognitoUserPoolResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSmsVerificationMessage (CognitoUserPoolResource s) s (TF.Attr s Text) where
    computedSmsVerificationMessage =
        (_sms_verification_message :: CognitoUserPoolResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (CognitoUserPoolResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: CognitoUserPoolResource s -> TF.Attr s P.Tags)
            . TF.refValue

instance P.HasComputedUsernameAttributes (CognitoUserPoolResource s) s (TF.Attr s Text) where
    computedUsernameAttributes =
        (_username_attributes :: CognitoUserPoolResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedVerificationMessageTemplate (CognitoUserPoolResource s) s (TF.Attr s Text) where
    computedVerificationMessageTemplate =
        (_verification_message_template :: CognitoUserPoolResource s -> TF.Attr s Text)
            . TF.refValue

cognitoUserPoolResource :: TF.Schema TF.Resource P.AWS (CognitoUserPoolResource s)
cognitoUserPoolResource =
    TF.newResource "aws_cognito_user_pool" $
        CognitoUserPoolResource {
              _admin_create_user_config = TF.Nil
            , _alias_attributes = TF.Nil
            , _auto_verified_attributes = TF.Nil
            , _device_configuration = TF.Nil
            , _email_configuration = TF.Nil
            , _email_verification_message = TF.Nil
            , _email_verification_subject = TF.Nil
            , _lambda_config = TF.Nil
            , _mfa_configuration = TF.Nil
            , _name = TF.Nil
            , _password_policy = TF.Nil
            , _schema = TF.Nil
            , _sms_authentication_message = TF.Nil
            , _sms_configuration = TF.Nil
            , _sms_verification_message = TF.Nil
            , _tags = TF.Nil
            , _username_attributes = TF.Nil
            , _verification_message_template = TF.Nil
            }

{- | The @aws_config_config_rule@ AWS resource.

Provides an AWS Config Rule. ~> Note: Config Rule requires an existing
</docs/providers/aws/r/config_configuration_recorder.html> to be present.
Use of @depends_on@ is recommended (as shown below) to avoid race
conditions.
-}
data ConfigConfigRuleResource s = ConfigConfigRuleResource {
      _description                 :: !(TF.Attr s Text)
    {- ^ (Optional) Description of the rule -}
    , _input_parameters            :: !(TF.Attr s Text)
    {- ^ (Optional) A string in JSON format that is passed to the AWS Config rule Lambda function. -}
    , _maximum_execution_frequency :: !(TF.Attr s Text)
    {- ^ (Optional) The maximum frequency with which AWS Config runs evaluations for a rule. -}
    , _name                        :: !(TF.Attr s Text)
    {- ^ (Required) The name of the rule -}
    , _scope                       :: !(TF.Attr s Text)
    {- ^ (Optional) Scope defines which resources can trigger an evaluation for the rule as documented below. -}
    , _source                      :: !(TF.Attr s Text)
    {- ^ (Required) Source specifies the rule owner, the rule identifier, and the notifications that cause the function to evaluate your AWS resources as documented below. -}
    } deriving (Show, Eq)

instance TF.ToHCL (ConfigConfigRuleResource s) where
    toHCL ConfigConfigRuleResource{..} = TF.inline $ catMaybes
        [ TF.assign "description" <$> TF.attribute _description
        , TF.assign "input_parameters" <$> TF.attribute _input_parameters
        , TF.assign "maximum_execution_frequency" <$> TF.attribute _maximum_execution_frequency
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "scope" <$> TF.attribute _scope
        , TF.assign "source" <$> TF.attribute _source
        ]

instance P.HasDescription (ConfigConfigRuleResource s) (TF.Attr s Text) where
    description =
        lens (_description :: ConfigConfigRuleResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: ConfigConfigRuleResource s)

instance P.HasInputParameters (ConfigConfigRuleResource s) (TF.Attr s Text) where
    inputParameters =
        lens (_input_parameters :: ConfigConfigRuleResource s -> TF.Attr s Text)
             (\s a -> s { _input_parameters = a } :: ConfigConfigRuleResource s)

instance P.HasMaximumExecutionFrequency (ConfigConfigRuleResource s) (TF.Attr s Text) where
    maximumExecutionFrequency =
        lens (_maximum_execution_frequency :: ConfigConfigRuleResource s -> TF.Attr s Text)
             (\s a -> s { _maximum_execution_frequency = a } :: ConfigConfigRuleResource s)

instance P.HasName (ConfigConfigRuleResource s) (TF.Attr s Text) where
    name =
        lens (_name :: ConfigConfigRuleResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: ConfigConfigRuleResource s)

instance P.HasScope (ConfigConfigRuleResource s) (TF.Attr s Text) where
    scope =
        lens (_scope :: ConfigConfigRuleResource s -> TF.Attr s Text)
             (\s a -> s { _scope = a } :: ConfigConfigRuleResource s)

instance P.HasSource (ConfigConfigRuleResource s) (TF.Attr s Text) where
    source =
        lens (_source :: ConfigConfigRuleResource s -> TF.Attr s Text)
             (\s a -> s { _source = a } :: ConfigConfigRuleResource s)

instance P.HasComputedArn (ConfigConfigRuleResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedDescription (ConfigConfigRuleResource s) s (TF.Attr s Text) where
    computedDescription =
        (_description :: ConfigConfigRuleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedInputParameters (ConfigConfigRuleResource s) s (TF.Attr s Text) where
    computedInputParameters =
        (_input_parameters :: ConfigConfigRuleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedMaximumExecutionFrequency (ConfigConfigRuleResource s) s (TF.Attr s Text) where
    computedMaximumExecutionFrequency =
        (_maximum_execution_frequency :: ConfigConfigRuleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (ConfigConfigRuleResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: ConfigConfigRuleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRuleId (ConfigConfigRuleResource s) s (TF.Attr s Text) where
    computedRuleId x = TF.compute (TF.refKey x) "rule_id"

instance P.HasComputedScope (ConfigConfigRuleResource s) s (TF.Attr s Text) where
    computedScope =
        (_scope :: ConfigConfigRuleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSource (ConfigConfigRuleResource s) s (TF.Attr s Text) where
    computedSource =
        (_source :: ConfigConfigRuleResource s -> TF.Attr s Text)
            . TF.refValue

configConfigRuleResource :: TF.Schema TF.Resource P.AWS (ConfigConfigRuleResource s)
configConfigRuleResource =
    TF.newResource "aws_config_config_rule" $
        ConfigConfigRuleResource {
              _description = TF.Nil
            , _input_parameters = TF.Nil
            , _maximum_execution_frequency = TF.Nil
            , _name = TF.Nil
            , _scope = TF.Nil
            , _source = TF.Nil
            }

{- | The @aws_config_configuration_recorder@ AWS resource.

Provides an AWS Config Configuration Recorder. Please note that this
resource does not start the created recorder automatically. ~> Note:
Starting the Configuration Recorder requires a
</docs/providers/aws/r/config_delivery_channel.html> (while delivery channel
creation requires Configuration Recorder). This is why
</docs/providers/aws/r/config_configuration_recorder_status.html> is a
separate resource.
-}
data ConfigConfigurationRecorderResource s = ConfigConfigurationRecorderResource {
      _name            :: !(TF.Attr s Text)
    {- ^ (Optional) The name of the recorder. Defaults to @default@ . Changing it recreates the resource. -}
    , _recording_group :: !(TF.Attr s Text)
    {- ^ (Optional) Recording group - see below. -}
    , _role_arn        :: !(TF.Attr s Text)
    {- ^ (Required) Amazon Resource Name (ARN) of the IAM role. used to make read or write requests to the delivery channel and to describe the AWS resources associated with the account. See <http://docs.aws.amazon.com/config/latest/developerguide/iamrole-permissions.html> for more details. -}
    } deriving (Show, Eq)

instance TF.ToHCL (ConfigConfigurationRecorderResource s) where
    toHCL ConfigConfigurationRecorderResource{..} = TF.inline $ catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "recording_group" <$> TF.attribute _recording_group
        , TF.assign "role_arn" <$> TF.attribute _role_arn
        ]

instance P.HasName (ConfigConfigurationRecorderResource s) (TF.Attr s Text) where
    name =
        lens (_name :: ConfigConfigurationRecorderResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: ConfigConfigurationRecorderResource s)

instance P.HasRecordingGroup (ConfigConfigurationRecorderResource s) (TF.Attr s Text) where
    recordingGroup =
        lens (_recording_group :: ConfigConfigurationRecorderResource s -> TF.Attr s Text)
             (\s a -> s { _recording_group = a } :: ConfigConfigurationRecorderResource s)

instance P.HasRoleArn (ConfigConfigurationRecorderResource s) (TF.Attr s Text) where
    roleArn =
        lens (_role_arn :: ConfigConfigurationRecorderResource s -> TF.Attr s Text)
             (\s a -> s { _role_arn = a } :: ConfigConfigurationRecorderResource s)

instance P.HasComputedId (ConfigConfigurationRecorderResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (ConfigConfigurationRecorderResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: ConfigConfigurationRecorderResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRecordingGroup (ConfigConfigurationRecorderResource s) s (TF.Attr s Text) where
    computedRecordingGroup =
        (_recording_group :: ConfigConfigurationRecorderResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRoleArn (ConfigConfigurationRecorderResource s) s (TF.Attr s Text) where
    computedRoleArn =
        (_role_arn :: ConfigConfigurationRecorderResource s -> TF.Attr s Text)
            . TF.refValue

configConfigurationRecorderResource :: TF.Schema TF.Resource P.AWS (ConfigConfigurationRecorderResource s)
configConfigurationRecorderResource =
    TF.newResource "aws_config_configuration_recorder" $
        ConfigConfigurationRecorderResource {
              _name = TF.Nil
            , _recording_group = TF.Nil
            , _role_arn = TF.Nil
            }

{- | The @aws_config_configuration_recorder_status@ AWS resource.

Manages status (recording / stopped) of an AWS Config Configuration
Recorder. ~> Note: Starting Configuration Recorder requires a
</docs/providers/aws/r/config_delivery_channel.html> to be present. Use of
@depends_on@ (as shown below) is recommended to avoid race conditions.
-}
data ConfigConfigurationRecorderStatusResource s = ConfigConfigurationRecorderStatusResource {
      _is_enabled :: !(TF.Attr s P.Bool)
    {- ^ (Required) Whether the configuration recorder should be enabled or disabled. -}
    , _name       :: !(TF.Attr s Text)
    {- ^ (Required) The name of the recorder -}
    } deriving (Show, Eq)

instance TF.ToHCL (ConfigConfigurationRecorderStatusResource s) where
    toHCL ConfigConfigurationRecorderStatusResource{..} = TF.inline $ catMaybes
        [ TF.assign "is_enabled" <$> TF.attribute _is_enabled
        , TF.assign "name" <$> TF.attribute _name
        ]

instance P.HasIsEnabled (ConfigConfigurationRecorderStatusResource s) (TF.Attr s P.Bool) where
    isEnabled =
        lens (_is_enabled :: ConfigConfigurationRecorderStatusResource s -> TF.Attr s P.Bool)
             (\s a -> s { _is_enabled = a } :: ConfigConfigurationRecorderStatusResource s)

instance P.HasName (ConfigConfigurationRecorderStatusResource s) (TF.Attr s Text) where
    name =
        lens (_name :: ConfigConfigurationRecorderStatusResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: ConfigConfigurationRecorderStatusResource s)

instance P.HasComputedIsEnabled (ConfigConfigurationRecorderStatusResource s) s (TF.Attr s P.Bool) where
    computedIsEnabled =
        (_is_enabled :: ConfigConfigurationRecorderStatusResource s -> TF.Attr s P.Bool)
            . TF.refValue

instance P.HasComputedName (ConfigConfigurationRecorderStatusResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: ConfigConfigurationRecorderStatusResource s -> TF.Attr s Text)
            . TF.refValue

configConfigurationRecorderStatusResource :: TF.Schema TF.Resource P.AWS (ConfigConfigurationRecorderStatusResource s)
configConfigurationRecorderStatusResource =
    TF.newResource "aws_config_configuration_recorder_status" $
        ConfigConfigurationRecorderStatusResource {
              _is_enabled = TF.Nil
            , _name = TF.Nil
            }

{- | The @aws_config_delivery_channel@ AWS resource.

Provides an AWS Config Delivery Channel. ~> Note: Delivery Channel requires
a </docs/providers/aws/r/config_configuration_recorder.html> to be present.
Use of @depends_on@ (as shown below) is recommended to avoid race
conditions.
-}
data ConfigDeliveryChannelResource s = ConfigDeliveryChannelResource {
      _name                         :: !(TF.Attr s Text)
    {- ^ (Optional) The name of the delivery channel. Defaults to @default@ . Changing it recreates the resource. -}
    , _s3_bucket_name               :: !(TF.Attr s Text)
    {- ^ (Required) The name of the S3 bucket used to store the configuration history. -}
    , _s3_key_prefix                :: !(TF.Attr s Text)
    {- ^ (Optional) The prefix for the specified S3 bucket. -}
    , _snapshot_delivery_properties :: !(TF.Attr s Text)
    {- ^ (Optional) Options for how AWS Config delivers configuration snapshots. See below -}
    , _sns_topic_arn                :: !(TF.Attr s Text)
    {- ^ (Optional) The ARN of the SNS topic that AWS Config delivers notifications to. -}
    } deriving (Show, Eq)

instance TF.ToHCL (ConfigDeliveryChannelResource s) where
    toHCL ConfigDeliveryChannelResource{..} = TF.inline $ catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "s3_bucket_name" <$> TF.attribute _s3_bucket_name
        , TF.assign "s3_key_prefix" <$> TF.attribute _s3_key_prefix
        , TF.assign "snapshot_delivery_properties" <$> TF.attribute _snapshot_delivery_properties
        , TF.assign "sns_topic_arn" <$> TF.attribute _sns_topic_arn
        ]

instance P.HasName (ConfigDeliveryChannelResource s) (TF.Attr s Text) where
    name =
        lens (_name :: ConfigDeliveryChannelResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: ConfigDeliveryChannelResource s)

instance P.HasS3BucketName (ConfigDeliveryChannelResource s) (TF.Attr s Text) where
    s3BucketName =
        lens (_s3_bucket_name :: ConfigDeliveryChannelResource s -> TF.Attr s Text)
             (\s a -> s { _s3_bucket_name = a } :: ConfigDeliveryChannelResource s)

instance P.HasS3KeyPrefix (ConfigDeliveryChannelResource s) (TF.Attr s Text) where
    s3KeyPrefix =
        lens (_s3_key_prefix :: ConfigDeliveryChannelResource s -> TF.Attr s Text)
             (\s a -> s { _s3_key_prefix = a } :: ConfigDeliveryChannelResource s)

instance P.HasSnapshotDeliveryProperties (ConfigDeliveryChannelResource s) (TF.Attr s Text) where
    snapshotDeliveryProperties =
        lens (_snapshot_delivery_properties :: ConfigDeliveryChannelResource s -> TF.Attr s Text)
             (\s a -> s { _snapshot_delivery_properties = a } :: ConfigDeliveryChannelResource s)

instance P.HasSnsTopicArn (ConfigDeliveryChannelResource s) (TF.Attr s Text) where
    snsTopicArn =
        lens (_sns_topic_arn :: ConfigDeliveryChannelResource s -> TF.Attr s Text)
             (\s a -> s { _sns_topic_arn = a } :: ConfigDeliveryChannelResource s)

instance P.HasComputedId (ConfigDeliveryChannelResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (ConfigDeliveryChannelResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: ConfigDeliveryChannelResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedS3BucketName (ConfigDeliveryChannelResource s) s (TF.Attr s Text) where
    computedS3BucketName =
        (_s3_bucket_name :: ConfigDeliveryChannelResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedS3KeyPrefix (ConfigDeliveryChannelResource s) s (TF.Attr s Text) where
    computedS3KeyPrefix =
        (_s3_key_prefix :: ConfigDeliveryChannelResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSnapshotDeliveryProperties (ConfigDeliveryChannelResource s) s (TF.Attr s Text) where
    computedSnapshotDeliveryProperties =
        (_snapshot_delivery_properties :: ConfigDeliveryChannelResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSnsTopicArn (ConfigDeliveryChannelResource s) s (TF.Attr s Text) where
    computedSnsTopicArn =
        (_sns_topic_arn :: ConfigDeliveryChannelResource s -> TF.Attr s Text)
            . TF.refValue

configDeliveryChannelResource :: TF.Schema TF.Resource P.AWS (ConfigDeliveryChannelResource s)
configDeliveryChannelResource =
    TF.newResource "aws_config_delivery_channel" $
        ConfigDeliveryChannelResource {
              _name = TF.Nil
            , _s3_bucket_name = TF.Nil
            , _s3_key_prefix = TF.Nil
            , _snapshot_delivery_properties = TF.Nil
            , _sns_topic_arn = TF.Nil
            }

{- | The @aws_customer_gateway@ AWS resource.

Provides a customer gateway inside a VPC. These objects can be connected to
VPN gateways via VPN connections, and allow you to establish tunnels between
your network and the VPC.
-}
data CustomerGatewayResource s = CustomerGatewayResource {
      _bgp_asn    :: !(TF.Attr s Text)
    {- ^ (Required) The gateway's Border Gateway Protocol (BGP) Autonomous System Number (ASN). -}
    , _ip_address :: !(TF.Attr s Text)
    {- ^ (Required) The IP address of the gateway's Internet-routable external interface. -}
    , _tags       :: !(TF.Attr s P.Tags)
    {- ^ (Optional) Tags to apply to the gateway. -}
    , _type'      :: !(TF.Attr s Text)
    {- ^ (Required) The type of customer gateway. The only type AWS supports at this time is "ipsec.1". -}
    } deriving (Show, Eq)

instance TF.ToHCL (CustomerGatewayResource s) where
    toHCL CustomerGatewayResource{..} = TF.inline $ catMaybes
        [ TF.assign "bgp_asn" <$> TF.attribute _bgp_asn
        , TF.assign "ip_address" <$> TF.attribute _ip_address
        , TF.assign "tags" <$> TF.attribute _tags
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance P.HasBgpAsn (CustomerGatewayResource s) (TF.Attr s Text) where
    bgpAsn =
        lens (_bgp_asn :: CustomerGatewayResource s -> TF.Attr s Text)
             (\s a -> s { _bgp_asn = a } :: CustomerGatewayResource s)

instance P.HasIpAddress (CustomerGatewayResource s) (TF.Attr s Text) where
    ipAddress =
        lens (_ip_address :: CustomerGatewayResource s -> TF.Attr s Text)
             (\s a -> s { _ip_address = a } :: CustomerGatewayResource s)

instance P.HasTags (CustomerGatewayResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: CustomerGatewayResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: CustomerGatewayResource s)

instance P.HasType' (CustomerGatewayResource s) (TF.Attr s Text) where
    type' =
        lens (_type' :: CustomerGatewayResource s -> TF.Attr s Text)
             (\s a -> s { _type' = a } :: CustomerGatewayResource s)

instance P.HasComputedBgpAsn (CustomerGatewayResource s) s (TF.Attr s Text) where
    computedBgpAsn x = TF.compute (TF.refKey x) "bgp_asn"

instance P.HasComputedId (CustomerGatewayResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedIpAddress (CustomerGatewayResource s) s (TF.Attr s Text) where
    computedIpAddress x = TF.compute (TF.refKey x) "ip_address"

instance P.HasComputedTags (CustomerGatewayResource s) s (TF.Attr s P.Tags) where
    computedTags x = TF.compute (TF.refKey x) "tags"

instance P.HasComputedType' (CustomerGatewayResource s) s (TF.Attr s Text) where
    computedType' x = TF.compute (TF.refKey x) "type"

customerGatewayResource :: TF.Schema TF.Resource P.AWS (CustomerGatewayResource s)
customerGatewayResource =
    TF.newResource "aws_customer_gateway" $
        CustomerGatewayResource {
              _bgp_asn = TF.Nil
            , _ip_address = TF.Nil
            , _tags = TF.Nil
            , _type' = TF.Nil
            }

{- | The @aws_dax_cluster@ AWS resource.

Provides a DAX Cluster resource.
-}
data DaxClusterResource s = DaxClusterResource {
      _availability_zones     :: !(TF.Attr s Text)
    {- ^ (Optional) List of Availability Zones in which the nodes will be created -}
    , _cluster_name           :: !(TF.Attr s Text)
    {- ^  (Required) Group identifier. DAX converts this name to lowercase -}
    , _description            :: !(TF.Attr s Text)
    {- ^  (Optional) Description for the cluster -}
    , _iam_role_arn           :: !(TF.Attr s Text)
    {- ^ (Required) A valid Amazon Resource Name (ARN) that identifies an IAM role. At runtime, DAX will assume this role and use the role's permissions to access DynamoDB on your behalf -}
    , _maintenance_window     :: !(TF.Attr s Text)
    {- ^  (Optional) Specifies the weekly time range for when maintenance on the cluster is performed. The format is @ddd:hh24:mi-ddd:hh24:mi@ (24H Clock UTC). The minimum maintenance window is a 60 minute period. Example: @sun:05:00-sun:09:00@ -}
    , _node_type              :: !(TF.Attr s Text)
    {- ^  (Required) The compute and memory capacity of the nodes. See <http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DAX.concepts.cluster.html#DAX.concepts.nodes> for supported node types -}
    , _notification_topic_arn :: !(TF.Attr s Text)
    {- ^  (Optional) An Amazon Resource Name (ARN) of an SNS topic to send DAX notifications to. Example: @arn:aws:sns:us-east-1:012345678999:my_sns_topic@ -}
    , _parameter_group_name   :: !(TF.Attr s Text)
    {- ^  (Optional) Name of the parameter group to associate with this DAX cluster -}
    , _replication_factor     :: !(TF.Attr s Text)
    {- ^  (Required) The number of nodes in the DAX cluster. A replication factor of 1 will create a single-node cluster, without any read replicas -}
    , _security_group_ids     :: !(TF.Attr s Text)
    {- ^  (Optional) One or more VPC security groups associated with the cluster -}
    , _subnet_group_name      :: !(TF.Attr s Text)
    {- ^  (Optional) Name of the subnet group to be used for the cluster -}
    , _tags                   :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource -}
    } deriving (Show, Eq)

instance TF.ToHCL (DaxClusterResource s) where
    toHCL DaxClusterResource{..} = TF.inline $ catMaybes
        [ TF.assign "availability_zones" <$> TF.attribute _availability_zones
        , TF.assign "cluster_name" <$> TF.attribute _cluster_name
        , TF.assign "description" <$> TF.attribute _description
        , TF.assign "iam_role_arn" <$> TF.attribute _iam_role_arn
        , TF.assign "maintenance_window" <$> TF.attribute _maintenance_window
        , TF.assign "node_type" <$> TF.attribute _node_type
        , TF.assign "notification_topic_arn" <$> TF.attribute _notification_topic_arn
        , TF.assign "parameter_group_name" <$> TF.attribute _parameter_group_name
        , TF.assign "replication_factor" <$> TF.attribute _replication_factor
        , TF.assign "security_group_ids" <$> TF.attribute _security_group_ids
        , TF.assign "subnet_group_name" <$> TF.attribute _subnet_group_name
        , TF.assign "tags" <$> TF.attribute _tags
        ]

instance P.HasAvailabilityZones (DaxClusterResource s) (TF.Attr s Text) where
    availabilityZones =
        lens (_availability_zones :: DaxClusterResource s -> TF.Attr s Text)
             (\s a -> s { _availability_zones = a } :: DaxClusterResource s)

instance P.HasClusterName (DaxClusterResource s) (TF.Attr s Text) where
    clusterName =
        lens (_cluster_name :: DaxClusterResource s -> TF.Attr s Text)
             (\s a -> s { _cluster_name = a } :: DaxClusterResource s)

instance P.HasDescription (DaxClusterResource s) (TF.Attr s Text) where
    description =
        lens (_description :: DaxClusterResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: DaxClusterResource s)

instance P.HasIamRoleArn (DaxClusterResource s) (TF.Attr s Text) where
    iamRoleArn =
        lens (_iam_role_arn :: DaxClusterResource s -> TF.Attr s Text)
             (\s a -> s { _iam_role_arn = a } :: DaxClusterResource s)

instance P.HasMaintenanceWindow (DaxClusterResource s) (TF.Attr s Text) where
    maintenanceWindow =
        lens (_maintenance_window :: DaxClusterResource s -> TF.Attr s Text)
             (\s a -> s { _maintenance_window = a } :: DaxClusterResource s)

instance P.HasNodeType (DaxClusterResource s) (TF.Attr s Text) where
    nodeType =
        lens (_node_type :: DaxClusterResource s -> TF.Attr s Text)
             (\s a -> s { _node_type = a } :: DaxClusterResource s)

instance P.HasNotificationTopicArn (DaxClusterResource s) (TF.Attr s Text) where
    notificationTopicArn =
        lens (_notification_topic_arn :: DaxClusterResource s -> TF.Attr s Text)
             (\s a -> s { _notification_topic_arn = a } :: DaxClusterResource s)

instance P.HasParameterGroupName (DaxClusterResource s) (TF.Attr s Text) where
    parameterGroupName =
        lens (_parameter_group_name :: DaxClusterResource s -> TF.Attr s Text)
             (\s a -> s { _parameter_group_name = a } :: DaxClusterResource s)

instance P.HasReplicationFactor (DaxClusterResource s) (TF.Attr s Text) where
    replicationFactor =
        lens (_replication_factor :: DaxClusterResource s -> TF.Attr s Text)
             (\s a -> s { _replication_factor = a } :: DaxClusterResource s)

instance P.HasSecurityGroupIds (DaxClusterResource s) (TF.Attr s Text) where
    securityGroupIds =
        lens (_security_group_ids :: DaxClusterResource s -> TF.Attr s Text)
             (\s a -> s { _security_group_ids = a } :: DaxClusterResource s)

instance P.HasSubnetGroupName (DaxClusterResource s) (TF.Attr s Text) where
    subnetGroupName =
        lens (_subnet_group_name :: DaxClusterResource s -> TF.Attr s Text)
             (\s a -> s { _subnet_group_name = a } :: DaxClusterResource s)

instance P.HasTags (DaxClusterResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: DaxClusterResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: DaxClusterResource s)

instance P.HasComputedArn (DaxClusterResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedAvailabilityZones (DaxClusterResource s) s (TF.Attr s Text) where
    computedAvailabilityZones =
        (_availability_zones :: DaxClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedClusterAddress (DaxClusterResource s) s (TF.Attr s Text) where
    computedClusterAddress x = TF.compute (TF.refKey x) "cluster_address"

instance P.HasComputedClusterName (DaxClusterResource s) s (TF.Attr s Text) where
    computedClusterName =
        (_cluster_name :: DaxClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedConfigurationEndpoint (DaxClusterResource s) s (TF.Attr s Text) where
    computedConfigurationEndpoint x = TF.compute (TF.refKey x) "configuration_endpoint"

instance P.HasComputedDescription (DaxClusterResource s) s (TF.Attr s Text) where
    computedDescription =
        (_description :: DaxClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedIamRoleArn (DaxClusterResource s) s (TF.Attr s Text) where
    computedIamRoleArn =
        (_iam_role_arn :: DaxClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedMaintenanceWindow (DaxClusterResource s) s (TF.Attr s Text) where
    computedMaintenanceWindow =
        (_maintenance_window :: DaxClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedNodeType (DaxClusterResource s) s (TF.Attr s Text) where
    computedNodeType =
        (_node_type :: DaxClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedNodes (DaxClusterResource s) s (TF.Attr s Text) where
    computedNodes x = TF.compute (TF.refKey x) "nodes"

instance P.HasComputedNotificationTopicArn (DaxClusterResource s) s (TF.Attr s Text) where
    computedNotificationTopicArn =
        (_notification_topic_arn :: DaxClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedParameterGroupName (DaxClusterResource s) s (TF.Attr s Text) where
    computedParameterGroupName =
        (_parameter_group_name :: DaxClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPort (DaxClusterResource s) s (TF.Attr s Text) where
    computedPort x = TF.compute (TF.refKey x) "port"

instance P.HasComputedReplicationFactor (DaxClusterResource s) s (TF.Attr s Text) where
    computedReplicationFactor =
        (_replication_factor :: DaxClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSecurityGroupIds (DaxClusterResource s) s (TF.Attr s Text) where
    computedSecurityGroupIds =
        (_security_group_ids :: DaxClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSubnetGroupName (DaxClusterResource s) s (TF.Attr s Text) where
    computedSubnetGroupName =
        (_subnet_group_name :: DaxClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (DaxClusterResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: DaxClusterResource s -> TF.Attr s P.Tags)
            . TF.refValue

daxClusterResource :: TF.Schema TF.Resource P.AWS (DaxClusterResource s)
daxClusterResource =
    TF.newResource "aws_dax_cluster" $
        DaxClusterResource {
              _availability_zones = TF.Nil
            , _cluster_name = TF.Nil
            , _description = TF.Nil
            , _iam_role_arn = TF.Nil
            , _maintenance_window = TF.Nil
            , _node_type = TF.Nil
            , _notification_topic_arn = TF.Nil
            , _parameter_group_name = TF.Nil
            , _replication_factor = TF.Nil
            , _security_group_ids = TF.Nil
            , _subnet_group_name = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_db_event_subscription@ AWS resource.

Provides a DB event subscription resource.
-}
data DbEventSubscriptionResource s = DbEventSubscriptionResource {
      _enabled          :: !(TF.Attr s P.Bool)
    {- ^ (Optional) A boolean flag to enable/disable the subscription. Defaults to true. -}
    , _event_categories :: !(TF.Attr s Text)
    {- ^ (Optional) A list of event categories for a SourceType that you want to subscribe to. See http://docs.aws.amazon.com/AmazonRDS/latest/UserGuide//USER_Events.html -}
    , _name             :: !(TF.Attr s Text)
    {- ^ (Required) The name of the DB event subscription. -}
    , _sns_topic        :: !(TF.Attr s Text)
    {- ^ (Required) The SNS topic to send events to. -}
    , _source_ids       :: !(TF.Attr s Text)
    {- ^ (Optional) A list of identifiers of the event sources for which events will be returned. If not specified, then all sources are included in the response. If specified, a source_type must also be specified. -}
    , _source_type      :: !(TF.Attr s Text)
    {- ^ (Optional) The type of source that will be generating the events. -}
    , _tags             :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    } deriving (Show, Eq)

instance TF.ToHCL (DbEventSubscriptionResource s) where
    toHCL DbEventSubscriptionResource{..} = TF.inline $ catMaybes
        [ TF.assign "enabled" <$> TF.attribute _enabled
        , TF.assign "event_categories" <$> TF.attribute _event_categories
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "sns_topic" <$> TF.attribute _sns_topic
        , TF.assign "source_ids" <$> TF.attribute _source_ids
        , TF.assign "source_type" <$> TF.attribute _source_type
        , TF.assign "tags" <$> TF.attribute _tags
        ]

instance P.HasEnabled (DbEventSubscriptionResource s) (TF.Attr s P.Bool) where
    enabled =
        lens (_enabled :: DbEventSubscriptionResource s -> TF.Attr s P.Bool)
             (\s a -> s { _enabled = a } :: DbEventSubscriptionResource s)

instance P.HasEventCategories (DbEventSubscriptionResource s) (TF.Attr s Text) where
    eventCategories =
        lens (_event_categories :: DbEventSubscriptionResource s -> TF.Attr s Text)
             (\s a -> s { _event_categories = a } :: DbEventSubscriptionResource s)

instance P.HasName (DbEventSubscriptionResource s) (TF.Attr s Text) where
    name =
        lens (_name :: DbEventSubscriptionResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: DbEventSubscriptionResource s)

instance P.HasSnsTopic (DbEventSubscriptionResource s) (TF.Attr s Text) where
    snsTopic =
        lens (_sns_topic :: DbEventSubscriptionResource s -> TF.Attr s Text)
             (\s a -> s { _sns_topic = a } :: DbEventSubscriptionResource s)

instance P.HasSourceIds (DbEventSubscriptionResource s) (TF.Attr s Text) where
    sourceIds =
        lens (_source_ids :: DbEventSubscriptionResource s -> TF.Attr s Text)
             (\s a -> s { _source_ids = a } :: DbEventSubscriptionResource s)

instance P.HasSourceType (DbEventSubscriptionResource s) (TF.Attr s Text) where
    sourceType =
        lens (_source_type :: DbEventSubscriptionResource s -> TF.Attr s Text)
             (\s a -> s { _source_type = a } :: DbEventSubscriptionResource s)

instance P.HasTags (DbEventSubscriptionResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: DbEventSubscriptionResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: DbEventSubscriptionResource s)

instance P.HasComputedEnabled (DbEventSubscriptionResource s) s (TF.Attr s P.Bool) where
    computedEnabled =
        (_enabled :: DbEventSubscriptionResource s -> TF.Attr s P.Bool)
            . TF.refValue

instance P.HasComputedEventCategories (DbEventSubscriptionResource s) s (TF.Attr s Text) where
    computedEventCategories =
        (_event_categories :: DbEventSubscriptionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (DbEventSubscriptionResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: DbEventSubscriptionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSnsTopic (DbEventSubscriptionResource s) s (TF.Attr s Text) where
    computedSnsTopic =
        (_sns_topic :: DbEventSubscriptionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSourceIds (DbEventSubscriptionResource s) s (TF.Attr s Text) where
    computedSourceIds =
        (_source_ids :: DbEventSubscriptionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSourceType (DbEventSubscriptionResource s) s (TF.Attr s Text) where
    computedSourceType =
        (_source_type :: DbEventSubscriptionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (DbEventSubscriptionResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: DbEventSubscriptionResource s -> TF.Attr s P.Tags)
            . TF.refValue

dbEventSubscriptionResource :: TF.Schema TF.Resource P.AWS (DbEventSubscriptionResource s)
dbEventSubscriptionResource =
    TF.newResource "aws_db_event_subscription" $
        DbEventSubscriptionResource {
              _enabled = TF.Nil
            , _event_categories = TF.Nil
            , _name = TF.Nil
            , _sns_topic = TF.Nil
            , _source_ids = TF.Nil
            , _source_type = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_db_instance@ AWS resource.

Provides an RDS instance resource.  A DB instance is an isolated database
environment in the cloud.  A DB instance can contain multiple user-created
databases. Changes to a DB instance can occur when you manually change a
parameter, such as @allocated_storage@ , and are reflected in the next
maintenance window. Because of this, Terraform may report a difference in
its planning phase because a modification has not yet taken place. You can
use the @apply_immediately@ flag to instruct the service to apply the change
immediately (see documentation below). When upgrading the major version of
an engine, @allow_major_version_upgrade@ must be set to @true@ . ~> Note:
using @apply_immediately@ can result in a brief downtime as the server
reboots. See the AWS Docs on
<https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_UpgradeDBInstance.Maintenance.html>
for more information. ~> Note: All arguments including the username and
password will be stored in the raw state as plain-text.
</docs/state/sensitive-data.html> .
-}
data DbInstanceResource s = DbInstanceResource {
      _allocated_storage                   :: !(TF.Attr s Text)
    {- ^ (Required unless a @snapshot_identifier@ or @replicate_source_db@ is provided) The allocated storage in gigabytes. -}
    , _allow_major_version_upgrade         :: !(TF.Attr s Text)
    {- ^ (Optional) Indicates that major version upgrades are allowed. Changing this parameter does not result in an outage and the change is asynchronously applied as soon as possible. -}
    , _apply_immediately                   :: !(TF.Attr s Text)
    {- ^ (Optional) Specifies whether any database modifications are applied immediately, or during the next maintenance window. Default is @false@ . See <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Overview.DBInstance.Modifying.html> for more information. -}
    , _auto_minor_version_upgrade          :: !(TF.Attr s Text)
    {- ^ (Optional) Indicates that minor engine upgrades will be applied automatically to the DB instance during the maintenance window. Defaults to true. -}
    , _availability_zone                   :: !(TF.Attr s P.Zone)
    {- ^ (Optional) The AZ for the RDS instance. -}
    , _backup_retention_period             :: !(TF.Attr s Text)
    {- ^ (Optional) The days to retain backups for. Must be @1@ or greater to be a source for a <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Overview.Replication.html> . -}
    , _backup_window                       :: !(TF.Attr s Text)
    {- ^ (Optional) The daily time range (in UTC) during which automated backups are created if they are enabled. Example: "09:46-10:16". Must not overlap with @maintenance_window@ . -}
    , _character_set_name                  :: !(TF.Attr s Text)
    {- ^ (Optional) The character set name to use for DB encoding in Oracle instances. This can't be changed. See <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Appendix.OracleCharacterSets.html> for more information. -}
    , _copy_tags_to_snapshot               :: !(TF.Attr s Text)
    {- ^  (Optional, boolean) On delete, copy all Instance @tags@ to the final snapshot (if @final_snapshot_identifier@ is specified). Default is @false@ . -}
    , _db_subnet_group_name                :: !(TF.Attr s Text)
    {- ^ (Optional) Name of DB subnet group. DB instance will be created in the VPC associated with the DB subnet group. If unspecified, will be created in the @default@ VPC, or in EC2 Classic, if available. -}
    , _engine                              :: !(TF.Attr s Text)
    {- ^ (Required unless a @snapshot_identifier@ or @replicate_source_db@ is provided) The database engine to use. -}
    , _engine_version                      :: !(TF.Attr s Text)
    {- ^ (Optional) The engine version to use. -}
    , _final_snapshot_identifier           :: !(TF.Attr s Text)
    {- ^ (Optional) The name of your final DB snapshot when this DB instance is deleted. If omitted, no final snapshot will be made. -}
    , _iam_database_authentication_enabled :: !(TF.Attr s P.Bool)
    {- ^ (Optional) Specifies whether or mappings of AWS Identity and Access Management (IAM) accounts to database accounts is enabled. -}
    , _identifier                          :: !(TF.Attr s Text)
    {- ^ (Optional, Forces new resource) The name of the RDS instance, if omitted, Terraform will assign a random, unique identifier. -}
    , _identifier_prefix                   :: !(TF.Attr s Text)
    {- ^ (Optional, Forces new resource) Creates a unique identifier beginning with the specified prefix. Conflicts with @identifer@ . -}
    , _instance_class                      :: !(TF.Attr s Text)
    {- ^ (Required) The instance type of the RDS instance. -}
    , _iops                                :: !(TF.Attr s Text)
    {- ^ (Optional) The amount of provisioned IOPS. Setting this implies a storage_type of "io1". -}
    , _kms_key_id                          :: !(TF.Attr s Text)
    {- ^ (Optional) The ARN for the KMS encryption key. If creating an encrypted replica, set this to the destination KMS ARN. -}
    , _license_model                       :: !(TF.Attr s Text)
    {- ^ (Optional, but required for some DB engines, i.e. Oracle SE1) License model information for this DB instance. -}
    , _maintenance_window                  :: !(TF.Attr s Text)
    {- ^ (Optional) The window to perform maintenance in. Syntax: "ddd:hh24:mi-ddd:hh24:mi". Eg: "Mon:00:00-Mon:03:00". See <http://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_UpgradeDBInstance.Maintenance.html#AdjustingTheMaintenanceWindow> for more information. -}
    , _monitoring_interval                 :: !(TF.Attr s Text)
    {- ^ (Optional) The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB instance. To disable collecting Enhanced Monitoring metrics, specify 0. The default is 0. Valid Values: 0, 1, 5, 10, 15, 30, 60. -}
    , _monitoring_role_arn                 :: !(TF.Attr s Text)
    {- ^ (Optional) The ARN for the IAM role that permits RDS to send enhanced monitoring metrics to CloudWatch Logs. You can find more information on the <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Monitoring.html> what IAM permissions are needed to allow Enhanced Monitoring for RDS Instances. -}
    , _multi_az                            :: !(TF.Attr s Text)
    {- ^ (Optional) Specifies if the RDS instance is multi-AZ -}
    , _name                                :: !(TF.Attr s Text)
    {- ^ (Optional) The name of the database to create when the DB instance is created. If this parameter is not specified, no database is created in the DB instance. Note that this does not apply for Oracle or SQL Server engines. See the <http://docs.aws.amazon.com/cli/latest/reference/rds/create-db-instance.html> for more details on what applies for those engines. -}
    , _option_group_name                   :: !(TF.Attr s Text)
    {- ^ (Optional) Name of the DB option group to associate. -}
    , _parameter_group_name                :: !(TF.Attr s Text)
    {- ^ (Optional) Name of the DB parameter group to associate. -}
    , _password                            :: !(TF.Attr s Text)
    {- ^ (Required unless a @snapshot_identifier@ or @replicate_source_db@ is provided) Password for the master DB user. Note that this may show up in logs, and it will be stored in the state file. -}
    , _port                                :: !(TF.Attr s Text)
    {- ^ (Optional) The port on which the DB accepts connections. -}
    , _publicly_accessible                 :: !(TF.Attr s Text)
    {- ^ (Optional) Bool to control if instance is publicly accessible. Default is @false@ . -}
    , _replicate_source_db                 :: !(TF.Attr s Text)
    {- ^ (Optional) Specifies that this resource is a Replicate database, and to use this value as the source database. This correlates to the @identifier@ of another Amazon RDS Database to replicate. See <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Overview.Replication.html> and <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_ReadRepl.html> for more information on using Replication. -}
    , _security_group_names                :: !(TF.Attr s Text)
    {- ^ (Optional/Deprecated) List of DB Security Groups to associate. Only used for <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_VPC.html#USER_VPC.FindDefaultVPC> . -}
    , _skip_final_snapshot                 :: !(TF.Attr s Text)
    {- ^ (Optional) Determines whether a final DB snapshot is created before the DB instance is deleted. If true is specified, no DBSnapshot is created. If false is specified, a DB snapshot is created before the DB instance is deleted, using the value from @final_snapshot_identifier@ . Default is @false@ . -}
    , _snapshot_identifier                 :: !(TF.Attr s Text)
    {- ^ (Optional) Specifies whether or not to create this database from a snapshot. This correlates to the snapshot ID you'd find in the RDS console, e.g: rds:production-2015-06-26-06-05. -}
    , _storage_encrypted                   :: !(TF.Attr s Text)
    {- ^ (Optional) Specifies whether the DB instance is encrypted. The default is @false@ if not specified. -}
    , _storage_type                        :: !(TF.Attr s Text)
    {- ^ (Optional) One of "standard" (magnetic), "gp2" (general purpose SSD), or "io1" (provisioned IOPS SSD). The default is "io1" if @iops@ is specified, "standard" if not. Note that this behaviour is different from the AWS web console, where the default is "gp2". -}
    , _tags                                :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    , _timezone                            :: !(TF.Attr s Text)
    {- ^ (Optional) Time zone of the DB instance. @timezone@ is currently only supported by Microsoft SQL Server. The @timezone@ can only be set on creation. See <http://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_SQLServer.html#SQLServer.Concepts.General.TimeZone> for more information. -}
    , _username                            :: !(TF.Attr s Text)
    {- ^ (Required unless a @snapshot_identifier@ or @replicate_source_db@ is provided) Username for the master DB user. -}
    , _vpc_security_group_ids              :: !(TF.Attr s Text)
    {- ^ (Optional) List of VPC security groups to associate. -}
    } deriving (Show, Eq)

instance TF.ToHCL (DbInstanceResource s) where
    toHCL DbInstanceResource{..} = TF.inline $ catMaybes
        [ TF.assign "allocated_storage" <$> TF.attribute _allocated_storage
        , TF.assign "allow_major_version_upgrade" <$> TF.attribute _allow_major_version_upgrade
        , TF.assign "apply_immediately" <$> TF.attribute _apply_immediately
        , TF.assign "auto_minor_version_upgrade" <$> TF.attribute _auto_minor_version_upgrade
        , TF.assign "availability_zone" <$> TF.attribute _availability_zone
        , TF.assign "backup_retention_period" <$> TF.attribute _backup_retention_period
        , TF.assign "backup_window" <$> TF.attribute _backup_window
        , TF.assign "character_set_name" <$> TF.attribute _character_set_name
        , TF.assign "copy_tags_to_snapshot" <$> TF.attribute _copy_tags_to_snapshot
        , TF.assign "db_subnet_group_name" <$> TF.attribute _db_subnet_group_name
        , TF.assign "engine" <$> TF.attribute _engine
        , TF.assign "engine_version" <$> TF.attribute _engine_version
        , TF.assign "final_snapshot_identifier" <$> TF.attribute _final_snapshot_identifier
        , TF.assign "iam_database_authentication_enabled" <$> TF.attribute _iam_database_authentication_enabled
        , TF.assign "identifier" <$> TF.attribute _identifier
        , TF.assign "identifier_prefix" <$> TF.attribute _identifier_prefix
        , TF.assign "instance_class" <$> TF.attribute _instance_class
        , TF.assign "iops" <$> TF.attribute _iops
        , TF.assign "kms_key_id" <$> TF.attribute _kms_key_id
        , TF.assign "license_model" <$> TF.attribute _license_model
        , TF.assign "maintenance_window" <$> TF.attribute _maintenance_window
        , TF.assign "monitoring_interval" <$> TF.attribute _monitoring_interval
        , TF.assign "monitoring_role_arn" <$> TF.attribute _monitoring_role_arn
        , TF.assign "multi_az" <$> TF.attribute _multi_az
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "option_group_name" <$> TF.attribute _option_group_name
        , TF.assign "parameter_group_name" <$> TF.attribute _parameter_group_name
        , TF.assign "password" <$> TF.attribute _password
        , TF.assign "port" <$> TF.attribute _port
        , TF.assign "publicly_accessible" <$> TF.attribute _publicly_accessible
        , TF.assign "replicate_source_db" <$> TF.attribute _replicate_source_db
        , TF.assign "security_group_names" <$> TF.attribute _security_group_names
        , TF.assign "skip_final_snapshot" <$> TF.attribute _skip_final_snapshot
        , TF.assign "snapshot_identifier" <$> TF.attribute _snapshot_identifier
        , TF.assign "storage_encrypted" <$> TF.attribute _storage_encrypted
        , TF.assign "storage_type" <$> TF.attribute _storage_type
        , TF.assign "tags" <$> TF.attribute _tags
        , TF.assign "timezone" <$> TF.attribute _timezone
        , TF.assign "username" <$> TF.attribute _username
        , TF.assign "vpc_security_group_ids" <$> TF.attribute _vpc_security_group_ids
        ]

instance P.HasAllocatedStorage (DbInstanceResource s) (TF.Attr s Text) where
    allocatedStorage =
        lens (_allocated_storage :: DbInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _allocated_storage = a } :: DbInstanceResource s)

instance P.HasAllowMajorVersionUpgrade (DbInstanceResource s) (TF.Attr s Text) where
    allowMajorVersionUpgrade =
        lens (_allow_major_version_upgrade :: DbInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _allow_major_version_upgrade = a } :: DbInstanceResource s)

instance P.HasApplyImmediately (DbInstanceResource s) (TF.Attr s Text) where
    applyImmediately =
        lens (_apply_immediately :: DbInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _apply_immediately = a } :: DbInstanceResource s)

instance P.HasAutoMinorVersionUpgrade (DbInstanceResource s) (TF.Attr s Text) where
    autoMinorVersionUpgrade =
        lens (_auto_minor_version_upgrade :: DbInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _auto_minor_version_upgrade = a } :: DbInstanceResource s)

instance P.HasAvailabilityZone (DbInstanceResource s) (TF.Attr s P.Zone) where
    availabilityZone =
        lens (_availability_zone :: DbInstanceResource s -> TF.Attr s P.Zone)
             (\s a -> s { _availability_zone = a } :: DbInstanceResource s)

instance P.HasBackupRetentionPeriod (DbInstanceResource s) (TF.Attr s Text) where
    backupRetentionPeriod =
        lens (_backup_retention_period :: DbInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _backup_retention_period = a } :: DbInstanceResource s)

instance P.HasBackupWindow (DbInstanceResource s) (TF.Attr s Text) where
    backupWindow =
        lens (_backup_window :: DbInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _backup_window = a } :: DbInstanceResource s)

instance P.HasCharacterSetName (DbInstanceResource s) (TF.Attr s Text) where
    characterSetName =
        lens (_character_set_name :: DbInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _character_set_name = a } :: DbInstanceResource s)

instance P.HasCopyTagsToSnapshot (DbInstanceResource s) (TF.Attr s Text) where
    copyTagsToSnapshot =
        lens (_copy_tags_to_snapshot :: DbInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _copy_tags_to_snapshot = a } :: DbInstanceResource s)

instance P.HasDbSubnetGroupName (DbInstanceResource s) (TF.Attr s Text) where
    dbSubnetGroupName =
        lens (_db_subnet_group_name :: DbInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _db_subnet_group_name = a } :: DbInstanceResource s)

instance P.HasEngine (DbInstanceResource s) (TF.Attr s Text) where
    engine =
        lens (_engine :: DbInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _engine = a } :: DbInstanceResource s)

instance P.HasEngineVersion (DbInstanceResource s) (TF.Attr s Text) where
    engineVersion =
        lens (_engine_version :: DbInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _engine_version = a } :: DbInstanceResource s)

instance P.HasFinalSnapshotIdentifier (DbInstanceResource s) (TF.Attr s Text) where
    finalSnapshotIdentifier =
        lens (_final_snapshot_identifier :: DbInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _final_snapshot_identifier = a } :: DbInstanceResource s)

instance P.HasIamDatabaseAuthenticationEnabled (DbInstanceResource s) (TF.Attr s P.Bool) where
    iamDatabaseAuthenticationEnabled =
        lens (_iam_database_authentication_enabled :: DbInstanceResource s -> TF.Attr s P.Bool)
             (\s a -> s { _iam_database_authentication_enabled = a } :: DbInstanceResource s)

instance P.HasIdentifier (DbInstanceResource s) (TF.Attr s Text) where
    identifier =
        lens (_identifier :: DbInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _identifier = a } :: DbInstanceResource s)

instance P.HasIdentifierPrefix (DbInstanceResource s) (TF.Attr s Text) where
    identifierPrefix =
        lens (_identifier_prefix :: DbInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _identifier_prefix = a } :: DbInstanceResource s)

instance P.HasInstanceClass (DbInstanceResource s) (TF.Attr s Text) where
    instanceClass =
        lens (_instance_class :: DbInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _instance_class = a } :: DbInstanceResource s)

instance P.HasIops (DbInstanceResource s) (TF.Attr s Text) where
    iops =
        lens (_iops :: DbInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _iops = a } :: DbInstanceResource s)

instance P.HasKmsKeyId (DbInstanceResource s) (TF.Attr s Text) where
    kmsKeyId =
        lens (_kms_key_id :: DbInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _kms_key_id = a } :: DbInstanceResource s)

instance P.HasLicenseModel (DbInstanceResource s) (TF.Attr s Text) where
    licenseModel =
        lens (_license_model :: DbInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _license_model = a } :: DbInstanceResource s)

instance P.HasMaintenanceWindow (DbInstanceResource s) (TF.Attr s Text) where
    maintenanceWindow =
        lens (_maintenance_window :: DbInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _maintenance_window = a } :: DbInstanceResource s)

instance P.HasMonitoringInterval (DbInstanceResource s) (TF.Attr s Text) where
    monitoringInterval =
        lens (_monitoring_interval :: DbInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _monitoring_interval = a } :: DbInstanceResource s)

instance P.HasMonitoringRoleArn (DbInstanceResource s) (TF.Attr s Text) where
    monitoringRoleArn =
        lens (_monitoring_role_arn :: DbInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _monitoring_role_arn = a } :: DbInstanceResource s)

instance P.HasMultiAz (DbInstanceResource s) (TF.Attr s Text) where
    multiAz =
        lens (_multi_az :: DbInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _multi_az = a } :: DbInstanceResource s)

instance P.HasName (DbInstanceResource s) (TF.Attr s Text) where
    name =
        lens (_name :: DbInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: DbInstanceResource s)

instance P.HasOptionGroupName (DbInstanceResource s) (TF.Attr s Text) where
    optionGroupName =
        lens (_option_group_name :: DbInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _option_group_name = a } :: DbInstanceResource s)

instance P.HasParameterGroupName (DbInstanceResource s) (TF.Attr s Text) where
    parameterGroupName =
        lens (_parameter_group_name :: DbInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _parameter_group_name = a } :: DbInstanceResource s)

instance P.HasPassword (DbInstanceResource s) (TF.Attr s Text) where
    password =
        lens (_password :: DbInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _password = a } :: DbInstanceResource s)

instance P.HasPort (DbInstanceResource s) (TF.Attr s Text) where
    port =
        lens (_port :: DbInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _port = a } :: DbInstanceResource s)

instance P.HasPubliclyAccessible (DbInstanceResource s) (TF.Attr s Text) where
    publiclyAccessible =
        lens (_publicly_accessible :: DbInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _publicly_accessible = a } :: DbInstanceResource s)

instance P.HasReplicateSourceDb (DbInstanceResource s) (TF.Attr s Text) where
    replicateSourceDb =
        lens (_replicate_source_db :: DbInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _replicate_source_db = a } :: DbInstanceResource s)

instance P.HasSecurityGroupNames (DbInstanceResource s) (TF.Attr s Text) where
    securityGroupNames =
        lens (_security_group_names :: DbInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _security_group_names = a } :: DbInstanceResource s)

instance P.HasSkipFinalSnapshot (DbInstanceResource s) (TF.Attr s Text) where
    skipFinalSnapshot =
        lens (_skip_final_snapshot :: DbInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _skip_final_snapshot = a } :: DbInstanceResource s)

instance P.HasSnapshotIdentifier (DbInstanceResource s) (TF.Attr s Text) where
    snapshotIdentifier =
        lens (_snapshot_identifier :: DbInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _snapshot_identifier = a } :: DbInstanceResource s)

instance P.HasStorageEncrypted (DbInstanceResource s) (TF.Attr s Text) where
    storageEncrypted =
        lens (_storage_encrypted :: DbInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _storage_encrypted = a } :: DbInstanceResource s)

instance P.HasStorageType (DbInstanceResource s) (TF.Attr s Text) where
    storageType =
        lens (_storage_type :: DbInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _storage_type = a } :: DbInstanceResource s)

instance P.HasTags (DbInstanceResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: DbInstanceResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: DbInstanceResource s)

instance P.HasTimezone (DbInstanceResource s) (TF.Attr s Text) where
    timezone =
        lens (_timezone :: DbInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _timezone = a } :: DbInstanceResource s)

instance P.HasUsername (DbInstanceResource s) (TF.Attr s Text) where
    username =
        lens (_username :: DbInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _username = a } :: DbInstanceResource s)

instance P.HasVpcSecurityGroupIds (DbInstanceResource s) (TF.Attr s Text) where
    vpcSecurityGroupIds =
        lens (_vpc_security_group_ids :: DbInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _vpc_security_group_ids = a } :: DbInstanceResource s)

instance P.HasComputedAddress (DbInstanceResource s) s (TF.Attr s Text) where
    computedAddress x = TF.compute (TF.refKey x) "address"

instance P.HasComputedAllocatedStorage (DbInstanceResource s) s (TF.Attr s Text) where
    computedAllocatedStorage x = TF.compute (TF.refKey x) "allocated_storage"

instance P.HasComputedAllowMajorVersionUpgrade (DbInstanceResource s) s (TF.Attr s Text) where
    computedAllowMajorVersionUpgrade =
        (_allow_major_version_upgrade :: DbInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedApplyImmediately (DbInstanceResource s) s (TF.Attr s Text) where
    computedApplyImmediately =
        (_apply_immediately :: DbInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedArn (DbInstanceResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedAutoMinorVersionUpgrade (DbInstanceResource s) s (TF.Attr s Text) where
    computedAutoMinorVersionUpgrade =
        (_auto_minor_version_upgrade :: DbInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAvailabilityZone (DbInstanceResource s) s (TF.Attr s P.Zone) where
    computedAvailabilityZone x = TF.compute (TF.refKey x) "availability_zone"

instance P.HasComputedBackupRetentionPeriod (DbInstanceResource s) s (TF.Attr s Text) where
    computedBackupRetentionPeriod x = TF.compute (TF.refKey x) "backup_retention_period"

instance P.HasComputedBackupWindow (DbInstanceResource s) s (TF.Attr s Text) where
    computedBackupWindow x = TF.compute (TF.refKey x) "backup_window"

instance P.HasComputedCaCertIdentifier (DbInstanceResource s) s (TF.Attr s Text) where
    computedCaCertIdentifier x = TF.compute (TF.refKey x) "ca_cert_identifier"

instance P.HasComputedCharacterSetName (DbInstanceResource s) s (TF.Attr s Text) where
    computedCharacterSetName =
        (_character_set_name :: DbInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCopyTagsToSnapshot (DbInstanceResource s) s (TF.Attr s Text) where
    computedCopyTagsToSnapshot =
        (_copy_tags_to_snapshot :: DbInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDbSubnetGroupName (DbInstanceResource s) s (TF.Attr s Text) where
    computedDbSubnetGroupName =
        (_db_subnet_group_name :: DbInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEndpoint (DbInstanceResource s) s (TF.Attr s Text) where
    computedEndpoint x = TF.compute (TF.refKey x) "endpoint"

instance P.HasComputedEngine (DbInstanceResource s) s (TF.Attr s Text) where
    computedEngine x = TF.compute (TF.refKey x) "engine"

instance P.HasComputedEngineVersion (DbInstanceResource s) s (TF.Attr s Text) where
    computedEngineVersion x = TF.compute (TF.refKey x) "engine_version"

instance P.HasComputedFinalSnapshotIdentifier (DbInstanceResource s) s (TF.Attr s Text) where
    computedFinalSnapshotIdentifier =
        (_final_snapshot_identifier :: DbInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedHostedZoneId (DbInstanceResource s) s (TF.Attr s Text) where
    computedHostedZoneId x = TF.compute (TF.refKey x) "hosted_zone_id"

instance P.HasComputedIamDatabaseAuthenticationEnabled (DbInstanceResource s) s (TF.Attr s P.Bool) where
    computedIamDatabaseAuthenticationEnabled =
        (_iam_database_authentication_enabled :: DbInstanceResource s -> TF.Attr s P.Bool)
            . TF.refValue

instance P.HasComputedId (DbInstanceResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedIdentifier (DbInstanceResource s) s (TF.Attr s Text) where
    computedIdentifier =
        (_identifier :: DbInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedIdentifierPrefix (DbInstanceResource s) s (TF.Attr s Text) where
    computedIdentifierPrefix =
        (_identifier_prefix :: DbInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedInstanceClass (DbInstanceResource s) s (TF.Attr s Text) where
    computedInstanceClass x = TF.compute (TF.refKey x) "instance_class"

instance P.HasComputedIops (DbInstanceResource s) s (TF.Attr s Text) where
    computedIops =
        (_iops :: DbInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedKmsKeyId (DbInstanceResource s) s (TF.Attr s Text) where
    computedKmsKeyId =
        (_kms_key_id :: DbInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedLicenseModel (DbInstanceResource s) s (TF.Attr s Text) where
    computedLicenseModel =
        (_license_model :: DbInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedMaintenanceWindow (DbInstanceResource s) s (TF.Attr s Text) where
    computedMaintenanceWindow x = TF.compute (TF.refKey x) "maintenance_window"

instance P.HasComputedMonitoringInterval (DbInstanceResource s) s (TF.Attr s Text) where
    computedMonitoringInterval =
        (_monitoring_interval :: DbInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedMonitoringRoleArn (DbInstanceResource s) s (TF.Attr s Text) where
    computedMonitoringRoleArn =
        (_monitoring_role_arn :: DbInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedMultiAz (DbInstanceResource s) s (TF.Attr s Text) where
    computedMultiAz x = TF.compute (TF.refKey x) "multi_az"

instance P.HasComputedName (DbInstanceResource s) s (TF.Attr s Text) where
    computedName x = TF.compute (TF.refKey x) "name"

instance P.HasComputedOptionGroupName (DbInstanceResource s) s (TF.Attr s Text) where
    computedOptionGroupName =
        (_option_group_name :: DbInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedParameterGroupName (DbInstanceResource s) s (TF.Attr s Text) where
    computedParameterGroupName =
        (_parameter_group_name :: DbInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPassword (DbInstanceResource s) s (TF.Attr s Text) where
    computedPassword =
        (_password :: DbInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPort (DbInstanceResource s) s (TF.Attr s Text) where
    computedPort x = TF.compute (TF.refKey x) "port"

instance P.HasComputedPubliclyAccessible (DbInstanceResource s) s (TF.Attr s Text) where
    computedPubliclyAccessible =
        (_publicly_accessible :: DbInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedReplicateSourceDb (DbInstanceResource s) s (TF.Attr s Text) where
    computedReplicateSourceDb =
        (_replicate_source_db :: DbInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedResourceId (DbInstanceResource s) s (TF.Attr s Text) where
    computedResourceId x = TF.compute (TF.refKey x) "resource_id"

instance P.HasComputedSecurityGroupNames (DbInstanceResource s) s (TF.Attr s Text) where
    computedSecurityGroupNames =
        (_security_group_names :: DbInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSkipFinalSnapshot (DbInstanceResource s) s (TF.Attr s Text) where
    computedSkipFinalSnapshot =
        (_skip_final_snapshot :: DbInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSnapshotIdentifier (DbInstanceResource s) s (TF.Attr s Text) where
    computedSnapshotIdentifier =
        (_snapshot_identifier :: DbInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedStatus (DbInstanceResource s) s (TF.Attr s Text) where
    computedStatus x = TF.compute (TF.refKey x) "status"

instance P.HasComputedStorageEncrypted (DbInstanceResource s) s (TF.Attr s Text) where
    computedStorageEncrypted x = TF.compute (TF.refKey x) "storage_encrypted"

instance P.HasComputedStorageType (DbInstanceResource s) s (TF.Attr s Text) where
    computedStorageType =
        (_storage_type :: DbInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (DbInstanceResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: DbInstanceResource s -> TF.Attr s P.Tags)
            . TF.refValue

instance P.HasComputedTimezone (DbInstanceResource s) s (TF.Attr s Text) where
    computedTimezone =
        (_timezone :: DbInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedUsername (DbInstanceResource s) s (TF.Attr s Text) where
    computedUsername x = TF.compute (TF.refKey x) "username"

instance P.HasComputedVpcSecurityGroupIds (DbInstanceResource s) s (TF.Attr s Text) where
    computedVpcSecurityGroupIds =
        (_vpc_security_group_ids :: DbInstanceResource s -> TF.Attr s Text)
            . TF.refValue

dbInstanceResource :: TF.Schema TF.Resource P.AWS (DbInstanceResource s)
dbInstanceResource =
    TF.newResource "aws_db_instance" $
        DbInstanceResource {
              _allocated_storage = TF.Nil
            , _allow_major_version_upgrade = TF.Nil
            , _apply_immediately = TF.Nil
            , _auto_minor_version_upgrade = TF.Nil
            , _availability_zone = TF.Nil
            , _backup_retention_period = TF.Nil
            , _backup_window = TF.Nil
            , _character_set_name = TF.Nil
            , _copy_tags_to_snapshot = TF.Nil
            , _db_subnet_group_name = TF.Nil
            , _engine = TF.Nil
            , _engine_version = TF.Nil
            , _final_snapshot_identifier = TF.Nil
            , _iam_database_authentication_enabled = TF.Nil
            , _identifier = TF.Nil
            , _identifier_prefix = TF.Nil
            , _instance_class = TF.Nil
            , _iops = TF.Nil
            , _kms_key_id = TF.Nil
            , _license_model = TF.Nil
            , _maintenance_window = TF.Nil
            , _monitoring_interval = TF.Nil
            , _monitoring_role_arn = TF.Nil
            , _multi_az = TF.Nil
            , _name = TF.Nil
            , _option_group_name = TF.Nil
            , _parameter_group_name = TF.Nil
            , _password = TF.Nil
            , _port = TF.Nil
            , _publicly_accessible = TF.Nil
            , _replicate_source_db = TF.Nil
            , _security_group_names = TF.Nil
            , _skip_final_snapshot = TF.Nil
            , _snapshot_identifier = TF.Nil
            , _storage_encrypted = TF.Nil
            , _storage_type = TF.Nil
            , _tags = TF.Nil
            , _timezone = TF.Nil
            , _username = TF.Nil
            , _vpc_security_group_ids = TF.Nil
            }

{- | The @aws_db_option_group@ AWS resource.

Provides an RDS DB option group resource.
-}
data DbOptionGroupResource s = DbOptionGroupResource {
      _engine_name              :: !(TF.Attr s Text)
    {- ^ (Required) Specifies the name of the engine that this option group should be associated with. -}
    , _major_engine_version     :: !(TF.Attr s Text)
    {- ^ (Required) Specifies the major version of the engine that this option group should be associated with. -}
    , _name                     :: !(TF.Attr s Text)
    {- ^ (Optional, Forces new resource) The name of the option group. If omitted, Terraform will assign a random, unique name. Must be lowercase, to match as it is stored in AWS. -}
    , _name_prefix              :: !(TF.Attr s Text)
    {- ^ (Optional, Forces new resource) Creates a unique name beginning with the specified prefix. Conflicts with @name@ . Must be lowercase, to match as it is stored in AWS. -}
    , _option                   :: !(TF.Attr s Text)
    {- ^ (Optional) A list of Options to apply. -}
    , _option_group_description :: !(TF.Attr s Text)
    {- ^ (Optional) The description of the option group. Defaults to "Managed by Terraform". -}
    , _tags                     :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    } deriving (Show, Eq)

instance TF.ToHCL (DbOptionGroupResource s) where
    toHCL DbOptionGroupResource{..} = TF.inline $ catMaybes
        [ TF.assign "engine_name" <$> TF.attribute _engine_name
        , TF.assign "major_engine_version" <$> TF.attribute _major_engine_version
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "name_prefix" <$> TF.attribute _name_prefix
        , TF.assign "option" <$> TF.attribute _option
        , TF.assign "option_group_description" <$> TF.attribute _option_group_description
        , TF.assign "tags" <$> TF.attribute _tags
        ]

instance P.HasEngineName (DbOptionGroupResource s) (TF.Attr s Text) where
    engineName =
        lens (_engine_name :: DbOptionGroupResource s -> TF.Attr s Text)
             (\s a -> s { _engine_name = a } :: DbOptionGroupResource s)

instance P.HasMajorEngineVersion (DbOptionGroupResource s) (TF.Attr s Text) where
    majorEngineVersion =
        lens (_major_engine_version :: DbOptionGroupResource s -> TF.Attr s Text)
             (\s a -> s { _major_engine_version = a } :: DbOptionGroupResource s)

instance P.HasName (DbOptionGroupResource s) (TF.Attr s Text) where
    name =
        lens (_name :: DbOptionGroupResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: DbOptionGroupResource s)

instance P.HasNamePrefix (DbOptionGroupResource s) (TF.Attr s Text) where
    namePrefix =
        lens (_name_prefix :: DbOptionGroupResource s -> TF.Attr s Text)
             (\s a -> s { _name_prefix = a } :: DbOptionGroupResource s)

instance P.HasOption (DbOptionGroupResource s) (TF.Attr s Text) where
    option =
        lens (_option :: DbOptionGroupResource s -> TF.Attr s Text)
             (\s a -> s { _option = a } :: DbOptionGroupResource s)

instance P.HasOptionGroupDescription (DbOptionGroupResource s) (TF.Attr s Text) where
    optionGroupDescription =
        lens (_option_group_description :: DbOptionGroupResource s -> TF.Attr s Text)
             (\s a -> s { _option_group_description = a } :: DbOptionGroupResource s)

instance P.HasTags (DbOptionGroupResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: DbOptionGroupResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: DbOptionGroupResource s)

instance P.HasComputedArn (DbOptionGroupResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedEngineName (DbOptionGroupResource s) s (TF.Attr s Text) where
    computedEngineName =
        (_engine_name :: DbOptionGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (DbOptionGroupResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedMajorEngineVersion (DbOptionGroupResource s) s (TF.Attr s Text) where
    computedMajorEngineVersion =
        (_major_engine_version :: DbOptionGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (DbOptionGroupResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: DbOptionGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedNamePrefix (DbOptionGroupResource s) s (TF.Attr s Text) where
    computedNamePrefix =
        (_name_prefix :: DbOptionGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedOption (DbOptionGroupResource s) s (TF.Attr s Text) where
    computedOption =
        (_option :: DbOptionGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedOptionGroupDescription (DbOptionGroupResource s) s (TF.Attr s Text) where
    computedOptionGroupDescription =
        (_option_group_description :: DbOptionGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (DbOptionGroupResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: DbOptionGroupResource s -> TF.Attr s P.Tags)
            . TF.refValue

dbOptionGroupResource :: TF.Schema TF.Resource P.AWS (DbOptionGroupResource s)
dbOptionGroupResource =
    TF.newResource "aws_db_option_group" $
        DbOptionGroupResource {
              _engine_name = TF.Nil
            , _major_engine_version = TF.Nil
            , _name = TF.Nil
            , _name_prefix = TF.Nil
            , _option = TF.Nil
            , _option_group_description = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_db_parameter_group@ AWS resource.

Provides an RDS DB parameter group resource.
-}
data DbParameterGroupResource s = DbParameterGroupResource {
      _description :: !(TF.Attr s Text)
    {- ^ (Optional) The description of the DB parameter group. Defaults to "Managed by Terraform". -}
    , _family'     :: !(TF.Attr s Text)
    {- ^ (Required) The family of the DB parameter group. -}
    , _name        :: !(TF.Attr s Text)
    {- ^ (Optional, Forces new resource) The name of the DB parameter group. If omitted, Terraform will assign a random, unique name. -}
    , _name_prefix :: !(TF.Attr s Text)
    {- ^ (Optional, Forces new resource) Creates a unique name beginning with the specified prefix. Conflicts with @name@ . -}
    , _parameter   :: !(TF.Attr s Text)
    {- ^ (Optional) A list of DB parameters to apply. Note that parameters may differ from a family to an other. Full list of all parameters can be discovered via <https://docs.aws.amazon.com/cli/latest/reference/rds/describe-db-parameters.html> after initial creation of the group. -}
    , _tags        :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    } deriving (Show, Eq)

instance TF.ToHCL (DbParameterGroupResource s) where
    toHCL DbParameterGroupResource{..} = TF.inline $ catMaybes
        [ TF.assign "description" <$> TF.attribute _description
        , TF.assign "family" <$> TF.attribute _family'
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "name_prefix" <$> TF.attribute _name_prefix
        , TF.assign "parameter" <$> TF.attribute _parameter
        , TF.assign "tags" <$> TF.attribute _tags
        ]

instance P.HasDescription (DbParameterGroupResource s) (TF.Attr s Text) where
    description =
        lens (_description :: DbParameterGroupResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: DbParameterGroupResource s)

instance P.HasFamily' (DbParameterGroupResource s) (TF.Attr s Text) where
    family' =
        lens (_family' :: DbParameterGroupResource s -> TF.Attr s Text)
             (\s a -> s { _family' = a } :: DbParameterGroupResource s)

instance P.HasName (DbParameterGroupResource s) (TF.Attr s Text) where
    name =
        lens (_name :: DbParameterGroupResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: DbParameterGroupResource s)

instance P.HasNamePrefix (DbParameterGroupResource s) (TF.Attr s Text) where
    namePrefix =
        lens (_name_prefix :: DbParameterGroupResource s -> TF.Attr s Text)
             (\s a -> s { _name_prefix = a } :: DbParameterGroupResource s)

instance P.HasParameter (DbParameterGroupResource s) (TF.Attr s Text) where
    parameter =
        lens (_parameter :: DbParameterGroupResource s -> TF.Attr s Text)
             (\s a -> s { _parameter = a } :: DbParameterGroupResource s)

instance P.HasTags (DbParameterGroupResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: DbParameterGroupResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: DbParameterGroupResource s)

instance P.HasComputedArn (DbParameterGroupResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedDescription (DbParameterGroupResource s) s (TF.Attr s Text) where
    computedDescription =
        (_description :: DbParameterGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedFamily' (DbParameterGroupResource s) s (TF.Attr s Text) where
    computedFamily' =
        (_family' :: DbParameterGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (DbParameterGroupResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (DbParameterGroupResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: DbParameterGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedNamePrefix (DbParameterGroupResource s) s (TF.Attr s Text) where
    computedNamePrefix =
        (_name_prefix :: DbParameterGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedParameter (DbParameterGroupResource s) s (TF.Attr s Text) where
    computedParameter =
        (_parameter :: DbParameterGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (DbParameterGroupResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: DbParameterGroupResource s -> TF.Attr s P.Tags)
            . TF.refValue

dbParameterGroupResource :: TF.Schema TF.Resource P.AWS (DbParameterGroupResource s)
dbParameterGroupResource =
    TF.newResource "aws_db_parameter_group" $
        DbParameterGroupResource {
              _description = TF.Nil
            , _family' = TF.Nil
            , _name = TF.Nil
            , _name_prefix = TF.Nil
            , _parameter = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_db_security_group@ AWS resource.

Provides an RDS security group resource. This is only for DB instances in
the EC2-Classic Platform. For instances inside a VPC, use the
</docs/providers/aws/r/db_instance.html#vpc_security_group_ids> attribute
instead.
-}
data DbSecurityGroupResource s = DbSecurityGroupResource {
      _description :: !(TF.Attr s Text)
    {- ^ (Optional) The description of the DB security group. Defaults to "Managed by Terraform". -}
    , _ingress     :: !(TF.Attr s Text)
    {- ^ (Required) A list of ingress rules. -}
    , _name        :: !(TF.Attr s Text)
    {- ^ (Required) The name of the DB security group. -}
    , _tags        :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    } deriving (Show, Eq)

instance TF.ToHCL (DbSecurityGroupResource s) where
    toHCL DbSecurityGroupResource{..} = TF.inline $ catMaybes
        [ TF.assign "description" <$> TF.attribute _description
        , TF.assign "ingress" <$> TF.attribute _ingress
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "tags" <$> TF.attribute _tags
        ]

instance P.HasDescription (DbSecurityGroupResource s) (TF.Attr s Text) where
    description =
        lens (_description :: DbSecurityGroupResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: DbSecurityGroupResource s)

instance P.HasIngress (DbSecurityGroupResource s) (TF.Attr s Text) where
    ingress =
        lens (_ingress :: DbSecurityGroupResource s -> TF.Attr s Text)
             (\s a -> s { _ingress = a } :: DbSecurityGroupResource s)

instance P.HasName (DbSecurityGroupResource s) (TF.Attr s Text) where
    name =
        lens (_name :: DbSecurityGroupResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: DbSecurityGroupResource s)

instance P.HasTags (DbSecurityGroupResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: DbSecurityGroupResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: DbSecurityGroupResource s)

instance P.HasComputedArn (DbSecurityGroupResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedDescription (DbSecurityGroupResource s) s (TF.Attr s Text) where
    computedDescription =
        (_description :: DbSecurityGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (DbSecurityGroupResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedIngress (DbSecurityGroupResource s) s (TF.Attr s Text) where
    computedIngress =
        (_ingress :: DbSecurityGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (DbSecurityGroupResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: DbSecurityGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (DbSecurityGroupResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: DbSecurityGroupResource s -> TF.Attr s P.Tags)
            . TF.refValue

dbSecurityGroupResource :: TF.Schema TF.Resource P.AWS (DbSecurityGroupResource s)
dbSecurityGroupResource =
    TF.newResource "aws_db_security_group" $
        DbSecurityGroupResource {
              _description = TF.Nil
            , _ingress = TF.Nil
            , _name = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_db_snapshot@ AWS resource.

Creates a Snapshot of an DB Instance.
-}
data DbSnapshotResource s = DbSnapshotResource {
      _db_instance_identifier :: !(TF.Attr s Text)
    {- ^ (Required) The DB Instance Identifier from which to take the snapshot. -}
    , _db_snapshot_identifier :: !(TF.Attr s Text)
    {- ^ (Required) The Identifier for the snapshot. -}
    } deriving (Show, Eq)

instance TF.ToHCL (DbSnapshotResource s) where
    toHCL DbSnapshotResource{..} = TF.inline $ catMaybes
        [ TF.assign "db_instance_identifier" <$> TF.attribute _db_instance_identifier
        , TF.assign "db_snapshot_identifier" <$> TF.attribute _db_snapshot_identifier
        ]

instance P.HasDbInstanceIdentifier (DbSnapshotResource s) (TF.Attr s Text) where
    dbInstanceIdentifier =
        lens (_db_instance_identifier :: DbSnapshotResource s -> TF.Attr s Text)
             (\s a -> s { _db_instance_identifier = a } :: DbSnapshotResource s)

instance P.HasDbSnapshotIdentifier (DbSnapshotResource s) (TF.Attr s Text) where
    dbSnapshotIdentifier =
        lens (_db_snapshot_identifier :: DbSnapshotResource s -> TF.Attr s Text)
             (\s a -> s { _db_snapshot_identifier = a } :: DbSnapshotResource s)

instance P.HasComputedAllocatedStorage (DbSnapshotResource s) s (TF.Attr s Text) where
    computedAllocatedStorage x = TF.compute (TF.refKey x) "allocated_storage"

instance P.HasComputedAvailabilityZone (DbSnapshotResource s) s (TF.Attr s P.Zone) where
    computedAvailabilityZone x = TF.compute (TF.refKey x) "availability_zone"

instance P.HasComputedDbInstanceIdentifier (DbSnapshotResource s) s (TF.Attr s Text) where
    computedDbInstanceIdentifier =
        (_db_instance_identifier :: DbSnapshotResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDbSnapshotArn (DbSnapshotResource s) s (TF.Attr s Text) where
    computedDbSnapshotArn x = TF.compute (TF.refKey x) "db_snapshot_arn"

instance P.HasComputedDbSnapshotIdentifier (DbSnapshotResource s) s (TF.Attr s Text) where
    computedDbSnapshotIdentifier =
        (_db_snapshot_identifier :: DbSnapshotResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEncrypted (DbSnapshotResource s) s (TF.Attr s Text) where
    computedEncrypted x = TF.compute (TF.refKey x) "encrypted"

instance P.HasComputedEngine (DbSnapshotResource s) s (TF.Attr s Text) where
    computedEngine x = TF.compute (TF.refKey x) "engine"

instance P.HasComputedEngineVersion (DbSnapshotResource s) s (TF.Attr s Text) where
    computedEngineVersion x = TF.compute (TF.refKey x) "engine_version"

instance P.HasComputedIops (DbSnapshotResource s) s (TF.Attr s Text) where
    computedIops x = TF.compute (TF.refKey x) "iops"

instance P.HasComputedKmsKeyId (DbSnapshotResource s) s (TF.Attr s Text) where
    computedKmsKeyId x = TF.compute (TF.refKey x) "kms_key_id"

instance P.HasComputedLicenseModel (DbSnapshotResource s) s (TF.Attr s Text) where
    computedLicenseModel x = TF.compute (TF.refKey x) "license_model"

instance P.HasComputedOptionGroupName (DbSnapshotResource s) s (TF.Attr s Text) where
    computedOptionGroupName x = TF.compute (TF.refKey x) "option_group_name"

instance P.HasComputedSourceDbSnapshotIdentifier (DbSnapshotResource s) s (TF.Attr s Text) where
    computedSourceDbSnapshotIdentifier x = TF.compute (TF.refKey x) "source_db_snapshot_identifier"

instance P.HasComputedSourceRegion (DbSnapshotResource s) s (TF.Attr s P.Region) where
    computedSourceRegion x = TF.compute (TF.refKey x) "source_region"

instance P.HasComputedStatus (DbSnapshotResource s) s (TF.Attr s Text) where
    computedStatus x = TF.compute (TF.refKey x) "status"

instance P.HasComputedStorageType (DbSnapshotResource s) s (TF.Attr s Text) where
    computedStorageType x = TF.compute (TF.refKey x) "storage_type"

instance P.HasComputedVpcId (DbSnapshotResource s) s (TF.Attr s Text) where
    computedVpcId x = TF.compute (TF.refKey x) "vpc_id"

dbSnapshotResource :: TF.Schema TF.Resource P.AWS (DbSnapshotResource s)
dbSnapshotResource =
    TF.newResource "aws_db_snapshot" $
        DbSnapshotResource {
              _db_instance_identifier = TF.Nil
            , _db_snapshot_identifier = TF.Nil
            }

{- | The @aws_db_subnet_group@ AWS resource.

Provides an RDS DB subnet group resource.
-}
data DbSubnetGroupResource s = DbSubnetGroupResource {
      _description :: !(TF.Attr s Text)
    {- ^ (Optional) The description of the DB subnet group. Defaults to "Managed by Terraform". -}
    , _name        :: !(TF.Attr s Text)
    {- ^ (Optional, Forces new resource) The name of the DB subnet group. If omitted, Terraform will assign a random, unique name. -}
    , _name_prefix :: !(TF.Attr s Text)
    {- ^ (Optional, Forces new resource) Creates a unique name beginning with the specified prefix. Conflicts with @name@ . -}
    , _subnet_ids  :: !(TF.Attr s Text)
    {- ^ (Required) A list of VPC subnet IDs. -}
    , _tags        :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    } deriving (Show, Eq)

instance TF.ToHCL (DbSubnetGroupResource s) where
    toHCL DbSubnetGroupResource{..} = TF.inline $ catMaybes
        [ TF.assign "description" <$> TF.attribute _description
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "name_prefix" <$> TF.attribute _name_prefix
        , TF.assign "subnet_ids" <$> TF.attribute _subnet_ids
        , TF.assign "tags" <$> TF.attribute _tags
        ]

instance P.HasDescription (DbSubnetGroupResource s) (TF.Attr s Text) where
    description =
        lens (_description :: DbSubnetGroupResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: DbSubnetGroupResource s)

instance P.HasName (DbSubnetGroupResource s) (TF.Attr s Text) where
    name =
        lens (_name :: DbSubnetGroupResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: DbSubnetGroupResource s)

instance P.HasNamePrefix (DbSubnetGroupResource s) (TF.Attr s Text) where
    namePrefix =
        lens (_name_prefix :: DbSubnetGroupResource s -> TF.Attr s Text)
             (\s a -> s { _name_prefix = a } :: DbSubnetGroupResource s)

instance P.HasSubnetIds (DbSubnetGroupResource s) (TF.Attr s Text) where
    subnetIds =
        lens (_subnet_ids :: DbSubnetGroupResource s -> TF.Attr s Text)
             (\s a -> s { _subnet_ids = a } :: DbSubnetGroupResource s)

instance P.HasTags (DbSubnetGroupResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: DbSubnetGroupResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: DbSubnetGroupResource s)

instance P.HasComputedArn (DbSubnetGroupResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedDescription (DbSubnetGroupResource s) s (TF.Attr s Text) where
    computedDescription =
        (_description :: DbSubnetGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (DbSubnetGroupResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (DbSubnetGroupResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: DbSubnetGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedNamePrefix (DbSubnetGroupResource s) s (TF.Attr s Text) where
    computedNamePrefix =
        (_name_prefix :: DbSubnetGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSubnetIds (DbSubnetGroupResource s) s (TF.Attr s Text) where
    computedSubnetIds =
        (_subnet_ids :: DbSubnetGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (DbSubnetGroupResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: DbSubnetGroupResource s -> TF.Attr s P.Tags)
            . TF.refValue

dbSubnetGroupResource :: TF.Schema TF.Resource P.AWS (DbSubnetGroupResource s)
dbSubnetGroupResource =
    TF.newResource "aws_db_subnet_group" $
        DbSubnetGroupResource {
              _description = TF.Nil
            , _name = TF.Nil
            , _name_prefix = TF.Nil
            , _subnet_ids = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_default_network_acl@ AWS resource.

Provides a resource to manage the default AWS Network ACL. VPC Only. Each
VPC created in AWS comes with a Default Network ACL that can be managed, but
not destroyed. This is an advanced resource , and has special caveats to be
aware of when using it. Please read this document in its entirety before
using this resource. The @aws_default_network_acl@ behaves differently from
normal resources, in that Terraform does not create this resource, but
instead attempts to "adopt" it into management. We can do this because each
VPC created has a Default Network ACL that cannot be destroyed, and is
created with a known set of default rules. When Terraform first adopts the
Default Network ACL, it immediately removes all rules in the ACL . It then
proceeds to create any rules specified in the configuration. This step is
required so that only the rules specified in the configuration are created.
This resource treats its inline rules as absolute; only the rules defined
inline are created, and any additions/removals external to this resource
will result in diffs being shown. For these reasons, this resource is
incompatible with the @aws_network_acl_rule@ resource. For more information
about Network ACLs, see the AWS Documentation on
<http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_ACLs.html> .
-}
data DefaultNetworkAclResource s = DefaultNetworkAclResource {
      _default_network_acl_id :: !(TF.Attr s Text)
    {- ^ (Required) The Network ACL ID to manage. This attribute is exported from @aws_vpc@ , or manually found via the AWS Console. -}
    , _egress                 :: !(TF.Attr s Text)
    {- ^ (Optional) Specifies an egress rule. Parameters defined below. -}
    , _ingress                :: !(TF.Attr s Text)
    {- ^ (Optional) Specifies an ingress rule. Parameters defined below. -}
    , _subnet_ids             :: !(TF.Attr s Text)
    {- ^ (Optional) A list of Subnet IDs to apply the ACL to. See the notes below on managing Subnets in the Default Network ACL -}
    , _tags                   :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    } deriving (Show, Eq)

instance TF.ToHCL (DefaultNetworkAclResource s) where
    toHCL DefaultNetworkAclResource{..} = TF.inline $ catMaybes
        [ TF.assign "default_network_acl_id" <$> TF.attribute _default_network_acl_id
        , TF.assign "egress" <$> TF.attribute _egress
        , TF.assign "ingress" <$> TF.attribute _ingress
        , TF.assign "subnet_ids" <$> TF.attribute _subnet_ids
        , TF.assign "tags" <$> TF.attribute _tags
        ]

instance P.HasDefaultNetworkAclId (DefaultNetworkAclResource s) (TF.Attr s Text) where
    defaultNetworkAclId =
        lens (_default_network_acl_id :: DefaultNetworkAclResource s -> TF.Attr s Text)
             (\s a -> s { _default_network_acl_id = a } :: DefaultNetworkAclResource s)

instance P.HasEgress (DefaultNetworkAclResource s) (TF.Attr s Text) where
    egress =
        lens (_egress :: DefaultNetworkAclResource s -> TF.Attr s Text)
             (\s a -> s { _egress = a } :: DefaultNetworkAclResource s)

instance P.HasIngress (DefaultNetworkAclResource s) (TF.Attr s Text) where
    ingress =
        lens (_ingress :: DefaultNetworkAclResource s -> TF.Attr s Text)
             (\s a -> s { _ingress = a } :: DefaultNetworkAclResource s)

instance P.HasSubnetIds (DefaultNetworkAclResource s) (TF.Attr s Text) where
    subnetIds =
        lens (_subnet_ids :: DefaultNetworkAclResource s -> TF.Attr s Text)
             (\s a -> s { _subnet_ids = a } :: DefaultNetworkAclResource s)

instance P.HasTags (DefaultNetworkAclResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: DefaultNetworkAclResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: DefaultNetworkAclResource s)

instance P.HasComputedDefaultNetworkAclId (DefaultNetworkAclResource s) s (TF.Attr s Text) where
    computedDefaultNetworkAclId =
        (_default_network_acl_id :: DefaultNetworkAclResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEgress (DefaultNetworkAclResource s) s (TF.Attr s Text) where
    computedEgress x = TF.compute (TF.refKey x) "egress"

instance P.HasComputedId (DefaultNetworkAclResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedIngress (DefaultNetworkAclResource s) s (TF.Attr s Text) where
    computedIngress x = TF.compute (TF.refKey x) "ingress"

instance P.HasComputedSubnetIds (DefaultNetworkAclResource s) s (TF.Attr s Text) where
    computedSubnetIds x = TF.compute (TF.refKey x) "subnet_ids"

instance P.HasComputedTags (DefaultNetworkAclResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: DefaultNetworkAclResource s -> TF.Attr s P.Tags)
            . TF.refValue

instance P.HasComputedVpcId (DefaultNetworkAclResource s) s (TF.Attr s Text) where
    computedVpcId x = TF.compute (TF.refKey x) "vpc_id"

defaultNetworkAclResource :: TF.Schema TF.Resource P.AWS (DefaultNetworkAclResource s)
defaultNetworkAclResource =
    TF.newResource "aws_default_network_acl" $
        DefaultNetworkAclResource {
              _default_network_acl_id = TF.Nil
            , _egress = TF.Nil
            , _ingress = TF.Nil
            , _subnet_ids = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_default_route_table@ AWS resource.

Provides a resource to manage a Default VPC Routing Table. Each VPC created
in AWS comes with a Default Route Table that can be managed, but not
destroyed. This is an advanced resource , and has special caveats to be
aware of when using it. Please read this document in its entirety before
using this resource. It is recommended you do not use both
@aws_default_route_table@ to manage the default route table and use the
@aws_main_route_table_association@ , due to possible conflict in routes. The
@aws_default_route_table@ behaves differently from normal resources, in that
Terraform does not create this resource, but instead attempts to "adopt" it
into management. We can do this because each VPC created has a Default Route
Table that cannot be destroyed, and is created with a single route. When
Terraform first adopts the Default Route Table, it immediately removes all
defined routes . It then proceeds to create any routes specified in the
configuration. This step is required so that only the routes specified in
the configuration present in the Default Route Table. For more information
about Route Tables, see the AWS Documentation on
<http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Route_Tables.html#Route_Replacing_Main_Table>
. For more information about managing normal Route Tables in Terraform, see
our documentation on </docs/providers/aws/r/route_table.html> . ~> NOTE on
Route Tables and Routes: Terraform currently provides both a standalone
<route.html> and a Route Table resource with routes defined in-line. At this
time you cannot use a Route Table with in-line routes in conjunction with
any Route resources. Doing so will cause a conflict of rule settings and
will overwrite routes.
-}
data DefaultRouteTableResource s = DefaultRouteTableResource {
      _default_route_table_id :: !(TF.Attr s Text)
    {- ^ (Required) The ID of the Default Routing Table. -}
    , _propagating_vgws       :: !(TF.Attr s Text)
    {- ^ (Optional) A list of virtual gateways for propagation. -}
    , _route                  :: !(TF.Attr s Text)
    {- ^ (Optional) A list of route objects. Their keys are documented below. -}
    , _tags                   :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    } deriving (Show, Eq)

instance TF.ToHCL (DefaultRouteTableResource s) where
    toHCL DefaultRouteTableResource{..} = TF.inline $ catMaybes
        [ TF.assign "default_route_table_id" <$> TF.attribute _default_route_table_id
        , TF.assign "propagating_vgws" <$> TF.attribute _propagating_vgws
        , TF.assign "route" <$> TF.attribute _route
        , TF.assign "tags" <$> TF.attribute _tags
        ]

instance P.HasDefaultRouteTableId (DefaultRouteTableResource s) (TF.Attr s Text) where
    defaultRouteTableId =
        lens (_default_route_table_id :: DefaultRouteTableResource s -> TF.Attr s Text)
             (\s a -> s { _default_route_table_id = a } :: DefaultRouteTableResource s)

instance P.HasPropagatingVgws (DefaultRouteTableResource s) (TF.Attr s Text) where
    propagatingVgws =
        lens (_propagating_vgws :: DefaultRouteTableResource s -> TF.Attr s Text)
             (\s a -> s { _propagating_vgws = a } :: DefaultRouteTableResource s)

instance P.HasRoute (DefaultRouteTableResource s) (TF.Attr s Text) where
    route =
        lens (_route :: DefaultRouteTableResource s -> TF.Attr s Text)
             (\s a -> s { _route = a } :: DefaultRouteTableResource s)

instance P.HasTags (DefaultRouteTableResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: DefaultRouteTableResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: DefaultRouteTableResource s)

instance P.HasComputedDefaultRouteTableId (DefaultRouteTableResource s) s (TF.Attr s Text) where
    computedDefaultRouteTableId =
        (_default_route_table_id :: DefaultRouteTableResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (DefaultRouteTableResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedPropagatingVgws (DefaultRouteTableResource s) s (TF.Attr s Text) where
    computedPropagatingVgws =
        (_propagating_vgws :: DefaultRouteTableResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRoute (DefaultRouteTableResource s) s (TF.Attr s Text) where
    computedRoute =
        (_route :: DefaultRouteTableResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (DefaultRouteTableResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: DefaultRouteTableResource s -> TF.Attr s P.Tags)
            . TF.refValue

defaultRouteTableResource :: TF.Schema TF.Resource P.AWS (DefaultRouteTableResource s)
defaultRouteTableResource =
    TF.newResource "aws_default_route_table" $
        DefaultRouteTableResource {
              _default_route_table_id = TF.Nil
            , _propagating_vgws = TF.Nil
            , _route = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_default_security_group@ AWS resource.

Provides a resource to manage the default AWS Security Group. For EC2
Classic accounts, each region comes with a Default Security Group.
Additionally, each VPC created in AWS comes with a Default Security Group
that can be managed, but not destroyed. This is an advanced resource , and
has special caveats to be aware of when using it. Please read this document
in its entirety before using this resource. The @aws_default_security_group@
behaves differently from normal resources, in that Terraform does not create
this resource, but instead "adopts" it into management. We can do this
because these default security groups cannot be destroyed, and are created
with a known set of default ingress/egress rules. When Terraform first
adopts the Default Security Group, it immediately removes all ingress and
egress rules in the Security Group . It then proceeds to create any rules
specified in the configuration. This step is required so that only the rules
specified in the configuration are created. This resource treats it's inline
rules as absolute; only the rules defined inline are created, and any
additions/removals external to this resource will result in diff shown. For
these reasons, this resource is incompatible with the
@aws_security_group_rule@ resource. For more information about Default
Security Groups, see the AWS Documentation on
<http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-network-security.html#default-security-group>
.
-}
data DefaultSecurityGroupResource s = DefaultSecurityGroupResource {
      _egress  :: !(TF.Attr s Text)
    {- ^ (Optional, VPC only) Can be specified multiple times for each egress rule. Each egress block supports fields documented below. -}
    , _ingress :: !(TF.Attr s Text)
    {- ^ (Optional) Can be specified multiple times for each ingress rule. Each ingress block supports fields documented below. -}
    , _tags    :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    , _vpc_id  :: !(TF.Attr s Text)
    {- ^ (Optional, Forces new resource) The VPC ID. Note that changing the @vpc_id@ will not restore any default security group rules that were modified, added, or removed. It will be left in it's current state -}
    } deriving (Show, Eq)

instance TF.ToHCL (DefaultSecurityGroupResource s) where
    toHCL DefaultSecurityGroupResource{..} = TF.inline $ catMaybes
        [ TF.assign "egress" <$> TF.attribute _egress
        , TF.assign "ingress" <$> TF.attribute _ingress
        , TF.assign "tags" <$> TF.attribute _tags
        , TF.assign "vpc_id" <$> TF.attribute _vpc_id
        ]

instance P.HasEgress (DefaultSecurityGroupResource s) (TF.Attr s Text) where
    egress =
        lens (_egress :: DefaultSecurityGroupResource s -> TF.Attr s Text)
             (\s a -> s { _egress = a } :: DefaultSecurityGroupResource s)

instance P.HasIngress (DefaultSecurityGroupResource s) (TF.Attr s Text) where
    ingress =
        lens (_ingress :: DefaultSecurityGroupResource s -> TF.Attr s Text)
             (\s a -> s { _ingress = a } :: DefaultSecurityGroupResource s)

instance P.HasTags (DefaultSecurityGroupResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: DefaultSecurityGroupResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: DefaultSecurityGroupResource s)

instance P.HasVpcId (DefaultSecurityGroupResource s) (TF.Attr s Text) where
    vpcId =
        lens (_vpc_id :: DefaultSecurityGroupResource s -> TF.Attr s Text)
             (\s a -> s { _vpc_id = a } :: DefaultSecurityGroupResource s)

instance P.HasComputedDescription (DefaultSecurityGroupResource s) s (TF.Attr s Text) where
    computedDescription x = TF.compute (TF.refKey x) "description"

instance P.HasComputedEgress (DefaultSecurityGroupResource s) s (TF.Attr s Text) where
    computedEgress x = TF.compute (TF.refKey x) "egress"

instance P.HasComputedId (DefaultSecurityGroupResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedIngress (DefaultSecurityGroupResource s) s (TF.Attr s Text) where
    computedIngress x = TF.compute (TF.refKey x) "ingress"

instance P.HasComputedName (DefaultSecurityGroupResource s) s (TF.Attr s Text) where
    computedName x = TF.compute (TF.refKey x) "name"

instance P.HasComputedOwnerId (DefaultSecurityGroupResource s) s (TF.Attr s Text) where
    computedOwnerId x = TF.compute (TF.refKey x) "owner_id"

instance P.HasComputedTags (DefaultSecurityGroupResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: DefaultSecurityGroupResource s -> TF.Attr s P.Tags)
            . TF.refValue

instance P.HasComputedVpcId (DefaultSecurityGroupResource s) s (TF.Attr s Text) where
    computedVpcId x = TF.compute (TF.refKey x) "vpc_id"

defaultSecurityGroupResource :: TF.Schema TF.Resource P.AWS (DefaultSecurityGroupResource s)
defaultSecurityGroupResource =
    TF.newResource "aws_default_security_group" $
        DefaultSecurityGroupResource {
              _egress = TF.Nil
            , _ingress = TF.Nil
            , _tags = TF.Nil
            , _vpc_id = TF.Nil
            }

{- | The @aws_default_subnet@ AWS resource.

Provides a resource to manage a
<http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/default-vpc.html#default-vpc-basics>
in the current region. The @aws_default_subnet@ behaves differently from
normal resources, in that Terraform does not create this resource, but
instead "adopts" it into management.
-}
data DefaultSubnetResource s = DefaultSubnetResource {
      _tags :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    } deriving (Show, Eq)

instance TF.ToHCL (DefaultSubnetResource s) where
    toHCL DefaultSubnetResource{..} = TF.inline $ catMaybes
        [ TF.assign "tags" <$> TF.attribute _tags
        ]

instance P.HasTags (DefaultSubnetResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: DefaultSubnetResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: DefaultSubnetResource s)

instance P.HasComputedAvailabilityZone (DefaultSubnetResource s) s (TF.Attr s P.Zone) where
    computedAvailabilityZone x = TF.compute (TF.refKey x) "availability_zone"

instance P.HasComputedCidrBlock (DefaultSubnetResource s) s (TF.Attr s P.CIDR) where
    computedCidrBlock x = TF.compute (TF.refKey x) "cidr_block"

instance P.HasComputedId (DefaultSubnetResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedIpv6AssociationId (DefaultSubnetResource s) s (TF.Attr s Text) where
    computedIpv6AssociationId x = TF.compute (TF.refKey x) "ipv6_association_id"

instance P.HasComputedIpv6CidrBlock (DefaultSubnetResource s) s (TF.Attr s P.CIDR) where
    computedIpv6CidrBlock x = TF.compute (TF.refKey x) "ipv6_cidr_block"

instance P.HasComputedTags (DefaultSubnetResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: DefaultSubnetResource s -> TF.Attr s P.Tags)
            . TF.refValue

instance P.HasComputedVpcId (DefaultSubnetResource s) s (TF.Attr s Text) where
    computedVpcId x = TF.compute (TF.refKey x) "vpc_id"

defaultSubnetResource :: TF.Schema TF.Resource P.AWS (DefaultSubnetResource s)
defaultSubnetResource =
    TF.newResource "aws_default_subnet" $
        DefaultSubnetResource {
              _tags = TF.Nil
            }

{- | The @aws_default_vpc_dhcp_options@ AWS resource.

Provides a resource to manage the
<http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_DHCP_Options.html#AmazonDNS>
in the current region. Each AWS region comes with a default set of DHCP
options. This is an advanced resource , and has special caveats to be aware
of when using it. Please read this document in its entirety before using
this resource. The @aws_default_vpc_dhcp_options@ behaves differently from
normal resources, in that Terraform does not create this resource, but
instead "adopts" it into management.
-}
data DefaultVpcDhcpOptionsResource s = DefaultVpcDhcpOptionsResource {
      _netbios_name_servers :: !(TF.Attr s Text)
    {- ^ (Optional) List of NETBIOS name servers. -}
    , _netbios_node_type    :: !(TF.Attr s Text)
    {- ^ (Optional) The NetBIOS node type (1, 2, 4, or 8). AWS recommends to specify 2 since broadcast and multicast are not supported in their network. For more information about these node types, see <http://www.ietf.org/rfc/rfc2132.txt> . -}
    , _tags                 :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    } deriving (Show, Eq)

instance TF.ToHCL (DefaultVpcDhcpOptionsResource s) where
    toHCL DefaultVpcDhcpOptionsResource{..} = TF.inline $ catMaybes
        [ TF.assign "netbios_name_servers" <$> TF.attribute _netbios_name_servers
        , TF.assign "netbios_node_type" <$> TF.attribute _netbios_node_type
        , TF.assign "tags" <$> TF.attribute _tags
        ]

instance P.HasNetbiosNameServers (DefaultVpcDhcpOptionsResource s) (TF.Attr s Text) where
    netbiosNameServers =
        lens (_netbios_name_servers :: DefaultVpcDhcpOptionsResource s -> TF.Attr s Text)
             (\s a -> s { _netbios_name_servers = a } :: DefaultVpcDhcpOptionsResource s)

instance P.HasNetbiosNodeType (DefaultVpcDhcpOptionsResource s) (TF.Attr s Text) where
    netbiosNodeType =
        lens (_netbios_node_type :: DefaultVpcDhcpOptionsResource s -> TF.Attr s Text)
             (\s a -> s { _netbios_node_type = a } :: DefaultVpcDhcpOptionsResource s)

instance P.HasTags (DefaultVpcDhcpOptionsResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: DefaultVpcDhcpOptionsResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: DefaultVpcDhcpOptionsResource s)

instance P.HasComputedId (DefaultVpcDhcpOptionsResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedNetbiosNameServers (DefaultVpcDhcpOptionsResource s) s (TF.Attr s Text) where
    computedNetbiosNameServers =
        (_netbios_name_servers :: DefaultVpcDhcpOptionsResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedNetbiosNodeType (DefaultVpcDhcpOptionsResource s) s (TF.Attr s Text) where
    computedNetbiosNodeType =
        (_netbios_node_type :: DefaultVpcDhcpOptionsResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (DefaultVpcDhcpOptionsResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: DefaultVpcDhcpOptionsResource s -> TF.Attr s P.Tags)
            . TF.refValue

defaultVpcDhcpOptionsResource :: TF.Schema TF.Resource P.AWS (DefaultVpcDhcpOptionsResource s)
defaultVpcDhcpOptionsResource =
    TF.newResource "aws_default_vpc_dhcp_options" $
        DefaultVpcDhcpOptionsResource {
              _netbios_name_servers = TF.Nil
            , _netbios_node_type = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_default_vpc@ AWS resource.

Provides a resource to manage the
<http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/default-vpc.html> in
the current region. For AWS accounts created after 2013-12-04, each region
comes with a Default VPC. This is an advanced resource , and has special
caveats to be aware of when using it. Please read this document in its
entirety before using this resource. The @aws_default_vpc@ behaves
differently from normal resources, in that Terraform does not create this
resource, but instead "adopts" it into management.
-}
data DefaultVpcResource s = DefaultVpcResource {
      _enable_classiclink   :: !(TF.Attr s P.Bool)
    {- ^ (Optional) A boolean flag to enable/disable ClassicLink for the VPC. Only valid in regions and accounts that support EC2 Classic. See the <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/vpc-classiclink.html> for more information. Defaults false. -}
    , _enable_dns_hostnames :: !(TF.Attr s P.Bool)
    {- ^ (Optional) A boolean flag to enable/disable DNS hostnames in the VPC. Defaults false. -}
    , _enable_dns_support   :: !(TF.Attr s P.Bool)
    {- ^ (Optional) A boolean flag to enable/disable DNS support in the VPC. Defaults true. -}
    , _tags                 :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    } deriving (Show, Eq)

instance TF.ToHCL (DefaultVpcResource s) where
    toHCL DefaultVpcResource{..} = TF.inline $ catMaybes
        [ TF.assign "enable_classiclink" <$> TF.attribute _enable_classiclink
        , TF.assign "enable_dns_hostnames" <$> TF.attribute _enable_dns_hostnames
        , TF.assign "enable_dns_support" <$> TF.attribute _enable_dns_support
        , TF.assign "tags" <$> TF.attribute _tags
        ]

instance P.HasEnableClassiclink (DefaultVpcResource s) (TF.Attr s P.Bool) where
    enableClassiclink =
        lens (_enable_classiclink :: DefaultVpcResource s -> TF.Attr s P.Bool)
             (\s a -> s { _enable_classiclink = a } :: DefaultVpcResource s)

instance P.HasEnableDnsHostnames (DefaultVpcResource s) (TF.Attr s P.Bool) where
    enableDnsHostnames =
        lens (_enable_dns_hostnames :: DefaultVpcResource s -> TF.Attr s P.Bool)
             (\s a -> s { _enable_dns_hostnames = a } :: DefaultVpcResource s)

instance P.HasEnableDnsSupport (DefaultVpcResource s) (TF.Attr s P.Bool) where
    enableDnsSupport =
        lens (_enable_dns_support :: DefaultVpcResource s -> TF.Attr s P.Bool)
             (\s a -> s { _enable_dns_support = a } :: DefaultVpcResource s)

instance P.HasTags (DefaultVpcResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: DefaultVpcResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: DefaultVpcResource s)

instance P.HasComputedAssignGeneratedIpv6CidrBlock (DefaultVpcResource s) s (TF.Attr s P.CIDR) where
    computedAssignGeneratedIpv6CidrBlock x = TF.compute (TF.refKey x) "assign_generated_ipv6_cidr_block"

instance P.HasComputedCidrBlock (DefaultVpcResource s) s (TF.Attr s P.CIDR) where
    computedCidrBlock x = TF.compute (TF.refKey x) "cidr_block"

instance P.HasComputedDefaultNetworkAclId (DefaultVpcResource s) s (TF.Attr s Text) where
    computedDefaultNetworkAclId x = TF.compute (TF.refKey x) "default_network_acl_id"

instance P.HasComputedDefaultRouteTableId (DefaultVpcResource s) s (TF.Attr s Text) where
    computedDefaultRouteTableId x = TF.compute (TF.refKey x) "default_route_table_id"

instance P.HasComputedDefaultSecurityGroupId (DefaultVpcResource s) s (TF.Attr s Text) where
    computedDefaultSecurityGroupId x = TF.compute (TF.refKey x) "default_security_group_id"

instance P.HasComputedEnableClassiclink (DefaultVpcResource s) s (TF.Attr s P.Bool) where
    computedEnableClassiclink x = TF.compute (TF.refKey x) "enable_classiclink"

instance P.HasComputedEnableDnsHostnames (DefaultVpcResource s) s (TF.Attr s P.Bool) where
    computedEnableDnsHostnames x = TF.compute (TF.refKey x) "enable_dns_hostnames"

instance P.HasComputedEnableDnsSupport (DefaultVpcResource s) s (TF.Attr s P.Bool) where
    computedEnableDnsSupport x = TF.compute (TF.refKey x) "enable_dns_support"

instance P.HasComputedId (DefaultVpcResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedInstanceTenancy (DefaultVpcResource s) s (TF.Attr s Text) where
    computedInstanceTenancy x = TF.compute (TF.refKey x) "instance_tenancy"

instance P.HasComputedIpv6AssociationId (DefaultVpcResource s) s (TF.Attr s Text) where
    computedIpv6AssociationId x = TF.compute (TF.refKey x) "ipv6_association_id"

instance P.HasComputedIpv6CidrBlock (DefaultVpcResource s) s (TF.Attr s P.CIDR) where
    computedIpv6CidrBlock x = TF.compute (TF.refKey x) "ipv6_cidr_block"

instance P.HasComputedMainRouteTableId (DefaultVpcResource s) s (TF.Attr s Text) where
    computedMainRouteTableId x = TF.compute (TF.refKey x) "main_route_table_id"

instance P.HasComputedTags (DefaultVpcResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: DefaultVpcResource s -> TF.Attr s P.Tags)
            . TF.refValue

defaultVpcResource :: TF.Schema TF.Resource P.AWS (DefaultVpcResource s)
defaultVpcResource =
    TF.newResource "aws_default_vpc" $
        DefaultVpcResource {
              _enable_classiclink = TF.Nil
            , _enable_dns_hostnames = TF.Nil
            , _enable_dns_support = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_devicefarm_project@ AWS resource.

Provides a resource to manage AWS Device Farm Projects. Please keep in mind
that this feature is only supported on the "us-west-2" region. This resource
will error if you try to create a project in another region. For more
information about Device Farm Projects, see the AWS Documentation on
<http://docs.aws.amazon.com/devicefarm/latest/APIReference/API_GetProject.html>
.
-}
data DevicefarmProjectResource s = DevicefarmProjectResource {
      _name :: !(TF.Attr s Text)
    {- ^ (Required) The name of the project -}
    } deriving (Show, Eq)

instance TF.ToHCL (DevicefarmProjectResource s) where
    toHCL DevicefarmProjectResource{..} = TF.inline $ catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        ]

instance P.HasName (DevicefarmProjectResource s) (TF.Attr s Text) where
    name =
        lens (_name :: DevicefarmProjectResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: DevicefarmProjectResource s)

instance P.HasComputedArn (DevicefarmProjectResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedName (DevicefarmProjectResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: DevicefarmProjectResource s -> TF.Attr s Text)
            . TF.refValue

devicefarmProjectResource :: TF.Schema TF.Resource P.AWS (DevicefarmProjectResource s)
devicefarmProjectResource =
    TF.newResource "aws_devicefarm_project" $
        DevicefarmProjectResource {
              _name = TF.Nil
            }

{- | The @aws_directory_service_directory@ AWS resource.

Provides a Simple or Managed Microsoft directory in AWS Directory Service.
~> Note: All arguments including the password and customer username will be
stored in the raw state as plain-text. </docs/state/sensitive-data.html> .
-}
data DirectoryServiceDirectoryResource s = DirectoryServiceDirectoryResource {
      _alias            :: !(TF.Attr s Text)
    {- ^ (Optional) The alias for the directory (must be unique amongst all aliases in AWS). Required for @enable_sso@ . -}
    , _connect_settings :: !(TF.Attr s Text)
    {- ^ (Required for @ADConnector@ ) Connector related information about the directory. Fields documented below. -}
    , _description      :: !(TF.Attr s Text)
    {- ^ (Optional) A textual description for the directory. -}
    , _enable_sso       :: !(TF.Attr s P.Bool)
    {- ^ (Optional) Whether to enable single-sign on for the directory. Requires @alias@ . Defaults to @false@ . -}
    , _name             :: !(TF.Attr s Text)
    {- ^ (Required) The fully qualified name for the directory, such as @corp.example.com@ -}
    , _password         :: !(TF.Attr s Text)
    {- ^ (Required) The password for the directory administrator or connector user. -}
    , _short_name       :: !(TF.Attr s Text)
    {- ^ (Optional) The short name of the directory, such as @CORP@ . -}
    , _size             :: !(TF.Attr s Text)
    {- ^ (Required for @SimpleAD@ and @ADConnector@ ) The size of the directory ( @Small@ or @Large@ are accepted values). -}
    , _tags             :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    , _type'            :: !(TF.Attr s Text)
    {- ^ (Optional) - The directory type ( @SimpleAD@ or @MicrosoftAD@ are accepted values). Defaults to @SimpleAD@ . -}
    , _vpc_settings     :: !(TF.Attr s Text)
    {- ^ (Required for @SimpleAD@ and @MicrosoftAD@ ) VPC related information about the directory. Fields documented below. -}
    } deriving (Show, Eq)

instance TF.ToHCL (DirectoryServiceDirectoryResource s) where
    toHCL DirectoryServiceDirectoryResource{..} = TF.inline $ catMaybes
        [ TF.assign "alias" <$> TF.attribute _alias
        , TF.assign "connect_settings" <$> TF.attribute _connect_settings
        , TF.assign "description" <$> TF.attribute _description
        , TF.assign "enable_sso" <$> TF.attribute _enable_sso
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "password" <$> TF.attribute _password
        , TF.assign "short_name" <$> TF.attribute _short_name
        , TF.assign "size" <$> TF.attribute _size
        , TF.assign "tags" <$> TF.attribute _tags
        , TF.assign "type" <$> TF.attribute _type'
        , TF.assign "vpc_settings" <$> TF.attribute _vpc_settings
        ]

instance P.HasAlias (DirectoryServiceDirectoryResource s) (TF.Attr s Text) where
    alias =
        lens (_alias :: DirectoryServiceDirectoryResource s -> TF.Attr s Text)
             (\s a -> s { _alias = a } :: DirectoryServiceDirectoryResource s)

instance P.HasConnectSettings (DirectoryServiceDirectoryResource s) (TF.Attr s Text) where
    connectSettings =
        lens (_connect_settings :: DirectoryServiceDirectoryResource s -> TF.Attr s Text)
             (\s a -> s { _connect_settings = a } :: DirectoryServiceDirectoryResource s)

instance P.HasDescription (DirectoryServiceDirectoryResource s) (TF.Attr s Text) where
    description =
        lens (_description :: DirectoryServiceDirectoryResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: DirectoryServiceDirectoryResource s)

instance P.HasEnableSso (DirectoryServiceDirectoryResource s) (TF.Attr s P.Bool) where
    enableSso =
        lens (_enable_sso :: DirectoryServiceDirectoryResource s -> TF.Attr s P.Bool)
             (\s a -> s { _enable_sso = a } :: DirectoryServiceDirectoryResource s)

instance P.HasName (DirectoryServiceDirectoryResource s) (TF.Attr s Text) where
    name =
        lens (_name :: DirectoryServiceDirectoryResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: DirectoryServiceDirectoryResource s)

instance P.HasPassword (DirectoryServiceDirectoryResource s) (TF.Attr s Text) where
    password =
        lens (_password :: DirectoryServiceDirectoryResource s -> TF.Attr s Text)
             (\s a -> s { _password = a } :: DirectoryServiceDirectoryResource s)

instance P.HasShortName (DirectoryServiceDirectoryResource s) (TF.Attr s Text) where
    shortName =
        lens (_short_name :: DirectoryServiceDirectoryResource s -> TF.Attr s Text)
             (\s a -> s { _short_name = a } :: DirectoryServiceDirectoryResource s)

instance P.HasSize (DirectoryServiceDirectoryResource s) (TF.Attr s Text) where
    size =
        lens (_size :: DirectoryServiceDirectoryResource s -> TF.Attr s Text)
             (\s a -> s { _size = a } :: DirectoryServiceDirectoryResource s)

instance P.HasTags (DirectoryServiceDirectoryResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: DirectoryServiceDirectoryResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: DirectoryServiceDirectoryResource s)

instance P.HasType' (DirectoryServiceDirectoryResource s) (TF.Attr s Text) where
    type' =
        lens (_type' :: DirectoryServiceDirectoryResource s -> TF.Attr s Text)
             (\s a -> s { _type' = a } :: DirectoryServiceDirectoryResource s)

instance P.HasVpcSettings (DirectoryServiceDirectoryResource s) (TF.Attr s Text) where
    vpcSettings =
        lens (_vpc_settings :: DirectoryServiceDirectoryResource s -> TF.Attr s Text)
             (\s a -> s { _vpc_settings = a } :: DirectoryServiceDirectoryResource s)

instance P.HasComputedAccessUrl (DirectoryServiceDirectoryResource s) s (TF.Attr s Text) where
    computedAccessUrl x = TF.compute (TF.refKey x) "access_url"

instance P.HasComputedAlias (DirectoryServiceDirectoryResource s) s (TF.Attr s Text) where
    computedAlias =
        (_alias :: DirectoryServiceDirectoryResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedConnectSettings (DirectoryServiceDirectoryResource s) s (TF.Attr s Text) where
    computedConnectSettings =
        (_connect_settings :: DirectoryServiceDirectoryResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDescription (DirectoryServiceDirectoryResource s) s (TF.Attr s Text) where
    computedDescription =
        (_description :: DirectoryServiceDirectoryResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDnsIpAddresses (DirectoryServiceDirectoryResource s) s (TF.Attr s Text) where
    computedDnsIpAddresses x = TF.compute (TF.refKey x) "dns_ip_addresses"

instance P.HasComputedEnableSso (DirectoryServiceDirectoryResource s) s (TF.Attr s P.Bool) where
    computedEnableSso =
        (_enable_sso :: DirectoryServiceDirectoryResource s -> TF.Attr s P.Bool)
            . TF.refValue

instance P.HasComputedId (DirectoryServiceDirectoryResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (DirectoryServiceDirectoryResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: DirectoryServiceDirectoryResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPassword (DirectoryServiceDirectoryResource s) s (TF.Attr s Text) where
    computedPassword =
        (_password :: DirectoryServiceDirectoryResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSecurityGroupId (DirectoryServiceDirectoryResource s) s (TF.Attr s Text) where
    computedSecurityGroupId x = TF.compute (TF.refKey x) "security_group_id"

instance P.HasComputedShortName (DirectoryServiceDirectoryResource s) s (TF.Attr s Text) where
    computedShortName =
        (_short_name :: DirectoryServiceDirectoryResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSize (DirectoryServiceDirectoryResource s) s (TF.Attr s Text) where
    computedSize =
        (_size :: DirectoryServiceDirectoryResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (DirectoryServiceDirectoryResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: DirectoryServiceDirectoryResource s -> TF.Attr s P.Tags)
            . TF.refValue

instance P.HasComputedType' (DirectoryServiceDirectoryResource s) s (TF.Attr s Text) where
    computedType' =
        (_type' :: DirectoryServiceDirectoryResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedVpcSettings (DirectoryServiceDirectoryResource s) s (TF.Attr s Text) where
    computedVpcSettings =
        (_vpc_settings :: DirectoryServiceDirectoryResource s -> TF.Attr s Text)
            . TF.refValue

directoryServiceDirectoryResource :: TF.Schema TF.Resource P.AWS (DirectoryServiceDirectoryResource s)
directoryServiceDirectoryResource =
    TF.newResource "aws_directory_service_directory" $
        DirectoryServiceDirectoryResource {
              _alias = TF.Nil
            , _connect_settings = TF.Nil
            , _description = TF.Nil
            , _enable_sso = TF.Nil
            , _name = TF.Nil
            , _password = TF.Nil
            , _short_name = TF.Nil
            , _size = TF.Nil
            , _tags = TF.Nil
            , _type' = TF.Nil
            , _vpc_settings = TF.Nil
            }

{- | The @aws_dms_certificate@ AWS resource.

Provides a DMS (Data Migration Service) certificate resource. DMS
certificates can be created, deleted, and imported. ~> Note: All arguments
including the PEM encoded certificate will be stored in the raw state as
plain-text. </docs/state/sensitive-data.html> .
-}
data DmsCertificateResource s = DmsCertificateResource {
      _certificate_id     :: !(TF.Attr s Text)
    {- ^ (Required) The certificate identifier. -}
    , _certificate_pem    :: !(TF.Attr s Text)
    {- ^ (Optional) The contents of the .pem X.509 certificate file for the certificate. Either @certificate_pem@ or @certificate_wallet@ must be set. -}
    , _certificate_wallet :: !(TF.Attr s Text)
    {- ^ (Optional) The contents of the Oracle Wallet certificate for use with SSL. Either @certificate_pem@ or @certificate_wallet@ must be set. -}
    } deriving (Show, Eq)

instance TF.ToHCL (DmsCertificateResource s) where
    toHCL DmsCertificateResource{..} = TF.inline $ catMaybes
        [ TF.assign "certificate_id" <$> TF.attribute _certificate_id
        , TF.assign "certificate_pem" <$> TF.attribute _certificate_pem
        , TF.assign "certificate_wallet" <$> TF.attribute _certificate_wallet
        ]

instance P.HasCertificateId (DmsCertificateResource s) (TF.Attr s Text) where
    certificateId =
        lens (_certificate_id :: DmsCertificateResource s -> TF.Attr s Text)
             (\s a -> s { _certificate_id = a } :: DmsCertificateResource s)

instance P.HasCertificatePem (DmsCertificateResource s) (TF.Attr s Text) where
    certificatePem =
        lens (_certificate_pem :: DmsCertificateResource s -> TF.Attr s Text)
             (\s a -> s { _certificate_pem = a } :: DmsCertificateResource s)

instance P.HasCertificateWallet (DmsCertificateResource s) (TF.Attr s Text) where
    certificateWallet =
        lens (_certificate_wallet :: DmsCertificateResource s -> TF.Attr s Text)
             (\s a -> s { _certificate_wallet = a } :: DmsCertificateResource s)

instance P.HasComputedCertificateArn (DmsCertificateResource s) s (TF.Attr s Text) where
    computedCertificateArn x = TF.compute (TF.refKey x) "certificate_arn"

instance P.HasComputedCertificateId (DmsCertificateResource s) s (TF.Attr s Text) where
    computedCertificateId =
        (_certificate_id :: DmsCertificateResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCertificatePem (DmsCertificateResource s) s (TF.Attr s Text) where
    computedCertificatePem =
        (_certificate_pem :: DmsCertificateResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCertificateWallet (DmsCertificateResource s) s (TF.Attr s Text) where
    computedCertificateWallet =
        (_certificate_wallet :: DmsCertificateResource s -> TF.Attr s Text)
            . TF.refValue

dmsCertificateResource :: TF.Schema TF.Resource P.AWS (DmsCertificateResource s)
dmsCertificateResource =
    TF.newResource "aws_dms_certificate" $
        DmsCertificateResource {
              _certificate_id = TF.Nil
            , _certificate_pem = TF.Nil
            , _certificate_wallet = TF.Nil
            }

{- | The @aws_dms_endpoint@ AWS resource.

Provides a DMS (Data Migration Service) endpoint resource. DMS endpoints can
be created, updated, deleted, and imported. ~> Note: All arguments including
the password will be stored in the raw state as plain-text.
</docs/state/sensitive-data.html> .
-}
data DmsEndpointResource s = DmsEndpointResource {
      _certificate_arn             :: !(TF.Attr s Text)
    {- ^ (Optional, Default: empty string) The Amazon Resource Name (ARN) for the certificate. -}
    , _database_name               :: !(TF.Attr s Text)
    {- ^ (Optional) The name of the endpoint database. -}
    , _endpoint_id                 :: !(TF.Attr s Text)
    {- ^ (Required) The database endpoint identifier. -}
    , _endpoint_type               :: !(TF.Attr s Text)
    {- ^ (Required) The type of endpoint. Can be one of @source | target@ . -}
    , _engine_name                 :: !(TF.Attr s Text)
    {- ^ (Required) The type of engine for the endpoint. Can be one of @mysql | oracle | postgres | mariadb | aurora | redshift | sybase | sqlserver | dynamodb@ . -}
    , _extra_connection_attributes :: !(TF.Attr s Text)
    {- ^ (Optional) Additional attributes associated with the connection. For available attributes see <http://docs.aws.amazon.com/dms/latest/userguide/CHAP_Introduction.ConnectionAttributes.html> . -}
    , _kms_key_arn                 :: !(TF.Attr s Text)
    {- ^ (Optional) The Amazon Resource Name (ARN) for the KMS key that will be used to encrypt the connection parameters. If you do not specify a value for @kms_key_arn@ , then AWS DMS will use your default encryption key. AWS KMS creates the default encryption key for your AWS account. Your AWS account has a different default encryption key for each AWS region. -}
    , _password                    :: !(TF.Attr s Text)
    {- ^ (Optional) The password to be used to login to the endpoint database. -}
    , _port                        :: !(TF.Attr s Text)
    {- ^ (Optional) The port used by the endpoint database. -}
    , _server_name                 :: !(TF.Attr s Text)
    {- ^ (Optional) The host name of the server. -}
    , _service_access_role         :: !(TF.Attr s Text)
    {- ^ (Optional) The Amazon Resource Name (ARN) used by the service access IAM role for dynamodb endpoints. -}
    , _ssl_mode                    :: !(TF.Attr s Text)
    {- ^ (Optional, Default: none) The SSL mode to use for the connection. Can be one of @none | require | verify-ca | verify-full@ -}
    , _tags                        :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    , _username                    :: !(TF.Attr s Text)
    {- ^ (Optional) The user name to be used to login to the endpoint database. -}
    } deriving (Show, Eq)

instance TF.ToHCL (DmsEndpointResource s) where
    toHCL DmsEndpointResource{..} = TF.inline $ catMaybes
        [ TF.assign "certificate_arn" <$> TF.attribute _certificate_arn
        , TF.assign "database_name" <$> TF.attribute _database_name
        , TF.assign "endpoint_id" <$> TF.attribute _endpoint_id
        , TF.assign "endpoint_type" <$> TF.attribute _endpoint_type
        , TF.assign "engine_name" <$> TF.attribute _engine_name
        , TF.assign "extra_connection_attributes" <$> TF.attribute _extra_connection_attributes
        , TF.assign "kms_key_arn" <$> TF.attribute _kms_key_arn
        , TF.assign "password" <$> TF.attribute _password
        , TF.assign "port" <$> TF.attribute _port
        , TF.assign "server_name" <$> TF.attribute _server_name
        , TF.assign "service_access_role" <$> TF.attribute _service_access_role
        , TF.assign "ssl_mode" <$> TF.attribute _ssl_mode
        , TF.assign "tags" <$> TF.attribute _tags
        , TF.assign "username" <$> TF.attribute _username
        ]

instance P.HasCertificateArn (DmsEndpointResource s) (TF.Attr s Text) where
    certificateArn =
        lens (_certificate_arn :: DmsEndpointResource s -> TF.Attr s Text)
             (\s a -> s { _certificate_arn = a } :: DmsEndpointResource s)

instance P.HasDatabaseName (DmsEndpointResource s) (TF.Attr s Text) where
    databaseName =
        lens (_database_name :: DmsEndpointResource s -> TF.Attr s Text)
             (\s a -> s { _database_name = a } :: DmsEndpointResource s)

instance P.HasEndpointId (DmsEndpointResource s) (TF.Attr s Text) where
    endpointId =
        lens (_endpoint_id :: DmsEndpointResource s -> TF.Attr s Text)
             (\s a -> s { _endpoint_id = a } :: DmsEndpointResource s)

instance P.HasEndpointType (DmsEndpointResource s) (TF.Attr s Text) where
    endpointType =
        lens (_endpoint_type :: DmsEndpointResource s -> TF.Attr s Text)
             (\s a -> s { _endpoint_type = a } :: DmsEndpointResource s)

instance P.HasEngineName (DmsEndpointResource s) (TF.Attr s Text) where
    engineName =
        lens (_engine_name :: DmsEndpointResource s -> TF.Attr s Text)
             (\s a -> s { _engine_name = a } :: DmsEndpointResource s)

instance P.HasExtraConnectionAttributes (DmsEndpointResource s) (TF.Attr s Text) where
    extraConnectionAttributes =
        lens (_extra_connection_attributes :: DmsEndpointResource s -> TF.Attr s Text)
             (\s a -> s { _extra_connection_attributes = a } :: DmsEndpointResource s)

instance P.HasKmsKeyArn (DmsEndpointResource s) (TF.Attr s Text) where
    kmsKeyArn =
        lens (_kms_key_arn :: DmsEndpointResource s -> TF.Attr s Text)
             (\s a -> s { _kms_key_arn = a } :: DmsEndpointResource s)

instance P.HasPassword (DmsEndpointResource s) (TF.Attr s Text) where
    password =
        lens (_password :: DmsEndpointResource s -> TF.Attr s Text)
             (\s a -> s { _password = a } :: DmsEndpointResource s)

instance P.HasPort (DmsEndpointResource s) (TF.Attr s Text) where
    port =
        lens (_port :: DmsEndpointResource s -> TF.Attr s Text)
             (\s a -> s { _port = a } :: DmsEndpointResource s)

instance P.HasServerName (DmsEndpointResource s) (TF.Attr s Text) where
    serverName =
        lens (_server_name :: DmsEndpointResource s -> TF.Attr s Text)
             (\s a -> s { _server_name = a } :: DmsEndpointResource s)

instance P.HasServiceAccessRole (DmsEndpointResource s) (TF.Attr s Text) where
    serviceAccessRole =
        lens (_service_access_role :: DmsEndpointResource s -> TF.Attr s Text)
             (\s a -> s { _service_access_role = a } :: DmsEndpointResource s)

instance P.HasSslMode (DmsEndpointResource s) (TF.Attr s Text) where
    sslMode =
        lens (_ssl_mode :: DmsEndpointResource s -> TF.Attr s Text)
             (\s a -> s { _ssl_mode = a } :: DmsEndpointResource s)

instance P.HasTags (DmsEndpointResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: DmsEndpointResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: DmsEndpointResource s)

instance P.HasUsername (DmsEndpointResource s) (TF.Attr s Text) where
    username =
        lens (_username :: DmsEndpointResource s -> TF.Attr s Text)
             (\s a -> s { _username = a } :: DmsEndpointResource s)

instance P.HasComputedCertificateArn (DmsEndpointResource s) s (TF.Attr s Text) where
    computedCertificateArn =
        (_certificate_arn :: DmsEndpointResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDatabaseName (DmsEndpointResource s) s (TF.Attr s Text) where
    computedDatabaseName =
        (_database_name :: DmsEndpointResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEndpointArn (DmsEndpointResource s) s (TF.Attr s Text) where
    computedEndpointArn x = TF.compute (TF.refKey x) "endpoint_arn"

instance P.HasComputedEndpointId (DmsEndpointResource s) s (TF.Attr s Text) where
    computedEndpointId =
        (_endpoint_id :: DmsEndpointResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEndpointType (DmsEndpointResource s) s (TF.Attr s Text) where
    computedEndpointType =
        (_endpoint_type :: DmsEndpointResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEngineName (DmsEndpointResource s) s (TF.Attr s Text) where
    computedEngineName =
        (_engine_name :: DmsEndpointResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedExtraConnectionAttributes (DmsEndpointResource s) s (TF.Attr s Text) where
    computedExtraConnectionAttributes =
        (_extra_connection_attributes :: DmsEndpointResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedKmsKeyArn (DmsEndpointResource s) s (TF.Attr s Text) where
    computedKmsKeyArn =
        (_kms_key_arn :: DmsEndpointResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPassword (DmsEndpointResource s) s (TF.Attr s Text) where
    computedPassword =
        (_password :: DmsEndpointResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPort (DmsEndpointResource s) s (TF.Attr s Text) where
    computedPort =
        (_port :: DmsEndpointResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedServerName (DmsEndpointResource s) s (TF.Attr s Text) where
    computedServerName =
        (_server_name :: DmsEndpointResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedServiceAccessRole (DmsEndpointResource s) s (TF.Attr s Text) where
    computedServiceAccessRole =
        (_service_access_role :: DmsEndpointResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSslMode (DmsEndpointResource s) s (TF.Attr s Text) where
    computedSslMode =
        (_ssl_mode :: DmsEndpointResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (DmsEndpointResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: DmsEndpointResource s -> TF.Attr s P.Tags)
            . TF.refValue

instance P.HasComputedUsername (DmsEndpointResource s) s (TF.Attr s Text) where
    computedUsername =
        (_username :: DmsEndpointResource s -> TF.Attr s Text)
            . TF.refValue

dmsEndpointResource :: TF.Schema TF.Resource P.AWS (DmsEndpointResource s)
dmsEndpointResource =
    TF.newResource "aws_dms_endpoint" $
        DmsEndpointResource {
              _certificate_arn = TF.Nil
            , _database_name = TF.Nil
            , _endpoint_id = TF.Nil
            , _endpoint_type = TF.Nil
            , _engine_name = TF.Nil
            , _extra_connection_attributes = TF.Nil
            , _kms_key_arn = TF.Nil
            , _password = TF.Nil
            , _port = TF.Nil
            , _server_name = TF.Nil
            , _service_access_role = TF.Nil
            , _ssl_mode = TF.Nil
            , _tags = TF.Nil
            , _username = TF.Nil
            }

{- | The @aws_dms_replication_instance@ AWS resource.

Provides a DMS (Data Migration Service) replication instance resource. DMS
replication instances can be created, updated, deleted, and imported.
-}
data DmsReplicationInstanceResource s = DmsReplicationInstanceResource {
      _allocated_storage            :: !(TF.Attr s Text)
    {- ^ (Optional, Default: 50, Min: 5, Max: 6144) The amount of storage (in gigabytes) to be initially allocated for the replication instance. -}
    , _apply_immediately            :: !(TF.Attr s Text)
    {- ^ (Optional, Default: false) Indicates whether the changes should be applied immediately or during the next maintenance window. Only used when updating an existing resource. -}
    , _auto_minor_version_upgrade   :: !(TF.Attr s Text)
    {- ^ (Optional, Default: false) Indicates that minor engine upgrades will be applied automatically to the replication instance during the maintenance window. -}
    , _availability_zone            :: !(TF.Attr s P.Zone)
    {- ^ (Optional) The EC2 Availability Zone that the replication instance will be created in. -}
    , _engine_version               :: !(TF.Attr s Text)
    {- ^ (Optional) The engine version number of the replication instance. -}
    , _kms_key_arn                  :: !(TF.Attr s Text)
    {- ^ (Optional) The Amazon Resource Name (ARN) for the KMS key that will be used to encrypt the connection parameters. If you do not specify a value for @kms_key_arn@ , then AWS DMS will use your default encryption key. AWS KMS creates the default encryption key for your AWS account. Your AWS account has a different default encryption key for each AWS region. -}
    , _multi_az                     :: !(TF.Attr s Text)
    {- ^ (Optional) Specifies if the replication instance is a multi-az deployment. You cannot set the @availability_zone@ parameter if the @multi_az@ parameter is set to @true@ . -}
    , _preferred_maintenance_window :: !(TF.Attr s Text)
    {- ^ (Optional) The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC). -}
    , _publicly_accessible          :: !(TF.Attr s Text)
    {- ^ (Optional, Default: false) Specifies the accessibility options for the replication instance. A value of true represents an instance with a public IP address. A value of false represents an instance with a private IP address. -}
    , _replication_instance_class   :: !(TF.Attr s Text)
    {- ^ (Required) The compute and memory capacity of the replication instance as specified by the replication instance class. Can be one of @dms.t2.micro | dms.t2.small | dms.t2.medium | dms.t2.large | dms.c4.large | dms.c4.xlarge | dms.c4.2xlarge | dms.c4.4xlarge@ -}
    , _replication_instance_id      :: !(TF.Attr s Text)
    {- ^ (Required) The replication instance identifier. This parameter is stored as a lowercase string. -}
    , _replication_subnet_group_id  :: !(TF.Attr s Text)
    {- ^ (Optional) A subnet group to associate with the replication instance. -}
    , _tags                         :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    , _vpc_security_group_ids       :: !(TF.Attr s Text)
    {- ^ (Optional) A list of VPC security group IDs to be used with the replication instance. The VPC security groups must work with the VPC containing the replication instance. -}
    } deriving (Show, Eq)

instance TF.ToHCL (DmsReplicationInstanceResource s) where
    toHCL DmsReplicationInstanceResource{..} = TF.inline $ catMaybes
        [ TF.assign "allocated_storage" <$> TF.attribute _allocated_storage
        , TF.assign "apply_immediately" <$> TF.attribute _apply_immediately
        , TF.assign "auto_minor_version_upgrade" <$> TF.attribute _auto_minor_version_upgrade
        , TF.assign "availability_zone" <$> TF.attribute _availability_zone
        , TF.assign "engine_version" <$> TF.attribute _engine_version
        , TF.assign "kms_key_arn" <$> TF.attribute _kms_key_arn
        , TF.assign "multi_az" <$> TF.attribute _multi_az
        , TF.assign "preferred_maintenance_window" <$> TF.attribute _preferred_maintenance_window
        , TF.assign "publicly_accessible" <$> TF.attribute _publicly_accessible
        , TF.assign "replication_instance_class" <$> TF.attribute _replication_instance_class
        , TF.assign "replication_instance_id" <$> TF.attribute _replication_instance_id
        , TF.assign "replication_subnet_group_id" <$> TF.attribute _replication_subnet_group_id
        , TF.assign "tags" <$> TF.attribute _tags
        , TF.assign "vpc_security_group_ids" <$> TF.attribute _vpc_security_group_ids
        ]

instance P.HasAllocatedStorage (DmsReplicationInstanceResource s) (TF.Attr s Text) where
    allocatedStorage =
        lens (_allocated_storage :: DmsReplicationInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _allocated_storage = a } :: DmsReplicationInstanceResource s)

instance P.HasApplyImmediately (DmsReplicationInstanceResource s) (TF.Attr s Text) where
    applyImmediately =
        lens (_apply_immediately :: DmsReplicationInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _apply_immediately = a } :: DmsReplicationInstanceResource s)

instance P.HasAutoMinorVersionUpgrade (DmsReplicationInstanceResource s) (TF.Attr s Text) where
    autoMinorVersionUpgrade =
        lens (_auto_minor_version_upgrade :: DmsReplicationInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _auto_minor_version_upgrade = a } :: DmsReplicationInstanceResource s)

instance P.HasAvailabilityZone (DmsReplicationInstanceResource s) (TF.Attr s P.Zone) where
    availabilityZone =
        lens (_availability_zone :: DmsReplicationInstanceResource s -> TF.Attr s P.Zone)
             (\s a -> s { _availability_zone = a } :: DmsReplicationInstanceResource s)

instance P.HasEngineVersion (DmsReplicationInstanceResource s) (TF.Attr s Text) where
    engineVersion =
        lens (_engine_version :: DmsReplicationInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _engine_version = a } :: DmsReplicationInstanceResource s)

instance P.HasKmsKeyArn (DmsReplicationInstanceResource s) (TF.Attr s Text) where
    kmsKeyArn =
        lens (_kms_key_arn :: DmsReplicationInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _kms_key_arn = a } :: DmsReplicationInstanceResource s)

instance P.HasMultiAz (DmsReplicationInstanceResource s) (TF.Attr s Text) where
    multiAz =
        lens (_multi_az :: DmsReplicationInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _multi_az = a } :: DmsReplicationInstanceResource s)

instance P.HasPreferredMaintenanceWindow (DmsReplicationInstanceResource s) (TF.Attr s Text) where
    preferredMaintenanceWindow =
        lens (_preferred_maintenance_window :: DmsReplicationInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _preferred_maintenance_window = a } :: DmsReplicationInstanceResource s)

instance P.HasPubliclyAccessible (DmsReplicationInstanceResource s) (TF.Attr s Text) where
    publiclyAccessible =
        lens (_publicly_accessible :: DmsReplicationInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _publicly_accessible = a } :: DmsReplicationInstanceResource s)

instance P.HasReplicationInstanceClass (DmsReplicationInstanceResource s) (TF.Attr s Text) where
    replicationInstanceClass =
        lens (_replication_instance_class :: DmsReplicationInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _replication_instance_class = a } :: DmsReplicationInstanceResource s)

instance P.HasReplicationInstanceId (DmsReplicationInstanceResource s) (TF.Attr s Text) where
    replicationInstanceId =
        lens (_replication_instance_id :: DmsReplicationInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _replication_instance_id = a } :: DmsReplicationInstanceResource s)

instance P.HasReplicationSubnetGroupId (DmsReplicationInstanceResource s) (TF.Attr s Text) where
    replicationSubnetGroupId =
        lens (_replication_subnet_group_id :: DmsReplicationInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _replication_subnet_group_id = a } :: DmsReplicationInstanceResource s)

instance P.HasTags (DmsReplicationInstanceResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: DmsReplicationInstanceResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: DmsReplicationInstanceResource s)

instance P.HasVpcSecurityGroupIds (DmsReplicationInstanceResource s) (TF.Attr s Text) where
    vpcSecurityGroupIds =
        lens (_vpc_security_group_ids :: DmsReplicationInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _vpc_security_group_ids = a } :: DmsReplicationInstanceResource s)

instance P.HasComputedAllocatedStorage (DmsReplicationInstanceResource s) s (TF.Attr s Text) where
    computedAllocatedStorage =
        (_allocated_storage :: DmsReplicationInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedApplyImmediately (DmsReplicationInstanceResource s) s (TF.Attr s Text) where
    computedApplyImmediately =
        (_apply_immediately :: DmsReplicationInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAutoMinorVersionUpgrade (DmsReplicationInstanceResource s) s (TF.Attr s Text) where
    computedAutoMinorVersionUpgrade =
        (_auto_minor_version_upgrade :: DmsReplicationInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAvailabilityZone (DmsReplicationInstanceResource s) s (TF.Attr s P.Zone) where
    computedAvailabilityZone =
        (_availability_zone :: DmsReplicationInstanceResource s -> TF.Attr s P.Zone)
            . TF.refValue

instance P.HasComputedEngineVersion (DmsReplicationInstanceResource s) s (TF.Attr s Text) where
    computedEngineVersion =
        (_engine_version :: DmsReplicationInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedKmsKeyArn (DmsReplicationInstanceResource s) s (TF.Attr s Text) where
    computedKmsKeyArn =
        (_kms_key_arn :: DmsReplicationInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedMultiAz (DmsReplicationInstanceResource s) s (TF.Attr s Text) where
    computedMultiAz =
        (_multi_az :: DmsReplicationInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPreferredMaintenanceWindow (DmsReplicationInstanceResource s) s (TF.Attr s Text) where
    computedPreferredMaintenanceWindow =
        (_preferred_maintenance_window :: DmsReplicationInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPubliclyAccessible (DmsReplicationInstanceResource s) s (TF.Attr s Text) where
    computedPubliclyAccessible =
        (_publicly_accessible :: DmsReplicationInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedReplicationInstanceArn (DmsReplicationInstanceResource s) s (TF.Attr s Text) where
    computedReplicationInstanceArn x = TF.compute (TF.refKey x) "replication_instance_arn"

instance P.HasComputedReplicationInstanceClass (DmsReplicationInstanceResource s) s (TF.Attr s Text) where
    computedReplicationInstanceClass =
        (_replication_instance_class :: DmsReplicationInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedReplicationInstanceId (DmsReplicationInstanceResource s) s (TF.Attr s Text) where
    computedReplicationInstanceId =
        (_replication_instance_id :: DmsReplicationInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedReplicationInstancePrivateIps (DmsReplicationInstanceResource s) s (TF.Attr s Text) where
    computedReplicationInstancePrivateIps x = TF.compute (TF.refKey x) "replication_instance_private_ips"

instance P.HasComputedReplicationInstancePublicIps (DmsReplicationInstanceResource s) s (TF.Attr s Text) where
    computedReplicationInstancePublicIps x = TF.compute (TF.refKey x) "replication_instance_public_ips"

instance P.HasComputedReplicationSubnetGroupId (DmsReplicationInstanceResource s) s (TF.Attr s Text) where
    computedReplicationSubnetGroupId =
        (_replication_subnet_group_id :: DmsReplicationInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (DmsReplicationInstanceResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: DmsReplicationInstanceResource s -> TF.Attr s P.Tags)
            . TF.refValue

instance P.HasComputedVpcSecurityGroupIds (DmsReplicationInstanceResource s) s (TF.Attr s Text) where
    computedVpcSecurityGroupIds =
        (_vpc_security_group_ids :: DmsReplicationInstanceResource s -> TF.Attr s Text)
            . TF.refValue

dmsReplicationInstanceResource :: TF.Schema TF.Resource P.AWS (DmsReplicationInstanceResource s)
dmsReplicationInstanceResource =
    TF.newResource "aws_dms_replication_instance" $
        DmsReplicationInstanceResource {
              _allocated_storage = TF.Nil
            , _apply_immediately = TF.Nil
            , _auto_minor_version_upgrade = TF.Nil
            , _availability_zone = TF.Nil
            , _engine_version = TF.Nil
            , _kms_key_arn = TF.Nil
            , _multi_az = TF.Nil
            , _preferred_maintenance_window = TF.Nil
            , _publicly_accessible = TF.Nil
            , _replication_instance_class = TF.Nil
            , _replication_instance_id = TF.Nil
            , _replication_subnet_group_id = TF.Nil
            , _tags = TF.Nil
            , _vpc_security_group_ids = TF.Nil
            }

{- | The @aws_dms_replication_subnet_group@ AWS resource.

Provides a DMS (Data Migration Service) replication subnet group resource.
DMS replication subnet groups can be created, updated, deleted, and
imported.
-}
data DmsReplicationSubnetGroupResource s = DmsReplicationSubnetGroupResource {
      _replication_subnet_group_description :: !(TF.Attr s Text)
    {- ^ (Required) The description for the subnet group. -}
    , _replication_subnet_group_id          :: !(TF.Attr s Text)
    {- ^ (Required) The name for the replication subnet group. This value is stored as a lowercase string. -}
    , _subnet_ids                           :: !(TF.Attr s Text)
    {- ^ (Required) A list of the EC2 subnet IDs for the subnet group. -}
    } deriving (Show, Eq)

instance TF.ToHCL (DmsReplicationSubnetGroupResource s) where
    toHCL DmsReplicationSubnetGroupResource{..} = TF.inline $ catMaybes
        [ TF.assign "replication_subnet_group_description" <$> TF.attribute _replication_subnet_group_description
        , TF.assign "replication_subnet_group_id" <$> TF.attribute _replication_subnet_group_id
        , TF.assign "subnet_ids" <$> TF.attribute _subnet_ids
        ]

instance P.HasReplicationSubnetGroupDescription (DmsReplicationSubnetGroupResource s) (TF.Attr s Text) where
    replicationSubnetGroupDescription =
        lens (_replication_subnet_group_description :: DmsReplicationSubnetGroupResource s -> TF.Attr s Text)
             (\s a -> s { _replication_subnet_group_description = a } :: DmsReplicationSubnetGroupResource s)

instance P.HasReplicationSubnetGroupId (DmsReplicationSubnetGroupResource s) (TF.Attr s Text) where
    replicationSubnetGroupId =
        lens (_replication_subnet_group_id :: DmsReplicationSubnetGroupResource s -> TF.Attr s Text)
             (\s a -> s { _replication_subnet_group_id = a } :: DmsReplicationSubnetGroupResource s)

instance P.HasSubnetIds (DmsReplicationSubnetGroupResource s) (TF.Attr s Text) where
    subnetIds =
        lens (_subnet_ids :: DmsReplicationSubnetGroupResource s -> TF.Attr s Text)
             (\s a -> s { _subnet_ids = a } :: DmsReplicationSubnetGroupResource s)

instance P.HasComputedReplicationSubnetGroupDescription (DmsReplicationSubnetGroupResource s) s (TF.Attr s Text) where
    computedReplicationSubnetGroupDescription =
        (_replication_subnet_group_description :: DmsReplicationSubnetGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedReplicationSubnetGroupId (DmsReplicationSubnetGroupResource s) s (TF.Attr s Text) where
    computedReplicationSubnetGroupId =
        (_replication_subnet_group_id :: DmsReplicationSubnetGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSubnetIds (DmsReplicationSubnetGroupResource s) s (TF.Attr s Text) where
    computedSubnetIds =
        (_subnet_ids :: DmsReplicationSubnetGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedVpcId (DmsReplicationSubnetGroupResource s) s (TF.Attr s Text) where
    computedVpcId x = TF.compute (TF.refKey x) "vpc_id"

dmsReplicationSubnetGroupResource :: TF.Schema TF.Resource P.AWS (DmsReplicationSubnetGroupResource s)
dmsReplicationSubnetGroupResource =
    TF.newResource "aws_dms_replication_subnet_group" $
        DmsReplicationSubnetGroupResource {
              _replication_subnet_group_description = TF.Nil
            , _replication_subnet_group_id = TF.Nil
            , _subnet_ids = TF.Nil
            }

{- | The @aws_dms_replication_task@ AWS resource.

Provides a DMS (Data Migration Service) replication task resource. DMS
replication tasks can be created, updated, deleted, and imported.
-}
data DmsReplicationTaskResource s = DmsReplicationTaskResource {
      _cdc_start_time            :: !(TF.Attr s Text)
    {- ^ (Optional) The Unix timestamp integer for the start of the Change Data Capture (CDC) operation. -}
    , _migration_type            :: !(TF.Attr s Text)
    {- ^ (Required) The migration type. Can be one of @full-load | cdc | full-load-and-cdc@ . -}
    , _replication_instance_arn  :: !(TF.Attr s Text)
    {- ^ (Required) The Amazon Resource Name (ARN) of the replication instance. -}
    , _replication_task_id       :: !(TF.Attr s Text)
    {- ^ (Required) The replication task identifier. -}
    , _replication_task_settings :: !(TF.Attr s Text)
    {- ^ (Optional) An escaped JSON string that contains the task settings. For a complete list of task settings, see <http://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.CustomizingTasks.TaskSettings.html> . -}
    , _source_endpoint_arn       :: !(TF.Attr s Text)
    {- ^ (Required) The Amazon Resource Name (ARN) string that uniquely identifies the source endpoint. -}
    , _table_mappings            :: !(TF.Attr s Text)
    {- ^ (Required) An escaped JSON string that contains the table mappings. For information on table mapping see <http://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.CustomizingTasks.TableMapping.html> -}
    , _tags                      :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    , _target_endpoint_arn       :: !(TF.Attr s Text)
    {- ^ (Required) The Amazon Resource Name (ARN) string that uniquely identifies the target endpoint. -}
    } deriving (Show, Eq)

instance TF.ToHCL (DmsReplicationTaskResource s) where
    toHCL DmsReplicationTaskResource{..} = TF.inline $ catMaybes
        [ TF.assign "cdc_start_time" <$> TF.attribute _cdc_start_time
        , TF.assign "migration_type" <$> TF.attribute _migration_type
        , TF.assign "replication_instance_arn" <$> TF.attribute _replication_instance_arn
        , TF.assign "replication_task_id" <$> TF.attribute _replication_task_id
        , TF.assign "replication_task_settings" <$> TF.attribute _replication_task_settings
        , TF.assign "source_endpoint_arn" <$> TF.attribute _source_endpoint_arn
        , TF.assign "table_mappings" <$> TF.attribute _table_mappings
        , TF.assign "tags" <$> TF.attribute _tags
        , TF.assign "target_endpoint_arn" <$> TF.attribute _target_endpoint_arn
        ]

instance P.HasCdcStartTime (DmsReplicationTaskResource s) (TF.Attr s Text) where
    cdcStartTime =
        lens (_cdc_start_time :: DmsReplicationTaskResource s -> TF.Attr s Text)
             (\s a -> s { _cdc_start_time = a } :: DmsReplicationTaskResource s)

instance P.HasMigrationType (DmsReplicationTaskResource s) (TF.Attr s Text) where
    migrationType =
        lens (_migration_type :: DmsReplicationTaskResource s -> TF.Attr s Text)
             (\s a -> s { _migration_type = a } :: DmsReplicationTaskResource s)

instance P.HasReplicationInstanceArn (DmsReplicationTaskResource s) (TF.Attr s Text) where
    replicationInstanceArn =
        lens (_replication_instance_arn :: DmsReplicationTaskResource s -> TF.Attr s Text)
             (\s a -> s { _replication_instance_arn = a } :: DmsReplicationTaskResource s)

instance P.HasReplicationTaskId (DmsReplicationTaskResource s) (TF.Attr s Text) where
    replicationTaskId =
        lens (_replication_task_id :: DmsReplicationTaskResource s -> TF.Attr s Text)
             (\s a -> s { _replication_task_id = a } :: DmsReplicationTaskResource s)

instance P.HasReplicationTaskSettings (DmsReplicationTaskResource s) (TF.Attr s Text) where
    replicationTaskSettings =
        lens (_replication_task_settings :: DmsReplicationTaskResource s -> TF.Attr s Text)
             (\s a -> s { _replication_task_settings = a } :: DmsReplicationTaskResource s)

instance P.HasSourceEndpointArn (DmsReplicationTaskResource s) (TF.Attr s Text) where
    sourceEndpointArn =
        lens (_source_endpoint_arn :: DmsReplicationTaskResource s -> TF.Attr s Text)
             (\s a -> s { _source_endpoint_arn = a } :: DmsReplicationTaskResource s)

instance P.HasTableMappings (DmsReplicationTaskResource s) (TF.Attr s Text) where
    tableMappings =
        lens (_table_mappings :: DmsReplicationTaskResource s -> TF.Attr s Text)
             (\s a -> s { _table_mappings = a } :: DmsReplicationTaskResource s)

instance P.HasTags (DmsReplicationTaskResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: DmsReplicationTaskResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: DmsReplicationTaskResource s)

instance P.HasTargetEndpointArn (DmsReplicationTaskResource s) (TF.Attr s Text) where
    targetEndpointArn =
        lens (_target_endpoint_arn :: DmsReplicationTaskResource s -> TF.Attr s Text)
             (\s a -> s { _target_endpoint_arn = a } :: DmsReplicationTaskResource s)

instance P.HasComputedCdcStartTime (DmsReplicationTaskResource s) s (TF.Attr s Text) where
    computedCdcStartTime =
        (_cdc_start_time :: DmsReplicationTaskResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedMigrationType (DmsReplicationTaskResource s) s (TF.Attr s Text) where
    computedMigrationType =
        (_migration_type :: DmsReplicationTaskResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedReplicationInstanceArn (DmsReplicationTaskResource s) s (TF.Attr s Text) where
    computedReplicationInstanceArn =
        (_replication_instance_arn :: DmsReplicationTaskResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedReplicationTaskArn (DmsReplicationTaskResource s) s (TF.Attr s Text) where
    computedReplicationTaskArn x = TF.compute (TF.refKey x) "replication_task_arn"

instance P.HasComputedReplicationTaskId (DmsReplicationTaskResource s) s (TF.Attr s Text) where
    computedReplicationTaskId =
        (_replication_task_id :: DmsReplicationTaskResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedReplicationTaskSettings (DmsReplicationTaskResource s) s (TF.Attr s Text) where
    computedReplicationTaskSettings =
        (_replication_task_settings :: DmsReplicationTaskResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSourceEndpointArn (DmsReplicationTaskResource s) s (TF.Attr s Text) where
    computedSourceEndpointArn =
        (_source_endpoint_arn :: DmsReplicationTaskResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTableMappings (DmsReplicationTaskResource s) s (TF.Attr s Text) where
    computedTableMappings =
        (_table_mappings :: DmsReplicationTaskResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (DmsReplicationTaskResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: DmsReplicationTaskResource s -> TF.Attr s P.Tags)
            . TF.refValue

instance P.HasComputedTargetEndpointArn (DmsReplicationTaskResource s) s (TF.Attr s Text) where
    computedTargetEndpointArn =
        (_target_endpoint_arn :: DmsReplicationTaskResource s -> TF.Attr s Text)
            . TF.refValue

dmsReplicationTaskResource :: TF.Schema TF.Resource P.AWS (DmsReplicationTaskResource s)
dmsReplicationTaskResource =
    TF.newResource "aws_dms_replication_task" $
        DmsReplicationTaskResource {
              _cdc_start_time = TF.Nil
            , _migration_type = TF.Nil
            , _replication_instance_arn = TF.Nil
            , _replication_task_id = TF.Nil
            , _replication_task_settings = TF.Nil
            , _source_endpoint_arn = TF.Nil
            , _table_mappings = TF.Nil
            , _tags = TF.Nil
            , _target_endpoint_arn = TF.Nil
            }

{- | The @aws_dx_connection_association@ AWS resource.

Associates a Direct Connect Connection with a LAG.
-}
data DxConnectionAssociationResource s = DxConnectionAssociationResource {
      _connection_id :: !(TF.Attr s Text)
    {- ^ (Required) The ID of the connection. -}
    , _lag_id        :: !(TF.Attr s Text)
    {- ^ (Required) The ID of the LAG with which to associate the connection. -}
    } deriving (Show, Eq)

instance TF.ToHCL (DxConnectionAssociationResource s) where
    toHCL DxConnectionAssociationResource{..} = TF.inline $ catMaybes
        [ TF.assign "connection_id" <$> TF.attribute _connection_id
        , TF.assign "lag_id" <$> TF.attribute _lag_id
        ]

instance P.HasConnectionId (DxConnectionAssociationResource s) (TF.Attr s Text) where
    connectionId =
        lens (_connection_id :: DxConnectionAssociationResource s -> TF.Attr s Text)
             (\s a -> s { _connection_id = a } :: DxConnectionAssociationResource s)

instance P.HasLagId (DxConnectionAssociationResource s) (TF.Attr s Text) where
    lagId =
        lens (_lag_id :: DxConnectionAssociationResource s -> TF.Attr s Text)
             (\s a -> s { _lag_id = a } :: DxConnectionAssociationResource s)

instance P.HasComputedConnectionId (DxConnectionAssociationResource s) s (TF.Attr s Text) where
    computedConnectionId =
        (_connection_id :: DxConnectionAssociationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedLagId (DxConnectionAssociationResource s) s (TF.Attr s Text) where
    computedLagId =
        (_lag_id :: DxConnectionAssociationResource s -> TF.Attr s Text)
            . TF.refValue

dxConnectionAssociationResource :: TF.Schema TF.Resource P.AWS (DxConnectionAssociationResource s)
dxConnectionAssociationResource =
    TF.newResource "aws_dx_connection_association" $
        DxConnectionAssociationResource {
              _connection_id = TF.Nil
            , _lag_id = TF.Nil
            }

{- | The @aws_dx_connection@ AWS resource.

Provides a Connection of Direct Connect.
-}
data DxConnectionResource s = DxConnectionResource {
      _bandwidth :: !(TF.Attr s Text)
    {- ^ (Required) The bandwidth of the connection. Available values: 1Gbps, 10Gbps. Case sensitive. -}
    , _location  :: !(TF.Attr s Text)
    {- ^ (Required) The AWS Direct Connect location where the connection is located. See <https://docs.aws.amazon.com/directconnect/latest/APIReference/API_DescribeLocations.html> for the list of AWS Direct Connect locations. Use @locationCode@ . -}
    , _name      :: !(TF.Attr s Text)
    {- ^ (Required) The name of the connection. -}
    , _tags      :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    } deriving (Show, Eq)

instance TF.ToHCL (DxConnectionResource s) where
    toHCL DxConnectionResource{..} = TF.inline $ catMaybes
        [ TF.assign "bandwidth" <$> TF.attribute _bandwidth
        , TF.assign "location" <$> TF.attribute _location
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "tags" <$> TF.attribute _tags
        ]

instance P.HasBandwidth (DxConnectionResource s) (TF.Attr s Text) where
    bandwidth =
        lens (_bandwidth :: DxConnectionResource s -> TF.Attr s Text)
             (\s a -> s { _bandwidth = a } :: DxConnectionResource s)

instance P.HasLocation (DxConnectionResource s) (TF.Attr s Text) where
    location =
        lens (_location :: DxConnectionResource s -> TF.Attr s Text)
             (\s a -> s { _location = a } :: DxConnectionResource s)

instance P.HasName (DxConnectionResource s) (TF.Attr s Text) where
    name =
        lens (_name :: DxConnectionResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: DxConnectionResource s)

instance P.HasTags (DxConnectionResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: DxConnectionResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: DxConnectionResource s)

instance P.HasComputedArn (DxConnectionResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedBandwidth (DxConnectionResource s) s (TF.Attr s Text) where
    computedBandwidth =
        (_bandwidth :: DxConnectionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (DxConnectionResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedLocation (DxConnectionResource s) s (TF.Attr s Text) where
    computedLocation =
        (_location :: DxConnectionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (DxConnectionResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: DxConnectionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (DxConnectionResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: DxConnectionResource s -> TF.Attr s P.Tags)
            . TF.refValue

dxConnectionResource :: TF.Schema TF.Resource P.AWS (DxConnectionResource s)
dxConnectionResource =
    TF.newResource "aws_dx_connection" $
        DxConnectionResource {
              _bandwidth = TF.Nil
            , _location = TF.Nil
            , _name = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_dx_lag@ AWS resource.

Provides a Direct Connect LAG.
-}
data DxLagResource s = DxLagResource {
      _connections_bandwidth :: !(TF.Attr s Text)
    {- ^ (Required) The bandwidth of the individual physical connections bundled by the LAG. Available values: 1Gbps, 10Gbps. Case sensitive. -}
    , _force_destroy         :: !(TF.Attr s Text)
    {- ^ (Optional, Default:false) A boolean that indicates all connections associated with the LAG should be deleted so that the LAG can be destroyed without error. These objects are not recoverable. -}
    , _location              :: !(TF.Attr s Text)
    {- ^ (Required) The AWS Direct Connect location in which the LAG should be allocated. See <https://docs.aws.amazon.com/directconnect/latest/APIReference/API_DescribeLocations.html> for the list of AWS Direct Connect locations. Use @locationCode@ . -}
    , _name                  :: !(TF.Attr s Text)
    {- ^ (Required) The name of the LAG. -}
    , _number_of_connections :: !(TF.Attr s Text)
    {- ^ - ( Deprecated ) The number of physical connections initially provisioned and bundled by the LAG. Use @aws_dx_connection@ and @aws_dx_connection_association@ resources instead. Default connections will be removed as part of LAG creation automatically in future versions. -}
    , _tags                  :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    } deriving (Show, Eq)

instance TF.ToHCL (DxLagResource s) where
    toHCL DxLagResource{..} = TF.inline $ catMaybes
        [ TF.assign "connections_bandwidth" <$> TF.attribute _connections_bandwidth
        , TF.assign "force_destroy" <$> TF.attribute _force_destroy
        , TF.assign "location" <$> TF.attribute _location
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "number_of_connections" <$> TF.attribute _number_of_connections
        , TF.assign "tags" <$> TF.attribute _tags
        ]

instance P.HasConnectionsBandwidth (DxLagResource s) (TF.Attr s Text) where
    connectionsBandwidth =
        lens (_connections_bandwidth :: DxLagResource s -> TF.Attr s Text)
             (\s a -> s { _connections_bandwidth = a } :: DxLagResource s)

instance P.HasForceDestroy (DxLagResource s) (TF.Attr s Text) where
    forceDestroy =
        lens (_force_destroy :: DxLagResource s -> TF.Attr s Text)
             (\s a -> s { _force_destroy = a } :: DxLagResource s)

instance P.HasLocation (DxLagResource s) (TF.Attr s Text) where
    location =
        lens (_location :: DxLagResource s -> TF.Attr s Text)
             (\s a -> s { _location = a } :: DxLagResource s)

instance P.HasName (DxLagResource s) (TF.Attr s Text) where
    name =
        lens (_name :: DxLagResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: DxLagResource s)

instance P.HasNumberOfConnections (DxLagResource s) (TF.Attr s Text) where
    numberOfConnections =
        lens (_number_of_connections :: DxLagResource s -> TF.Attr s Text)
             (\s a -> s { _number_of_connections = a } :: DxLagResource s)

instance P.HasTags (DxLagResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: DxLagResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: DxLagResource s)

instance P.HasComputedArn (DxLagResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedConnectionsBandwidth (DxLagResource s) s (TF.Attr s Text) where
    computedConnectionsBandwidth =
        (_connections_bandwidth :: DxLagResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedForceDestroy (DxLagResource s) s (TF.Attr s Text) where
    computedForceDestroy =
        (_force_destroy :: DxLagResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (DxLagResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedLocation (DxLagResource s) s (TF.Attr s Text) where
    computedLocation =
        (_location :: DxLagResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (DxLagResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: DxLagResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedNumberOfConnections (DxLagResource s) s (TF.Attr s Text) where
    computedNumberOfConnections =
        (_number_of_connections :: DxLagResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (DxLagResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: DxLagResource s -> TF.Attr s P.Tags)
            . TF.refValue

dxLagResource :: TF.Schema TF.Resource P.AWS (DxLagResource s)
dxLagResource =
    TF.newResource "aws_dx_lag" $
        DxLagResource {
              _connections_bandwidth = TF.Nil
            , _force_destroy = TF.Nil
            , _location = TF.Nil
            , _name = TF.Nil
            , _number_of_connections = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_dynamodb_global_table@ AWS resource.

Provides a resource to manage a DynamoDB Global Table. These are layered on
top of existing DynamoDB Tables. ~> Note: There are many restrictions before
you can properly create DynamoDB Global Tables in multiple regions. See the
<http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables_reqs_bestpractices.html>
for more information.
-}
data DynamodbGlobalTableResource s = DynamodbGlobalTableResource {
      _name    :: !(TF.Attr s Text)
    {- ^ (Required) The name of the global table. Must match underlying DynamoDB Table names in all regions. -}
    , _replica :: !(TF.Attr s Text)
    {- ^ (Required) Underlying DynamoDB Table. At least 1 replica must be defined. See below. -}
    } deriving (Show, Eq)

instance TF.ToHCL (DynamodbGlobalTableResource s) where
    toHCL DynamodbGlobalTableResource{..} = TF.inline $ catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "replica" <$> TF.attribute _replica
        ]

instance P.HasName (DynamodbGlobalTableResource s) (TF.Attr s Text) where
    name =
        lens (_name :: DynamodbGlobalTableResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: DynamodbGlobalTableResource s)

instance P.HasReplica (DynamodbGlobalTableResource s) (TF.Attr s Text) where
    replica =
        lens (_replica :: DynamodbGlobalTableResource s -> TF.Attr s Text)
             (\s a -> s { _replica = a } :: DynamodbGlobalTableResource s)

instance P.HasComputedArn (DynamodbGlobalTableResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedId (DynamodbGlobalTableResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (DynamodbGlobalTableResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: DynamodbGlobalTableResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedReplica (DynamodbGlobalTableResource s) s (TF.Attr s Text) where
    computedReplica =
        (_replica :: DynamodbGlobalTableResource s -> TF.Attr s Text)
            . TF.refValue

dynamodbGlobalTableResource :: TF.Schema TF.Resource P.AWS (DynamodbGlobalTableResource s)
dynamodbGlobalTableResource =
    TF.newResource "aws_dynamodb_global_table" $
        DynamodbGlobalTableResource {
              _name = TF.Nil
            , _replica = TF.Nil
            }

{- | The @aws_dynamodb_table_item@ AWS resource.

Provides a DynamoDB table item resource -> Note: This resource is not meant
to be used for managing large amounts of data in your table, it is not
designed to scale. You should perform regular backups of all data in the
table, see
<https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/BackupRestore.html>
.
-}
data DynamodbTableItemResource s = DynamodbTableItemResource {
      _hash_key   :: !(TF.Attr s Text)
    {- ^ (Required) Hash key to use for lookups and identification of the item -}
    , _item       :: !(TF.Attr s Text)
    {- ^ (Required) JSON representation of a map of attribute name/value pairs, one for each attribute. Only the primary key attributes are required; you can optionally provide other attribute name-value pairs for the item. -}
    , _range_key  :: !(TF.Attr s Text)
    {- ^ (Optional) Range key to use for lookups and identification of the item. Required if there is range key defined in the table. -}
    , _table_name :: !(TF.Attr s Text)
    {- ^ (Required) The name of the table to contain the item. -}
    } deriving (Show, Eq)

instance TF.ToHCL (DynamodbTableItemResource s) where
    toHCL DynamodbTableItemResource{..} = TF.inline $ catMaybes
        [ TF.assign "hash_key" <$> TF.attribute _hash_key
        , TF.assign "item" <$> TF.attribute _item
        , TF.assign "range_key" <$> TF.attribute _range_key
        , TF.assign "table_name" <$> TF.attribute _table_name
        ]

instance P.HasHashKey (DynamodbTableItemResource s) (TF.Attr s Text) where
    hashKey =
        lens (_hash_key :: DynamodbTableItemResource s -> TF.Attr s Text)
             (\s a -> s { _hash_key = a } :: DynamodbTableItemResource s)

instance P.HasItem (DynamodbTableItemResource s) (TF.Attr s Text) where
    item =
        lens (_item :: DynamodbTableItemResource s -> TF.Attr s Text)
             (\s a -> s { _item = a } :: DynamodbTableItemResource s)

instance P.HasRangeKey (DynamodbTableItemResource s) (TF.Attr s Text) where
    rangeKey =
        lens (_range_key :: DynamodbTableItemResource s -> TF.Attr s Text)
             (\s a -> s { _range_key = a } :: DynamodbTableItemResource s)

instance P.HasTableName (DynamodbTableItemResource s) (TF.Attr s Text) where
    tableName =
        lens (_table_name :: DynamodbTableItemResource s -> TF.Attr s Text)
             (\s a -> s { _table_name = a } :: DynamodbTableItemResource s)

instance P.HasComputedHashKey (DynamodbTableItemResource s) s (TF.Attr s Text) where
    computedHashKey =
        (_hash_key :: DynamodbTableItemResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedItem (DynamodbTableItemResource s) s (TF.Attr s Text) where
    computedItem =
        (_item :: DynamodbTableItemResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRangeKey (DynamodbTableItemResource s) s (TF.Attr s Text) where
    computedRangeKey =
        (_range_key :: DynamodbTableItemResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTableName (DynamodbTableItemResource s) s (TF.Attr s Text) where
    computedTableName =
        (_table_name :: DynamodbTableItemResource s -> TF.Attr s Text)
            . TF.refValue

dynamodbTableItemResource :: TF.Schema TF.Resource P.AWS (DynamodbTableItemResource s)
dynamodbTableItemResource =
    TF.newResource "aws_dynamodb_table_item" $
        DynamodbTableItemResource {
              _hash_key = TF.Nil
            , _item = TF.Nil
            , _range_key = TF.Nil
            , _table_name = TF.Nil
            }

{- | The @aws_dynamodb_table@ AWS resource.

Provides a DynamoDB table resource ~> Note: It is recommended to use
@lifecycle@  </docs/configuration/resources.html#ignore_changes> for
@read_capacity@ and/or @write_capacity@ if there's
</docs/providers/aws/r/appautoscaling_policy.html> attached to the table.
-}
data DynamodbTableResource s = DynamodbTableResource {
      _attribute              :: !(P.Maybe [P.DynamoTableAttribute])
    {- ^ (Required) Define an attribute, has two properties: -}
    , _global_secondary_index :: !(TF.Attr s Text)
    {- ^ (Optional) Describe a GSO for the table; subject to the normal limits on the number of GSIs, projected attributes, etc. -}
    , _hash_key               :: !(TF.Attr s Text)
    {- ^ (Required, Forces new resource) The attribute to use as the hash key (the attribute must also be defined as an attribute record -}
    , _local_secondary_index  :: !(TF.Attr s Text)
    {- ^ (Optional, Forces new resource) Describe an LSI on the table; these can only be allocated at creation so you cannot change this definition after you have created the resource. -}
    , _name                   :: !(TF.Attr s Text)
    {- ^ (Required) The name of the table, this needs to be unique within a region. -}
    , _range_key              :: !(TF.Attr s Text)
    {- ^ (Optional, Forces new resource) The attribute to use as the range key (must also be defined) -}
    , _read_capacity          :: !(TF.Attr s P.Natural)
    {- ^ (Required) The number of read units for this table -}
    , _stream_enabled         :: !(TF.Attr s P.Bool)
    {- ^ (Optional) Indicates whether Streams are to be enabled (true) or disabled (false). -}
    , _stream_view_type       :: !(TF.Attr s Text)
    {- ^ (Optional) When an item in the table is modified, StreamViewType determines what information is written to the table's stream. Valid values are @KEYS_ONLY@ , @NEW_IMAGE@ , @OLD_IMAGE@ , @NEW_AND_OLD_IMAGES@ . -}
    , _tags                   :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A map of tags to populate on the created table. -}
    , _ttl                    :: !(TF.Attr s Text)
    {- ^ (Optional) Defines ttl, has two properties, and can only be specified once: -}
    , _write_capacity         :: !(TF.Attr s P.Natural)
    {- ^ (Required) The number of write units for this table -}
    } deriving (Show, Eq)

instance TF.ToHCL (DynamodbTableResource s) where
    toHCL DynamodbTableResource{..} = TF.inline $ catMaybes
        [ TF.assign "attribute" <$>  _attribute
        , TF.assign "global_secondary_index" <$> TF.attribute _global_secondary_index
        , TF.assign "hash_key" <$> TF.attribute _hash_key
        , TF.assign "local_secondary_index" <$> TF.attribute _local_secondary_index
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "range_key" <$> TF.attribute _range_key
        , TF.assign "read_capacity" <$> TF.attribute _read_capacity
        , TF.assign "stream_enabled" <$> TF.attribute _stream_enabled
        , TF.assign "stream_view_type" <$> TF.attribute _stream_view_type
        , TF.assign "tags" <$> TF.attribute _tags
        , TF.assign "ttl" <$> TF.attribute _ttl
        , TF.assign "write_capacity" <$> TF.attribute _write_capacity
        ]

instance P.HasAttribute (DynamodbTableResource s) (P.Maybe [P.DynamoTableAttribute]) where
    attribute =
        lens (_attribute :: DynamodbTableResource s -> P.Maybe [P.DynamoTableAttribute])
             (\s a -> s { _attribute = a } :: DynamodbTableResource s)

instance P.HasGlobalSecondaryIndex (DynamodbTableResource s) (TF.Attr s Text) where
    globalSecondaryIndex =
        lens (_global_secondary_index :: DynamodbTableResource s -> TF.Attr s Text)
             (\s a -> s { _global_secondary_index = a } :: DynamodbTableResource s)

instance P.HasHashKey (DynamodbTableResource s) (TF.Attr s Text) where
    hashKey =
        lens (_hash_key :: DynamodbTableResource s -> TF.Attr s Text)
             (\s a -> s { _hash_key = a } :: DynamodbTableResource s)

instance P.HasLocalSecondaryIndex (DynamodbTableResource s) (TF.Attr s Text) where
    localSecondaryIndex =
        lens (_local_secondary_index :: DynamodbTableResource s -> TF.Attr s Text)
             (\s a -> s { _local_secondary_index = a } :: DynamodbTableResource s)

instance P.HasName (DynamodbTableResource s) (TF.Attr s Text) where
    name =
        lens (_name :: DynamodbTableResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: DynamodbTableResource s)

instance P.HasRangeKey (DynamodbTableResource s) (TF.Attr s Text) where
    rangeKey =
        lens (_range_key :: DynamodbTableResource s -> TF.Attr s Text)
             (\s a -> s { _range_key = a } :: DynamodbTableResource s)

instance P.HasReadCapacity (DynamodbTableResource s) (TF.Attr s P.Natural) where
    readCapacity =
        lens (_read_capacity :: DynamodbTableResource s -> TF.Attr s P.Natural)
             (\s a -> s { _read_capacity = a } :: DynamodbTableResource s)

instance P.HasStreamEnabled (DynamodbTableResource s) (TF.Attr s P.Bool) where
    streamEnabled =
        lens (_stream_enabled :: DynamodbTableResource s -> TF.Attr s P.Bool)
             (\s a -> s { _stream_enabled = a } :: DynamodbTableResource s)

instance P.HasStreamViewType (DynamodbTableResource s) (TF.Attr s Text) where
    streamViewType =
        lens (_stream_view_type :: DynamodbTableResource s -> TF.Attr s Text)
             (\s a -> s { _stream_view_type = a } :: DynamodbTableResource s)

instance P.HasTags (DynamodbTableResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: DynamodbTableResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: DynamodbTableResource s)

instance P.HasTtl (DynamodbTableResource s) (TF.Attr s Text) where
    ttl =
        lens (_ttl :: DynamodbTableResource s -> TF.Attr s Text)
             (\s a -> s { _ttl = a } :: DynamodbTableResource s)

instance P.HasWriteCapacity (DynamodbTableResource s) (TF.Attr s P.Natural) where
    writeCapacity =
        lens (_write_capacity :: DynamodbTableResource s -> TF.Attr s P.Natural)
             (\s a -> s { _write_capacity = a } :: DynamodbTableResource s)

instance P.HasComputedArn (DynamodbTableResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedAttribute (DynamodbTableResource s) s (P.Maybe [P.DynamoTableAttribute]) where
    computedAttribute =
        (_attribute :: DynamodbTableResource s -> P.Maybe [P.DynamoTableAttribute])
            . TF.refValue

instance P.HasComputedGlobalSecondaryIndex (DynamodbTableResource s) s (TF.Attr s Text) where
    computedGlobalSecondaryIndex =
        (_global_secondary_index :: DynamodbTableResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedHashKey (DynamodbTableResource s) s (TF.Attr s Text) where
    computedHashKey =
        (_hash_key :: DynamodbTableResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (DynamodbTableResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedLocalSecondaryIndex (DynamodbTableResource s) s (TF.Attr s Text) where
    computedLocalSecondaryIndex =
        (_local_secondary_index :: DynamodbTableResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (DynamodbTableResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: DynamodbTableResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRangeKey (DynamodbTableResource s) s (TF.Attr s Text) where
    computedRangeKey =
        (_range_key :: DynamodbTableResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedReadCapacity (DynamodbTableResource s) s (TF.Attr s P.Natural) where
    computedReadCapacity =
        (_read_capacity :: DynamodbTableResource s -> TF.Attr s P.Natural)
            . TF.refValue

instance P.HasComputedStreamArn (DynamodbTableResource s) s (TF.Attr s Text) where
    computedStreamArn x = TF.compute (TF.refKey x) "stream_arn"

instance P.HasComputedStreamEnabled (DynamodbTableResource s) s (TF.Attr s P.Bool) where
    computedStreamEnabled =
        (_stream_enabled :: DynamodbTableResource s -> TF.Attr s P.Bool)
            . TF.refValue

instance P.HasComputedStreamLabel (DynamodbTableResource s) s (TF.Attr s Text) where
    computedStreamLabel x = TF.compute (TF.refKey x) "stream_label"

instance P.HasComputedStreamViewType (DynamodbTableResource s) s (TF.Attr s Text) where
    computedStreamViewType =
        (_stream_view_type :: DynamodbTableResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (DynamodbTableResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: DynamodbTableResource s -> TF.Attr s P.Tags)
            . TF.refValue

instance P.HasComputedTtl (DynamodbTableResource s) s (TF.Attr s Text) where
    computedTtl =
        (_ttl :: DynamodbTableResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedWriteCapacity (DynamodbTableResource s) s (TF.Attr s P.Natural) where
    computedWriteCapacity =
        (_write_capacity :: DynamodbTableResource s -> TF.Attr s P.Natural)
            . TF.refValue

dynamodbTableResource :: TF.Schema TF.Resource P.AWS (DynamodbTableResource s)
dynamodbTableResource =
    TF.newResource "aws_dynamodb_table" $
        DynamodbTableResource {
              _attribute = P.Nothing
            , _global_secondary_index = TF.Nil
            , _hash_key = TF.Nil
            , _local_secondary_index = TF.Nil
            , _name = TF.Nil
            , _range_key = TF.Nil
            , _read_capacity = TF.Nil
            , _stream_enabled = TF.Nil
            , _stream_view_type = TF.Nil
            , _tags = TF.Nil
            , _ttl = TF.Nil
            , _write_capacity = TF.Nil
            }

{- | The @aws_ebs_snapshot@ AWS resource.

Creates a Snapshot of an EBS Volume.
-}
data EbsSnapshotResource s = EbsSnapshotResource {
      _description :: !(TF.Attr s Text)
    {- ^ (Optional) A description of what the snapshot is. -}
    , _tags        :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the snapshot -}
    , _volume_id   :: !(TF.Attr s Text)
    {- ^ (Required) The Volume ID of which to make a snapshot. -}
    } deriving (Show, Eq)

instance TF.ToHCL (EbsSnapshotResource s) where
    toHCL EbsSnapshotResource{..} = TF.inline $ catMaybes
        [ TF.assign "description" <$> TF.attribute _description
        , TF.assign "tags" <$> TF.attribute _tags
        , TF.assign "volume_id" <$> TF.attribute _volume_id
        ]

instance P.HasDescription (EbsSnapshotResource s) (TF.Attr s Text) where
    description =
        lens (_description :: EbsSnapshotResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: EbsSnapshotResource s)

instance P.HasTags (EbsSnapshotResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: EbsSnapshotResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: EbsSnapshotResource s)

instance P.HasVolumeId (EbsSnapshotResource s) (TF.Attr s Text) where
    volumeId =
        lens (_volume_id :: EbsSnapshotResource s -> TF.Attr s Text)
             (\s a -> s { _volume_id = a } :: EbsSnapshotResource s)

instance P.HasComputedDataEncryptionKeyId (EbsSnapshotResource s) s (TF.Attr s Text) where
    computedDataEncryptionKeyId x = TF.compute (TF.refKey x) "data_encryption_key_id"

instance P.HasComputedDescription (EbsSnapshotResource s) s (TF.Attr s Text) where
    computedDescription =
        (_description :: EbsSnapshotResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEncrypted (EbsSnapshotResource s) s (TF.Attr s Text) where
    computedEncrypted x = TF.compute (TF.refKey x) "encrypted"

instance P.HasComputedId (EbsSnapshotResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedKmsKeyId (EbsSnapshotResource s) s (TF.Attr s Text) where
    computedKmsKeyId x = TF.compute (TF.refKey x) "kms_key_id"

instance P.HasComputedOwnerAlias (EbsSnapshotResource s) s (TF.Attr s Text) where
    computedOwnerAlias x = TF.compute (TF.refKey x) "owner_alias"

instance P.HasComputedOwnerId (EbsSnapshotResource s) s (TF.Attr s Text) where
    computedOwnerId x = TF.compute (TF.refKey x) "owner_id"

instance P.HasComputedTags (EbsSnapshotResource s) s (TF.Attr s P.Tags) where
    computedTags x = TF.compute (TF.refKey x) "tags"

instance P.HasComputedVolumeId (EbsSnapshotResource s) s (TF.Attr s Text) where
    computedVolumeId =
        (_volume_id :: EbsSnapshotResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedVolumeSize (EbsSnapshotResource s) s (TF.Attr s Text) where
    computedVolumeSize x = TF.compute (TF.refKey x) "volume_size"

ebsSnapshotResource :: TF.Schema TF.Resource P.AWS (EbsSnapshotResource s)
ebsSnapshotResource =
    TF.newResource "aws_ebs_snapshot" $
        EbsSnapshotResource {
              _description = TF.Nil
            , _tags = TF.Nil
            , _volume_id = TF.Nil
            }

{- | The @aws_ebs_volume@ AWS resource.

Manages a single EBS volume.
-}
data EbsVolumeResource s = EbsVolumeResource {
      _availability_zone :: !(TF.Attr s P.Zone)
    {- ^ (Required) The AZ where the EBS volume will exist. -}
    , _encrypted         :: !(TF.Attr s Text)
    {- ^ (Optional) If true, the disk will be encrypted. -}
    , _iops              :: !(TF.Attr s Text)
    {- ^ (Optional) The amount of IOPS to provision for the disk. -}
    , _kms_key_id        :: !(TF.Attr s Text)
    {- ^ (Optional) The ARN for the KMS encryption key. When specifying @kms_key_id@ , @encrypted@ needs to be set to true. -}
    , _size              :: !(TF.Attr s Text)
    {- ^ (Optional) The size of the drive in GiBs. -}
    , _snapshot_id       :: !(TF.Attr s Text)
    {- ^ (Optional) A snapshot to base the EBS volume off of. -}
    , _tags              :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    , _type'             :: !(TF.Attr s Text)
    {- ^ (Optional) The type of EBS volume. Can be "standard", "gp2", "io1", "sc1" or "st1" (Default: "standard"). -}
    } deriving (Show, Eq)

instance TF.ToHCL (EbsVolumeResource s) where
    toHCL EbsVolumeResource{..} = TF.inline $ catMaybes
        [ TF.assign "availability_zone" <$> TF.attribute _availability_zone
        , TF.assign "encrypted" <$> TF.attribute _encrypted
        , TF.assign "iops" <$> TF.attribute _iops
        , TF.assign "kms_key_id" <$> TF.attribute _kms_key_id
        , TF.assign "size" <$> TF.attribute _size
        , TF.assign "snapshot_id" <$> TF.attribute _snapshot_id
        , TF.assign "tags" <$> TF.attribute _tags
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance P.HasAvailabilityZone (EbsVolumeResource s) (TF.Attr s P.Zone) where
    availabilityZone =
        lens (_availability_zone :: EbsVolumeResource s -> TF.Attr s P.Zone)
             (\s a -> s { _availability_zone = a } :: EbsVolumeResource s)

instance P.HasEncrypted (EbsVolumeResource s) (TF.Attr s Text) where
    encrypted =
        lens (_encrypted :: EbsVolumeResource s -> TF.Attr s Text)
             (\s a -> s { _encrypted = a } :: EbsVolumeResource s)

instance P.HasIops (EbsVolumeResource s) (TF.Attr s Text) where
    iops =
        lens (_iops :: EbsVolumeResource s -> TF.Attr s Text)
             (\s a -> s { _iops = a } :: EbsVolumeResource s)

instance P.HasKmsKeyId (EbsVolumeResource s) (TF.Attr s Text) where
    kmsKeyId =
        lens (_kms_key_id :: EbsVolumeResource s -> TF.Attr s Text)
             (\s a -> s { _kms_key_id = a } :: EbsVolumeResource s)

instance P.HasSize (EbsVolumeResource s) (TF.Attr s Text) where
    size =
        lens (_size :: EbsVolumeResource s -> TF.Attr s Text)
             (\s a -> s { _size = a } :: EbsVolumeResource s)

instance P.HasSnapshotId (EbsVolumeResource s) (TF.Attr s Text) where
    snapshotId =
        lens (_snapshot_id :: EbsVolumeResource s -> TF.Attr s Text)
             (\s a -> s { _snapshot_id = a } :: EbsVolumeResource s)

instance P.HasTags (EbsVolumeResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: EbsVolumeResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: EbsVolumeResource s)

instance P.HasType' (EbsVolumeResource s) (TF.Attr s Text) where
    type' =
        lens (_type' :: EbsVolumeResource s -> TF.Attr s Text)
             (\s a -> s { _type' = a } :: EbsVolumeResource s)

instance P.HasComputedArn (EbsVolumeResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedAvailabilityZone (EbsVolumeResource s) s (TF.Attr s P.Zone) where
    computedAvailabilityZone =
        (_availability_zone :: EbsVolumeResource s -> TF.Attr s P.Zone)
            . TF.refValue

instance P.HasComputedEncrypted (EbsVolumeResource s) s (TF.Attr s Text) where
    computedEncrypted =
        (_encrypted :: EbsVolumeResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (EbsVolumeResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedIops (EbsVolumeResource s) s (TF.Attr s Text) where
    computedIops =
        (_iops :: EbsVolumeResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedKmsKeyId (EbsVolumeResource s) s (TF.Attr s Text) where
    computedKmsKeyId =
        (_kms_key_id :: EbsVolumeResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSize (EbsVolumeResource s) s (TF.Attr s Text) where
    computedSize =
        (_size :: EbsVolumeResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSnapshotId (EbsVolumeResource s) s (TF.Attr s Text) where
    computedSnapshotId =
        (_snapshot_id :: EbsVolumeResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (EbsVolumeResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: EbsVolumeResource s -> TF.Attr s P.Tags)
            . TF.refValue

instance P.HasComputedType' (EbsVolumeResource s) s (TF.Attr s Text) where
    computedType' =
        (_type' :: EbsVolumeResource s -> TF.Attr s Text)
            . TF.refValue

ebsVolumeResource :: TF.Schema TF.Resource P.AWS (EbsVolumeResource s)
ebsVolumeResource =
    TF.newResource "aws_ebs_volume" $
        EbsVolumeResource {
              _availability_zone = TF.Nil
            , _encrypted = TF.Nil
            , _iops = TF.Nil
            , _kms_key_id = TF.Nil
            , _size = TF.Nil
            , _snapshot_id = TF.Nil
            , _tags = TF.Nil
            , _type' = TF.Nil
            }

{- | The @aws_ecr_lifecycle_policy@ AWS resource.

Provides an ECR lifecycle policy.
-}
data EcrLifecyclePolicyResource s = EcrLifecyclePolicyResource {
      _policy     :: !(TF.Attr s Text)
    {- ^ (Required) The policy document. This is a JSON formatted string. See more details about <http://docs.aws.amazon.com/ja_jp/AmazonECR/latest/userguide/LifecyclePolicies.html#lifecycle_policy_parameters> in the official AWS docs. -}
    , _repository :: !(TF.Attr s Text)
    {- ^ (Required) Name of the repository to apply the policy. -}
    } deriving (Show, Eq)

instance TF.ToHCL (EcrLifecyclePolicyResource s) where
    toHCL EcrLifecyclePolicyResource{..} = TF.inline $ catMaybes
        [ TF.assign "policy" <$> TF.attribute _policy
        , TF.assign "repository" <$> TF.attribute _repository
        ]

instance P.HasPolicy (EcrLifecyclePolicyResource s) (TF.Attr s Text) where
    policy =
        lens (_policy :: EcrLifecyclePolicyResource s -> TF.Attr s Text)
             (\s a -> s { _policy = a } :: EcrLifecyclePolicyResource s)

instance P.HasRepository (EcrLifecyclePolicyResource s) (TF.Attr s Text) where
    repository =
        lens (_repository :: EcrLifecyclePolicyResource s -> TF.Attr s Text)
             (\s a -> s { _repository = a } :: EcrLifecyclePolicyResource s)

instance P.HasComputedPolicy (EcrLifecyclePolicyResource s) s (TF.Attr s Text) where
    computedPolicy =
        (_policy :: EcrLifecyclePolicyResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRegistryId (EcrLifecyclePolicyResource s) s (TF.Attr s Text) where
    computedRegistryId x = TF.compute (TF.refKey x) "registry_id"

instance P.HasComputedRepository (EcrLifecyclePolicyResource s) s (TF.Attr s Text) where
    computedRepository x = TF.compute (TF.refKey x) "repository"

ecrLifecyclePolicyResource :: TF.Schema TF.Resource P.AWS (EcrLifecyclePolicyResource s)
ecrLifecyclePolicyResource =
    TF.newResource "aws_ecr_lifecycle_policy" $
        EcrLifecyclePolicyResource {
              _policy = TF.Nil
            , _repository = TF.Nil
            }

{- | The @aws_ecr_repository_policy@ AWS resource.

Provides an ECR repository policy. Note that currently only one policy may
be applied to a repository. ~> NOTE on ECR Availability : The EC2 Container
Registry is not yet rolled out in all regions - available regions are listed
<https://docs.aws.amazon.com/general/latest/gr/rande.html#ecr_region> .
-}
data EcrRepositoryPolicyResource s = EcrRepositoryPolicyResource {
      _policy     :: !(TF.Attr s Text)
    {- ^ (Required) The policy document. This is a JSON formatted string. -}
    , _repository :: !(TF.Attr s Text)
    {- ^ (Required) Name of the repository to apply the policy. -}
    } deriving (Show, Eq)

instance TF.ToHCL (EcrRepositoryPolicyResource s) where
    toHCL EcrRepositoryPolicyResource{..} = TF.inline $ catMaybes
        [ TF.assign "policy" <$> TF.attribute _policy
        , TF.assign "repository" <$> TF.attribute _repository
        ]

instance P.HasPolicy (EcrRepositoryPolicyResource s) (TF.Attr s Text) where
    policy =
        lens (_policy :: EcrRepositoryPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _policy = a } :: EcrRepositoryPolicyResource s)

instance P.HasRepository (EcrRepositoryPolicyResource s) (TF.Attr s Text) where
    repository =
        lens (_repository :: EcrRepositoryPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _repository = a } :: EcrRepositoryPolicyResource s)

instance P.HasComputedPolicy (EcrRepositoryPolicyResource s) s (TF.Attr s Text) where
    computedPolicy =
        (_policy :: EcrRepositoryPolicyResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRegistryId (EcrRepositoryPolicyResource s) s (TF.Attr s Text) where
    computedRegistryId x = TF.compute (TF.refKey x) "registry_id"

instance P.HasComputedRepository (EcrRepositoryPolicyResource s) s (TF.Attr s Text) where
    computedRepository x = TF.compute (TF.refKey x) "repository"

ecrRepositoryPolicyResource :: TF.Schema TF.Resource P.AWS (EcrRepositoryPolicyResource s)
ecrRepositoryPolicyResource =
    TF.newResource "aws_ecr_repository_policy" $
        EcrRepositoryPolicyResource {
              _policy = TF.Nil
            , _repository = TF.Nil
            }

{- | The @aws_ecr_repository@ AWS resource.

Provides an EC2 Container Registry Repository. ~> NOTE on ECR Availability :
The EC2 Container Registry is not yet rolled out in all regions - available
regions are listed
<https://docs.aws.amazon.com/general/latest/gr/rande.html#ecr_region> .
-}
data EcrRepositoryResource s = EcrRepositoryResource {
      _name :: !(TF.Attr s Text)
    {- ^ (Required) Name of the repository. -}
    } deriving (Show, Eq)

instance TF.ToHCL (EcrRepositoryResource s) where
    toHCL EcrRepositoryResource{..} = TF.inline $ catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        ]

instance P.HasName (EcrRepositoryResource s) (TF.Attr s Text) where
    name =
        lens (_name :: EcrRepositoryResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: EcrRepositoryResource s)

instance P.HasComputedArn (EcrRepositoryResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedName (EcrRepositoryResource s) s (TF.Attr s Text) where
    computedName x = TF.compute (TF.refKey x) "name"

instance P.HasComputedRegistryId (EcrRepositoryResource s) s (TF.Attr s Text) where
    computedRegistryId x = TF.compute (TF.refKey x) "registry_id"

instance P.HasComputedRepositoryUrl (EcrRepositoryResource s) s (TF.Attr s Text) where
    computedRepositoryUrl x = TF.compute (TF.refKey x) "repository_url"

ecrRepositoryResource :: TF.Schema TF.Resource P.AWS (EcrRepositoryResource s)
ecrRepositoryResource =
    TF.newResource "aws_ecr_repository" $
        EcrRepositoryResource {
              _name = TF.Nil
            }

{- | The @aws_ecs_cluster@ AWS resource.

Provides an ECS cluster.
-}
data EcsClusterResource s = EcsClusterResource {
      _name :: !(TF.Attr s Text)
    {- ^ (Required) The name of the cluster (up to 255 letters, numbers, hyphens, and underscores) -}
    } deriving (Show, Eq)

instance TF.ToHCL (EcsClusterResource s) where
    toHCL EcsClusterResource{..} = TF.inline $ catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        ]

instance P.HasName (EcsClusterResource s) (TF.Attr s Text) where
    name =
        lens (_name :: EcsClusterResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: EcsClusterResource s)

instance P.HasComputedArn (EcsClusterResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedId (EcsClusterResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (EcsClusterResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: EcsClusterResource s -> TF.Attr s Text)
            . TF.refValue

ecsClusterResource :: TF.Schema TF.Resource P.AWS (EcsClusterResource s)
ecsClusterResource =
    TF.newResource "aws_ecs_cluster" $
        EcsClusterResource {
              _name = TF.Nil
            }

{- | The @aws_ecs_service@ AWS resource.

-> Note: To prevent a race condition during service deletion, make sure to
set @depends_on@ to the related @aws_iam_role_policy@ ; otherwise, the
policy may be destroyed too soon and the ECS service will then get stuck in
the @DRAINING@ state. Provides an ECS service - effectively a task that is
expected to run until an error occurs or a user terminates it (typically a
webserver or a database). See
<https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs_services.html>
.
-}
data EcsServiceResource s = EcsServiceResource {
      _cluster                            :: !(TF.Attr s Text)
    {- ^ (Optional) ARN of an ECS cluster -}
    , _deployment_maximum_percent         :: !(TF.Attr s Text)
    {- ^ (Optional) The upper limit (as a percentage of the service's desiredCount) of the number of running tasks that can be running in a service during a deployment. -}
    , _deployment_minimum_healthy_percent :: !(TF.Attr s Text)
    {- ^ (Optional) The lower limit (as a percentage of the service's desiredCount) of the number of running tasks that must remain running and healthy in a service during a deployment. -}
    , _desired_count                      :: !(TF.Attr s Text)
    {- ^ (Required) The number of instances of the task definition to place and keep running -}
    , _health_check_grace_period_seconds  :: !(TF.Attr s Text)
    {- ^ (Optional) Seconds to ignore failing load balancer health checks on newly instantiated tasks to prevent premature shutdown, up to 1800. Only valid for services configured to use load balancers. -}
    , _iam_role                           :: !(TF.Attr s Text)
    {- ^ (Optional) The ARN of IAM role that allows your Amazon ECS container agent to make calls to your load balancer on your behalf. This parameter is only required if you are using a load balancer with your service. -}
    , _launch_type                        :: !(TF.Attr s Text)
    {- ^ (Optional) The launch type on which to run your service. The valid values are @EC2@ and @FARGATE@ . Defaults to @EC2@ . -}
    , _load_balancer                      :: !(TF.Attr s Text)
    {- ^ (Optional) A load balancer block. Load balancers documented below. -}
    , _name                               :: !(TF.Attr s Text)
    {- ^ (Required) The name of the service (up to 255 letters, numbers, hyphens, and underscores) -}
    , _network_configuration              :: !(TF.Attr s Text)
    {- ^ (Optional) The network configuration for the service. This parameter is required for task definitions that use the awsvpc network mode to receive their own Elastic Network Interface, and it is not supported for other network modes. -}
    , _placement_constraints              :: !(TF.Attr s Text)
    {- ^ (Optional) rules that are taken into consideration during task placement. Maximum number of @placement_constraints@ is @10@ . Defined below. -}
    , _placement_strategy                 :: !(TF.Attr s Text)
    {- ^ (Optional) Service level strategy rules that are taken into consideration during task placement. The maximum number of @placement_strategy@ blocks is @5@ . Defined below. -}
    , _task_definition                    :: !(TF.Attr s Text)
    {- ^ (Required) The family and revision ( @family:revision@ ) or full ARN of the task definition that you want to run in your service. -}
    } deriving (Show, Eq)

instance TF.ToHCL (EcsServiceResource s) where
    toHCL EcsServiceResource{..} = TF.inline $ catMaybes
        [ TF.assign "cluster" <$> TF.attribute _cluster
        , TF.assign "deployment_maximum_percent" <$> TF.attribute _deployment_maximum_percent
        , TF.assign "deployment_minimum_healthy_percent" <$> TF.attribute _deployment_minimum_healthy_percent
        , TF.assign "desired_count" <$> TF.attribute _desired_count
        , TF.assign "health_check_grace_period_seconds" <$> TF.attribute _health_check_grace_period_seconds
        , TF.assign "iam_role" <$> TF.attribute _iam_role
        , TF.assign "launch_type" <$> TF.attribute _launch_type
        , TF.assign "load_balancer" <$> TF.attribute _load_balancer
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "network_configuration" <$> TF.attribute _network_configuration
        , TF.assign "placement_constraints" <$> TF.attribute _placement_constraints
        , TF.assign "placement_strategy" <$> TF.attribute _placement_strategy
        , TF.assign "task_definition" <$> TF.attribute _task_definition
        ]

instance P.HasCluster (EcsServiceResource s) (TF.Attr s Text) where
    cluster =
        lens (_cluster :: EcsServiceResource s -> TF.Attr s Text)
             (\s a -> s { _cluster = a } :: EcsServiceResource s)

instance P.HasDeploymentMaximumPercent (EcsServiceResource s) (TF.Attr s Text) where
    deploymentMaximumPercent =
        lens (_deployment_maximum_percent :: EcsServiceResource s -> TF.Attr s Text)
             (\s a -> s { _deployment_maximum_percent = a } :: EcsServiceResource s)

instance P.HasDeploymentMinimumHealthyPercent (EcsServiceResource s) (TF.Attr s Text) where
    deploymentMinimumHealthyPercent =
        lens (_deployment_minimum_healthy_percent :: EcsServiceResource s -> TF.Attr s Text)
             (\s a -> s { _deployment_minimum_healthy_percent = a } :: EcsServiceResource s)

instance P.HasDesiredCount (EcsServiceResource s) (TF.Attr s Text) where
    desiredCount =
        lens (_desired_count :: EcsServiceResource s -> TF.Attr s Text)
             (\s a -> s { _desired_count = a } :: EcsServiceResource s)

instance P.HasHealthCheckGracePeriodSeconds (EcsServiceResource s) (TF.Attr s Text) where
    healthCheckGracePeriodSeconds =
        lens (_health_check_grace_period_seconds :: EcsServiceResource s -> TF.Attr s Text)
             (\s a -> s { _health_check_grace_period_seconds = a } :: EcsServiceResource s)

instance P.HasIamRole (EcsServiceResource s) (TF.Attr s Text) where
    iamRole =
        lens (_iam_role :: EcsServiceResource s -> TF.Attr s Text)
             (\s a -> s { _iam_role = a } :: EcsServiceResource s)

instance P.HasLaunchType (EcsServiceResource s) (TF.Attr s Text) where
    launchType =
        lens (_launch_type :: EcsServiceResource s -> TF.Attr s Text)
             (\s a -> s { _launch_type = a } :: EcsServiceResource s)

instance P.HasLoadBalancer (EcsServiceResource s) (TF.Attr s Text) where
    loadBalancer =
        lens (_load_balancer :: EcsServiceResource s -> TF.Attr s Text)
             (\s a -> s { _load_balancer = a } :: EcsServiceResource s)

instance P.HasName (EcsServiceResource s) (TF.Attr s Text) where
    name =
        lens (_name :: EcsServiceResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: EcsServiceResource s)

instance P.HasNetworkConfiguration (EcsServiceResource s) (TF.Attr s Text) where
    networkConfiguration =
        lens (_network_configuration :: EcsServiceResource s -> TF.Attr s Text)
             (\s a -> s { _network_configuration = a } :: EcsServiceResource s)

instance P.HasPlacementConstraints (EcsServiceResource s) (TF.Attr s Text) where
    placementConstraints =
        lens (_placement_constraints :: EcsServiceResource s -> TF.Attr s Text)
             (\s a -> s { _placement_constraints = a } :: EcsServiceResource s)

instance P.HasPlacementStrategy (EcsServiceResource s) (TF.Attr s Text) where
    placementStrategy =
        lens (_placement_strategy :: EcsServiceResource s -> TF.Attr s Text)
             (\s a -> s { _placement_strategy = a } :: EcsServiceResource s)

instance P.HasTaskDefinition (EcsServiceResource s) (TF.Attr s Text) where
    taskDefinition =
        lens (_task_definition :: EcsServiceResource s -> TF.Attr s Text)
             (\s a -> s { _task_definition = a } :: EcsServiceResource s)

instance P.HasComputedCluster (EcsServiceResource s) s (TF.Attr s Text) where
    computedCluster x = TF.compute (TF.refKey x) "cluster"

instance P.HasComputedDeploymentMaximumPercent (EcsServiceResource s) s (TF.Attr s Text) where
    computedDeploymentMaximumPercent =
        (_deployment_maximum_percent :: EcsServiceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDeploymentMinimumHealthyPercent (EcsServiceResource s) s (TF.Attr s Text) where
    computedDeploymentMinimumHealthyPercent =
        (_deployment_minimum_healthy_percent :: EcsServiceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDesiredCount (EcsServiceResource s) s (TF.Attr s Text) where
    computedDesiredCount x = TF.compute (TF.refKey x) "desired_count"

instance P.HasComputedHealthCheckGracePeriodSeconds (EcsServiceResource s) s (TF.Attr s Text) where
    computedHealthCheckGracePeriodSeconds =
        (_health_check_grace_period_seconds :: EcsServiceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedIamRole (EcsServiceResource s) s (TF.Attr s Text) where
    computedIamRole x = TF.compute (TF.refKey x) "iam_role"

instance P.HasComputedId (EcsServiceResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedLaunchType (EcsServiceResource s) s (TF.Attr s Text) where
    computedLaunchType =
        (_launch_type :: EcsServiceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedLoadBalancer (EcsServiceResource s) s (TF.Attr s Text) where
    computedLoadBalancer =
        (_load_balancer :: EcsServiceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (EcsServiceResource s) s (TF.Attr s Text) where
    computedName x = TF.compute (TF.refKey x) "name"

instance P.HasComputedNetworkConfiguration (EcsServiceResource s) s (TF.Attr s Text) where
    computedNetworkConfiguration =
        (_network_configuration :: EcsServiceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPlacementConstraints (EcsServiceResource s) s (TF.Attr s Text) where
    computedPlacementConstraints =
        (_placement_constraints :: EcsServiceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPlacementStrategy (EcsServiceResource s) s (TF.Attr s Text) where
    computedPlacementStrategy =
        (_placement_strategy :: EcsServiceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTaskDefinition (EcsServiceResource s) s (TF.Attr s Text) where
    computedTaskDefinition =
        (_task_definition :: EcsServiceResource s -> TF.Attr s Text)
            . TF.refValue

ecsServiceResource :: TF.Schema TF.Resource P.AWS (EcsServiceResource s)
ecsServiceResource =
    TF.newResource "aws_ecs_service" $
        EcsServiceResource {
              _cluster = TF.Nil
            , _deployment_maximum_percent = TF.Nil
            , _deployment_minimum_healthy_percent = TF.Nil
            , _desired_count = TF.Nil
            , _health_check_grace_period_seconds = TF.Nil
            , _iam_role = TF.Nil
            , _launch_type = TF.Nil
            , _load_balancer = TF.Nil
            , _name = TF.Nil
            , _network_configuration = TF.Nil
            , _placement_constraints = TF.Nil
            , _placement_strategy = TF.Nil
            , _task_definition = TF.Nil
            }

{- | The @aws_ecs_task_definition@ AWS resource.

Provides an ECS task definition to be used in @aws_ecs_service@ .
-}
data EcsTaskDefinitionResource s = EcsTaskDefinitionResource {
      _container_definitions :: !(TF.Attr s Text)
    {- ^ (Required) A list of valid [container definitions] (http://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html) provided as a single valid JSON document. Please note that you should only provide values that are part of the container definition document. For a detailed description of what parameters are available, see the [Task Definition Parameters] (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definition_parameters.html) section from the official <https://docs.aws.amazon.com/AmazonECS/latest/developerguide> . -}
    , _family'               :: !(TF.Attr s Text)
    {- ^ (Required) A unique name for your task definition. -}
    } deriving (Show, Eq)

instance TF.ToHCL (EcsTaskDefinitionResource s) where
    toHCL EcsTaskDefinitionResource{..} = TF.inline $ catMaybes
        [ TF.assign "container_definitions" <$> TF.attribute _container_definitions
        , TF.assign "family" <$> TF.attribute _family'
        ]

instance P.HasContainerDefinitions (EcsTaskDefinitionResource s) (TF.Attr s Text) where
    containerDefinitions =
        lens (_container_definitions :: EcsTaskDefinitionResource s -> TF.Attr s Text)
             (\s a -> s { _container_definitions = a } :: EcsTaskDefinitionResource s)

instance P.HasFamily' (EcsTaskDefinitionResource s) (TF.Attr s Text) where
    family' =
        lens (_family' :: EcsTaskDefinitionResource s -> TF.Attr s Text)
             (\s a -> s { _family' = a } :: EcsTaskDefinitionResource s)

instance P.HasComputedArn (EcsTaskDefinitionResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedContainerDefinitions (EcsTaskDefinitionResource s) s (TF.Attr s Text) where
    computedContainerDefinitions =
        (_container_definitions :: EcsTaskDefinitionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedFamily' (EcsTaskDefinitionResource s) s (TF.Attr s Text) where
    computedFamily' x = TF.compute (TF.refKey x) "family"

instance P.HasComputedRevision (EcsTaskDefinitionResource s) s (TF.Attr s Text) where
    computedRevision x = TF.compute (TF.refKey x) "revision"

ecsTaskDefinitionResource :: TF.Schema TF.Resource P.AWS (EcsTaskDefinitionResource s)
ecsTaskDefinitionResource =
    TF.newResource "aws_ecs_task_definition" $
        EcsTaskDefinitionResource {
              _container_definitions = TF.Nil
            , _family' = TF.Nil
            }

{- | The @aws_efs_file_system@ AWS resource.

Provides an Elastic File System (EFS) resource.
-}
data EfsFileSystemResource s = EfsFileSystemResource {
      _creation_token   :: !(TF.Attr s Text)
    {- ^ (Optional) A unique name (a maximum of 64 characters are allowed) used as reference when creating the Elastic File System to ensure idempotent file system creation. By default generated by Terraform. See [Elastic File System] (http://docs.aws.amazon.com/efs/latest/ug/) user guide for more information. -}
    , _encrypted        :: !(TF.Attr s Text)
    {- ^ (Optional) If true, the disk will be encrypted. -}
    , _kms_key_id       :: !(TF.Attr s Text)
    {- ^ (Optional) The ARN for the KMS encryption key. When specifying kms_key_id, encrypted needs to be set to true. -}
    , _performance_mode :: !(TF.Attr s Text)
    {- ^ (Optional) The file system performance mode. Can be either @"generalPurpose"@ or @"maxIO"@ (Default: @"generalPurpose"@ ). -}
    , _reference_name   :: !(TF.Attr s Text)
    {- ^ - DEPRECATED (Optional) A reference name used when creating the @Creation Token@ which Amazon EFS uses to ensure idempotent file system creation. By default generated by Terraform. -}
    , _tags             :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the file system. -}
    } deriving (Show, Eq)

instance TF.ToHCL (EfsFileSystemResource s) where
    toHCL EfsFileSystemResource{..} = TF.inline $ catMaybes
        [ TF.assign "creation_token" <$> TF.attribute _creation_token
        , TF.assign "encrypted" <$> TF.attribute _encrypted
        , TF.assign "kms_key_id" <$> TF.attribute _kms_key_id
        , TF.assign "performance_mode" <$> TF.attribute _performance_mode
        , TF.assign "reference_name" <$> TF.attribute _reference_name
        , TF.assign "tags" <$> TF.attribute _tags
        ]

instance P.HasCreationToken (EfsFileSystemResource s) (TF.Attr s Text) where
    creationToken =
        lens (_creation_token :: EfsFileSystemResource s -> TF.Attr s Text)
             (\s a -> s { _creation_token = a } :: EfsFileSystemResource s)

instance P.HasEncrypted (EfsFileSystemResource s) (TF.Attr s Text) where
    encrypted =
        lens (_encrypted :: EfsFileSystemResource s -> TF.Attr s Text)
             (\s a -> s { _encrypted = a } :: EfsFileSystemResource s)

instance P.HasKmsKeyId (EfsFileSystemResource s) (TF.Attr s Text) where
    kmsKeyId =
        lens (_kms_key_id :: EfsFileSystemResource s -> TF.Attr s Text)
             (\s a -> s { _kms_key_id = a } :: EfsFileSystemResource s)

instance P.HasPerformanceMode (EfsFileSystemResource s) (TF.Attr s Text) where
    performanceMode =
        lens (_performance_mode :: EfsFileSystemResource s -> TF.Attr s Text)
             (\s a -> s { _performance_mode = a } :: EfsFileSystemResource s)

instance P.HasReferenceName (EfsFileSystemResource s) (TF.Attr s Text) where
    referenceName =
        lens (_reference_name :: EfsFileSystemResource s -> TF.Attr s Text)
             (\s a -> s { _reference_name = a } :: EfsFileSystemResource s)

instance P.HasTags (EfsFileSystemResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: EfsFileSystemResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: EfsFileSystemResource s)

instance P.HasComputedCreationToken (EfsFileSystemResource s) s (TF.Attr s Text) where
    computedCreationToken =
        (_creation_token :: EfsFileSystemResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDnsName (EfsFileSystemResource s) s (TF.Attr s Text) where
    computedDnsName x = TF.compute (TF.refKey x) "dns_name"

instance P.HasComputedEncrypted (EfsFileSystemResource s) s (TF.Attr s Text) where
    computedEncrypted =
        (_encrypted :: EfsFileSystemResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (EfsFileSystemResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedKmsKeyId (EfsFileSystemResource s) s (TF.Attr s Text) where
    computedKmsKeyId x = TF.compute (TF.refKey x) "kms_key_id"

instance P.HasComputedPerformanceMode (EfsFileSystemResource s) s (TF.Attr s Text) where
    computedPerformanceMode =
        (_performance_mode :: EfsFileSystemResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedReferenceName (EfsFileSystemResource s) s (TF.Attr s Text) where
    computedReferenceName =
        (_reference_name :: EfsFileSystemResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (EfsFileSystemResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: EfsFileSystemResource s -> TF.Attr s P.Tags)
            . TF.refValue

efsFileSystemResource :: TF.Schema TF.Resource P.AWS (EfsFileSystemResource s)
efsFileSystemResource =
    TF.newResource "aws_efs_file_system" $
        EfsFileSystemResource {
              _creation_token = TF.Nil
            , _encrypted = TF.Nil
            , _kms_key_id = TF.Nil
            , _performance_mode = TF.Nil
            , _reference_name = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_efs_mount_target@ AWS resource.

Provides an Elastic File System (EFS) mount target.
-}
data EfsMountTargetResource s = EfsMountTargetResource {
      _file_system_id  :: !(TF.Attr s Text)
    {- ^ (Required) The ID of the file system for which the mount target is intended. -}
    , _ip_address      :: !(TF.Attr s Text)
    {- ^ (Optional) The address (within the address range of the specified subnet) at which the file system may be mounted via the mount target. -}
    , _security_groups :: !(TF.Attr s Text)
    {- ^ (Optional) A list of up to 5 VPC security group IDs (that must be for the same VPC as subnet specified) in effect for the mount target. -}
    , _subnet_id       :: !(TF.Attr s Text)
    {- ^ (Required) The ID of the subnet to add the mount target in. -}
    } deriving (Show, Eq)

instance TF.ToHCL (EfsMountTargetResource s) where
    toHCL EfsMountTargetResource{..} = TF.inline $ catMaybes
        [ TF.assign "file_system_id" <$> TF.attribute _file_system_id
        , TF.assign "ip_address" <$> TF.attribute _ip_address
        , TF.assign "security_groups" <$> TF.attribute _security_groups
        , TF.assign "subnet_id" <$> TF.attribute _subnet_id
        ]

instance P.HasFileSystemId (EfsMountTargetResource s) (TF.Attr s Text) where
    fileSystemId =
        lens (_file_system_id :: EfsMountTargetResource s -> TF.Attr s Text)
             (\s a -> s { _file_system_id = a } :: EfsMountTargetResource s)

instance P.HasIpAddress (EfsMountTargetResource s) (TF.Attr s Text) where
    ipAddress =
        lens (_ip_address :: EfsMountTargetResource s -> TF.Attr s Text)
             (\s a -> s { _ip_address = a } :: EfsMountTargetResource s)

instance P.HasSecurityGroups (EfsMountTargetResource s) (TF.Attr s Text) where
    securityGroups =
        lens (_security_groups :: EfsMountTargetResource s -> TF.Attr s Text)
             (\s a -> s { _security_groups = a } :: EfsMountTargetResource s)

instance P.HasSubnetId (EfsMountTargetResource s) (TF.Attr s Text) where
    subnetId =
        lens (_subnet_id :: EfsMountTargetResource s -> TF.Attr s Text)
             (\s a -> s { _subnet_id = a } :: EfsMountTargetResource s)

instance P.HasComputedDnsName (EfsMountTargetResource s) s (TF.Attr s Text) where
    computedDnsName x = TF.compute (TF.refKey x) "dns_name"

instance P.HasComputedFileSystemId (EfsMountTargetResource s) s (TF.Attr s Text) where
    computedFileSystemId =
        (_file_system_id :: EfsMountTargetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (EfsMountTargetResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedIpAddress (EfsMountTargetResource s) s (TF.Attr s Text) where
    computedIpAddress =
        (_ip_address :: EfsMountTargetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedNetworkInterfaceId (EfsMountTargetResource s) s (TF.Attr s Text) where
    computedNetworkInterfaceId x = TF.compute (TF.refKey x) "network_interface_id"

instance P.HasComputedSecurityGroups (EfsMountTargetResource s) s (TF.Attr s Text) where
    computedSecurityGroups =
        (_security_groups :: EfsMountTargetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSubnetId (EfsMountTargetResource s) s (TF.Attr s Text) where
    computedSubnetId =
        (_subnet_id :: EfsMountTargetResource s -> TF.Attr s Text)
            . TF.refValue

efsMountTargetResource :: TF.Schema TF.Resource P.AWS (EfsMountTargetResource s)
efsMountTargetResource =
    TF.newResource "aws_efs_mount_target" $
        EfsMountTargetResource {
              _file_system_id = TF.Nil
            , _ip_address = TF.Nil
            , _security_groups = TF.Nil
            , _subnet_id = TF.Nil
            }

{- | The @aws_egress_only_internet_gateway@ AWS resource.

[IPv6 only] Creates an egress-only Internet gateway for your VPC. An
egress-only Internet gateway is used to enable outbound communication over
IPv6 from instances in your VPC to the Internet, and prevents hosts outside
of your VPC from initiating an IPv6 connection with your instance.
-}
data EgressOnlyInternetGatewayResource s = EgressOnlyInternetGatewayResource {
      _vpc_id :: !(TF.Attr s Text)
    {- ^ (Required) The VPC ID to create in. -}
    } deriving (Show, Eq)

instance TF.ToHCL (EgressOnlyInternetGatewayResource s) where
    toHCL EgressOnlyInternetGatewayResource{..} = TF.inline $ catMaybes
        [ TF.assign "vpc_id" <$> TF.attribute _vpc_id
        ]

instance P.HasVpcId (EgressOnlyInternetGatewayResource s) (TF.Attr s Text) where
    vpcId =
        lens (_vpc_id :: EgressOnlyInternetGatewayResource s -> TF.Attr s Text)
             (\s a -> s { _vpc_id = a } :: EgressOnlyInternetGatewayResource s)

instance P.HasComputedId (EgressOnlyInternetGatewayResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedVpcId (EgressOnlyInternetGatewayResource s) s (TF.Attr s Text) where
    computedVpcId =
        (_vpc_id :: EgressOnlyInternetGatewayResource s -> TF.Attr s Text)
            . TF.refValue

egressOnlyInternetGatewayResource :: TF.Schema TF.Resource P.AWS (EgressOnlyInternetGatewayResource s)
egressOnlyInternetGatewayResource =
    TF.newResource "aws_egress_only_internet_gateway" $
        EgressOnlyInternetGatewayResource {
              _vpc_id = TF.Nil
            }

{- | The @aws_eip_association@ AWS resource.

Provides an AWS EIP Association as a top level resource, to associate and
disassociate Elastic IPs from AWS Instances and Network Interfaces. ~> NOTE:
@aws_eip_association@ is useful in scenarios where EIPs are either
pre-existing or distributed to customers or users and therefore cannot be
changed.
-}
data EipAssociationResource s = EipAssociationResource {
      _allocation_id        :: !(TF.Attr s Text)
    {- ^ (Optional) The allocation ID. This is required for EC2-VPC. -}
    , _allow_reassociation  :: !(TF.Attr s Text)
    {- ^ (Optional, Boolean) Whether to allow an Elastic IP to be re-associated. Defaults to @true@ in VPC. -}
    , _instance_id          :: !(TF.Attr s Text)
    {- ^ (Optional) The ID of the instance. This is required for EC2-Classic. For EC2-VPC, you can specify either the instance ID or the network interface ID, but not both. The operation fails if you specify an instance ID unless exactly one network interface is attached. -}
    , _network_interface_id :: !(TF.Attr s Text)
    {- ^ (Optional) The ID of the network interface. If the instance has more than one network interface, you must specify a network interface ID. -}
    , _private_ip_address   :: !(TF.Attr s Text)
    {- ^ (Optional) The primary or secondary private IP address to associate with the Elastic IP address. If no private IP address is specified, the Elastic IP address is associated with the primary private IP address. -}
    , _public_ip            :: !(TF.Attr s Text)
    {- ^ (Optional) The Elastic IP address. This is required for EC2-Classic. -}
    } deriving (Show, Eq)

instance TF.ToHCL (EipAssociationResource s) where
    toHCL EipAssociationResource{..} = TF.inline $ catMaybes
        [ TF.assign "allocation_id" <$> TF.attribute _allocation_id
        , TF.assign "allow_reassociation" <$> TF.attribute _allow_reassociation
        , TF.assign "instance_id" <$> TF.attribute _instance_id
        , TF.assign "network_interface_id" <$> TF.attribute _network_interface_id
        , TF.assign "private_ip_address" <$> TF.attribute _private_ip_address
        , TF.assign "public_ip" <$> TF.attribute _public_ip
        ]

instance P.HasAllocationId (EipAssociationResource s) (TF.Attr s Text) where
    allocationId =
        lens (_allocation_id :: EipAssociationResource s -> TF.Attr s Text)
             (\s a -> s { _allocation_id = a } :: EipAssociationResource s)

instance P.HasAllowReassociation (EipAssociationResource s) (TF.Attr s Text) where
    allowReassociation =
        lens (_allow_reassociation :: EipAssociationResource s -> TF.Attr s Text)
             (\s a -> s { _allow_reassociation = a } :: EipAssociationResource s)

instance P.HasInstanceId (EipAssociationResource s) (TF.Attr s Text) where
    instanceId =
        lens (_instance_id :: EipAssociationResource s -> TF.Attr s Text)
             (\s a -> s { _instance_id = a } :: EipAssociationResource s)

instance P.HasNetworkInterfaceId (EipAssociationResource s) (TF.Attr s Text) where
    networkInterfaceId =
        lens (_network_interface_id :: EipAssociationResource s -> TF.Attr s Text)
             (\s a -> s { _network_interface_id = a } :: EipAssociationResource s)

instance P.HasPrivateIpAddress (EipAssociationResource s) (TF.Attr s Text) where
    privateIpAddress =
        lens (_private_ip_address :: EipAssociationResource s -> TF.Attr s Text)
             (\s a -> s { _private_ip_address = a } :: EipAssociationResource s)

instance P.HasPublicIp (EipAssociationResource s) (TF.Attr s Text) where
    publicIp =
        lens (_public_ip :: EipAssociationResource s -> TF.Attr s Text)
             (\s a -> s { _public_ip = a } :: EipAssociationResource s)

instance P.HasComputedAllocationId (EipAssociationResource s) s (TF.Attr s Text) where
    computedAllocationId x = TF.compute (TF.refKey x) "allocation_id"

instance P.HasComputedAllowReassociation (EipAssociationResource s) s (TF.Attr s Text) where
    computedAllowReassociation =
        (_allow_reassociation :: EipAssociationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAssociationId (EipAssociationResource s) s (TF.Attr s Text) where
    computedAssociationId x = TF.compute (TF.refKey x) "association_id"

instance P.HasComputedInstanceId (EipAssociationResource s) s (TF.Attr s Text) where
    computedInstanceId x = TF.compute (TF.refKey x) "instance_id"

instance P.HasComputedNetworkInterfaceId (EipAssociationResource s) s (TF.Attr s Text) where
    computedNetworkInterfaceId x = TF.compute (TF.refKey x) "network_interface_id"

instance P.HasComputedPrivateIpAddress (EipAssociationResource s) s (TF.Attr s Text) where
    computedPrivateIpAddress x = TF.compute (TF.refKey x) "private_ip_address"

instance P.HasComputedPublicIp (EipAssociationResource s) s (TF.Attr s Text) where
    computedPublicIp x = TF.compute (TF.refKey x) "public_ip"

eipAssociationResource :: TF.Schema TF.Resource P.AWS (EipAssociationResource s)
eipAssociationResource =
    TF.newResource "aws_eip_association" $
        EipAssociationResource {
              _allocation_id = TF.Nil
            , _allow_reassociation = TF.Nil
            , _instance_id = TF.Nil
            , _network_interface_id = TF.Nil
            , _private_ip_address = TF.Nil
            , _public_ip = TF.Nil
            }

{- | The @aws_eip@ AWS resource.

Provides an Elastic IP resource. ~> Note: EIP may require IGW to exist prior
to association. Use @depends_on@ to set an explicit dependency on the IGW.
-}
data EipResource s = EipResource {
      _associate_with_private_ip :: !(TF.Attr s Text)
    {- ^ (Optional) A user specified primary or secondary private IP address to associate with the Elastic IP address. If no private IP address is specified, the Elastic IP address is associated with the primary private IP address. -}
    , _instance'                 :: !(TF.Attr s Text)
    {- ^ (Optional) EC2 instance ID. -}
    , _network_interface         :: !(TF.Attr s Text)
    {- ^ (Optional) Network interface ID to associate with. -}
    , _tags                      :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    , _vpc                       :: !(TF.Attr s Text)
    {- ^ (Optional) Boolean if the EIP is in a VPC or not. -}
    } deriving (Show, Eq)

instance TF.ToHCL (EipResource s) where
    toHCL EipResource{..} = TF.inline $ catMaybes
        [ TF.assign "associate_with_private_ip" <$> TF.attribute _associate_with_private_ip
        , TF.assign "instance" <$> TF.attribute _instance'
        , TF.assign "network_interface" <$> TF.attribute _network_interface
        , TF.assign "tags" <$> TF.attribute _tags
        , TF.assign "vpc" <$> TF.attribute _vpc
        ]

instance P.HasAssociateWithPrivateIp (EipResource s) (TF.Attr s Text) where
    associateWithPrivateIp =
        lens (_associate_with_private_ip :: EipResource s -> TF.Attr s Text)
             (\s a -> s { _associate_with_private_ip = a } :: EipResource s)

instance P.HasInstance' (EipResource s) (TF.Attr s Text) where
    instance' =
        lens (_instance' :: EipResource s -> TF.Attr s Text)
             (\s a -> s { _instance' = a } :: EipResource s)

instance P.HasNetworkInterface (EipResource s) (TF.Attr s Text) where
    networkInterface =
        lens (_network_interface :: EipResource s -> TF.Attr s Text)
             (\s a -> s { _network_interface = a } :: EipResource s)

instance P.HasTags (EipResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: EipResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: EipResource s)

instance P.HasVpc (EipResource s) (TF.Attr s Text) where
    vpc =
        lens (_vpc :: EipResource s -> TF.Attr s Text)
             (\s a -> s { _vpc = a } :: EipResource s)

instance P.HasComputedAssociateWithPrivateIp (EipResource s) s (TF.Attr s Text) where
    computedAssociateWithPrivateIp x = TF.compute (TF.refKey x) "associate_with_private_ip"

instance P.HasComputedId (EipResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedInstance' (EipResource s) s (TF.Attr s Text) where
    computedInstance' x = TF.compute (TF.refKey x) "instance"

instance P.HasComputedNetworkInterface (EipResource s) s (TF.Attr s Text) where
    computedNetworkInterface x = TF.compute (TF.refKey x) "network_interface"

instance P.HasComputedPrivateIp (EipResource s) s (TF.Attr s Text) where
    computedPrivateIp x = TF.compute (TF.refKey x) "private_ip"

instance P.HasComputedPublicIp (EipResource s) s (TF.Attr s Text) where
    computedPublicIp x = TF.compute (TF.refKey x) "public_ip"

instance P.HasComputedTags (EipResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: EipResource s -> TF.Attr s P.Tags)
            . TF.refValue

instance P.HasComputedVpc (EipResource s) s (TF.Attr s Text) where
    computedVpc =
        (_vpc :: EipResource s -> TF.Attr s Text)
            . TF.refValue

eipResource :: TF.Schema TF.Resource P.AWS (EipResource s)
eipResource =
    TF.newResource "aws_eip" $
        EipResource {
              _associate_with_private_ip = TF.Nil
            , _instance' = TF.Nil
            , _network_interface = TF.Nil
            , _tags = TF.Nil
            , _vpc = TF.Nil
            }

{- | The @aws_elastic_beanstalk_application@ AWS resource.

Provides an Elastic Beanstalk Application Resource. Elastic Beanstalk allows
you to deploy and manage applications in the AWS cloud without worrying
about the infrastructure that runs those applications. This resource creates
an application that has one configuration template named @default@ , and no
application versions
-}
data ElasticBeanstalkApplicationResource s = ElasticBeanstalkApplicationResource {
      _description :: !(TF.Attr s Text)
    {- ^ (Optional) Short description of the application -}
    , _name        :: !(TF.Attr s Text)
    {- ^ (Required) The name of the application, must be unique within your account -}
    } deriving (Show, Eq)

instance TF.ToHCL (ElasticBeanstalkApplicationResource s) where
    toHCL ElasticBeanstalkApplicationResource{..} = TF.inline $ catMaybes
        [ TF.assign "description" <$> TF.attribute _description
        , TF.assign "name" <$> TF.attribute _name
        ]

instance P.HasDescription (ElasticBeanstalkApplicationResource s) (TF.Attr s Text) where
    description =
        lens (_description :: ElasticBeanstalkApplicationResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: ElasticBeanstalkApplicationResource s)

instance P.HasName (ElasticBeanstalkApplicationResource s) (TF.Attr s Text) where
    name =
        lens (_name :: ElasticBeanstalkApplicationResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: ElasticBeanstalkApplicationResource s)

instance P.HasComputedDescription (ElasticBeanstalkApplicationResource s) s (TF.Attr s Text) where
    computedDescription =
        (_description :: ElasticBeanstalkApplicationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (ElasticBeanstalkApplicationResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: ElasticBeanstalkApplicationResource s -> TF.Attr s Text)
            . TF.refValue

elasticBeanstalkApplicationResource :: TF.Schema TF.Resource P.AWS (ElasticBeanstalkApplicationResource s)
elasticBeanstalkApplicationResource =
    TF.newResource "aws_elastic_beanstalk_application" $
        ElasticBeanstalkApplicationResource {
              _description = TF.Nil
            , _name = TF.Nil
            }

{- | The @aws_elastic_beanstalk_application_version@ AWS resource.

Provides an Elastic Beanstalk Application Version Resource. Elastic
Beanstalk allows you to deploy and manage applications in the AWS cloud
without worrying about the infrastructure that runs those applications. This
resource creates a Beanstalk Application Version that can be deployed to a
Beanstalk Environment. ~> NOTE on Application Version Resource: When using
the Application Version resource with multiple
<elastic_beanstalk_environment.html> it is possible that an error may be
returned when attempting to delete an Application Version while it is still
in use by a different environment. To work around this you can:
-}
data ElasticBeanstalkApplicationVersionResource s = ElasticBeanstalkApplicationVersionResource {
      _application  :: !(TF.Attr s Text)
    {- ^ (Required) Name of the Beanstalk Application the version is associated with. -}
    , _bucket       :: !(TF.Attr s Text)
    {- ^ (Required) S3 bucket that contains the Application Version source bundle. -}
    , _description  :: !(TF.Attr s Text)
    {- ^ (Optional) Short description of the Application Version. -}
    , _force_delete :: !(TF.Attr s Text)
    {- ^ (Optional) On delete, force an Application Version to be deleted when it may be in use by multiple Elastic Beanstalk Environments. -}
    , _key          :: !(TF.Attr s Text)
    {- ^ (Required) S3 object that is the Application Version source bundle. -}
    , _name         :: !(TF.Attr s Text)
    {- ^ (Required) A unique name for the this Application Version. -}
    } deriving (Show, Eq)

instance TF.ToHCL (ElasticBeanstalkApplicationVersionResource s) where
    toHCL ElasticBeanstalkApplicationVersionResource{..} = TF.inline $ catMaybes
        [ TF.assign "application" <$> TF.attribute _application
        , TF.assign "bucket" <$> TF.attribute _bucket
        , TF.assign "description" <$> TF.attribute _description
        , TF.assign "force_delete" <$> TF.attribute _force_delete
        , TF.assign "key" <$> TF.attribute _key
        , TF.assign "name" <$> TF.attribute _name
        ]

instance P.HasApplication (ElasticBeanstalkApplicationVersionResource s) (TF.Attr s Text) where
    application =
        lens (_application :: ElasticBeanstalkApplicationVersionResource s -> TF.Attr s Text)
             (\s a -> s { _application = a } :: ElasticBeanstalkApplicationVersionResource s)

instance P.HasBucket (ElasticBeanstalkApplicationVersionResource s) (TF.Attr s Text) where
    bucket =
        lens (_bucket :: ElasticBeanstalkApplicationVersionResource s -> TF.Attr s Text)
             (\s a -> s { _bucket = a } :: ElasticBeanstalkApplicationVersionResource s)

instance P.HasDescription (ElasticBeanstalkApplicationVersionResource s) (TF.Attr s Text) where
    description =
        lens (_description :: ElasticBeanstalkApplicationVersionResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: ElasticBeanstalkApplicationVersionResource s)

instance P.HasForceDelete (ElasticBeanstalkApplicationVersionResource s) (TF.Attr s Text) where
    forceDelete =
        lens (_force_delete :: ElasticBeanstalkApplicationVersionResource s -> TF.Attr s Text)
             (\s a -> s { _force_delete = a } :: ElasticBeanstalkApplicationVersionResource s)

instance P.HasKey (ElasticBeanstalkApplicationVersionResource s) (TF.Attr s Text) where
    key =
        lens (_key :: ElasticBeanstalkApplicationVersionResource s -> TF.Attr s Text)
             (\s a -> s { _key = a } :: ElasticBeanstalkApplicationVersionResource s)

instance P.HasName (ElasticBeanstalkApplicationVersionResource s) (TF.Attr s Text) where
    name =
        lens (_name :: ElasticBeanstalkApplicationVersionResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: ElasticBeanstalkApplicationVersionResource s)

instance P.HasComputedApplication (ElasticBeanstalkApplicationVersionResource s) s (TF.Attr s Text) where
    computedApplication =
        (_application :: ElasticBeanstalkApplicationVersionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedBucket (ElasticBeanstalkApplicationVersionResource s) s (TF.Attr s Text) where
    computedBucket =
        (_bucket :: ElasticBeanstalkApplicationVersionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDescription (ElasticBeanstalkApplicationVersionResource s) s (TF.Attr s Text) where
    computedDescription =
        (_description :: ElasticBeanstalkApplicationVersionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedForceDelete (ElasticBeanstalkApplicationVersionResource s) s (TF.Attr s Text) where
    computedForceDelete =
        (_force_delete :: ElasticBeanstalkApplicationVersionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedKey (ElasticBeanstalkApplicationVersionResource s) s (TF.Attr s Text) where
    computedKey =
        (_key :: ElasticBeanstalkApplicationVersionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (ElasticBeanstalkApplicationVersionResource s) s (TF.Attr s Text) where
    computedName x = TF.compute (TF.refKey x) "name"

elasticBeanstalkApplicationVersionResource :: TF.Schema TF.Resource P.AWS (ElasticBeanstalkApplicationVersionResource s)
elasticBeanstalkApplicationVersionResource =
    TF.newResource "aws_elastic_beanstalk_application_version" $
        ElasticBeanstalkApplicationVersionResource {
              _application = TF.Nil
            , _bucket = TF.Nil
            , _description = TF.Nil
            , _force_delete = TF.Nil
            , _key = TF.Nil
            , _name = TF.Nil
            }

{- | The @aws_elastic_beanstalk_configuration_template@ AWS resource.

Provides an Elastic Beanstalk Configuration Template, which are associated
with a specific application and are used to deploy different versions of the
application with the same configuration settings.
-}
data ElasticBeanstalkConfigurationTemplateResource s = ElasticBeanstalkConfigurationTemplateResource {
      _application         :: !(TF.Attr s Text)
    {- ^  (Required) name of the application to associate with this configuration template -}
    , _description         :: !(TF.Attr s Text)
    {- ^ (Optional) Short description of the Template -}
    , _environment_id      :: !(TF.Attr s Text)
    {- ^  (Optional) The ID of the environment used with this configuration template -}
    , _name                :: !(TF.Attr s Text)
    {- ^ (Required) A unique name for this Template. -}
    , _setting             :: !(TF.Attr s Text)
    {- ^ (Optional) Option settings to configure the new Environment. These override specific values that are set as defaults. The format is detailed below in <#option-settings> -}
    , _solution_stack_name :: !(TF.Attr s Text)
    {- ^ (Optional) A solution stack to base your Template off of. Example stacks can be found in the <https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/concepts.platforms.html> -}
    } deriving (Show, Eq)

instance TF.ToHCL (ElasticBeanstalkConfigurationTemplateResource s) where
    toHCL ElasticBeanstalkConfigurationTemplateResource{..} = TF.inline $ catMaybes
        [ TF.assign "application" <$> TF.attribute _application
        , TF.assign "description" <$> TF.attribute _description
        , TF.assign "environment_id" <$> TF.attribute _environment_id
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "setting" <$> TF.attribute _setting
        , TF.assign "solution_stack_name" <$> TF.attribute _solution_stack_name
        ]

instance P.HasApplication (ElasticBeanstalkConfigurationTemplateResource s) (TF.Attr s Text) where
    application =
        lens (_application :: ElasticBeanstalkConfigurationTemplateResource s -> TF.Attr s Text)
             (\s a -> s { _application = a } :: ElasticBeanstalkConfigurationTemplateResource s)

instance P.HasDescription (ElasticBeanstalkConfigurationTemplateResource s) (TF.Attr s Text) where
    description =
        lens (_description :: ElasticBeanstalkConfigurationTemplateResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: ElasticBeanstalkConfigurationTemplateResource s)

instance P.HasEnvironmentId (ElasticBeanstalkConfigurationTemplateResource s) (TF.Attr s Text) where
    environmentId =
        lens (_environment_id :: ElasticBeanstalkConfigurationTemplateResource s -> TF.Attr s Text)
             (\s a -> s { _environment_id = a } :: ElasticBeanstalkConfigurationTemplateResource s)

instance P.HasName (ElasticBeanstalkConfigurationTemplateResource s) (TF.Attr s Text) where
    name =
        lens (_name :: ElasticBeanstalkConfigurationTemplateResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: ElasticBeanstalkConfigurationTemplateResource s)

instance P.HasSetting (ElasticBeanstalkConfigurationTemplateResource s) (TF.Attr s Text) where
    setting =
        lens (_setting :: ElasticBeanstalkConfigurationTemplateResource s -> TF.Attr s Text)
             (\s a -> s { _setting = a } :: ElasticBeanstalkConfigurationTemplateResource s)

instance P.HasSolutionStackName (ElasticBeanstalkConfigurationTemplateResource s) (TF.Attr s Text) where
    solutionStackName =
        lens (_solution_stack_name :: ElasticBeanstalkConfigurationTemplateResource s -> TF.Attr s Text)
             (\s a -> s { _solution_stack_name = a } :: ElasticBeanstalkConfigurationTemplateResource s)

instance P.HasComputedApplication (ElasticBeanstalkConfigurationTemplateResource s) s (TF.Attr s Text) where
    computedApplication =
        (_application :: ElasticBeanstalkConfigurationTemplateResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDescription (ElasticBeanstalkConfigurationTemplateResource s) s (TF.Attr s Text) where
    computedDescription =
        (_description :: ElasticBeanstalkConfigurationTemplateResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEnvironmentId (ElasticBeanstalkConfigurationTemplateResource s) s (TF.Attr s Text) where
    computedEnvironmentId =
        (_environment_id :: ElasticBeanstalkConfigurationTemplateResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (ElasticBeanstalkConfigurationTemplateResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: ElasticBeanstalkConfigurationTemplateResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSetting (ElasticBeanstalkConfigurationTemplateResource s) s (TF.Attr s Text) where
    computedSetting =
        (_setting :: ElasticBeanstalkConfigurationTemplateResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSolutionStackName (ElasticBeanstalkConfigurationTemplateResource s) s (TF.Attr s Text) where
    computedSolutionStackName =
        (_solution_stack_name :: ElasticBeanstalkConfigurationTemplateResource s -> TF.Attr s Text)
            . TF.refValue

elasticBeanstalkConfigurationTemplateResource :: TF.Schema TF.Resource P.AWS (ElasticBeanstalkConfigurationTemplateResource s)
elasticBeanstalkConfigurationTemplateResource =
    TF.newResource "aws_elastic_beanstalk_configuration_template" $
        ElasticBeanstalkConfigurationTemplateResource {
              _application = TF.Nil
            , _description = TF.Nil
            , _environment_id = TF.Nil
            , _name = TF.Nil
            , _setting = TF.Nil
            , _solution_stack_name = TF.Nil
            }

{- | The @aws_elastic_beanstalk_environment@ AWS resource.

Provides an Elastic Beanstalk Environment Resource. Elastic Beanstalk allows
you to deploy and manage applications in the AWS cloud without worrying
about the infrastructure that runs those applications. Environments are
often things such as @development@ , @integration@ , or @production@ .
-}
data ElasticBeanstalkEnvironmentResource s = ElasticBeanstalkEnvironmentResource {
      _application            :: !(TF.Attr s Text)
    {- ^  (Required) Name of the application that contains the version to be deployed -}
    , _cname_prefix           :: !(TF.Attr s Text)
    {- ^ (Optional) Prefix to use for the fully qualified DNS name of the Environment. -}
    , _description            :: !(TF.Attr s Text)
    {- ^ (Optional) Short description of the Environment -}
    , _name                   :: !(TF.Attr s Text)
    {- ^ (Required) A unique name for this Environment. This name is used in the application URL -}
    , _poll_interval          :: !(TF.Attr s Text)
    {- ^ The time between polling the AWS API to check if changes have been applied. Use this to adjust the rate of API calls for any @create@ or @update@ action. Minimum @10s@ , maximum @180s@ . Omit this to use the default behavior, which is an exponential backoff -}
    , _setting                :: !(P.Maybe [P.ElasticBeanstalkSetting s])
    {- ^ (Optional) Option settings to configure the new Environment. These override specific values that are set as defaults. The format is detailed below in <#option-settings> -}
    , _solution_stack_name    :: !(TF.Attr s Text)
    {- ^ (Optional) A solution stack to base your environment off of. Example stacks can be found in the <https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/concepts.platforms.html> -}
    , _tags                   :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A set of tags to apply to the Environment. Note: at this time the Elastic Beanstalk API does not provide a programatic way of changing these tags after initial application -}
    , _template_name          :: !(TF.Attr s Text)
    {- ^  (Optional) The name of the Elastic Beanstalk Configuration template to use in deployment -}
    , _tier                   :: !(TF.Attr s Text)
    {- ^ (Optional) Elastic Beanstalk Environment tier. Valid values are @Worker@ or @WebServer@ . If tier is left blank @WebServer@ will be used. -}
    , _version_label          :: !(TF.Attr s Text)
    {- ^ (Optional) The name of the Elastic Beanstalk Application Version to use in deployment. -}
    , _wait_for_ready_timeout :: !(TF.Attr s Text)
    {- ^ - (Default: @20m@ ) The maximum <https://golang.org/pkg/time/#ParseDuration> that Terraform should wait for an Elastic Beanstalk Environment to be in a ready state before timing out. -}
    } deriving (Show, Eq)

instance TF.ToHCL (ElasticBeanstalkEnvironmentResource s) where
    toHCL ElasticBeanstalkEnvironmentResource{..} = TF.inline $ catMaybes
        [ TF.assign "application" <$> TF.attribute _application
        , TF.assign "cname_prefix" <$> TF.attribute _cname_prefix
        , TF.assign "description" <$> TF.attribute _description
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "poll_interval" <$> TF.attribute _poll_interval
        , TF.assign "setting" <$>  _setting
        , TF.assign "solution_stack_name" <$> TF.attribute _solution_stack_name
        , TF.assign "tags" <$> TF.attribute _tags
        , TF.assign "template_name" <$> TF.attribute _template_name
        , TF.assign "tier" <$> TF.attribute _tier
        , TF.assign "version_label" <$> TF.attribute _version_label
        , TF.assign "wait_for_ready_timeout" <$> TF.attribute _wait_for_ready_timeout
        ]

instance P.HasApplication (ElasticBeanstalkEnvironmentResource s) (TF.Attr s Text) where
    application =
        lens (_application :: ElasticBeanstalkEnvironmentResource s -> TF.Attr s Text)
             (\s a -> s { _application = a } :: ElasticBeanstalkEnvironmentResource s)

instance P.HasCnamePrefix (ElasticBeanstalkEnvironmentResource s) (TF.Attr s Text) where
    cnamePrefix =
        lens (_cname_prefix :: ElasticBeanstalkEnvironmentResource s -> TF.Attr s Text)
             (\s a -> s { _cname_prefix = a } :: ElasticBeanstalkEnvironmentResource s)

instance P.HasDescription (ElasticBeanstalkEnvironmentResource s) (TF.Attr s Text) where
    description =
        lens (_description :: ElasticBeanstalkEnvironmentResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: ElasticBeanstalkEnvironmentResource s)

instance P.HasName (ElasticBeanstalkEnvironmentResource s) (TF.Attr s Text) where
    name =
        lens (_name :: ElasticBeanstalkEnvironmentResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: ElasticBeanstalkEnvironmentResource s)

instance P.HasPollInterval (ElasticBeanstalkEnvironmentResource s) (TF.Attr s Text) where
    pollInterval =
        lens (_poll_interval :: ElasticBeanstalkEnvironmentResource s -> TF.Attr s Text)
             (\s a -> s { _poll_interval = a } :: ElasticBeanstalkEnvironmentResource s)

instance P.HasSetting (ElasticBeanstalkEnvironmentResource s) (P.Maybe [P.ElasticBeanstalkSetting s]) where
    setting =
        lens (_setting :: ElasticBeanstalkEnvironmentResource s -> P.Maybe [P.ElasticBeanstalkSetting s])
             (\s a -> s { _setting = a } :: ElasticBeanstalkEnvironmentResource s)

instance P.HasSolutionStackName (ElasticBeanstalkEnvironmentResource s) (TF.Attr s Text) where
    solutionStackName =
        lens (_solution_stack_name :: ElasticBeanstalkEnvironmentResource s -> TF.Attr s Text)
             (\s a -> s { _solution_stack_name = a } :: ElasticBeanstalkEnvironmentResource s)

instance P.HasTags (ElasticBeanstalkEnvironmentResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: ElasticBeanstalkEnvironmentResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: ElasticBeanstalkEnvironmentResource s)

instance P.HasTemplateName (ElasticBeanstalkEnvironmentResource s) (TF.Attr s Text) where
    templateName =
        lens (_template_name :: ElasticBeanstalkEnvironmentResource s -> TF.Attr s Text)
             (\s a -> s { _template_name = a } :: ElasticBeanstalkEnvironmentResource s)

instance P.HasTier (ElasticBeanstalkEnvironmentResource s) (TF.Attr s Text) where
    tier =
        lens (_tier :: ElasticBeanstalkEnvironmentResource s -> TF.Attr s Text)
             (\s a -> s { _tier = a } :: ElasticBeanstalkEnvironmentResource s)

instance P.HasVersionLabel (ElasticBeanstalkEnvironmentResource s) (TF.Attr s Text) where
    versionLabel =
        lens (_version_label :: ElasticBeanstalkEnvironmentResource s -> TF.Attr s Text)
             (\s a -> s { _version_label = a } :: ElasticBeanstalkEnvironmentResource s)

instance P.HasWaitForReadyTimeout (ElasticBeanstalkEnvironmentResource s) (TF.Attr s Text) where
    waitForReadyTimeout =
        lens (_wait_for_ready_timeout :: ElasticBeanstalkEnvironmentResource s -> TF.Attr s Text)
             (\s a -> s { _wait_for_ready_timeout = a } :: ElasticBeanstalkEnvironmentResource s)

instance P.HasComputedAllSettings (ElasticBeanstalkEnvironmentResource s) s (TF.Attr s Text) where
    computedAllSettings x = TF.compute (TF.refKey x) "all_settings"

instance P.HasComputedApplication (ElasticBeanstalkEnvironmentResource s) s (TF.Attr s Text) where
    computedApplication x = TF.compute (TF.refKey x) "application"

instance P.HasComputedAutoscalingGroups (ElasticBeanstalkEnvironmentResource s) s (TF.Attr s Text) where
    computedAutoscalingGroups x = TF.compute (TF.refKey x) "autoscaling_groups"

instance P.HasComputedCname (ElasticBeanstalkEnvironmentResource s) s (TF.Attr s Text) where
    computedCname x = TF.compute (TF.refKey x) "cname"

instance P.HasComputedCnamePrefix (ElasticBeanstalkEnvironmentResource s) s (TF.Attr s Text) where
    computedCnamePrefix =
        (_cname_prefix :: ElasticBeanstalkEnvironmentResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDescription (ElasticBeanstalkEnvironmentResource s) s (TF.Attr s Text) where
    computedDescription x = TF.compute (TF.refKey x) "description"

instance P.HasComputedId (ElasticBeanstalkEnvironmentResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedInstances (ElasticBeanstalkEnvironmentResource s) s (TF.Attr s Text) where
    computedInstances x = TF.compute (TF.refKey x) "instances"

instance P.HasComputedLaunchConfigurations (ElasticBeanstalkEnvironmentResource s) s (TF.Attr s Text) where
    computedLaunchConfigurations x = TF.compute (TF.refKey x) "launch_configurations"

instance P.HasComputedLoadBalancers (ElasticBeanstalkEnvironmentResource s) s (TF.Attr s Text) where
    computedLoadBalancers x = TF.compute (TF.refKey x) "load_balancers"

instance P.HasComputedName (ElasticBeanstalkEnvironmentResource s) s (TF.Attr s Text) where
    computedName x = TF.compute (TF.refKey x) "name"

instance P.HasComputedPollInterval (ElasticBeanstalkEnvironmentResource s) s (TF.Attr s Text) where
    computedPollInterval =
        (_poll_interval :: ElasticBeanstalkEnvironmentResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedQueues (ElasticBeanstalkEnvironmentResource s) s (TF.Attr s Text) where
    computedQueues x = TF.compute (TF.refKey x) "queues"

instance P.HasComputedSetting (ElasticBeanstalkEnvironmentResource s) s (TF.Attr s Text) where
    computedSetting x = TF.compute (TF.refKey x) "setting"

instance P.HasComputedSolutionStackName (ElasticBeanstalkEnvironmentResource s) s (TF.Attr s Text) where
    computedSolutionStackName =
        (_solution_stack_name :: ElasticBeanstalkEnvironmentResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (ElasticBeanstalkEnvironmentResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: ElasticBeanstalkEnvironmentResource s -> TF.Attr s P.Tags)
            . TF.refValue

instance P.HasComputedTemplateName (ElasticBeanstalkEnvironmentResource s) s (TF.Attr s Text) where
    computedTemplateName =
        (_template_name :: ElasticBeanstalkEnvironmentResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTier (ElasticBeanstalkEnvironmentResource s) s (TF.Attr s Text) where
    computedTier x = TF.compute (TF.refKey x) "tier"

instance P.HasComputedTriggers (ElasticBeanstalkEnvironmentResource s) s (TF.Attr s Text) where
    computedTriggers x = TF.compute (TF.refKey x) "triggers"

instance P.HasComputedVersionLabel (ElasticBeanstalkEnvironmentResource s) s (TF.Attr s Text) where
    computedVersionLabel =
        (_version_label :: ElasticBeanstalkEnvironmentResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedWaitForReadyTimeout (ElasticBeanstalkEnvironmentResource s) s (TF.Attr s Text) where
    computedWaitForReadyTimeout =
        (_wait_for_ready_timeout :: ElasticBeanstalkEnvironmentResource s -> TF.Attr s Text)
            . TF.refValue

elasticBeanstalkEnvironmentResource :: TF.Schema TF.Resource P.AWS (ElasticBeanstalkEnvironmentResource s)
elasticBeanstalkEnvironmentResource =
    TF.newResource "aws_elastic_beanstalk_environment" $
        ElasticBeanstalkEnvironmentResource {
              _application = TF.Nil
            , _cname_prefix = TF.Nil
            , _description = TF.Nil
            , _name = TF.Nil
            , _poll_interval = TF.Nil
            , _setting = P.Nothing
            , _solution_stack_name = TF.Nil
            , _tags = TF.Nil
            , _template_name = TF.Nil
            , _tier = TF.Nil
            , _version_label = TF.Nil
            , _wait_for_ready_timeout = TF.Nil
            }

{- | The @aws_elasticache_cluster@ AWS resource.

Provides an ElastiCache Cluster resource. Changes to a Cache Cluster can
occur when you manually change a parameter, such as @node_type@ , and are
reflected in the next maintenance window. Because of this, Terraform may
report a difference in its planning phase because a modification has not yet
taken place. You can use the @apply_immediately@ flag to instruct the
service to apply the change immediately (see documentation below). ~> Note:
using @apply_immediately@ can result in a brief downtime as the server
reboots. See the AWS Docs on
<https://docs.aws.amazon.com/AmazonElastiCache/latest/UserGuide/Clusters.Modify.html>
for more information.
-}
data ElasticacheClusterResource s = ElasticacheClusterResource {
      _apply_immediately        :: !(TF.Attr s Text)
    {- ^ (Optional) Specifies whether any database modifications are applied immediately, or during the next maintenance window. Default is @false@ . See <https://docs.aws.amazon.com/AmazonElastiCache/latest/APIReference/API_ModifyCacheCluster.html> (Available since v0.6.0) -}
    , _availability_zone        :: !(TF.Attr s P.Zone)
    {- ^ (Optional) The Availability Zone for the cache cluster. If you want to create cache nodes in multi-az, use @availability_zones@ -}
    , _availability_zones       :: !(TF.Attr s Text)
    {- ^ (Optional, Memcached only) List of Availability Zones in which the cache nodes will be created. If you want to create cache nodes in single-az, use @availability_zone@ -}
    , _az_mode                  :: !(TF.Attr s Text)
    {- ^ (Optional, Memcached only) Specifies whether the nodes in this Memcached node group are created in a single Availability Zone or created across multiple Availability Zones in the cluster's region. Valid values for this parameter are @single-az@ or @cross-az@ , default is @single-az@ . If you want to choose @cross-az@ , @num_cache_nodes@ must be greater than @1@ -}
    , _cluster_id               :: !(TF.Attr s Text)
    {- ^  (Required) Group identifier. ElastiCache converts this name to lowercase -}
    , _engine                   :: !(TF.Attr s Text)
    {- ^  (Required) Name of the cache engine to be used for this cache cluster. Valid values for this parameter are @memcached@ or @redis@ -}
    , _engine_version           :: !(TF.Attr s Text)
    {- ^  (Optional) Version number of the cache engine to be used. See <https://docs.aws.amazon.com/AmazonElastiCache/latest/UserGuide/SelectEngine.html> in the AWS Documentation center for supported versions -}
    , _maintenance_window       :: !(TF.Attr s Text)
    {- ^ (Optional) Specifies the weekly time range for when maintenance on the cache cluster is performed. The format is @ddd:hh24:mi-ddd:hh24:mi@ (24H Clock UTC). The minimum maintenance window is a 60 minute period. Example: @sun:05:00-sun:09:00@ -}
    , _node_type                :: !(TF.Attr s Text)
    {- ^  (Required) The compute and memory capacity of the nodes. See <https://aws.amazon.com/elasticache/details#Available_Cache_Node_Types> for supported node types -}
    , _notification_topic_arn   :: !(TF.Attr s Text)
    {- ^ (Optional) An Amazon Resource Name (ARN) of an SNS topic to send ElastiCache notifications to. Example: @arn:aws:sns:us-east-1:012345678999:my_sns_topic@ -}
    , _num_cache_nodes          :: !(TF.Attr s Text)
    {- ^  (Required) The initial number of cache nodes that the cache cluster will have. For Redis, this value must be 1. For Memcache, this value must be between 1 and 20. If this number is reduced on subsequent runs, the highest numbered nodes will be removed. -}
    , _parameter_group_name     :: !(TF.Attr s Text)
    {- ^  (Required) Name of the parameter group to associate with this cache cluster -}
    , _port                     :: !(TF.Attr s Text)
    {- ^  (Required) The port number on which each of the cache nodes will accept connections. For Memcache the default is 11211, and for Redis the default port is 6379. -}
    , _security_group_ids       :: !(TF.Attr s Text)
    {- ^  (Optional, VPC only) One or more VPC security groups associated with the cache cluster -}
    , _security_group_names     :: !(TF.Attr s Text)
    {- ^  (Optional, EC2 Classic only) List of security group names to associate with this cache cluster -}
    , _snapshot_arns            :: !(TF.Attr s Text)
    {- ^ (Optional) A single-element string list containing an Amazon Resource Name (ARN) of a Redis RDB snapshot file stored in Amazon S3. Example: @arn:aws:s3:::my_bucket/snapshot1.rdb@ -}
    , _snapshot_name            :: !(TF.Attr s Text)
    {- ^ (Optional) The name of a snapshot from which to restore data into the new node group.  Changing the @snapshot_name@ forces a new resource. -}
    , _snapshot_retention_limit :: !(TF.Attr s Text)
    {- ^ (Optional, Redis only) The number of days for which ElastiCache will retain automatic cache cluster snapshots before deleting them. For example, if you set SnapshotRetentionLimit to 5, then a snapshot that was taken today will be retained for 5 days before being deleted. If the value of SnapshotRetentionLimit is set to zero (0), backups are turned off. Please note that setting a @snapshot_retention_limit@ is not supported on cache.t1.micro or cache.t2.* cache nodes -}
    , _snapshot_window          :: !(TF.Attr s Text)
    {- ^ (Optional, Redis only) The daily time range (in UTC) during which ElastiCache will begin taking a daily snapshot of your cache cluster. Example: 05:00-09:00 -}
    , _subnet_group_name        :: !(TF.Attr s Text)
    {- ^  (Optional, VPC only) Name of the subnet group to be used for the cache cluster. -}
    , _tags                     :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource -}
    } deriving (Show, Eq)

instance TF.ToHCL (ElasticacheClusterResource s) where
    toHCL ElasticacheClusterResource{..} = TF.inline $ catMaybes
        [ TF.assign "apply_immediately" <$> TF.attribute _apply_immediately
        , TF.assign "availability_zone" <$> TF.attribute _availability_zone
        , TF.assign "availability_zones" <$> TF.attribute _availability_zones
        , TF.assign "az_mode" <$> TF.attribute _az_mode
        , TF.assign "cluster_id" <$> TF.attribute _cluster_id
        , TF.assign "engine" <$> TF.attribute _engine
        , TF.assign "engine_version" <$> TF.attribute _engine_version
        , TF.assign "maintenance_window" <$> TF.attribute _maintenance_window
        , TF.assign "node_type" <$> TF.attribute _node_type
        , TF.assign "notification_topic_arn" <$> TF.attribute _notification_topic_arn
        , TF.assign "num_cache_nodes" <$> TF.attribute _num_cache_nodes
        , TF.assign "parameter_group_name" <$> TF.attribute _parameter_group_name
        , TF.assign "port" <$> TF.attribute _port
        , TF.assign "security_group_ids" <$> TF.attribute _security_group_ids
        , TF.assign "security_group_names" <$> TF.attribute _security_group_names
        , TF.assign "snapshot_arns" <$> TF.attribute _snapshot_arns
        , TF.assign "snapshot_name" <$> TF.attribute _snapshot_name
        , TF.assign "snapshot_retention_limit" <$> TF.attribute _snapshot_retention_limit
        , TF.assign "snapshot_window" <$> TF.attribute _snapshot_window
        , TF.assign "subnet_group_name" <$> TF.attribute _subnet_group_name
        , TF.assign "tags" <$> TF.attribute _tags
        ]

instance P.HasApplyImmediately (ElasticacheClusterResource s) (TF.Attr s Text) where
    applyImmediately =
        lens (_apply_immediately :: ElasticacheClusterResource s -> TF.Attr s Text)
             (\s a -> s { _apply_immediately = a } :: ElasticacheClusterResource s)

instance P.HasAvailabilityZone (ElasticacheClusterResource s) (TF.Attr s P.Zone) where
    availabilityZone =
        lens (_availability_zone :: ElasticacheClusterResource s -> TF.Attr s P.Zone)
             (\s a -> s { _availability_zone = a } :: ElasticacheClusterResource s)

instance P.HasAvailabilityZones (ElasticacheClusterResource s) (TF.Attr s Text) where
    availabilityZones =
        lens (_availability_zones :: ElasticacheClusterResource s -> TF.Attr s Text)
             (\s a -> s { _availability_zones = a } :: ElasticacheClusterResource s)

instance P.HasAzMode (ElasticacheClusterResource s) (TF.Attr s Text) where
    azMode =
        lens (_az_mode :: ElasticacheClusterResource s -> TF.Attr s Text)
             (\s a -> s { _az_mode = a } :: ElasticacheClusterResource s)

instance P.HasClusterId (ElasticacheClusterResource s) (TF.Attr s Text) where
    clusterId =
        lens (_cluster_id :: ElasticacheClusterResource s -> TF.Attr s Text)
             (\s a -> s { _cluster_id = a } :: ElasticacheClusterResource s)

instance P.HasEngine (ElasticacheClusterResource s) (TF.Attr s Text) where
    engine =
        lens (_engine :: ElasticacheClusterResource s -> TF.Attr s Text)
             (\s a -> s { _engine = a } :: ElasticacheClusterResource s)

instance P.HasEngineVersion (ElasticacheClusterResource s) (TF.Attr s Text) where
    engineVersion =
        lens (_engine_version :: ElasticacheClusterResource s -> TF.Attr s Text)
             (\s a -> s { _engine_version = a } :: ElasticacheClusterResource s)

instance P.HasMaintenanceWindow (ElasticacheClusterResource s) (TF.Attr s Text) where
    maintenanceWindow =
        lens (_maintenance_window :: ElasticacheClusterResource s -> TF.Attr s Text)
             (\s a -> s { _maintenance_window = a } :: ElasticacheClusterResource s)

instance P.HasNodeType (ElasticacheClusterResource s) (TF.Attr s Text) where
    nodeType =
        lens (_node_type :: ElasticacheClusterResource s -> TF.Attr s Text)
             (\s a -> s { _node_type = a } :: ElasticacheClusterResource s)

instance P.HasNotificationTopicArn (ElasticacheClusterResource s) (TF.Attr s Text) where
    notificationTopicArn =
        lens (_notification_topic_arn :: ElasticacheClusterResource s -> TF.Attr s Text)
             (\s a -> s { _notification_topic_arn = a } :: ElasticacheClusterResource s)

instance P.HasNumCacheNodes (ElasticacheClusterResource s) (TF.Attr s Text) where
    numCacheNodes =
        lens (_num_cache_nodes :: ElasticacheClusterResource s -> TF.Attr s Text)
             (\s a -> s { _num_cache_nodes = a } :: ElasticacheClusterResource s)

instance P.HasParameterGroupName (ElasticacheClusterResource s) (TF.Attr s Text) where
    parameterGroupName =
        lens (_parameter_group_name :: ElasticacheClusterResource s -> TF.Attr s Text)
             (\s a -> s { _parameter_group_name = a } :: ElasticacheClusterResource s)

instance P.HasPort (ElasticacheClusterResource s) (TF.Attr s Text) where
    port =
        lens (_port :: ElasticacheClusterResource s -> TF.Attr s Text)
             (\s a -> s { _port = a } :: ElasticacheClusterResource s)

instance P.HasSecurityGroupIds (ElasticacheClusterResource s) (TF.Attr s Text) where
    securityGroupIds =
        lens (_security_group_ids :: ElasticacheClusterResource s -> TF.Attr s Text)
             (\s a -> s { _security_group_ids = a } :: ElasticacheClusterResource s)

instance P.HasSecurityGroupNames (ElasticacheClusterResource s) (TF.Attr s Text) where
    securityGroupNames =
        lens (_security_group_names :: ElasticacheClusterResource s -> TF.Attr s Text)
             (\s a -> s { _security_group_names = a } :: ElasticacheClusterResource s)

instance P.HasSnapshotArns (ElasticacheClusterResource s) (TF.Attr s Text) where
    snapshotArns =
        lens (_snapshot_arns :: ElasticacheClusterResource s -> TF.Attr s Text)
             (\s a -> s { _snapshot_arns = a } :: ElasticacheClusterResource s)

instance P.HasSnapshotName (ElasticacheClusterResource s) (TF.Attr s Text) where
    snapshotName =
        lens (_snapshot_name :: ElasticacheClusterResource s -> TF.Attr s Text)
             (\s a -> s { _snapshot_name = a } :: ElasticacheClusterResource s)

instance P.HasSnapshotRetentionLimit (ElasticacheClusterResource s) (TF.Attr s Text) where
    snapshotRetentionLimit =
        lens (_snapshot_retention_limit :: ElasticacheClusterResource s -> TF.Attr s Text)
             (\s a -> s { _snapshot_retention_limit = a } :: ElasticacheClusterResource s)

instance P.HasSnapshotWindow (ElasticacheClusterResource s) (TF.Attr s Text) where
    snapshotWindow =
        lens (_snapshot_window :: ElasticacheClusterResource s -> TF.Attr s Text)
             (\s a -> s { _snapshot_window = a } :: ElasticacheClusterResource s)

instance P.HasSubnetGroupName (ElasticacheClusterResource s) (TF.Attr s Text) where
    subnetGroupName =
        lens (_subnet_group_name :: ElasticacheClusterResource s -> TF.Attr s Text)
             (\s a -> s { _subnet_group_name = a } :: ElasticacheClusterResource s)

instance P.HasTags (ElasticacheClusterResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: ElasticacheClusterResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: ElasticacheClusterResource s)

instance P.HasComputedApplyImmediately (ElasticacheClusterResource s) s (TF.Attr s Text) where
    computedApplyImmediately =
        (_apply_immediately :: ElasticacheClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAvailabilityZone (ElasticacheClusterResource s) s (TF.Attr s P.Zone) where
    computedAvailabilityZone =
        (_availability_zone :: ElasticacheClusterResource s -> TF.Attr s P.Zone)
            . TF.refValue

instance P.HasComputedAvailabilityZones (ElasticacheClusterResource s) s (TF.Attr s Text) where
    computedAvailabilityZones =
        (_availability_zones :: ElasticacheClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAzMode (ElasticacheClusterResource s) s (TF.Attr s Text) where
    computedAzMode =
        (_az_mode :: ElasticacheClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCacheNodes (ElasticacheClusterResource s) s (TF.Attr s Text) where
    computedCacheNodes x = TF.compute (TF.refKey x) "cache_nodes"

instance P.HasComputedClusterAddress (ElasticacheClusterResource s) s (TF.Attr s Text) where
    computedClusterAddress x = TF.compute (TF.refKey x) "cluster_address"

instance P.HasComputedClusterId (ElasticacheClusterResource s) s (TF.Attr s Text) where
    computedClusterId =
        (_cluster_id :: ElasticacheClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedConfigurationEndpoint (ElasticacheClusterResource s) s (TF.Attr s Text) where
    computedConfigurationEndpoint x = TF.compute (TF.refKey x) "configuration_endpoint"

instance P.HasComputedEngine (ElasticacheClusterResource s) s (TF.Attr s Text) where
    computedEngine =
        (_engine :: ElasticacheClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEngineVersion (ElasticacheClusterResource s) s (TF.Attr s Text) where
    computedEngineVersion =
        (_engine_version :: ElasticacheClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedMaintenanceWindow (ElasticacheClusterResource s) s (TF.Attr s Text) where
    computedMaintenanceWindow =
        (_maintenance_window :: ElasticacheClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedNodeType (ElasticacheClusterResource s) s (TF.Attr s Text) where
    computedNodeType =
        (_node_type :: ElasticacheClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedNotificationTopicArn (ElasticacheClusterResource s) s (TF.Attr s Text) where
    computedNotificationTopicArn =
        (_notification_topic_arn :: ElasticacheClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedNumCacheNodes (ElasticacheClusterResource s) s (TF.Attr s Text) where
    computedNumCacheNodes =
        (_num_cache_nodes :: ElasticacheClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedParameterGroupName (ElasticacheClusterResource s) s (TF.Attr s Text) where
    computedParameterGroupName =
        (_parameter_group_name :: ElasticacheClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPort (ElasticacheClusterResource s) s (TF.Attr s Text) where
    computedPort =
        (_port :: ElasticacheClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSecurityGroupIds (ElasticacheClusterResource s) s (TF.Attr s Text) where
    computedSecurityGroupIds =
        (_security_group_ids :: ElasticacheClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSecurityGroupNames (ElasticacheClusterResource s) s (TF.Attr s Text) where
    computedSecurityGroupNames =
        (_security_group_names :: ElasticacheClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSnapshotArns (ElasticacheClusterResource s) s (TF.Attr s Text) where
    computedSnapshotArns =
        (_snapshot_arns :: ElasticacheClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSnapshotName (ElasticacheClusterResource s) s (TF.Attr s Text) where
    computedSnapshotName =
        (_snapshot_name :: ElasticacheClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSnapshotRetentionLimit (ElasticacheClusterResource s) s (TF.Attr s Text) where
    computedSnapshotRetentionLimit =
        (_snapshot_retention_limit :: ElasticacheClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSnapshotWindow (ElasticacheClusterResource s) s (TF.Attr s Text) where
    computedSnapshotWindow =
        (_snapshot_window :: ElasticacheClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSubnetGroupName (ElasticacheClusterResource s) s (TF.Attr s Text) where
    computedSubnetGroupName =
        (_subnet_group_name :: ElasticacheClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (ElasticacheClusterResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: ElasticacheClusterResource s -> TF.Attr s P.Tags)
            . TF.refValue

elasticacheClusterResource :: TF.Schema TF.Resource P.AWS (ElasticacheClusterResource s)
elasticacheClusterResource =
    TF.newResource "aws_elasticache_cluster" $
        ElasticacheClusterResource {
              _apply_immediately = TF.Nil
            , _availability_zone = TF.Nil
            , _availability_zones = TF.Nil
            , _az_mode = TF.Nil
            , _cluster_id = TF.Nil
            , _engine = TF.Nil
            , _engine_version = TF.Nil
            , _maintenance_window = TF.Nil
            , _node_type = TF.Nil
            , _notification_topic_arn = TF.Nil
            , _num_cache_nodes = TF.Nil
            , _parameter_group_name = TF.Nil
            , _port = TF.Nil
            , _security_group_ids = TF.Nil
            , _security_group_names = TF.Nil
            , _snapshot_arns = TF.Nil
            , _snapshot_name = TF.Nil
            , _snapshot_retention_limit = TF.Nil
            , _snapshot_window = TF.Nil
            , _subnet_group_name = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_elasticache_parameter_group@ AWS resource.

Provides an ElastiCache parameter group resource.
-}
data ElasticacheParameterGroupResource s = ElasticacheParameterGroupResource {
      _description :: !(TF.Attr s Text)
    {- ^ (Optional) The description of the ElastiCache parameter group. Defaults to "Managed by Terraform". -}
    , _family'     :: !(TF.Attr s Text)
    {- ^ (Required) The family of the ElastiCache parameter group. -}
    , _name        :: !(TF.Attr s Text)
    {- ^ (Required) The name of the ElastiCache parameter group. -}
    , _parameter   :: !(TF.Attr s Text)
    {- ^ (Optional) A list of ElastiCache parameters to apply. -}
    } deriving (Show, Eq)

instance TF.ToHCL (ElasticacheParameterGroupResource s) where
    toHCL ElasticacheParameterGroupResource{..} = TF.inline $ catMaybes
        [ TF.assign "description" <$> TF.attribute _description
        , TF.assign "family" <$> TF.attribute _family'
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "parameter" <$> TF.attribute _parameter
        ]

instance P.HasDescription (ElasticacheParameterGroupResource s) (TF.Attr s Text) where
    description =
        lens (_description :: ElasticacheParameterGroupResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: ElasticacheParameterGroupResource s)

instance P.HasFamily' (ElasticacheParameterGroupResource s) (TF.Attr s Text) where
    family' =
        lens (_family' :: ElasticacheParameterGroupResource s -> TF.Attr s Text)
             (\s a -> s { _family' = a } :: ElasticacheParameterGroupResource s)

instance P.HasName (ElasticacheParameterGroupResource s) (TF.Attr s Text) where
    name =
        lens (_name :: ElasticacheParameterGroupResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: ElasticacheParameterGroupResource s)

instance P.HasParameter (ElasticacheParameterGroupResource s) (TF.Attr s Text) where
    parameter =
        lens (_parameter :: ElasticacheParameterGroupResource s -> TF.Attr s Text)
             (\s a -> s { _parameter = a } :: ElasticacheParameterGroupResource s)

instance P.HasComputedDescription (ElasticacheParameterGroupResource s) s (TF.Attr s Text) where
    computedDescription =
        (_description :: ElasticacheParameterGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedFamily' (ElasticacheParameterGroupResource s) s (TF.Attr s Text) where
    computedFamily' =
        (_family' :: ElasticacheParameterGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (ElasticacheParameterGroupResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (ElasticacheParameterGroupResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: ElasticacheParameterGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedParameter (ElasticacheParameterGroupResource s) s (TF.Attr s Text) where
    computedParameter =
        (_parameter :: ElasticacheParameterGroupResource s -> TF.Attr s Text)
            . TF.refValue

elasticacheParameterGroupResource :: TF.Schema TF.Resource P.AWS (ElasticacheParameterGroupResource s)
elasticacheParameterGroupResource =
    TF.newResource "aws_elasticache_parameter_group" $
        ElasticacheParameterGroupResource {
              _description = TF.Nil
            , _family' = TF.Nil
            , _name = TF.Nil
            , _parameter = TF.Nil
            }

{- | The @aws_elasticache_replication_group@ AWS resource.

Provides an ElastiCache Replication Group resource.
-}
data ElasticacheReplicationGroupResource s = ElasticacheReplicationGroupResource {
      _apply_immediately             :: !(TF.Attr s Text)
    {- ^ (Optional) Specifies whether any modifications are applied immediately, or during the next maintenance window. Default is @false@ . -}
    , _at_rest_encryption_enabled    :: !(TF.Attr s P.Bool)
    {- ^ (Optional) Whether to enable encryption at rest. -}
    , _auth_token                    :: !(TF.Attr s Text)
    {- ^ (Optional) The password used to access a password protected server. Can be specified only if @transit_encryption_enabled = true@ . -}
    , _auto_minor_version_upgrade    :: !(TF.Attr s Text)
    {- ^ (Optional) Specifies whether a minor engine upgrades will be applied automatically to the underlying Cache Cluster instances during the maintenance window. Defaults to @true@ . -}
    , _automatic_failover_enabled    :: !(TF.Attr s P.Bool)
    {- ^ (Optional) Specifies whether a read-only replica will be automatically promoted to read/write primary if the existing primary fails. Defaults to @false@ . -}
    , _availability_zones            :: !(TF.Attr s Text)
    {- ^ (Optional) A list of EC2 availability zones in which the replication group's cache clusters will be created. The order of the availability zones in the list is not important. -}
    , _cluster_mode                  :: !(TF.Attr s Text)
    {- ^ (Optional) Create a native redis cluster. @automatic_failover_enabled@ must be set to true. Cluster Mode documented below. Only 1 @cluster_mode@ block is allowed. -}
    , _engine                        :: !(TF.Attr s Text)
    {- ^ (Optional) The name of the cache engine to be used for the clusters in this replication group. e.g. @redis@ -}
    , _engine_version                :: !(TF.Attr s Text)
    {- ^ (Optional) The version number of the cache engine to be used for the cache clusters in this replication group. -}
    , _maintenance_window            :: !(TF.Attr s Text)
    {- ^ (Optional) Specifies the weekly time range for when maintenance on the cache cluster is performed. The format is @ddd:hh24:mi-ddd:hh24:mi@ (24H Clock UTC). The minimum maintenance window is a 60 minute period. Example: @sun:05:00-sun:09:00@ -}
    , _node_type                     :: !(TF.Attr s Text)
    {- ^ (Required) The compute and memory capacity of the nodes in the node group. -}
    , _notification_topic_arn        :: !(TF.Attr s Text)
    {- ^ (Optional) An Amazon Resource Name (ARN) of an SNS topic to send ElastiCache notifications to. Example: @arn:aws:sns:us-east-1:012345678999:my_sns_topic@ -}
    , _number_cache_clusters         :: !(TF.Attr s Text)
    {- ^ (Required) The number of cache clusters this replication group will have. If Multi-AZ is enabled , the value of this parameter must be at least 2. Changing this number will force a new resource -}
    , _parameter_group_name          :: !(TF.Attr s Text)
    {- ^ (Optional) The name of the parameter group to associate with this replication group. If this argument is omitted, the default cache parameter group for the specified engine is used. -}
    , _port                          :: !(TF.Attr s Text)
    {- ^  (Required) The port number on which each of the cache nodes will accept connections. For Memcache the default is 11211, and for Redis the default port is 6379. -}
    , _replication_group_description :: !(TF.Attr s Text)
    {- ^  (Required) A user-created description for the replication group. -}
    , _replication_group_id          :: !(TF.Attr s Text)
    {- ^  (Required) The replication group identifier. This parameter is stored as a lowercase string. -}
    , _security_group_ids            :: !(TF.Attr s Text)
    {- ^ (Optional) One or more Amazon VPC security groups associated with this replication group. Use this parameter only when you are creating a replication group in an Amazon Virtual Private Cloud -}
    , _security_group_names          :: !(TF.Attr s Text)
    {- ^ (Optional) A list of cache security group names to associate with this replication group. -}
    , _snapshot_arns                 :: !(TF.Attr s Text)
    {- ^ (Optional) A single-element string list containing an Amazon Resource Name (ARN) of a Redis RDB snapshot file stored in Amazon S3. Example: @arn:aws:s3:::my_bucket/snapshot1.rdb@ -}
    , _snapshot_name                 :: !(TF.Attr s Text)
    {- ^ (Optional) The name of a snapshot from which to restore data into the new node group. Changing the @snapshot_name@ forces a new resource. -}
    , _snapshot_retention_limit      :: !(TF.Attr s Text)
    {- ^ (Optional, Redis only) The number of days for which ElastiCache will retain automatic cache cluster snapshots before deleting them. For example, if you set SnapshotRetentionLimit to 5, then a snapshot that was taken today will be retained for 5 days before being deleted. If the value of SnapshotRetentionLimit is set to zero (0), backups are turned off. Please note that setting a @snapshot_retention_limit@ is not supported on cache.t1.micro or cache.t2.* cache nodes -}
    , _snapshot_window               :: !(TF.Attr s Text)
    {- ^ (Optional, Redis only) The daily time range (in UTC) during which ElastiCache will begin taking a daily snapshot of your cache cluster. The minimum snapshot window is a 60 minute period. Example: @05:00-09:00@ -}
    , _subnet_group_name             :: !(TF.Attr s Text)
    {- ^ (Optional) The name of the cache subnet group to be used for the replication group. -}
    , _tags                          :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource -}
    , _transit_encryption_enabled    :: !(TF.Attr s P.Bool)
    {- ^ (Optional) Whether to enable encryption in transit. -}
    } deriving (Show, Eq)

instance TF.ToHCL (ElasticacheReplicationGroupResource s) where
    toHCL ElasticacheReplicationGroupResource{..} = TF.inline $ catMaybes
        [ TF.assign "apply_immediately" <$> TF.attribute _apply_immediately
        , TF.assign "at_rest_encryption_enabled" <$> TF.attribute _at_rest_encryption_enabled
        , TF.assign "auth_token" <$> TF.attribute _auth_token
        , TF.assign "auto_minor_version_upgrade" <$> TF.attribute _auto_minor_version_upgrade
        , TF.assign "automatic_failover_enabled" <$> TF.attribute _automatic_failover_enabled
        , TF.assign "availability_zones" <$> TF.attribute _availability_zones
        , TF.assign "cluster_mode" <$> TF.attribute _cluster_mode
        , TF.assign "engine" <$> TF.attribute _engine
        , TF.assign "engine_version" <$> TF.attribute _engine_version
        , TF.assign "maintenance_window" <$> TF.attribute _maintenance_window
        , TF.assign "node_type" <$> TF.attribute _node_type
        , TF.assign "notification_topic_arn" <$> TF.attribute _notification_topic_arn
        , TF.assign "number_cache_clusters" <$> TF.attribute _number_cache_clusters
        , TF.assign "parameter_group_name" <$> TF.attribute _parameter_group_name
        , TF.assign "port" <$> TF.attribute _port
        , TF.assign "replication_group_description" <$> TF.attribute _replication_group_description
        , TF.assign "replication_group_id" <$> TF.attribute _replication_group_id
        , TF.assign "security_group_ids" <$> TF.attribute _security_group_ids
        , TF.assign "security_group_names" <$> TF.attribute _security_group_names
        , TF.assign "snapshot_arns" <$> TF.attribute _snapshot_arns
        , TF.assign "snapshot_name" <$> TF.attribute _snapshot_name
        , TF.assign "snapshot_retention_limit" <$> TF.attribute _snapshot_retention_limit
        , TF.assign "snapshot_window" <$> TF.attribute _snapshot_window
        , TF.assign "subnet_group_name" <$> TF.attribute _subnet_group_name
        , TF.assign "tags" <$> TF.attribute _tags
        , TF.assign "transit_encryption_enabled" <$> TF.attribute _transit_encryption_enabled
        ]

instance P.HasApplyImmediately (ElasticacheReplicationGroupResource s) (TF.Attr s Text) where
    applyImmediately =
        lens (_apply_immediately :: ElasticacheReplicationGroupResource s -> TF.Attr s Text)
             (\s a -> s { _apply_immediately = a } :: ElasticacheReplicationGroupResource s)

instance P.HasAtRestEncryptionEnabled (ElasticacheReplicationGroupResource s) (TF.Attr s P.Bool) where
    atRestEncryptionEnabled =
        lens (_at_rest_encryption_enabled :: ElasticacheReplicationGroupResource s -> TF.Attr s P.Bool)
             (\s a -> s { _at_rest_encryption_enabled = a } :: ElasticacheReplicationGroupResource s)

instance P.HasAuthToken (ElasticacheReplicationGroupResource s) (TF.Attr s Text) where
    authToken =
        lens (_auth_token :: ElasticacheReplicationGroupResource s -> TF.Attr s Text)
             (\s a -> s { _auth_token = a } :: ElasticacheReplicationGroupResource s)

instance P.HasAutoMinorVersionUpgrade (ElasticacheReplicationGroupResource s) (TF.Attr s Text) where
    autoMinorVersionUpgrade =
        lens (_auto_minor_version_upgrade :: ElasticacheReplicationGroupResource s -> TF.Attr s Text)
             (\s a -> s { _auto_minor_version_upgrade = a } :: ElasticacheReplicationGroupResource s)

instance P.HasAutomaticFailoverEnabled (ElasticacheReplicationGroupResource s) (TF.Attr s P.Bool) where
    automaticFailoverEnabled =
        lens (_automatic_failover_enabled :: ElasticacheReplicationGroupResource s -> TF.Attr s P.Bool)
             (\s a -> s { _automatic_failover_enabled = a } :: ElasticacheReplicationGroupResource s)

instance P.HasAvailabilityZones (ElasticacheReplicationGroupResource s) (TF.Attr s Text) where
    availabilityZones =
        lens (_availability_zones :: ElasticacheReplicationGroupResource s -> TF.Attr s Text)
             (\s a -> s { _availability_zones = a } :: ElasticacheReplicationGroupResource s)

instance P.HasClusterMode (ElasticacheReplicationGroupResource s) (TF.Attr s Text) where
    clusterMode =
        lens (_cluster_mode :: ElasticacheReplicationGroupResource s -> TF.Attr s Text)
             (\s a -> s { _cluster_mode = a } :: ElasticacheReplicationGroupResource s)

instance P.HasEngine (ElasticacheReplicationGroupResource s) (TF.Attr s Text) where
    engine =
        lens (_engine :: ElasticacheReplicationGroupResource s -> TF.Attr s Text)
             (\s a -> s { _engine = a } :: ElasticacheReplicationGroupResource s)

instance P.HasEngineVersion (ElasticacheReplicationGroupResource s) (TF.Attr s Text) where
    engineVersion =
        lens (_engine_version :: ElasticacheReplicationGroupResource s -> TF.Attr s Text)
             (\s a -> s { _engine_version = a } :: ElasticacheReplicationGroupResource s)

instance P.HasMaintenanceWindow (ElasticacheReplicationGroupResource s) (TF.Attr s Text) where
    maintenanceWindow =
        lens (_maintenance_window :: ElasticacheReplicationGroupResource s -> TF.Attr s Text)
             (\s a -> s { _maintenance_window = a } :: ElasticacheReplicationGroupResource s)

instance P.HasNodeType (ElasticacheReplicationGroupResource s) (TF.Attr s Text) where
    nodeType =
        lens (_node_type :: ElasticacheReplicationGroupResource s -> TF.Attr s Text)
             (\s a -> s { _node_type = a } :: ElasticacheReplicationGroupResource s)

instance P.HasNotificationTopicArn (ElasticacheReplicationGroupResource s) (TF.Attr s Text) where
    notificationTopicArn =
        lens (_notification_topic_arn :: ElasticacheReplicationGroupResource s -> TF.Attr s Text)
             (\s a -> s { _notification_topic_arn = a } :: ElasticacheReplicationGroupResource s)

instance P.HasNumberCacheClusters (ElasticacheReplicationGroupResource s) (TF.Attr s Text) where
    numberCacheClusters =
        lens (_number_cache_clusters :: ElasticacheReplicationGroupResource s -> TF.Attr s Text)
             (\s a -> s { _number_cache_clusters = a } :: ElasticacheReplicationGroupResource s)

instance P.HasParameterGroupName (ElasticacheReplicationGroupResource s) (TF.Attr s Text) where
    parameterGroupName =
        lens (_parameter_group_name :: ElasticacheReplicationGroupResource s -> TF.Attr s Text)
             (\s a -> s { _parameter_group_name = a } :: ElasticacheReplicationGroupResource s)

instance P.HasPort (ElasticacheReplicationGroupResource s) (TF.Attr s Text) where
    port =
        lens (_port :: ElasticacheReplicationGroupResource s -> TF.Attr s Text)
             (\s a -> s { _port = a } :: ElasticacheReplicationGroupResource s)

instance P.HasReplicationGroupDescription (ElasticacheReplicationGroupResource s) (TF.Attr s Text) where
    replicationGroupDescription =
        lens (_replication_group_description :: ElasticacheReplicationGroupResource s -> TF.Attr s Text)
             (\s a -> s { _replication_group_description = a } :: ElasticacheReplicationGroupResource s)

instance P.HasReplicationGroupId (ElasticacheReplicationGroupResource s) (TF.Attr s Text) where
    replicationGroupId =
        lens (_replication_group_id :: ElasticacheReplicationGroupResource s -> TF.Attr s Text)
             (\s a -> s { _replication_group_id = a } :: ElasticacheReplicationGroupResource s)

instance P.HasSecurityGroupIds (ElasticacheReplicationGroupResource s) (TF.Attr s Text) where
    securityGroupIds =
        lens (_security_group_ids :: ElasticacheReplicationGroupResource s -> TF.Attr s Text)
             (\s a -> s { _security_group_ids = a } :: ElasticacheReplicationGroupResource s)

instance P.HasSecurityGroupNames (ElasticacheReplicationGroupResource s) (TF.Attr s Text) where
    securityGroupNames =
        lens (_security_group_names :: ElasticacheReplicationGroupResource s -> TF.Attr s Text)
             (\s a -> s { _security_group_names = a } :: ElasticacheReplicationGroupResource s)

instance P.HasSnapshotArns (ElasticacheReplicationGroupResource s) (TF.Attr s Text) where
    snapshotArns =
        lens (_snapshot_arns :: ElasticacheReplicationGroupResource s -> TF.Attr s Text)
             (\s a -> s { _snapshot_arns = a } :: ElasticacheReplicationGroupResource s)

instance P.HasSnapshotName (ElasticacheReplicationGroupResource s) (TF.Attr s Text) where
    snapshotName =
        lens (_snapshot_name :: ElasticacheReplicationGroupResource s -> TF.Attr s Text)
             (\s a -> s { _snapshot_name = a } :: ElasticacheReplicationGroupResource s)

instance P.HasSnapshotRetentionLimit (ElasticacheReplicationGroupResource s) (TF.Attr s Text) where
    snapshotRetentionLimit =
        lens (_snapshot_retention_limit :: ElasticacheReplicationGroupResource s -> TF.Attr s Text)
             (\s a -> s { _snapshot_retention_limit = a } :: ElasticacheReplicationGroupResource s)

instance P.HasSnapshotWindow (ElasticacheReplicationGroupResource s) (TF.Attr s Text) where
    snapshotWindow =
        lens (_snapshot_window :: ElasticacheReplicationGroupResource s -> TF.Attr s Text)
             (\s a -> s { _snapshot_window = a } :: ElasticacheReplicationGroupResource s)

instance P.HasSubnetGroupName (ElasticacheReplicationGroupResource s) (TF.Attr s Text) where
    subnetGroupName =
        lens (_subnet_group_name :: ElasticacheReplicationGroupResource s -> TF.Attr s Text)
             (\s a -> s { _subnet_group_name = a } :: ElasticacheReplicationGroupResource s)

instance P.HasTags (ElasticacheReplicationGroupResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: ElasticacheReplicationGroupResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: ElasticacheReplicationGroupResource s)

instance P.HasTransitEncryptionEnabled (ElasticacheReplicationGroupResource s) (TF.Attr s P.Bool) where
    transitEncryptionEnabled =
        lens (_transit_encryption_enabled :: ElasticacheReplicationGroupResource s -> TF.Attr s P.Bool)
             (\s a -> s { _transit_encryption_enabled = a } :: ElasticacheReplicationGroupResource s)

instance P.HasComputedApplyImmediately (ElasticacheReplicationGroupResource s) s (TF.Attr s Text) where
    computedApplyImmediately =
        (_apply_immediately :: ElasticacheReplicationGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAtRestEncryptionEnabled (ElasticacheReplicationGroupResource s) s (TF.Attr s P.Bool) where
    computedAtRestEncryptionEnabled =
        (_at_rest_encryption_enabled :: ElasticacheReplicationGroupResource s -> TF.Attr s P.Bool)
            . TF.refValue

instance P.HasComputedAuthToken (ElasticacheReplicationGroupResource s) s (TF.Attr s Text) where
    computedAuthToken =
        (_auth_token :: ElasticacheReplicationGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAutoMinorVersionUpgrade (ElasticacheReplicationGroupResource s) s (TF.Attr s Text) where
    computedAutoMinorVersionUpgrade =
        (_auto_minor_version_upgrade :: ElasticacheReplicationGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAutomaticFailoverEnabled (ElasticacheReplicationGroupResource s) s (TF.Attr s P.Bool) where
    computedAutomaticFailoverEnabled =
        (_automatic_failover_enabled :: ElasticacheReplicationGroupResource s -> TF.Attr s P.Bool)
            . TF.refValue

instance P.HasComputedAvailabilityZones (ElasticacheReplicationGroupResource s) s (TF.Attr s Text) where
    computedAvailabilityZones =
        (_availability_zones :: ElasticacheReplicationGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedClusterMode (ElasticacheReplicationGroupResource s) s (TF.Attr s Text) where
    computedClusterMode =
        (_cluster_mode :: ElasticacheReplicationGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedConfigurationEndpointAddress (ElasticacheReplicationGroupResource s) s (TF.Attr s Text) where
    computedConfigurationEndpointAddress x = TF.compute (TF.refKey x) "configuration_endpoint_address"

instance P.HasComputedEngine (ElasticacheReplicationGroupResource s) s (TF.Attr s Text) where
    computedEngine =
        (_engine :: ElasticacheReplicationGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEngineVersion (ElasticacheReplicationGroupResource s) s (TF.Attr s Text) where
    computedEngineVersion =
        (_engine_version :: ElasticacheReplicationGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (ElasticacheReplicationGroupResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedMaintenanceWindow (ElasticacheReplicationGroupResource s) s (TF.Attr s Text) where
    computedMaintenanceWindow =
        (_maintenance_window :: ElasticacheReplicationGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedNodeType (ElasticacheReplicationGroupResource s) s (TF.Attr s Text) where
    computedNodeType =
        (_node_type :: ElasticacheReplicationGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedNotificationTopicArn (ElasticacheReplicationGroupResource s) s (TF.Attr s Text) where
    computedNotificationTopicArn =
        (_notification_topic_arn :: ElasticacheReplicationGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedNumberCacheClusters (ElasticacheReplicationGroupResource s) s (TF.Attr s Text) where
    computedNumberCacheClusters =
        (_number_cache_clusters :: ElasticacheReplicationGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedParameterGroupName (ElasticacheReplicationGroupResource s) s (TF.Attr s Text) where
    computedParameterGroupName =
        (_parameter_group_name :: ElasticacheReplicationGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPort (ElasticacheReplicationGroupResource s) s (TF.Attr s Text) where
    computedPort =
        (_port :: ElasticacheReplicationGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPrimaryEndpointAddress (ElasticacheReplicationGroupResource s) s (TF.Attr s Text) where
    computedPrimaryEndpointAddress x = TF.compute (TF.refKey x) "primary_endpoint_address"

instance P.HasComputedReplicationGroupDescription (ElasticacheReplicationGroupResource s) s (TF.Attr s Text) where
    computedReplicationGroupDescription =
        (_replication_group_description :: ElasticacheReplicationGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedReplicationGroupId (ElasticacheReplicationGroupResource s) s (TF.Attr s Text) where
    computedReplicationGroupId =
        (_replication_group_id :: ElasticacheReplicationGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSecurityGroupIds (ElasticacheReplicationGroupResource s) s (TF.Attr s Text) where
    computedSecurityGroupIds =
        (_security_group_ids :: ElasticacheReplicationGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSecurityGroupNames (ElasticacheReplicationGroupResource s) s (TF.Attr s Text) where
    computedSecurityGroupNames =
        (_security_group_names :: ElasticacheReplicationGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSnapshotArns (ElasticacheReplicationGroupResource s) s (TF.Attr s Text) where
    computedSnapshotArns =
        (_snapshot_arns :: ElasticacheReplicationGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSnapshotName (ElasticacheReplicationGroupResource s) s (TF.Attr s Text) where
    computedSnapshotName =
        (_snapshot_name :: ElasticacheReplicationGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSnapshotRetentionLimit (ElasticacheReplicationGroupResource s) s (TF.Attr s Text) where
    computedSnapshotRetentionLimit =
        (_snapshot_retention_limit :: ElasticacheReplicationGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSnapshotWindow (ElasticacheReplicationGroupResource s) s (TF.Attr s Text) where
    computedSnapshotWindow =
        (_snapshot_window :: ElasticacheReplicationGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSubnetGroupName (ElasticacheReplicationGroupResource s) s (TF.Attr s Text) where
    computedSubnetGroupName =
        (_subnet_group_name :: ElasticacheReplicationGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (ElasticacheReplicationGroupResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: ElasticacheReplicationGroupResource s -> TF.Attr s P.Tags)
            . TF.refValue

instance P.HasComputedTransitEncryptionEnabled (ElasticacheReplicationGroupResource s) s (TF.Attr s P.Bool) where
    computedTransitEncryptionEnabled =
        (_transit_encryption_enabled :: ElasticacheReplicationGroupResource s -> TF.Attr s P.Bool)
            . TF.refValue

elasticacheReplicationGroupResource :: TF.Schema TF.Resource P.AWS (ElasticacheReplicationGroupResource s)
elasticacheReplicationGroupResource =
    TF.newResource "aws_elasticache_replication_group" $
        ElasticacheReplicationGroupResource {
              _apply_immediately = TF.Nil
            , _at_rest_encryption_enabled = TF.Nil
            , _auth_token = TF.Nil
            , _auto_minor_version_upgrade = TF.Nil
            , _automatic_failover_enabled = TF.Nil
            , _availability_zones = TF.Nil
            , _cluster_mode = TF.Nil
            , _engine = TF.Nil
            , _engine_version = TF.Nil
            , _maintenance_window = TF.Nil
            , _node_type = TF.Nil
            , _notification_topic_arn = TF.Nil
            , _number_cache_clusters = TF.Nil
            , _parameter_group_name = TF.Nil
            , _port = TF.Nil
            , _replication_group_description = TF.Nil
            , _replication_group_id = TF.Nil
            , _security_group_ids = TF.Nil
            , _security_group_names = TF.Nil
            , _snapshot_arns = TF.Nil
            , _snapshot_name = TF.Nil
            , _snapshot_retention_limit = TF.Nil
            , _snapshot_window = TF.Nil
            , _subnet_group_name = TF.Nil
            , _tags = TF.Nil
            , _transit_encryption_enabled = TF.Nil
            }

{- | The @aws_elasticache_security_group@ AWS resource.

Provides an ElastiCache Security Group to control access to one or more
cache clusters. ~> NOTE: ElastiCache Security Groups are for use only when
working with an ElastiCache cluster outside of a VPC. If you are using a
VPC, see the <elasticache_subnet_group.html> .
-}
data ElasticacheSecurityGroupResource s = ElasticacheSecurityGroupResource {
      _description          :: !(TF.Attr s Text)
    {- ^  (Optional) description for the cache security group. Defaults to "Managed by Terraform". -}
    , _name                 :: !(TF.Attr s Text)
    {- ^  (Required) Name for the cache security group. This value is stored as a lowercase string. -}
    , _security_group_names :: !(TF.Attr s Text)
    {- ^  (Required) List of EC2 security group names to be authorized for ingress to the cache security group -}
    } deriving (Show, Eq)

instance TF.ToHCL (ElasticacheSecurityGroupResource s) where
    toHCL ElasticacheSecurityGroupResource{..} = TF.inline $ catMaybes
        [ TF.assign "description" <$> TF.attribute _description
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "security_group_names" <$> TF.attribute _security_group_names
        ]

instance P.HasDescription (ElasticacheSecurityGroupResource s) (TF.Attr s Text) where
    description =
        lens (_description :: ElasticacheSecurityGroupResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: ElasticacheSecurityGroupResource s)

instance P.HasName (ElasticacheSecurityGroupResource s) (TF.Attr s Text) where
    name =
        lens (_name :: ElasticacheSecurityGroupResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: ElasticacheSecurityGroupResource s)

instance P.HasSecurityGroupNames (ElasticacheSecurityGroupResource s) (TF.Attr s Text) where
    securityGroupNames =
        lens (_security_group_names :: ElasticacheSecurityGroupResource s -> TF.Attr s Text)
             (\s a -> s { _security_group_names = a } :: ElasticacheSecurityGroupResource s)

instance P.HasComputedDescription (ElasticacheSecurityGroupResource s) s (TF.Attr s Text) where
    computedDescription =
        (_description :: ElasticacheSecurityGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (ElasticacheSecurityGroupResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: ElasticacheSecurityGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSecurityGroupNames (ElasticacheSecurityGroupResource s) s (TF.Attr s Text) where
    computedSecurityGroupNames =
        (_security_group_names :: ElasticacheSecurityGroupResource s -> TF.Attr s Text)
            . TF.refValue

elasticacheSecurityGroupResource :: TF.Schema TF.Resource P.AWS (ElasticacheSecurityGroupResource s)
elasticacheSecurityGroupResource =
    TF.newResource "aws_elasticache_security_group" $
        ElasticacheSecurityGroupResource {
              _description = TF.Nil
            , _name = TF.Nil
            , _security_group_names = TF.Nil
            }

{- | The @aws_elasticache_subnet_group@ AWS resource.

Provides an ElastiCache Subnet Group resource. ~> NOTE: ElastiCache Subnet
Groups are only for use when working with an ElastiCache cluster inside of a
VPC. If you are on EC2 Classic, see the <elasticache_security_group.html> .
-}
data ElasticacheSubnetGroupResource s = ElasticacheSubnetGroupResource {
      _description :: !(TF.Attr s Text)
    {- ^  (Optional) Description for the cache subnet group. Defaults to "Managed by Terraform". -}
    , _name        :: !(TF.Attr s Text)
    {- ^  (Required) Name for the cache subnet group. Elasticache converts this name to lowercase. -}
    , _subnet_ids  :: !(TF.Attr s Text)
    {- ^  (Required) List of VPC Subnet IDs for the cache subnet group -}
    } deriving (Show, Eq)

instance TF.ToHCL (ElasticacheSubnetGroupResource s) where
    toHCL ElasticacheSubnetGroupResource{..} = TF.inline $ catMaybes
        [ TF.assign "description" <$> TF.attribute _description
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "subnet_ids" <$> TF.attribute _subnet_ids
        ]

instance P.HasDescription (ElasticacheSubnetGroupResource s) (TF.Attr s Text) where
    description =
        lens (_description :: ElasticacheSubnetGroupResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: ElasticacheSubnetGroupResource s)

instance P.HasName (ElasticacheSubnetGroupResource s) (TF.Attr s Text) where
    name =
        lens (_name :: ElasticacheSubnetGroupResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: ElasticacheSubnetGroupResource s)

instance P.HasSubnetIds (ElasticacheSubnetGroupResource s) (TF.Attr s Text) where
    subnetIds =
        lens (_subnet_ids :: ElasticacheSubnetGroupResource s -> TF.Attr s Text)
             (\s a -> s { _subnet_ids = a } :: ElasticacheSubnetGroupResource s)

instance P.HasComputedDescription (ElasticacheSubnetGroupResource s) s (TF.Attr s Text) where
    computedDescription =
        (_description :: ElasticacheSubnetGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (ElasticacheSubnetGroupResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: ElasticacheSubnetGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSubnetIds (ElasticacheSubnetGroupResource s) s (TF.Attr s Text) where
    computedSubnetIds =
        (_subnet_ids :: ElasticacheSubnetGroupResource s -> TF.Attr s Text)
            . TF.refValue

elasticacheSubnetGroupResource :: TF.Schema TF.Resource P.AWS (ElasticacheSubnetGroupResource s)
elasticacheSubnetGroupResource =
    TF.newResource "aws_elasticache_subnet_group" $
        ElasticacheSubnetGroupResource {
              _description = TF.Nil
            , _name = TF.Nil
            , _subnet_ids = TF.Nil
            }

{- | The @aws_elasticsearch_domain_policy@ AWS resource.

Allows setting policy to an ElasticSearch domain while referencing domain
attributes (e.g. ARN)
-}
data ElasticsearchDomainPolicyResource s = ElasticsearchDomainPolicyResource {
      _access_policies :: !(TF.Attr s Text)
    {- ^ (Optional) IAM policy document specifying the access policies for the domain -}
    , _domain_name     :: !(TF.Attr s Text)
    {- ^ (Required) Name of the domain. -}
    } deriving (Show, Eq)

instance TF.ToHCL (ElasticsearchDomainPolicyResource s) where
    toHCL ElasticsearchDomainPolicyResource{..} = TF.inline $ catMaybes
        [ TF.assign "access_policies" <$> TF.attribute _access_policies
        , TF.assign "domain_name" <$> TF.attribute _domain_name
        ]

instance P.HasAccessPolicies (ElasticsearchDomainPolicyResource s) (TF.Attr s Text) where
    accessPolicies =
        lens (_access_policies :: ElasticsearchDomainPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _access_policies = a } :: ElasticsearchDomainPolicyResource s)

instance P.HasDomainName (ElasticsearchDomainPolicyResource s) (TF.Attr s Text) where
    domainName =
        lens (_domain_name :: ElasticsearchDomainPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _domain_name = a } :: ElasticsearchDomainPolicyResource s)

instance P.HasComputedAccessPolicies (ElasticsearchDomainPolicyResource s) s (TF.Attr s Text) where
    computedAccessPolicies =
        (_access_policies :: ElasticsearchDomainPolicyResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDomainName (ElasticsearchDomainPolicyResource s) s (TF.Attr s Text) where
    computedDomainName =
        (_domain_name :: ElasticsearchDomainPolicyResource s -> TF.Attr s Text)
            . TF.refValue

elasticsearchDomainPolicyResource :: TF.Schema TF.Resource P.AWS (ElasticsearchDomainPolicyResource s)
elasticsearchDomainPolicyResource =
    TF.newResource "aws_elasticsearch_domain_policy" $
        ElasticsearchDomainPolicyResource {
              _access_policies = TF.Nil
            , _domain_name = TF.Nil
            }

{- | The @aws_elasticsearch_domain@ AWS resource.


-}
data ElasticsearchDomainResource s = ElasticsearchDomainResource {
      _access_policies        :: !(TF.Attr s Text)
    {- ^ (Optional) IAM policy document specifying the access policies for the domain -}
    , _advanced_options       :: !(TF.Attr s Text)
    {- ^ (Optional) Key-value string pairs to specify advanced configuration options. -}
    , _cluster_config         :: !(TF.Attr s Text)
    {- ^ (Optional) Cluster configuration of the domain, see below. -}
    , _domain_name            :: !(TF.Attr s Text)
    {- ^ (Required) Name of the domain. -}
    , _ebs_options            :: !(TF.Attr s Text)
    {- ^ (Optional) EBS related options, may be required based on chosen <https://aws.amazon.com/elasticsearch-service/pricing/> . See below. -}
    , _elasticsearch_version  :: !(TF.Attr s Text)
    {- ^ (Optional) The version of ElasticSearch to deploy. Defaults to @1.5@ -}
    , _encrypt_at_rest        :: !(TF.Attr s Text)
    {- ^ (Optional) Encrypt at rest options. Only available for <http://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/aes-supported-instance-types.html> . See below. -}
    , _log_publishing_options :: !(TF.Attr s Text)
    {- ^ (Optional) Options for publishing slow logs to CloudWatch Logs. -}
    , _snapshot_options       :: !(TF.Attr s Text)
    {- ^ (Optional) Snapshot related options, see below. -}
    , _tags                   :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource -}
    , _vpc_options            :: !(TF.Attr s Text)
    {- ^ (Optional) VPC related options, see below. Adding or removing this configuration forces a new resource ( <https://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-vpc.html#es-vpc-limitations> ). -}
    } deriving (Show, Eq)

instance TF.ToHCL (ElasticsearchDomainResource s) where
    toHCL ElasticsearchDomainResource{..} = TF.inline $ catMaybes
        [ TF.assign "access_policies" <$> TF.attribute _access_policies
        , TF.assign "advanced_options" <$> TF.attribute _advanced_options
        , TF.assign "cluster_config" <$> TF.attribute _cluster_config
        , TF.assign "domain_name" <$> TF.attribute _domain_name
        , TF.assign "ebs_options" <$> TF.attribute _ebs_options
        , TF.assign "elasticsearch_version" <$> TF.attribute _elasticsearch_version
        , TF.assign "encrypt_at_rest" <$> TF.attribute _encrypt_at_rest
        , TF.assign "log_publishing_options" <$> TF.attribute _log_publishing_options
        , TF.assign "snapshot_options" <$> TF.attribute _snapshot_options
        , TF.assign "tags" <$> TF.attribute _tags
        , TF.assign "vpc_options" <$> TF.attribute _vpc_options
        ]

instance P.HasAccessPolicies (ElasticsearchDomainResource s) (TF.Attr s Text) where
    accessPolicies =
        lens (_access_policies :: ElasticsearchDomainResource s -> TF.Attr s Text)
             (\s a -> s { _access_policies = a } :: ElasticsearchDomainResource s)

instance P.HasAdvancedOptions (ElasticsearchDomainResource s) (TF.Attr s Text) where
    advancedOptions =
        lens (_advanced_options :: ElasticsearchDomainResource s -> TF.Attr s Text)
             (\s a -> s { _advanced_options = a } :: ElasticsearchDomainResource s)

instance P.HasClusterConfig (ElasticsearchDomainResource s) (TF.Attr s Text) where
    clusterConfig =
        lens (_cluster_config :: ElasticsearchDomainResource s -> TF.Attr s Text)
             (\s a -> s { _cluster_config = a } :: ElasticsearchDomainResource s)

instance P.HasDomainName (ElasticsearchDomainResource s) (TF.Attr s Text) where
    domainName =
        lens (_domain_name :: ElasticsearchDomainResource s -> TF.Attr s Text)
             (\s a -> s { _domain_name = a } :: ElasticsearchDomainResource s)

instance P.HasEbsOptions (ElasticsearchDomainResource s) (TF.Attr s Text) where
    ebsOptions =
        lens (_ebs_options :: ElasticsearchDomainResource s -> TF.Attr s Text)
             (\s a -> s { _ebs_options = a } :: ElasticsearchDomainResource s)

instance P.HasElasticsearchVersion (ElasticsearchDomainResource s) (TF.Attr s Text) where
    elasticsearchVersion =
        lens (_elasticsearch_version :: ElasticsearchDomainResource s -> TF.Attr s Text)
             (\s a -> s { _elasticsearch_version = a } :: ElasticsearchDomainResource s)

instance P.HasEncryptAtRest (ElasticsearchDomainResource s) (TF.Attr s Text) where
    encryptAtRest =
        lens (_encrypt_at_rest :: ElasticsearchDomainResource s -> TF.Attr s Text)
             (\s a -> s { _encrypt_at_rest = a } :: ElasticsearchDomainResource s)

instance P.HasLogPublishingOptions (ElasticsearchDomainResource s) (TF.Attr s Text) where
    logPublishingOptions =
        lens (_log_publishing_options :: ElasticsearchDomainResource s -> TF.Attr s Text)
             (\s a -> s { _log_publishing_options = a } :: ElasticsearchDomainResource s)

instance P.HasSnapshotOptions (ElasticsearchDomainResource s) (TF.Attr s Text) where
    snapshotOptions =
        lens (_snapshot_options :: ElasticsearchDomainResource s -> TF.Attr s Text)
             (\s a -> s { _snapshot_options = a } :: ElasticsearchDomainResource s)

instance P.HasTags (ElasticsearchDomainResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: ElasticsearchDomainResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: ElasticsearchDomainResource s)

instance P.HasVpcOptions (ElasticsearchDomainResource s) (TF.Attr s Text) where
    vpcOptions =
        lens (_vpc_options :: ElasticsearchDomainResource s -> TF.Attr s Text)
             (\s a -> s { _vpc_options = a } :: ElasticsearchDomainResource s)

instance P.HasComputedAccessPolicies (ElasticsearchDomainResource s) s (TF.Attr s Text) where
    computedAccessPolicies =
        (_access_policies :: ElasticsearchDomainResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAdvancedOptions (ElasticsearchDomainResource s) s (TF.Attr s Text) where
    computedAdvancedOptions =
        (_advanced_options :: ElasticsearchDomainResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedArn (ElasticsearchDomainResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedClusterConfig (ElasticsearchDomainResource s) s (TF.Attr s Text) where
    computedClusterConfig =
        (_cluster_config :: ElasticsearchDomainResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDomainId (ElasticsearchDomainResource s) s (TF.Attr s Text) where
    computedDomainId x = TF.compute (TF.refKey x) "domain_id"

instance P.HasComputedDomainName (ElasticsearchDomainResource s) s (TF.Attr s Text) where
    computedDomainName =
        (_domain_name :: ElasticsearchDomainResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEbsOptions (ElasticsearchDomainResource s) s (TF.Attr s Text) where
    computedEbsOptions =
        (_ebs_options :: ElasticsearchDomainResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedElasticsearchVersion (ElasticsearchDomainResource s) s (TF.Attr s Text) where
    computedElasticsearchVersion =
        (_elasticsearch_version :: ElasticsearchDomainResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEncryptAtRest (ElasticsearchDomainResource s) s (TF.Attr s Text) where
    computedEncryptAtRest =
        (_encrypt_at_rest :: ElasticsearchDomainResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEndpoint (ElasticsearchDomainResource s) s (TF.Attr s Text) where
    computedEndpoint x = TF.compute (TF.refKey x) "endpoint"

instance P.HasComputedKibanaEndpoint (ElasticsearchDomainResource s) s (TF.Attr s Text) where
    computedKibanaEndpoint x = TF.compute (TF.refKey x) "kibana_endpoint"

instance P.HasComputedLogPublishingOptions (ElasticsearchDomainResource s) s (TF.Attr s Text) where
    computedLogPublishingOptions =
        (_log_publishing_options :: ElasticsearchDomainResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSnapshotOptions (ElasticsearchDomainResource s) s (TF.Attr s Text) where
    computedSnapshotOptions =
        (_snapshot_options :: ElasticsearchDomainResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (ElasticsearchDomainResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: ElasticsearchDomainResource s -> TF.Attr s P.Tags)
            . TF.refValue

instance P.HasComputedVpcOptions (ElasticsearchDomainResource s) s (TF.Attr s Text) where
    computedVpcOptions =
        (_vpc_options :: ElasticsearchDomainResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedVpcOptions0AvailabilityZones (ElasticsearchDomainResource s) s (TF.Attr s Text) where
    computedVpcOptions0AvailabilityZones x = TF.compute (TF.refKey x) "vpc_options.0.availability_zones"

instance P.HasComputedVpcOptions0VpcId (ElasticsearchDomainResource s) s (TF.Attr s Text) where
    computedVpcOptions0VpcId x = TF.compute (TF.refKey x) "vpc_options.0.vpc_id"

elasticsearchDomainResource :: TF.Schema TF.Resource P.AWS (ElasticsearchDomainResource s)
elasticsearchDomainResource =
    TF.newResource "aws_elasticsearch_domain" $
        ElasticsearchDomainResource {
              _access_policies = TF.Nil
            , _advanced_options = TF.Nil
            , _cluster_config = TF.Nil
            , _domain_name = TF.Nil
            , _ebs_options = TF.Nil
            , _elasticsearch_version = TF.Nil
            , _encrypt_at_rest = TF.Nil
            , _log_publishing_options = TF.Nil
            , _snapshot_options = TF.Nil
            , _tags = TF.Nil
            , _vpc_options = TF.Nil
            }

{- | The @aws_elastictranscoder_pipeline@ AWS resource.

Provides an Elastic Transcoder pipeline resource.
-}
data ElastictranscoderPipelineResource s = ElastictranscoderPipelineResource {
      _aws_kms_key_arn              :: !(TF.Attr s Text)
    {- ^ (Optional) The AWS Key Management Service (AWS KMS) key that you want to use with this pipeline. -}
    , _content_config               :: !(TF.Attr s Text)
    {- ^ (Optional) The ContentConfig object specifies information about the Amazon S3 bucket in which you want Elastic Transcoder to save transcoded files and playlists. (documented below) -}
    , _content_config_permissions   :: !(TF.Attr s Text)
    {- ^ (Optional) The permissions for the @content_config@ object. (documented below) -}
    , _input_bucket                 :: !(TF.Attr s Text)
    {- ^ (Required) The Amazon S3 bucket in which you saved the media files that you want to transcode and the graphics that you want to use as watermarks. -}
    , _name                         :: !(TF.Attr s Text)
    {- ^ (Optional, Forces new resource) The name of the pipeline. Maximum 40 characters -}
    , _notifications                :: !(TF.Attr s Text)
    {- ^ (Optional) The Amazon Simple Notification Service (Amazon SNS) topic that you want to notify to report job status. (documented below) -}
    , _output_bucket                :: !(TF.Attr s Text)
    {- ^ (Optional) The Amazon S3 bucket in which you want Elastic Transcoder to save the transcoded files. -}
    , _role                         :: !(TF.Attr s Text)
    {- ^ (Required) The IAM Amazon Resource Name (ARN) for the role that you want Elastic Transcoder to use to transcode jobs for this pipeline. -}
    , _thumbnail_config             :: !(TF.Attr s Text)
    {- ^ (Optional) The ThumbnailConfig object specifies information about the Amazon S3 bucket in which you want Elastic Transcoder to save thumbnail files. (documented below) -}
    , _thumbnail_config_permissions :: !(TF.Attr s Text)
    {- ^ (Optional) The permissions for the @thumbnail_config@ object. (documented below) -}
    } deriving (Show, Eq)

instance TF.ToHCL (ElastictranscoderPipelineResource s) where
    toHCL ElastictranscoderPipelineResource{..} = TF.inline $ catMaybes
        [ TF.assign "aws_kms_key_arn" <$> TF.attribute _aws_kms_key_arn
        , TF.assign "content_config" <$> TF.attribute _content_config
        , TF.assign "content_config_permissions" <$> TF.attribute _content_config_permissions
        , TF.assign "input_bucket" <$> TF.attribute _input_bucket
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "notifications" <$> TF.attribute _notifications
        , TF.assign "output_bucket" <$> TF.attribute _output_bucket
        , TF.assign "role" <$> TF.attribute _role
        , TF.assign "thumbnail_config" <$> TF.attribute _thumbnail_config
        , TF.assign "thumbnail_config_permissions" <$> TF.attribute _thumbnail_config_permissions
        ]

instance P.HasAwsKmsKeyArn (ElastictranscoderPipelineResource s) (TF.Attr s Text) where
    awsKmsKeyArn =
        lens (_aws_kms_key_arn :: ElastictranscoderPipelineResource s -> TF.Attr s Text)
             (\s a -> s { _aws_kms_key_arn = a } :: ElastictranscoderPipelineResource s)

instance P.HasContentConfig (ElastictranscoderPipelineResource s) (TF.Attr s Text) where
    contentConfig =
        lens (_content_config :: ElastictranscoderPipelineResource s -> TF.Attr s Text)
             (\s a -> s { _content_config = a } :: ElastictranscoderPipelineResource s)

instance P.HasContentConfigPermissions (ElastictranscoderPipelineResource s) (TF.Attr s Text) where
    contentConfigPermissions =
        lens (_content_config_permissions :: ElastictranscoderPipelineResource s -> TF.Attr s Text)
             (\s a -> s { _content_config_permissions = a } :: ElastictranscoderPipelineResource s)

instance P.HasInputBucket (ElastictranscoderPipelineResource s) (TF.Attr s Text) where
    inputBucket =
        lens (_input_bucket :: ElastictranscoderPipelineResource s -> TF.Attr s Text)
             (\s a -> s { _input_bucket = a } :: ElastictranscoderPipelineResource s)

instance P.HasName (ElastictranscoderPipelineResource s) (TF.Attr s Text) where
    name =
        lens (_name :: ElastictranscoderPipelineResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: ElastictranscoderPipelineResource s)

instance P.HasNotifications (ElastictranscoderPipelineResource s) (TF.Attr s Text) where
    notifications =
        lens (_notifications :: ElastictranscoderPipelineResource s -> TF.Attr s Text)
             (\s a -> s { _notifications = a } :: ElastictranscoderPipelineResource s)

instance P.HasOutputBucket (ElastictranscoderPipelineResource s) (TF.Attr s Text) where
    outputBucket =
        lens (_output_bucket :: ElastictranscoderPipelineResource s -> TF.Attr s Text)
             (\s a -> s { _output_bucket = a } :: ElastictranscoderPipelineResource s)

instance P.HasRole (ElastictranscoderPipelineResource s) (TF.Attr s Text) where
    role =
        lens (_role :: ElastictranscoderPipelineResource s -> TF.Attr s Text)
             (\s a -> s { _role = a } :: ElastictranscoderPipelineResource s)

instance P.HasThumbnailConfig (ElastictranscoderPipelineResource s) (TF.Attr s Text) where
    thumbnailConfig =
        lens (_thumbnail_config :: ElastictranscoderPipelineResource s -> TF.Attr s Text)
             (\s a -> s { _thumbnail_config = a } :: ElastictranscoderPipelineResource s)

instance P.HasThumbnailConfigPermissions (ElastictranscoderPipelineResource s) (TF.Attr s Text) where
    thumbnailConfigPermissions =
        lens (_thumbnail_config_permissions :: ElastictranscoderPipelineResource s -> TF.Attr s Text)
             (\s a -> s { _thumbnail_config_permissions = a } :: ElastictranscoderPipelineResource s)

instance P.HasComputedAwsKmsKeyArn (ElastictranscoderPipelineResource s) s (TF.Attr s Text) where
    computedAwsKmsKeyArn =
        (_aws_kms_key_arn :: ElastictranscoderPipelineResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedContentConfig (ElastictranscoderPipelineResource s) s (TF.Attr s Text) where
    computedContentConfig =
        (_content_config :: ElastictranscoderPipelineResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedContentConfigPermissions (ElastictranscoderPipelineResource s) s (TF.Attr s Text) where
    computedContentConfigPermissions =
        (_content_config_permissions :: ElastictranscoderPipelineResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedInputBucket (ElastictranscoderPipelineResource s) s (TF.Attr s Text) where
    computedInputBucket =
        (_input_bucket :: ElastictranscoderPipelineResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (ElastictranscoderPipelineResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: ElastictranscoderPipelineResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedNotifications (ElastictranscoderPipelineResource s) s (TF.Attr s Text) where
    computedNotifications =
        (_notifications :: ElastictranscoderPipelineResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedOutputBucket (ElastictranscoderPipelineResource s) s (TF.Attr s Text) where
    computedOutputBucket =
        (_output_bucket :: ElastictranscoderPipelineResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRole (ElastictranscoderPipelineResource s) s (TF.Attr s Text) where
    computedRole =
        (_role :: ElastictranscoderPipelineResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedThumbnailConfig (ElastictranscoderPipelineResource s) s (TF.Attr s Text) where
    computedThumbnailConfig =
        (_thumbnail_config :: ElastictranscoderPipelineResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedThumbnailConfigPermissions (ElastictranscoderPipelineResource s) s (TF.Attr s Text) where
    computedThumbnailConfigPermissions =
        (_thumbnail_config_permissions :: ElastictranscoderPipelineResource s -> TF.Attr s Text)
            . TF.refValue

elastictranscoderPipelineResource :: TF.Schema TF.Resource P.AWS (ElastictranscoderPipelineResource s)
elastictranscoderPipelineResource =
    TF.newResource "aws_elastictranscoder_pipeline" $
        ElastictranscoderPipelineResource {
              _aws_kms_key_arn = TF.Nil
            , _content_config = TF.Nil
            , _content_config_permissions = TF.Nil
            , _input_bucket = TF.Nil
            , _name = TF.Nil
            , _notifications = TF.Nil
            , _output_bucket = TF.Nil
            , _role = TF.Nil
            , _thumbnail_config = TF.Nil
            , _thumbnail_config_permissions = TF.Nil
            }

{- | The @aws_elastictranscoder_preset@ AWS resource.

Provides an Elastic Transcoder preset resource.
-}
data ElastictranscoderPresetResource s = ElastictranscoderPresetResource {
      _audio               :: !(TF.Attr s Text)
    {- ^ (Optional, Forces new resource) Audio parameters object (documented below). -}
    , _audio_codec_options :: !(TF.Attr s Text)
    {- ^ (Optional, Forces new resource) Codec options for the audio parameters (documented below) -}
    , _container           :: !(TF.Attr s Text)
    {- ^ (Required, Forces new resource) The container type for the output file. Valid values are @flac@ , @flv@ , @fmp4@ , @gif@ , @mp3@ , @mp4@ , @mpg@ , @mxf@ , @oga@ , @ogg@ , @ts@ , and @webm@ . -}
    , _description         :: !(TF.Attr s Text)
    {- ^ (Optional, Forces new resource) A description of the preset (maximum 255 characters) -}
    , _name                :: !(TF.Attr s Text)
    {- ^ (Optional, Forces new resource) The name of the preset. (maximum 40 characters) -}
    , _thumbnails          :: !(TF.Attr s Text)
    {- ^ (Optional, Forces new resource) Thumbnail parameters object (documented below) -}
    , _video               :: !(TF.Attr s Text)
    {- ^ (Optional, Forces new resource) Video parameters object (documented below) -}
    , _video_codec_options :: !(TF.Attr s Text)
    {- ^ (Optional, Forces new resource) Codec options for the video parameters -}
    , _video_watermarks    :: !(TF.Attr s Text)
    {- ^ (Optional, Forces new resource) Watermark parameters for the video parameters (documented below) -}
    } deriving (Show, Eq)

instance TF.ToHCL (ElastictranscoderPresetResource s) where
    toHCL ElastictranscoderPresetResource{..} = TF.inline $ catMaybes
        [ TF.assign "audio" <$> TF.attribute _audio
        , TF.assign "audio_codec_options" <$> TF.attribute _audio_codec_options
        , TF.assign "container" <$> TF.attribute _container
        , TF.assign "description" <$> TF.attribute _description
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "thumbnails" <$> TF.attribute _thumbnails
        , TF.assign "video" <$> TF.attribute _video
        , TF.assign "video_codec_options" <$> TF.attribute _video_codec_options
        , TF.assign "video_watermarks" <$> TF.attribute _video_watermarks
        ]

instance P.HasAudio (ElastictranscoderPresetResource s) (TF.Attr s Text) where
    audio =
        lens (_audio :: ElastictranscoderPresetResource s -> TF.Attr s Text)
             (\s a -> s { _audio = a } :: ElastictranscoderPresetResource s)

instance P.HasAudioCodecOptions (ElastictranscoderPresetResource s) (TF.Attr s Text) where
    audioCodecOptions =
        lens (_audio_codec_options :: ElastictranscoderPresetResource s -> TF.Attr s Text)
             (\s a -> s { _audio_codec_options = a } :: ElastictranscoderPresetResource s)

instance P.HasContainer (ElastictranscoderPresetResource s) (TF.Attr s Text) where
    container =
        lens (_container :: ElastictranscoderPresetResource s -> TF.Attr s Text)
             (\s a -> s { _container = a } :: ElastictranscoderPresetResource s)

instance P.HasDescription (ElastictranscoderPresetResource s) (TF.Attr s Text) where
    description =
        lens (_description :: ElastictranscoderPresetResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: ElastictranscoderPresetResource s)

instance P.HasName (ElastictranscoderPresetResource s) (TF.Attr s Text) where
    name =
        lens (_name :: ElastictranscoderPresetResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: ElastictranscoderPresetResource s)

instance P.HasThumbnails (ElastictranscoderPresetResource s) (TF.Attr s Text) where
    thumbnails =
        lens (_thumbnails :: ElastictranscoderPresetResource s -> TF.Attr s Text)
             (\s a -> s { _thumbnails = a } :: ElastictranscoderPresetResource s)

instance P.HasVideo (ElastictranscoderPresetResource s) (TF.Attr s Text) where
    video =
        lens (_video :: ElastictranscoderPresetResource s -> TF.Attr s Text)
             (\s a -> s { _video = a } :: ElastictranscoderPresetResource s)

instance P.HasVideoCodecOptions (ElastictranscoderPresetResource s) (TF.Attr s Text) where
    videoCodecOptions =
        lens (_video_codec_options :: ElastictranscoderPresetResource s -> TF.Attr s Text)
             (\s a -> s { _video_codec_options = a } :: ElastictranscoderPresetResource s)

instance P.HasVideoWatermarks (ElastictranscoderPresetResource s) (TF.Attr s Text) where
    videoWatermarks =
        lens (_video_watermarks :: ElastictranscoderPresetResource s -> TF.Attr s Text)
             (\s a -> s { _video_watermarks = a } :: ElastictranscoderPresetResource s)

instance P.HasComputedAudio (ElastictranscoderPresetResource s) s (TF.Attr s Text) where
    computedAudio =
        (_audio :: ElastictranscoderPresetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAudioCodecOptions (ElastictranscoderPresetResource s) s (TF.Attr s Text) where
    computedAudioCodecOptions =
        (_audio_codec_options :: ElastictranscoderPresetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedContainer (ElastictranscoderPresetResource s) s (TF.Attr s Text) where
    computedContainer =
        (_container :: ElastictranscoderPresetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDescription (ElastictranscoderPresetResource s) s (TF.Attr s Text) where
    computedDescription =
        (_description :: ElastictranscoderPresetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (ElastictranscoderPresetResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: ElastictranscoderPresetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedThumbnails (ElastictranscoderPresetResource s) s (TF.Attr s Text) where
    computedThumbnails =
        (_thumbnails :: ElastictranscoderPresetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedVideo (ElastictranscoderPresetResource s) s (TF.Attr s Text) where
    computedVideo =
        (_video :: ElastictranscoderPresetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedVideoCodecOptions (ElastictranscoderPresetResource s) s (TF.Attr s Text) where
    computedVideoCodecOptions =
        (_video_codec_options :: ElastictranscoderPresetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedVideoWatermarks (ElastictranscoderPresetResource s) s (TF.Attr s Text) where
    computedVideoWatermarks =
        (_video_watermarks :: ElastictranscoderPresetResource s -> TF.Attr s Text)
            . TF.refValue

elastictranscoderPresetResource :: TF.Schema TF.Resource P.AWS (ElastictranscoderPresetResource s)
elastictranscoderPresetResource =
    TF.newResource "aws_elastictranscoder_preset" $
        ElastictranscoderPresetResource {
              _audio = TF.Nil
            , _audio_codec_options = TF.Nil
            , _container = TF.Nil
            , _description = TF.Nil
            , _name = TF.Nil
            , _thumbnails = TF.Nil
            , _video = TF.Nil
            , _video_codec_options = TF.Nil
            , _video_watermarks = TF.Nil
            }

{- | The @aws_elb_attachment@ AWS resource.

Provides an Elastic Load Balancer Attachment resource. ~> NOTE on ELB
Instances and ELB Attachments: Terraform currently provides both a
standalone ELB Attachment resource (describing an instance attached to an
ELB), and an <elb.html> with @instances@ defined in-line. At this time you
cannot use an ELB with in-line instances in conjunction with an ELB
Attachment resource. Doing so will cause a conflict and will overwrite
attachments.
-}
data ElbAttachmentResource s = ElbAttachmentResource {
      _elb       :: !(TF.Attr s Text)
    {- ^ (Required) The name of the ELB. -}
    , _instance' :: !(TF.Attr s Text)
    {- ^ (Required) Instance ID to place in the ELB pool. -}
    } deriving (Show, Eq)

instance TF.ToHCL (ElbAttachmentResource s) where
    toHCL ElbAttachmentResource{..} = TF.inline $ catMaybes
        [ TF.assign "elb" <$> TF.attribute _elb
        , TF.assign "instance" <$> TF.attribute _instance'
        ]

instance P.HasElb (ElbAttachmentResource s) (TF.Attr s Text) where
    elb =
        lens (_elb :: ElbAttachmentResource s -> TF.Attr s Text)
             (\s a -> s { _elb = a } :: ElbAttachmentResource s)

instance P.HasInstance' (ElbAttachmentResource s) (TF.Attr s Text) where
    instance' =
        lens (_instance' :: ElbAttachmentResource s -> TF.Attr s Text)
             (\s a -> s { _instance' = a } :: ElbAttachmentResource s)

instance P.HasComputedElb (ElbAttachmentResource s) s (TF.Attr s Text) where
    computedElb =
        (_elb :: ElbAttachmentResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedInstance' (ElbAttachmentResource s) s (TF.Attr s Text) where
    computedInstance' =
        (_instance' :: ElbAttachmentResource s -> TF.Attr s Text)
            . TF.refValue

elbAttachmentResource :: TF.Schema TF.Resource P.AWS (ElbAttachmentResource s)
elbAttachmentResource =
    TF.newResource "aws_elb_attachment" $
        ElbAttachmentResource {
              _elb = TF.Nil
            , _instance' = TF.Nil
            }

{- | The @aws_elb_load_balancer_backend_server_policy@ AWS resource.

Attaches a load balancer policy to an ELB backend server.
-}
data ElbLoadBalancerBackendServerPolicyResource s = ElbLoadBalancerBackendServerPolicyResource {
      _instance_port      :: !(TF.Attr s P.Word16)
    {- ^ (Required) The instance port to apply the policy to. -}
    , _load_balancer_name :: !(TF.Attr s Text)
    {- ^ (Required) The load balancer to attach the policy to. -}
    , _policy_names       :: !(TF.Attr s Text)
    {- ^ (Required) List of Policy Names to apply to the backend server. -}
    } deriving (Show, Eq)

instance TF.ToHCL (ElbLoadBalancerBackendServerPolicyResource s) where
    toHCL ElbLoadBalancerBackendServerPolicyResource{..} = TF.inline $ catMaybes
        [ TF.assign "instance_port" <$> TF.attribute _instance_port
        , TF.assign "load_balancer_name" <$> TF.attribute _load_balancer_name
        , TF.assign "policy_names" <$> TF.attribute _policy_names
        ]

instance P.HasInstancePort (ElbLoadBalancerBackendServerPolicyResource s) (TF.Attr s P.Word16) where
    instancePort =
        lens (_instance_port :: ElbLoadBalancerBackendServerPolicyResource s -> TF.Attr s P.Word16)
             (\s a -> s { _instance_port = a } :: ElbLoadBalancerBackendServerPolicyResource s)

instance P.HasLoadBalancerName (ElbLoadBalancerBackendServerPolicyResource s) (TF.Attr s Text) where
    loadBalancerName =
        lens (_load_balancer_name :: ElbLoadBalancerBackendServerPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _load_balancer_name = a } :: ElbLoadBalancerBackendServerPolicyResource s)

instance P.HasPolicyNames (ElbLoadBalancerBackendServerPolicyResource s) (TF.Attr s Text) where
    policyNames =
        lens (_policy_names :: ElbLoadBalancerBackendServerPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _policy_names = a } :: ElbLoadBalancerBackendServerPolicyResource s)

instance P.HasComputedId (ElbLoadBalancerBackendServerPolicyResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedInstancePort (ElbLoadBalancerBackendServerPolicyResource s) s (TF.Attr s P.Word16) where
    computedInstancePort x = TF.compute (TF.refKey x) "instance_port"

instance P.HasComputedLoadBalancerName (ElbLoadBalancerBackendServerPolicyResource s) s (TF.Attr s Text) where
    computedLoadBalancerName x = TF.compute (TF.refKey x) "load_balancer_name"

instance P.HasComputedPolicyNames (ElbLoadBalancerBackendServerPolicyResource s) s (TF.Attr s Text) where
    computedPolicyNames =
        (_policy_names :: ElbLoadBalancerBackendServerPolicyResource s -> TF.Attr s Text)
            . TF.refValue

elbLoadBalancerBackendServerPolicyResource :: TF.Schema TF.Resource P.AWS (ElbLoadBalancerBackendServerPolicyResource s)
elbLoadBalancerBackendServerPolicyResource =
    TF.newResource "aws_elb_load_balancer_backend_server_policy" $
        ElbLoadBalancerBackendServerPolicyResource {
              _instance_port = TF.Nil
            , _load_balancer_name = TF.Nil
            , _policy_names = TF.Nil
            }

{- | The @aws_elb_load_balancer_listener_policy@ AWS resource.

Attaches a load balancer policy to an ELB Listener.
-}
data ElbLoadBalancerListenerPolicyResource s = ElbLoadBalancerListenerPolicyResource {
      _load_balancer_name :: !(TF.Attr s Text)
    {- ^ (Required) The load balancer to attach the policy to. -}
    , _load_balancer_port :: !(TF.Attr s P.Word16)
    {- ^ (Required) The load balancer listener port to apply the policy to. -}
    , _policy_names       :: !(TF.Attr s Text)
    {- ^ (Required) List of Policy Names to apply to the backend server. -}
    } deriving (Show, Eq)

instance TF.ToHCL (ElbLoadBalancerListenerPolicyResource s) where
    toHCL ElbLoadBalancerListenerPolicyResource{..} = TF.inline $ catMaybes
        [ TF.assign "load_balancer_name" <$> TF.attribute _load_balancer_name
        , TF.assign "load_balancer_port" <$> TF.attribute _load_balancer_port
        , TF.assign "policy_names" <$> TF.attribute _policy_names
        ]

instance P.HasLoadBalancerName (ElbLoadBalancerListenerPolicyResource s) (TF.Attr s Text) where
    loadBalancerName =
        lens (_load_balancer_name :: ElbLoadBalancerListenerPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _load_balancer_name = a } :: ElbLoadBalancerListenerPolicyResource s)

instance P.HasLoadBalancerPort (ElbLoadBalancerListenerPolicyResource s) (TF.Attr s P.Word16) where
    loadBalancerPort =
        lens (_load_balancer_port :: ElbLoadBalancerListenerPolicyResource s -> TF.Attr s P.Word16)
             (\s a -> s { _load_balancer_port = a } :: ElbLoadBalancerListenerPolicyResource s)

instance P.HasPolicyNames (ElbLoadBalancerListenerPolicyResource s) (TF.Attr s Text) where
    policyNames =
        lens (_policy_names :: ElbLoadBalancerListenerPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _policy_names = a } :: ElbLoadBalancerListenerPolicyResource s)

instance P.HasComputedId (ElbLoadBalancerListenerPolicyResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedLoadBalancerName (ElbLoadBalancerListenerPolicyResource s) s (TF.Attr s Text) where
    computedLoadBalancerName x = TF.compute (TF.refKey x) "load_balancer_name"

instance P.HasComputedLoadBalancerPort (ElbLoadBalancerListenerPolicyResource s) s (TF.Attr s P.Word16) where
    computedLoadBalancerPort x = TF.compute (TF.refKey x) "load_balancer_port"

instance P.HasComputedPolicyNames (ElbLoadBalancerListenerPolicyResource s) s (TF.Attr s Text) where
    computedPolicyNames =
        (_policy_names :: ElbLoadBalancerListenerPolicyResource s -> TF.Attr s Text)
            . TF.refValue

elbLoadBalancerListenerPolicyResource :: TF.Schema TF.Resource P.AWS (ElbLoadBalancerListenerPolicyResource s)
elbLoadBalancerListenerPolicyResource =
    TF.newResource "aws_elb_load_balancer_listener_policy" $
        ElbLoadBalancerListenerPolicyResource {
              _load_balancer_name = TF.Nil
            , _load_balancer_port = TF.Nil
            , _policy_names = TF.Nil
            }

{- | The @aws_elb_load_balancer_policy@ AWS resource.

Provides a load balancer policy, which can be attached to an ELB listener or
backend server.
-}
data ElbLoadBalancerPolicyResource s = ElbLoadBalancerPolicyResource {
      _load_balancer_name :: !(TF.Attr s Text)
    {- ^ (Required) The load balancer on which the policy is defined. -}
    , _policy_attribute   :: !(TF.Attr s Text)
    {- ^ (Optional) Policy attribute to apply to the policy. -}
    , _policy_name        :: !(TF.Attr s Text)
    {- ^ (Required) The name of the load balancer policy. -}
    , _policy_type_name   :: !(TF.Attr s Text)
    {- ^ (Required) The policy type. -}
    } deriving (Show, Eq)

instance TF.ToHCL (ElbLoadBalancerPolicyResource s) where
    toHCL ElbLoadBalancerPolicyResource{..} = TF.inline $ catMaybes
        [ TF.assign "load_balancer_name" <$> TF.attribute _load_balancer_name
        , TF.assign "policy_attribute" <$> TF.attribute _policy_attribute
        , TF.assign "policy_name" <$> TF.attribute _policy_name
        , TF.assign "policy_type_name" <$> TF.attribute _policy_type_name
        ]

instance P.HasLoadBalancerName (ElbLoadBalancerPolicyResource s) (TF.Attr s Text) where
    loadBalancerName =
        lens (_load_balancer_name :: ElbLoadBalancerPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _load_balancer_name = a } :: ElbLoadBalancerPolicyResource s)

instance P.HasPolicyAttribute (ElbLoadBalancerPolicyResource s) (TF.Attr s Text) where
    policyAttribute =
        lens (_policy_attribute :: ElbLoadBalancerPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _policy_attribute = a } :: ElbLoadBalancerPolicyResource s)

instance P.HasPolicyName (ElbLoadBalancerPolicyResource s) (TF.Attr s Text) where
    policyName =
        lens (_policy_name :: ElbLoadBalancerPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _policy_name = a } :: ElbLoadBalancerPolicyResource s)

instance P.HasPolicyTypeName (ElbLoadBalancerPolicyResource s) (TF.Attr s Text) where
    policyTypeName =
        lens (_policy_type_name :: ElbLoadBalancerPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _policy_type_name = a } :: ElbLoadBalancerPolicyResource s)

instance P.HasComputedId (ElbLoadBalancerPolicyResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedLoadBalancerName (ElbLoadBalancerPolicyResource s) s (TF.Attr s Text) where
    computedLoadBalancerName x = TF.compute (TF.refKey x) "load_balancer_name"

instance P.HasComputedPolicyAttribute (ElbLoadBalancerPolicyResource s) s (TF.Attr s Text) where
    computedPolicyAttribute =
        (_policy_attribute :: ElbLoadBalancerPolicyResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPolicyName (ElbLoadBalancerPolicyResource s) s (TF.Attr s Text) where
    computedPolicyName x = TF.compute (TF.refKey x) "policy_name"

instance P.HasComputedPolicyTypeName (ElbLoadBalancerPolicyResource s) s (TF.Attr s Text) where
    computedPolicyTypeName x = TF.compute (TF.refKey x) "policy_type_name"

elbLoadBalancerPolicyResource :: TF.Schema TF.Resource P.AWS (ElbLoadBalancerPolicyResource s)
elbLoadBalancerPolicyResource =
    TF.newResource "aws_elb_load_balancer_policy" $
        ElbLoadBalancerPolicyResource {
              _load_balancer_name = TF.Nil
            , _policy_attribute = TF.Nil
            , _policy_name = TF.Nil
            , _policy_type_name = TF.Nil
            }

{- | The @aws_elb@ AWS resource.

Provides an Elastic Load Balancer resource, also known as a "Classic Load
Balancer" after the release of </docs/providers/aws/r/lb.html> . ~> NOTE on
ELB Instances and ELB Attachments: Terraform currently provides both a
standalone <elb_attachment.html> (describing an instance attached to an
ELB), and an ELB resource with @instances@ defined in-line. At this time you
cannot use an ELB with in-line instances in conjunction with a ELB
Attachment resources. Doing so will cause a conflict and will overwrite
attachments.
-}
data ElbResource s = ElbResource {
      _access_logs                 :: !(TF.Attr s Text)
    {- ^ (Optional) An Access Logs block. Access Logs documented below. -}
    , _availability_zones          :: !(TF.Attr s Text)
    {- ^ (Required for an EC2-classic ELB) The AZ's to serve traffic in. -}
    , _connection_draining         :: !(TF.Attr s Text)
    {- ^ (Optional) Boolean to enable connection draining. Default: @false@ -}
    , _connection_draining_timeout :: !(TF.Attr s Text)
    {- ^ (Optional) The time in seconds to allow for connections to drain. Default: @300@ -}
    , _cross_zone_load_balancing   :: !(TF.Attr s Text)
    {- ^ (Optional) Enable cross-zone load balancing. Default: @true@ -}
    , _health_check                :: !(TF.Attr s Text)
    {- ^ (Optional) A health_check block. Health Check documented below. -}
    , _idle_timeout                :: !(TF.Attr s Text)
    {- ^ (Optional) The time in seconds that the connection is allowed to be idle. Default: @60@ -}
    , _instances                   :: !(TF.Attr s Text)
    {- ^ (Optional) A list of instance ids to place in the ELB pool. -}
    , _internal                    :: !(TF.Attr s Text)
    {- ^ (Optional) If true, ELB will be an internal ELB. -}
    , _listener                    :: !(TF.Attr s Text)
    {- ^ (Required) A list of listener blocks. Listeners documented below. -}
    , _name                        :: !(TF.Attr s Text)
    {- ^ (Optional) The name of the ELB. By default generated by Terraform. -}
    , _name_prefix                 :: !(TF.Attr s Text)
    {- ^ (Optional, Forces new resource) Creates a unique name beginning with the specified prefix. Conflicts with @name@ . -}
    , _security_groups             :: !(TF.Attr s Text)
    {- ^ (Optional) A list of security group IDs to assign to the ELB. Only valid if creating an ELB within a VPC -}
    , _subnets                     :: !(TF.Attr s Text)
    {- ^ (Required for a VPC ELB) A list of subnet IDs to attach to the ELB. -}
    , _tags                        :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    } deriving (Show, Eq)

instance TF.ToHCL (ElbResource s) where
    toHCL ElbResource{..} = TF.inline $ catMaybes
        [ TF.assign "access_logs" <$> TF.attribute _access_logs
        , TF.assign "availability_zones" <$> TF.attribute _availability_zones
        , TF.assign "connection_draining" <$> TF.attribute _connection_draining
        , TF.assign "connection_draining_timeout" <$> TF.attribute _connection_draining_timeout
        , TF.assign "cross_zone_load_balancing" <$> TF.attribute _cross_zone_load_balancing
        , TF.assign "health_check" <$> TF.attribute _health_check
        , TF.assign "idle_timeout" <$> TF.attribute _idle_timeout
        , TF.assign "instances" <$> TF.attribute _instances
        , TF.assign "internal" <$> TF.attribute _internal
        , TF.assign "listener" <$> TF.attribute _listener
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "name_prefix" <$> TF.attribute _name_prefix
        , TF.assign "security_groups" <$> TF.attribute _security_groups
        , TF.assign "subnets" <$> TF.attribute _subnets
        , TF.assign "tags" <$> TF.attribute _tags
        ]

instance P.HasAccessLogs (ElbResource s) (TF.Attr s Text) where
    accessLogs =
        lens (_access_logs :: ElbResource s -> TF.Attr s Text)
             (\s a -> s { _access_logs = a } :: ElbResource s)

instance P.HasAvailabilityZones (ElbResource s) (TF.Attr s Text) where
    availabilityZones =
        lens (_availability_zones :: ElbResource s -> TF.Attr s Text)
             (\s a -> s { _availability_zones = a } :: ElbResource s)

instance P.HasConnectionDraining (ElbResource s) (TF.Attr s Text) where
    connectionDraining =
        lens (_connection_draining :: ElbResource s -> TF.Attr s Text)
             (\s a -> s { _connection_draining = a } :: ElbResource s)

instance P.HasConnectionDrainingTimeout (ElbResource s) (TF.Attr s Text) where
    connectionDrainingTimeout =
        lens (_connection_draining_timeout :: ElbResource s -> TF.Attr s Text)
             (\s a -> s { _connection_draining_timeout = a } :: ElbResource s)

instance P.HasCrossZoneLoadBalancing (ElbResource s) (TF.Attr s Text) where
    crossZoneLoadBalancing =
        lens (_cross_zone_load_balancing :: ElbResource s -> TF.Attr s Text)
             (\s a -> s { _cross_zone_load_balancing = a } :: ElbResource s)

instance P.HasHealthCheck (ElbResource s) (TF.Attr s Text) where
    healthCheck =
        lens (_health_check :: ElbResource s -> TF.Attr s Text)
             (\s a -> s { _health_check = a } :: ElbResource s)

instance P.HasIdleTimeout (ElbResource s) (TF.Attr s Text) where
    idleTimeout =
        lens (_idle_timeout :: ElbResource s -> TF.Attr s Text)
             (\s a -> s { _idle_timeout = a } :: ElbResource s)

instance P.HasInstances (ElbResource s) (TF.Attr s Text) where
    instances =
        lens (_instances :: ElbResource s -> TF.Attr s Text)
             (\s a -> s { _instances = a } :: ElbResource s)

instance P.HasInternal (ElbResource s) (TF.Attr s Text) where
    internal =
        lens (_internal :: ElbResource s -> TF.Attr s Text)
             (\s a -> s { _internal = a } :: ElbResource s)

instance P.HasListener (ElbResource s) (TF.Attr s Text) where
    listener =
        lens (_listener :: ElbResource s -> TF.Attr s Text)
             (\s a -> s { _listener = a } :: ElbResource s)

instance P.HasName (ElbResource s) (TF.Attr s Text) where
    name =
        lens (_name :: ElbResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: ElbResource s)

instance P.HasNamePrefix (ElbResource s) (TF.Attr s Text) where
    namePrefix =
        lens (_name_prefix :: ElbResource s -> TF.Attr s Text)
             (\s a -> s { _name_prefix = a } :: ElbResource s)

instance P.HasSecurityGroups (ElbResource s) (TF.Attr s Text) where
    securityGroups =
        lens (_security_groups :: ElbResource s -> TF.Attr s Text)
             (\s a -> s { _security_groups = a } :: ElbResource s)

instance P.HasSubnets (ElbResource s) (TF.Attr s Text) where
    subnets =
        lens (_subnets :: ElbResource s -> TF.Attr s Text)
             (\s a -> s { _subnets = a } :: ElbResource s)

instance P.HasTags (ElbResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: ElbResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: ElbResource s)

instance P.HasComputedAccessLogs (ElbResource s) s (TF.Attr s Text) where
    computedAccessLogs =
        (_access_logs :: ElbResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedArn (ElbResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedAvailabilityZones (ElbResource s) s (TF.Attr s Text) where
    computedAvailabilityZones =
        (_availability_zones :: ElbResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedConnectionDraining (ElbResource s) s (TF.Attr s Text) where
    computedConnectionDraining =
        (_connection_draining :: ElbResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedConnectionDrainingTimeout (ElbResource s) s (TF.Attr s Text) where
    computedConnectionDrainingTimeout =
        (_connection_draining_timeout :: ElbResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCrossZoneLoadBalancing (ElbResource s) s (TF.Attr s Text) where
    computedCrossZoneLoadBalancing =
        (_cross_zone_load_balancing :: ElbResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDnsName (ElbResource s) s (TF.Attr s Text) where
    computedDnsName x = TF.compute (TF.refKey x) "dns_name"

instance P.HasComputedHealthCheck (ElbResource s) s (TF.Attr s Text) where
    computedHealthCheck =
        (_health_check :: ElbResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (ElbResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedIdleTimeout (ElbResource s) s (TF.Attr s Text) where
    computedIdleTimeout =
        (_idle_timeout :: ElbResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedInstances (ElbResource s) s (TF.Attr s Text) where
    computedInstances x = TF.compute (TF.refKey x) "instances"

instance P.HasComputedInternal (ElbResource s) s (TF.Attr s Text) where
    computedInternal =
        (_internal :: ElbResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedListener (ElbResource s) s (TF.Attr s Text) where
    computedListener =
        (_listener :: ElbResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (ElbResource s) s (TF.Attr s Text) where
    computedName x = TF.compute (TF.refKey x) "name"

instance P.HasComputedNamePrefix (ElbResource s) s (TF.Attr s Text) where
    computedNamePrefix =
        (_name_prefix :: ElbResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSecurityGroups (ElbResource s) s (TF.Attr s Text) where
    computedSecurityGroups =
        (_security_groups :: ElbResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSourceSecurityGroup (ElbResource s) s (TF.Attr s Text) where
    computedSourceSecurityGroup x = TF.compute (TF.refKey x) "source_security_group"

instance P.HasComputedSourceSecurityGroupId (ElbResource s) s (TF.Attr s Text) where
    computedSourceSecurityGroupId x = TF.compute (TF.refKey x) "source_security_group_id"

instance P.HasComputedSubnets (ElbResource s) s (TF.Attr s Text) where
    computedSubnets =
        (_subnets :: ElbResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (ElbResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: ElbResource s -> TF.Attr s P.Tags)
            . TF.refValue

instance P.HasComputedZoneId (ElbResource s) s (TF.Attr s Text) where
    computedZoneId x = TF.compute (TF.refKey x) "zone_id"

elbResource :: TF.Schema TF.Resource P.AWS (ElbResource s)
elbResource =
    TF.newResource "aws_elb" $
        ElbResource {
              _access_logs = TF.Nil
            , _availability_zones = TF.Nil
            , _connection_draining = TF.Nil
            , _connection_draining_timeout = TF.Nil
            , _cross_zone_load_balancing = TF.Nil
            , _health_check = TF.Nil
            , _idle_timeout = TF.Nil
            , _instances = TF.Nil
            , _internal = TF.Nil
            , _listener = TF.Nil
            , _name = TF.Nil
            , _name_prefix = TF.Nil
            , _security_groups = TF.Nil
            , _subnets = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_emr_cluster@ AWS resource.

Provides an Elastic MapReduce Cluster, a web service that makes it easy to
process large amounts of data efficiently. See
<https://aws.amazon.com/documentation/elastic-mapreduce/> for more
information.
-}
data EmrClusterResource s = EmrClusterResource {
      _applications                      :: !(TF.Attr s Text)
    {- ^ (Optional) A list of applications for the cluster. Valid values are: @Flink@ , @Hadoop@ , @Hive@ , @Mahout@ , @Pig@ , and @Spark@ . Case insensitive -}
    , _autoscaling_role                  :: !(TF.Attr s Text)
    {- ^ (Optional) An IAM role for automatic scaling policies. The IAM role provides permissions that the automatic scaling feature requires to launch and terminate EC2 instances in an instance group. -}
    , _bootstrap_action                  :: !(TF.Attr s Text)
    {- ^ (Optional) List of bootstrap actions that will be run before Hadoop is started on the cluster nodes. Defined below -}
    , _configurations                    :: !(TF.Attr s Text)
    {- ^ (Optional) List of configurations supplied for the EMR cluster you are creating -}
    , _core_instance_count               :: !(TF.Attr s Text)
    {- ^ (Optional) Number of Amazon EC2 instances used to execute the job flow. EMR will use one node as the cluster's master node and use the remainder of the nodes ( @core_instance_count@ -1) as core nodes. Cannot be specified if @instance_groups@ is set. Default @1@ -}
    , _core_instance_type                :: !(TF.Attr s Text)
    {- ^ (Optional) The EC2 instance type of the slave nodes. Cannot be specified if @instance_groups@ is set -}
    , _custom_ami_id                     :: !(TF.Attr s Text)
    {- ^ (Optional) A custom Amazon Linux AMI for the cluster (instead of an EMR-owned AMI). Available in Amazon EMR version 5.7.0 and later. -}
    , _ebs_root_volume_size              :: !(TF.Attr s Text)
    {- ^ (Optional) Size in GiB of the EBS root device volume of the Linux AMI that is used for each EC2 instance. Available in Amazon EMR version 4.x and later. -}
    , _ec2_attributes                    :: !(TF.Attr s Text)
    {- ^ (Optional) Attributes for the EC2 instances running the job flow. Defined below -}
    , _instance_group                    :: !(TF.Attr s Text)
    {- ^ (Optional) A list of @instance_group@ objects for each instance group in the cluster. Exactly one of @master_instance_type@ and @instance_group@ must be specified. If @instance_group@ is set, then it must contain a configuration block for at least the @MASTER@ instance group type (as well as any additional instance groups). Defined below -}
    , _keep_job_flow_alive_when_no_steps :: !(TF.Attr s Text)
    {- ^ (Optional) Switch on/off run cluster with no steps or when all steps are complete (default is on) -}
    , _log_uri                           :: !(TF.Attr s Text)
    {- ^ (Optional) S3 bucket to write the log files of the job flow. If a value is not provided, logs are not created -}
    , _master_instance_type              :: !(TF.Attr s Text)
    {- ^ (Optional) The EC2 instance type of the master node. Exactly one of @master_instance_type@ and @instance_group@ must be specified. -}
    , _name                              :: !(TF.Attr s Text)
    {- ^ (Required) The name of the job flow -}
    , _release_label                     :: !(TF.Attr s Text)
    {- ^ (Required) The release label for the Amazon EMR release -}
    , _security_configuration            :: !(TF.Attr s Text)
    {- ^ (Optional) The security configuration name to attach to the EMR cluster. Only valid for EMR clusters with @release_label@ 4.8.0 or greater -}
    , _service_role                      :: !(TF.Attr s Text)
    {- ^ (Required) IAM role that will be assumed by the Amazon EMR service to access AWS resources -}
    , _tags                              :: !(TF.Attr s P.Tags)
    {- ^ (Optional) list of tags to apply to the EMR Cluster -}
    , _termination_protection            :: !(TF.Attr s Text)
    {- ^ (Optional) Switch on/off termination protection (default is off) -}
    , _visible_to_all_users              :: !(TF.Attr s Text)
    {- ^ (Optional) Whether the job flow is visible to all IAM users of the AWS account associated with the job flow. Default @true@ -}
    } deriving (Show, Eq)

instance TF.ToHCL (EmrClusterResource s) where
    toHCL EmrClusterResource{..} = TF.inline $ catMaybes
        [ TF.assign "applications" <$> TF.attribute _applications
        , TF.assign "autoscaling_role" <$> TF.attribute _autoscaling_role
        , TF.assign "bootstrap_action" <$> TF.attribute _bootstrap_action
        , TF.assign "configurations" <$> TF.attribute _configurations
        , TF.assign "core_instance_count" <$> TF.attribute _core_instance_count
        , TF.assign "core_instance_type" <$> TF.attribute _core_instance_type
        , TF.assign "custom_ami_id" <$> TF.attribute _custom_ami_id
        , TF.assign "ebs_root_volume_size" <$> TF.attribute _ebs_root_volume_size
        , TF.assign "ec2_attributes" <$> TF.attribute _ec2_attributes
        , TF.assign "instance_group" <$> TF.attribute _instance_group
        , TF.assign "keep_job_flow_alive_when_no_steps" <$> TF.attribute _keep_job_flow_alive_when_no_steps
        , TF.assign "log_uri" <$> TF.attribute _log_uri
        , TF.assign "master_instance_type" <$> TF.attribute _master_instance_type
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "release_label" <$> TF.attribute _release_label
        , TF.assign "security_configuration" <$> TF.attribute _security_configuration
        , TF.assign "service_role" <$> TF.attribute _service_role
        , TF.assign "tags" <$> TF.attribute _tags
        , TF.assign "termination_protection" <$> TF.attribute _termination_protection
        , TF.assign "visible_to_all_users" <$> TF.attribute _visible_to_all_users
        ]

instance P.HasApplications (EmrClusterResource s) (TF.Attr s Text) where
    applications =
        lens (_applications :: EmrClusterResource s -> TF.Attr s Text)
             (\s a -> s { _applications = a } :: EmrClusterResource s)

instance P.HasAutoscalingRole (EmrClusterResource s) (TF.Attr s Text) where
    autoscalingRole =
        lens (_autoscaling_role :: EmrClusterResource s -> TF.Attr s Text)
             (\s a -> s { _autoscaling_role = a } :: EmrClusterResource s)

instance P.HasBootstrapAction (EmrClusterResource s) (TF.Attr s Text) where
    bootstrapAction =
        lens (_bootstrap_action :: EmrClusterResource s -> TF.Attr s Text)
             (\s a -> s { _bootstrap_action = a } :: EmrClusterResource s)

instance P.HasConfigurations (EmrClusterResource s) (TF.Attr s Text) where
    configurations =
        lens (_configurations :: EmrClusterResource s -> TF.Attr s Text)
             (\s a -> s { _configurations = a } :: EmrClusterResource s)

instance P.HasCoreInstanceCount (EmrClusterResource s) (TF.Attr s Text) where
    coreInstanceCount =
        lens (_core_instance_count :: EmrClusterResource s -> TF.Attr s Text)
             (\s a -> s { _core_instance_count = a } :: EmrClusterResource s)

instance P.HasCoreInstanceType (EmrClusterResource s) (TF.Attr s Text) where
    coreInstanceType =
        lens (_core_instance_type :: EmrClusterResource s -> TF.Attr s Text)
             (\s a -> s { _core_instance_type = a } :: EmrClusterResource s)

instance P.HasCustomAmiId (EmrClusterResource s) (TF.Attr s Text) where
    customAmiId =
        lens (_custom_ami_id :: EmrClusterResource s -> TF.Attr s Text)
             (\s a -> s { _custom_ami_id = a } :: EmrClusterResource s)

instance P.HasEbsRootVolumeSize (EmrClusterResource s) (TF.Attr s Text) where
    ebsRootVolumeSize =
        lens (_ebs_root_volume_size :: EmrClusterResource s -> TF.Attr s Text)
             (\s a -> s { _ebs_root_volume_size = a } :: EmrClusterResource s)

instance P.HasEc2Attributes (EmrClusterResource s) (TF.Attr s Text) where
    ec2Attributes =
        lens (_ec2_attributes :: EmrClusterResource s -> TF.Attr s Text)
             (\s a -> s { _ec2_attributes = a } :: EmrClusterResource s)

instance P.HasInstanceGroup (EmrClusterResource s) (TF.Attr s Text) where
    instanceGroup =
        lens (_instance_group :: EmrClusterResource s -> TF.Attr s Text)
             (\s a -> s { _instance_group = a } :: EmrClusterResource s)

instance P.HasKeepJobFlowAliveWhenNoSteps (EmrClusterResource s) (TF.Attr s Text) where
    keepJobFlowAliveWhenNoSteps =
        lens (_keep_job_flow_alive_when_no_steps :: EmrClusterResource s -> TF.Attr s Text)
             (\s a -> s { _keep_job_flow_alive_when_no_steps = a } :: EmrClusterResource s)

instance P.HasLogUri (EmrClusterResource s) (TF.Attr s Text) where
    logUri =
        lens (_log_uri :: EmrClusterResource s -> TF.Attr s Text)
             (\s a -> s { _log_uri = a } :: EmrClusterResource s)

instance P.HasMasterInstanceType (EmrClusterResource s) (TF.Attr s Text) where
    masterInstanceType =
        lens (_master_instance_type :: EmrClusterResource s -> TF.Attr s Text)
             (\s a -> s { _master_instance_type = a } :: EmrClusterResource s)

instance P.HasName (EmrClusterResource s) (TF.Attr s Text) where
    name =
        lens (_name :: EmrClusterResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: EmrClusterResource s)

instance P.HasReleaseLabel (EmrClusterResource s) (TF.Attr s Text) where
    releaseLabel =
        lens (_release_label :: EmrClusterResource s -> TF.Attr s Text)
             (\s a -> s { _release_label = a } :: EmrClusterResource s)

instance P.HasSecurityConfiguration (EmrClusterResource s) (TF.Attr s Text) where
    securityConfiguration =
        lens (_security_configuration :: EmrClusterResource s -> TF.Attr s Text)
             (\s a -> s { _security_configuration = a } :: EmrClusterResource s)

instance P.HasServiceRole (EmrClusterResource s) (TF.Attr s Text) where
    serviceRole =
        lens (_service_role :: EmrClusterResource s -> TF.Attr s Text)
             (\s a -> s { _service_role = a } :: EmrClusterResource s)

instance P.HasTags (EmrClusterResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: EmrClusterResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: EmrClusterResource s)

instance P.HasTerminationProtection (EmrClusterResource s) (TF.Attr s Text) where
    terminationProtection =
        lens (_termination_protection :: EmrClusterResource s -> TF.Attr s Text)
             (\s a -> s { _termination_protection = a } :: EmrClusterResource s)

instance P.HasVisibleToAllUsers (EmrClusterResource s) (TF.Attr s Text) where
    visibleToAllUsers =
        lens (_visible_to_all_users :: EmrClusterResource s -> TF.Attr s Text)
             (\s a -> s { _visible_to_all_users = a } :: EmrClusterResource s)

instance P.HasComputedApplications (EmrClusterResource s) s (TF.Attr s Text) where
    computedApplications x = TF.compute (TF.refKey x) "applications"

instance P.HasComputedAutoscalingRole (EmrClusterResource s) s (TF.Attr s Text) where
    computedAutoscalingRole =
        (_autoscaling_role :: EmrClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedBootstrapAction (EmrClusterResource s) s (TF.Attr s Text) where
    computedBootstrapAction x = TF.compute (TF.refKey x) "bootstrap_action"

instance P.HasComputedConfigurations (EmrClusterResource s) s (TF.Attr s Text) where
    computedConfigurations x = TF.compute (TF.refKey x) "configurations"

instance P.HasComputedCoreInstanceCount (EmrClusterResource s) s (TF.Attr s Text) where
    computedCoreInstanceCount x = TF.compute (TF.refKey x) "core_instance_count"

instance P.HasComputedCoreInstanceType (EmrClusterResource s) s (TF.Attr s Text) where
    computedCoreInstanceType x = TF.compute (TF.refKey x) "core_instance_type"

instance P.HasComputedCustomAmiId (EmrClusterResource s) s (TF.Attr s Text) where
    computedCustomAmiId =
        (_custom_ami_id :: EmrClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEbsRootVolumeSize (EmrClusterResource s) s (TF.Attr s Text) where
    computedEbsRootVolumeSize =
        (_ebs_root_volume_size :: EmrClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEc2Attributes (EmrClusterResource s) s (TF.Attr s Text) where
    computedEc2Attributes x = TF.compute (TF.refKey x) "ec2_attributes"

instance P.HasComputedId (EmrClusterResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedInstanceGroup (EmrClusterResource s) s (TF.Attr s Text) where
    computedInstanceGroup =
        (_instance_group :: EmrClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedKeepJobFlowAliveWhenNoSteps (EmrClusterResource s) s (TF.Attr s Text) where
    computedKeepJobFlowAliveWhenNoSteps =
        (_keep_job_flow_alive_when_no_steps :: EmrClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedLogUri (EmrClusterResource s) s (TF.Attr s Text) where
    computedLogUri x = TF.compute (TF.refKey x) "log_uri"

instance P.HasComputedMasterInstanceType (EmrClusterResource s) s (TF.Attr s Text) where
    computedMasterInstanceType x = TF.compute (TF.refKey x) "master_instance_type"

instance P.HasComputedMasterPublicDns (EmrClusterResource s) s (TF.Attr s Text) where
    computedMasterPublicDns x = TF.compute (TF.refKey x) "master_public_dns"

instance P.HasComputedName (EmrClusterResource s) s (TF.Attr s Text) where
    computedName x = TF.compute (TF.refKey x) "name"

instance P.HasComputedReleaseLabel (EmrClusterResource s) s (TF.Attr s Text) where
    computedReleaseLabel x = TF.compute (TF.refKey x) "release_label"

instance P.HasComputedSecurityConfiguration (EmrClusterResource s) s (TF.Attr s Text) where
    computedSecurityConfiguration =
        (_security_configuration :: EmrClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedServiceRole (EmrClusterResource s) s (TF.Attr s Text) where
    computedServiceRole x = TF.compute (TF.refKey x) "service_role"

instance P.HasComputedTags (EmrClusterResource s) s (TF.Attr s P.Tags) where
    computedTags x = TF.compute (TF.refKey x) "tags"

instance P.HasComputedTerminationProtection (EmrClusterResource s) s (TF.Attr s Text) where
    computedTerminationProtection =
        (_termination_protection :: EmrClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedVisibleToAllUsers (EmrClusterResource s) s (TF.Attr s Text) where
    computedVisibleToAllUsers x = TF.compute (TF.refKey x) "visible_to_all_users"

emrClusterResource :: TF.Schema TF.Resource P.AWS (EmrClusterResource s)
emrClusterResource =
    TF.newResource "aws_emr_cluster" $
        EmrClusterResource {
              _applications = TF.Nil
            , _autoscaling_role = TF.Nil
            , _bootstrap_action = TF.Nil
            , _configurations = TF.Nil
            , _core_instance_count = TF.Nil
            , _core_instance_type = TF.Nil
            , _custom_ami_id = TF.Nil
            , _ebs_root_volume_size = TF.Nil
            , _ec2_attributes = TF.Nil
            , _instance_group = TF.Nil
            , _keep_job_flow_alive_when_no_steps = TF.Nil
            , _log_uri = TF.Nil
            , _master_instance_type = TF.Nil
            , _name = TF.Nil
            , _release_label = TF.Nil
            , _security_configuration = TF.Nil
            , _service_role = TF.Nil
            , _tags = TF.Nil
            , _termination_protection = TF.Nil
            , _visible_to_all_users = TF.Nil
            }

{- | The @aws_emr_instance_group@ AWS resource.

Provides an Elastic MapReduce Cluster Instance Group configuration. See
<https://aws.amazon.com/documentation/emr/> for more information. ~> NOTE:
At this time, Instance Groups cannot be destroyed through the API nor web
interface. Instance Groups are destroyed when the EMR Cluster is destroyed.
Terraform will resize any Instance Group to zero when destroying the
resource.
-}
data EmrInstanceGroupResource s = EmrInstanceGroupResource {
      _cluster_id     :: !(TF.Attr s Text)
    {- ^ (Required) ID of the EMR Cluster to attach to. Changing this forces a new resource to be created. -}
    , _ebs_config     :: !(TF.Attr s Text)
    {- ^ (Optional) One or more @ebs_config@ blocks as defined below. Changing this forces a new resource to be created. -}
    , _ebs_optimized  :: !(TF.Attr s Text)
    {- ^ (Optional) Indicates whether an Amazon EBS volume is EBS-optimized. Changing this forces a new resource to be created. -}
    , _instance_count :: !(TF.Attr s Text)
    {- ^ (Optional) Target number of instances for the instance group. Defaults to 0. -}
    , _instance_type  :: !(TF.Attr s Text)
    {- ^ (Required) The EC2 instance type for all instances in the instance group. Changing this forces a new resource to be created. -}
    , _name           :: !(TF.Attr s Text)
    {- ^ (Required) Human friendly name given to the instance group. Changing this forces a new resource to be created. -}
    } deriving (Show, Eq)

instance TF.ToHCL (EmrInstanceGroupResource s) where
    toHCL EmrInstanceGroupResource{..} = TF.inline $ catMaybes
        [ TF.assign "cluster_id" <$> TF.attribute _cluster_id
        , TF.assign "ebs_config" <$> TF.attribute _ebs_config
        , TF.assign "ebs_optimized" <$> TF.attribute _ebs_optimized
        , TF.assign "instance_count" <$> TF.attribute _instance_count
        , TF.assign "instance_type" <$> TF.attribute _instance_type
        , TF.assign "name" <$> TF.attribute _name
        ]

instance P.HasClusterId (EmrInstanceGroupResource s) (TF.Attr s Text) where
    clusterId =
        lens (_cluster_id :: EmrInstanceGroupResource s -> TF.Attr s Text)
             (\s a -> s { _cluster_id = a } :: EmrInstanceGroupResource s)

instance P.HasEbsConfig (EmrInstanceGroupResource s) (TF.Attr s Text) where
    ebsConfig =
        lens (_ebs_config :: EmrInstanceGroupResource s -> TF.Attr s Text)
             (\s a -> s { _ebs_config = a } :: EmrInstanceGroupResource s)

instance P.HasEbsOptimized (EmrInstanceGroupResource s) (TF.Attr s Text) where
    ebsOptimized =
        lens (_ebs_optimized :: EmrInstanceGroupResource s -> TF.Attr s Text)
             (\s a -> s { _ebs_optimized = a } :: EmrInstanceGroupResource s)

instance P.HasInstanceCount (EmrInstanceGroupResource s) (TF.Attr s Text) where
    instanceCount =
        lens (_instance_count :: EmrInstanceGroupResource s -> TF.Attr s Text)
             (\s a -> s { _instance_count = a } :: EmrInstanceGroupResource s)

instance P.HasInstanceType (EmrInstanceGroupResource s) (TF.Attr s Text) where
    instanceType =
        lens (_instance_type :: EmrInstanceGroupResource s -> TF.Attr s Text)
             (\s a -> s { _instance_type = a } :: EmrInstanceGroupResource s)

instance P.HasName (EmrInstanceGroupResource s) (TF.Attr s Text) where
    name =
        lens (_name :: EmrInstanceGroupResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: EmrInstanceGroupResource s)

instance P.HasComputedClusterId (EmrInstanceGroupResource s) s (TF.Attr s Text) where
    computedClusterId =
        (_cluster_id :: EmrInstanceGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEbsConfig (EmrInstanceGroupResource s) s (TF.Attr s Text) where
    computedEbsConfig =
        (_ebs_config :: EmrInstanceGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEbsOptimized (EmrInstanceGroupResource s) s (TF.Attr s Text) where
    computedEbsOptimized =
        (_ebs_optimized :: EmrInstanceGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (EmrInstanceGroupResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedInstanceCount (EmrInstanceGroupResource s) s (TF.Attr s Text) where
    computedInstanceCount =
        (_instance_count :: EmrInstanceGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedInstanceType (EmrInstanceGroupResource s) s (TF.Attr s Text) where
    computedInstanceType =
        (_instance_type :: EmrInstanceGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (EmrInstanceGroupResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: EmrInstanceGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRunningInstanceCount (EmrInstanceGroupResource s) s (TF.Attr s Text) where
    computedRunningInstanceCount x = TF.compute (TF.refKey x) "running_instance_count"

instance P.HasComputedStatus (EmrInstanceGroupResource s) s (TF.Attr s Text) where
    computedStatus x = TF.compute (TF.refKey x) "status"

emrInstanceGroupResource :: TF.Schema TF.Resource P.AWS (EmrInstanceGroupResource s)
emrInstanceGroupResource =
    TF.newResource "aws_emr_instance_group" $
        EmrInstanceGroupResource {
              _cluster_id = TF.Nil
            , _ebs_config = TF.Nil
            , _ebs_optimized = TF.Nil
            , _instance_count = TF.Nil
            , _instance_type = TF.Nil
            , _name = TF.Nil
            }

{- | The @aws_emr_security_configuration@ AWS resource.

Provides a resource to manage AWS EMR Security Configurations
-}
data EmrSecurityConfigurationResource s = EmrSecurityConfigurationResource {
      _configuration :: !(TF.Attr s Text)
    {- ^ (Required) A JSON formatted Security Configuration -}
    , _name          :: !(TF.Attr s Text)
    {- ^ (Optional) The name of the EMR Security Configuration. By default generated by Terraform. -}
    , _name_prefix   :: !(TF.Attr s Text)
    {- ^ (Optional) Creates a unique name beginning with the specified prefix. Conflicts with @name@ . -}
    } deriving (Show, Eq)

instance TF.ToHCL (EmrSecurityConfigurationResource s) where
    toHCL EmrSecurityConfigurationResource{..} = TF.inline $ catMaybes
        [ TF.assign "configuration" <$> TF.attribute _configuration
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "name_prefix" <$> TF.attribute _name_prefix
        ]

instance P.HasConfiguration (EmrSecurityConfigurationResource s) (TF.Attr s Text) where
    configuration =
        lens (_configuration :: EmrSecurityConfigurationResource s -> TF.Attr s Text)
             (\s a -> s { _configuration = a } :: EmrSecurityConfigurationResource s)

instance P.HasName (EmrSecurityConfigurationResource s) (TF.Attr s Text) where
    name =
        lens (_name :: EmrSecurityConfigurationResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: EmrSecurityConfigurationResource s)

instance P.HasNamePrefix (EmrSecurityConfigurationResource s) (TF.Attr s Text) where
    namePrefix =
        lens (_name_prefix :: EmrSecurityConfigurationResource s -> TF.Attr s Text)
             (\s a -> s { _name_prefix = a } :: EmrSecurityConfigurationResource s)

instance P.HasComputedConfiguration (EmrSecurityConfigurationResource s) s (TF.Attr s Text) where
    computedConfiguration x = TF.compute (TF.refKey x) "configuration"

instance P.HasComputedCreationDate (EmrSecurityConfigurationResource s) s (TF.Attr s Text) where
    computedCreationDate x = TF.compute (TF.refKey x) "creation_date"

instance P.HasComputedId (EmrSecurityConfigurationResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (EmrSecurityConfigurationResource s) s (TF.Attr s Text) where
    computedName x = TF.compute (TF.refKey x) "name"

instance P.HasComputedNamePrefix (EmrSecurityConfigurationResource s) s (TF.Attr s Text) where
    computedNamePrefix =
        (_name_prefix :: EmrSecurityConfigurationResource s -> TF.Attr s Text)
            . TF.refValue

emrSecurityConfigurationResource :: TF.Schema TF.Resource P.AWS (EmrSecurityConfigurationResource s)
emrSecurityConfigurationResource =
    TF.newResource "aws_emr_security_configuration" $
        EmrSecurityConfigurationResource {
              _configuration = TF.Nil
            , _name = TF.Nil
            , _name_prefix = TF.Nil
            }

{- | The @aws_flow_log@ AWS resource.

Provides a VPC/Subnet/ENI Flow Log to capture IP traffic for a specific
network interface, subnet, or VPC. Logs are sent to a CloudWatch Log Group.
-}
data FlowLogResource s = FlowLogResource {
      _eni_id         :: !(TF.Attr s Text)
    {- ^ (Optional) Elastic Network Interface ID to attach to -}
    , _iam_role_arn   :: !(TF.Attr s Text)
    {- ^ (Required) The ARN for the IAM role that's used to post flow logs to a CloudWatch Logs log group -}
    , _log_group_name :: !(TF.Attr s Text)
    {- ^ (Required) The name of the CloudWatch log group -}
    , _subnet_id      :: !(TF.Attr s Text)
    {- ^ (Optional) Subnet ID to attach to -}
    , _traffic_type   :: !(TF.Attr s Text)
    {- ^ (Required) The type of traffic to capture. Valid values: @ACCEPT@ , @REJECT@ , @ALL@ -}
    , _vpc_id         :: !(TF.Attr s Text)
    {- ^ (Optional) VPC ID to attach to -}
    } deriving (Show, Eq)

instance TF.ToHCL (FlowLogResource s) where
    toHCL FlowLogResource{..} = TF.inline $ catMaybes
        [ TF.assign "eni_id" <$> TF.attribute _eni_id
        , TF.assign "iam_role_arn" <$> TF.attribute _iam_role_arn
        , TF.assign "log_group_name" <$> TF.attribute _log_group_name
        , TF.assign "subnet_id" <$> TF.attribute _subnet_id
        , TF.assign "traffic_type" <$> TF.attribute _traffic_type
        , TF.assign "vpc_id" <$> TF.attribute _vpc_id
        ]

instance P.HasEniId (FlowLogResource s) (TF.Attr s Text) where
    eniId =
        lens (_eni_id :: FlowLogResource s -> TF.Attr s Text)
             (\s a -> s { _eni_id = a } :: FlowLogResource s)

instance P.HasIamRoleArn (FlowLogResource s) (TF.Attr s Text) where
    iamRoleArn =
        lens (_iam_role_arn :: FlowLogResource s -> TF.Attr s Text)
             (\s a -> s { _iam_role_arn = a } :: FlowLogResource s)

instance P.HasLogGroupName (FlowLogResource s) (TF.Attr s Text) where
    logGroupName =
        lens (_log_group_name :: FlowLogResource s -> TF.Attr s Text)
             (\s a -> s { _log_group_name = a } :: FlowLogResource s)

instance P.HasSubnetId (FlowLogResource s) (TF.Attr s Text) where
    subnetId =
        lens (_subnet_id :: FlowLogResource s -> TF.Attr s Text)
             (\s a -> s { _subnet_id = a } :: FlowLogResource s)

instance P.HasTrafficType (FlowLogResource s) (TF.Attr s Text) where
    trafficType =
        lens (_traffic_type :: FlowLogResource s -> TF.Attr s Text)
             (\s a -> s { _traffic_type = a } :: FlowLogResource s)

instance P.HasVpcId (FlowLogResource s) (TF.Attr s Text) where
    vpcId =
        lens (_vpc_id :: FlowLogResource s -> TF.Attr s Text)
             (\s a -> s { _vpc_id = a } :: FlowLogResource s)

instance P.HasComputedEniId (FlowLogResource s) s (TF.Attr s Text) where
    computedEniId =
        (_eni_id :: FlowLogResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedIamRoleArn (FlowLogResource s) s (TF.Attr s Text) where
    computedIamRoleArn =
        (_iam_role_arn :: FlowLogResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (FlowLogResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedLogGroupName (FlowLogResource s) s (TF.Attr s Text) where
    computedLogGroupName =
        (_log_group_name :: FlowLogResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSubnetId (FlowLogResource s) s (TF.Attr s Text) where
    computedSubnetId =
        (_subnet_id :: FlowLogResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTrafficType (FlowLogResource s) s (TF.Attr s Text) where
    computedTrafficType =
        (_traffic_type :: FlowLogResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedVpcId (FlowLogResource s) s (TF.Attr s Text) where
    computedVpcId =
        (_vpc_id :: FlowLogResource s -> TF.Attr s Text)
            . TF.refValue

flowLogResource :: TF.Schema TF.Resource P.AWS (FlowLogResource s)
flowLogResource =
    TF.newResource "aws_flow_log" $
        FlowLogResource {
              _eni_id = TF.Nil
            , _iam_role_arn = TF.Nil
            , _log_group_name = TF.Nil
            , _subnet_id = TF.Nil
            , _traffic_type = TF.Nil
            , _vpc_id = TF.Nil
            }

{- | The @aws_gamelift_alias@ AWS resource.

Provides a Gamelift Alias resource.
-}
data GameliftAliasResource s = GameliftAliasResource {
      _description      :: !(TF.Attr s Text)
    {- ^ (Optional) Description of the alias. -}
    , _name             :: !(TF.Attr s Text)
    {- ^ (Required) Name of the alias. -}
    , _routing_strategy :: !(TF.Attr s Text)
    {- ^ (Required) Specifies the fleet and/or routing type to use for the alias. -}
    } deriving (Show, Eq)

instance TF.ToHCL (GameliftAliasResource s) where
    toHCL GameliftAliasResource{..} = TF.inline $ catMaybes
        [ TF.assign "description" <$> TF.attribute _description
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "routing_strategy" <$> TF.attribute _routing_strategy
        ]

instance P.HasDescription (GameliftAliasResource s) (TF.Attr s Text) where
    description =
        lens (_description :: GameliftAliasResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: GameliftAliasResource s)

instance P.HasName (GameliftAliasResource s) (TF.Attr s Text) where
    name =
        lens (_name :: GameliftAliasResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: GameliftAliasResource s)

instance P.HasRoutingStrategy (GameliftAliasResource s) (TF.Attr s Text) where
    routingStrategy =
        lens (_routing_strategy :: GameliftAliasResource s -> TF.Attr s Text)
             (\s a -> s { _routing_strategy = a } :: GameliftAliasResource s)

instance P.HasComputedArn (GameliftAliasResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedDescription (GameliftAliasResource s) s (TF.Attr s Text) where
    computedDescription =
        (_description :: GameliftAliasResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (GameliftAliasResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (GameliftAliasResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: GameliftAliasResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRoutingStrategy (GameliftAliasResource s) s (TF.Attr s Text) where
    computedRoutingStrategy =
        (_routing_strategy :: GameliftAliasResource s -> TF.Attr s Text)
            . TF.refValue

gameliftAliasResource :: TF.Schema TF.Resource P.AWS (GameliftAliasResource s)
gameliftAliasResource =
    TF.newResource "aws_gamelift_alias" $
        GameliftAliasResource {
              _description = TF.Nil
            , _name = TF.Nil
            , _routing_strategy = TF.Nil
            }

{- | The @aws_gamelift_build@ AWS resource.

Provides an Gamelift Build resource.
-}
data GameliftBuildResource s = GameliftBuildResource {
      _name             :: !(TF.Attr s Text)
    {- ^ (Required) Name of the build -}
    , _operating_system :: !(TF.Attr s Text)
    {- ^ (Required) Operating system that the game server binaries are built to run on. e.g. @WINDOWS_2012@ or @AMAZON_LINUX@ . -}
    , _storage_location :: !(TF.Attr s Text)
    {- ^ (Required) Information indicating where your game build files are stored. See below. -}
    , _version          :: !(TF.Attr s Text)
    {- ^ (Optional) Version that is associated with this build. -}
    } deriving (Show, Eq)

instance TF.ToHCL (GameliftBuildResource s) where
    toHCL GameliftBuildResource{..} = TF.inline $ catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "operating_system" <$> TF.attribute _operating_system
        , TF.assign "storage_location" <$> TF.attribute _storage_location
        , TF.assign "version" <$> TF.attribute _version
        ]

instance P.HasName (GameliftBuildResource s) (TF.Attr s Text) where
    name =
        lens (_name :: GameliftBuildResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: GameliftBuildResource s)

instance P.HasOperatingSystem (GameliftBuildResource s) (TF.Attr s Text) where
    operatingSystem =
        lens (_operating_system :: GameliftBuildResource s -> TF.Attr s Text)
             (\s a -> s { _operating_system = a } :: GameliftBuildResource s)

instance P.HasStorageLocation (GameliftBuildResource s) (TF.Attr s Text) where
    storageLocation =
        lens (_storage_location :: GameliftBuildResource s -> TF.Attr s Text)
             (\s a -> s { _storage_location = a } :: GameliftBuildResource s)

instance P.HasVersion (GameliftBuildResource s) (TF.Attr s Text) where
    version =
        lens (_version :: GameliftBuildResource s -> TF.Attr s Text)
             (\s a -> s { _version = a } :: GameliftBuildResource s)

instance P.HasComputedId (GameliftBuildResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (GameliftBuildResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: GameliftBuildResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedOperatingSystem (GameliftBuildResource s) s (TF.Attr s Text) where
    computedOperatingSystem =
        (_operating_system :: GameliftBuildResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedStorageLocation (GameliftBuildResource s) s (TF.Attr s Text) where
    computedStorageLocation =
        (_storage_location :: GameliftBuildResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedVersion (GameliftBuildResource s) s (TF.Attr s Text) where
    computedVersion =
        (_version :: GameliftBuildResource s -> TF.Attr s Text)
            . TF.refValue

gameliftBuildResource :: TF.Schema TF.Resource P.AWS (GameliftBuildResource s)
gameliftBuildResource =
    TF.newResource "aws_gamelift_build" $
        GameliftBuildResource {
              _name = TF.Nil
            , _operating_system = TF.Nil
            , _storage_location = TF.Nil
            , _version = TF.Nil
            }

{- | The @aws_gamelift_fleet@ AWS resource.

Provides a Gamelift Fleet resource.
-}
data GameliftFleetResource s = GameliftFleetResource {
      _build_id                           :: !(TF.Attr s Text)
    {- ^ (Required) ID of the Gamelift Build to be deployed on the fleet. -}
    , _description                        :: !(TF.Attr s Text)
    {- ^ (Optional) Human-readable description of the fleet. -}
    , _ec2_inbound_permission             :: !(TF.Attr s Text)
    {- ^ (Optional) Range of IP addresses and port settings that permit inbound traffic to access server processes running on the fleet. See below. -}
    , _ec2_instance_type                  :: !(TF.Attr s Text)
    {- ^ (Required) Name of an EC2 instance type. e.g. @t2.micro@ -}
    , _metric_groups                      :: !(TF.Attr s Text)
    {- ^ (Optional) List of names of metric groups to add this fleet to. A metric group tracks metrics across all fleets in the group. Defaults to @default@ . -}
    , _name                               :: !(TF.Attr s Text)
    {- ^ (Required) The name of the fleet. -}
    , _new_game_session_protection_policy :: !(TF.Attr s Text)
    {- ^ (Optional) Game session protection policy to apply to all instances in this fleet. e.g. @FullProtection@ . Defaults to @NoProtection@ . -}
    , _resource_creation_limit_policy     :: !(TF.Attr s Text)
    {- ^ (Optional) Policy that limits the number of game sessions an individual player can create over a span of time for this fleet. See below. -}
    , _runtime_configuration              :: !(TF.Attr s Text)
    {- ^ (Optional) Instructions for launching server processes on each instance in the fleet. See below. -}
    } deriving (Show, Eq)

instance TF.ToHCL (GameliftFleetResource s) where
    toHCL GameliftFleetResource{..} = TF.inline $ catMaybes
        [ TF.assign "build_id" <$> TF.attribute _build_id
        , TF.assign "description" <$> TF.attribute _description
        , TF.assign "ec2_inbound_permission" <$> TF.attribute _ec2_inbound_permission
        , TF.assign "ec2_instance_type" <$> TF.attribute _ec2_instance_type
        , TF.assign "metric_groups" <$> TF.attribute _metric_groups
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "new_game_session_protection_policy" <$> TF.attribute _new_game_session_protection_policy
        , TF.assign "resource_creation_limit_policy" <$> TF.attribute _resource_creation_limit_policy
        , TF.assign "runtime_configuration" <$> TF.attribute _runtime_configuration
        ]

instance P.HasBuildId (GameliftFleetResource s) (TF.Attr s Text) where
    buildId =
        lens (_build_id :: GameliftFleetResource s -> TF.Attr s Text)
             (\s a -> s { _build_id = a } :: GameliftFleetResource s)

instance P.HasDescription (GameliftFleetResource s) (TF.Attr s Text) where
    description =
        lens (_description :: GameliftFleetResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: GameliftFleetResource s)

instance P.HasEc2InboundPermission (GameliftFleetResource s) (TF.Attr s Text) where
    ec2InboundPermission =
        lens (_ec2_inbound_permission :: GameliftFleetResource s -> TF.Attr s Text)
             (\s a -> s { _ec2_inbound_permission = a } :: GameliftFleetResource s)

instance P.HasEc2InstanceType (GameliftFleetResource s) (TF.Attr s Text) where
    ec2InstanceType =
        lens (_ec2_instance_type :: GameliftFleetResource s -> TF.Attr s Text)
             (\s a -> s { _ec2_instance_type = a } :: GameliftFleetResource s)

instance P.HasMetricGroups (GameliftFleetResource s) (TF.Attr s Text) where
    metricGroups =
        lens (_metric_groups :: GameliftFleetResource s -> TF.Attr s Text)
             (\s a -> s { _metric_groups = a } :: GameliftFleetResource s)

instance P.HasName (GameliftFleetResource s) (TF.Attr s Text) where
    name =
        lens (_name :: GameliftFleetResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: GameliftFleetResource s)

instance P.HasNewGameSessionProtectionPolicy (GameliftFleetResource s) (TF.Attr s Text) where
    newGameSessionProtectionPolicy =
        lens (_new_game_session_protection_policy :: GameliftFleetResource s -> TF.Attr s Text)
             (\s a -> s { _new_game_session_protection_policy = a } :: GameliftFleetResource s)

instance P.HasResourceCreationLimitPolicy (GameliftFleetResource s) (TF.Attr s Text) where
    resourceCreationLimitPolicy =
        lens (_resource_creation_limit_policy :: GameliftFleetResource s -> TF.Attr s Text)
             (\s a -> s { _resource_creation_limit_policy = a } :: GameliftFleetResource s)

instance P.HasRuntimeConfiguration (GameliftFleetResource s) (TF.Attr s Text) where
    runtimeConfiguration =
        lens (_runtime_configuration :: GameliftFleetResource s -> TF.Attr s Text)
             (\s a -> s { _runtime_configuration = a } :: GameliftFleetResource s)

instance P.HasComputedArn (GameliftFleetResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedBuildId (GameliftFleetResource s) s (TF.Attr s Text) where
    computedBuildId =
        (_build_id :: GameliftFleetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDescription (GameliftFleetResource s) s (TF.Attr s Text) where
    computedDescription =
        (_description :: GameliftFleetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEc2InboundPermission (GameliftFleetResource s) s (TF.Attr s Text) where
    computedEc2InboundPermission =
        (_ec2_inbound_permission :: GameliftFleetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEc2InstanceType (GameliftFleetResource s) s (TF.Attr s Text) where
    computedEc2InstanceType =
        (_ec2_instance_type :: GameliftFleetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (GameliftFleetResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedMetricGroups (GameliftFleetResource s) s (TF.Attr s Text) where
    computedMetricGroups =
        (_metric_groups :: GameliftFleetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (GameliftFleetResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: GameliftFleetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedNewGameSessionProtectionPolicy (GameliftFleetResource s) s (TF.Attr s Text) where
    computedNewGameSessionProtectionPolicy =
        (_new_game_session_protection_policy :: GameliftFleetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedOperatingSystem (GameliftFleetResource s) s (TF.Attr s Text) where
    computedOperatingSystem x = TF.compute (TF.refKey x) "operating_system"

instance P.HasComputedResourceCreationLimitPolicy (GameliftFleetResource s) s (TF.Attr s Text) where
    computedResourceCreationLimitPolicy =
        (_resource_creation_limit_policy :: GameliftFleetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRuntimeConfiguration (GameliftFleetResource s) s (TF.Attr s Text) where
    computedRuntimeConfiguration =
        (_runtime_configuration :: GameliftFleetResource s -> TF.Attr s Text)
            . TF.refValue

gameliftFleetResource :: TF.Schema TF.Resource P.AWS (GameliftFleetResource s)
gameliftFleetResource =
    TF.newResource "aws_gamelift_fleet" $
        GameliftFleetResource {
              _build_id = TF.Nil
            , _description = TF.Nil
            , _ec2_inbound_permission = TF.Nil
            , _ec2_instance_type = TF.Nil
            , _metric_groups = TF.Nil
            , _name = TF.Nil
            , _new_game_session_protection_policy = TF.Nil
            , _resource_creation_limit_policy = TF.Nil
            , _runtime_configuration = TF.Nil
            }

{- | The @aws_glacier_vault@ AWS resource.

Provides a Glacier Vault Resource. You can refer to the
<https://docs.aws.amazon.com/amazonglacier/latest/dev/working-with-vaults.html>
for a full explanation of the Glacier Vault functionality ~> NOTE: When
removing a Glacier Vault, the Vault must be empty.
-}
data GlacierVaultResource s = GlacierVaultResource {
      _access_policy :: !(TF.Attr s Text)
    {- ^ (Optional) The policy document. This is a JSON formatted string. The heredoc syntax or @file@ function is helpful here. Use the <https://docs.aws.amazon.com/amazonglacier/latest/dev/vault-access-policy.html> for more information on Glacier Vault Policy -}
    , _name          :: !(TF.Attr s Text)
    {- ^ (Required) The name of the Vault. Names can be between 1 and 255 characters long and the valid characters are a-z, A-Z, 0-9, '_' (underscore), '-' (hyphen), and '.' (period). -}
    , _notification  :: !(TF.Attr s Text)
    {- ^ (Optional) The notifications for the Vault. Fields documented below. -}
    , _tags          :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    } deriving (Show, Eq)

instance TF.ToHCL (GlacierVaultResource s) where
    toHCL GlacierVaultResource{..} = TF.inline $ catMaybes
        [ TF.assign "access_policy" <$> TF.attribute _access_policy
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "notification" <$> TF.attribute _notification
        , TF.assign "tags" <$> TF.attribute _tags
        ]

instance P.HasAccessPolicy (GlacierVaultResource s) (TF.Attr s Text) where
    accessPolicy =
        lens (_access_policy :: GlacierVaultResource s -> TF.Attr s Text)
             (\s a -> s { _access_policy = a } :: GlacierVaultResource s)

instance P.HasName (GlacierVaultResource s) (TF.Attr s Text) where
    name =
        lens (_name :: GlacierVaultResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: GlacierVaultResource s)

instance P.HasNotification (GlacierVaultResource s) (TF.Attr s Text) where
    notification =
        lens (_notification :: GlacierVaultResource s -> TF.Attr s Text)
             (\s a -> s { _notification = a } :: GlacierVaultResource s)

instance P.HasTags (GlacierVaultResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: GlacierVaultResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: GlacierVaultResource s)

instance P.HasComputedAccessPolicy (GlacierVaultResource s) s (TF.Attr s Text) where
    computedAccessPolicy =
        (_access_policy :: GlacierVaultResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedArn (GlacierVaultResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedLocation (GlacierVaultResource s) s (TF.Attr s Text) where
    computedLocation x = TF.compute (TF.refKey x) "location"

instance P.HasComputedName (GlacierVaultResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: GlacierVaultResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedNotification (GlacierVaultResource s) s (TF.Attr s Text) where
    computedNotification =
        (_notification :: GlacierVaultResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (GlacierVaultResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: GlacierVaultResource s -> TF.Attr s P.Tags)
            . TF.refValue

glacierVaultResource :: TF.Schema TF.Resource P.AWS (GlacierVaultResource s)
glacierVaultResource =
    TF.newResource "aws_glacier_vault" $
        GlacierVaultResource {
              _access_policy = TF.Nil
            , _name = TF.Nil
            , _notification = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_glue_catalog_database@ AWS resource.

Provides a Glue Catalog Database Resource. You can refer to the
<http://docs.aws.amazon.com/glue/latest/dg/populate-data-catalog.html> for a
full explanation of the Glue Data Catalog functionality
-}
data GlueCatalogDatabaseResource s = GlueCatalogDatabaseResource {
      _catalog_id   :: !(TF.Attr s Text)
    {- ^ (Optional) ID of the Glue Catalog to create the database in. If omitted, this defaults to the AWS Account ID. -}
    , _description  :: !(TF.Attr s Text)
    {- ^ (Optional) Description of the database. -}
    , _location_uri :: !(TF.Attr s Text)
    {- ^ (Optional) The location of the database (for example, an HDFS path). -}
    , _name         :: !(TF.Attr s Text)
    {- ^ (Required) The name of the database. -}
    , _parameters   :: !(TF.Attr s Text)
    {- ^ (Optional) A list of key-value pairs that define parameters and properties of the database. -}
    } deriving (Show, Eq)

instance TF.ToHCL (GlueCatalogDatabaseResource s) where
    toHCL GlueCatalogDatabaseResource{..} = TF.inline $ catMaybes
        [ TF.assign "catalog_id" <$> TF.attribute _catalog_id
        , TF.assign "description" <$> TF.attribute _description
        , TF.assign "location_uri" <$> TF.attribute _location_uri
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "parameters" <$> TF.attribute _parameters
        ]

instance P.HasCatalogId (GlueCatalogDatabaseResource s) (TF.Attr s Text) where
    catalogId =
        lens (_catalog_id :: GlueCatalogDatabaseResource s -> TF.Attr s Text)
             (\s a -> s { _catalog_id = a } :: GlueCatalogDatabaseResource s)

instance P.HasDescription (GlueCatalogDatabaseResource s) (TF.Attr s Text) where
    description =
        lens (_description :: GlueCatalogDatabaseResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: GlueCatalogDatabaseResource s)

instance P.HasLocationUri (GlueCatalogDatabaseResource s) (TF.Attr s Text) where
    locationUri =
        lens (_location_uri :: GlueCatalogDatabaseResource s -> TF.Attr s Text)
             (\s a -> s { _location_uri = a } :: GlueCatalogDatabaseResource s)

instance P.HasName (GlueCatalogDatabaseResource s) (TF.Attr s Text) where
    name =
        lens (_name :: GlueCatalogDatabaseResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: GlueCatalogDatabaseResource s)

instance P.HasParameters (GlueCatalogDatabaseResource s) (TF.Attr s Text) where
    parameters =
        lens (_parameters :: GlueCatalogDatabaseResource s -> TF.Attr s Text)
             (\s a -> s { _parameters = a } :: GlueCatalogDatabaseResource s)

instance P.HasComputedCatalogId (GlueCatalogDatabaseResource s) s (TF.Attr s Text) where
    computedCatalogId =
        (_catalog_id :: GlueCatalogDatabaseResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDescription (GlueCatalogDatabaseResource s) s (TF.Attr s Text) where
    computedDescription =
        (_description :: GlueCatalogDatabaseResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedLocationUri (GlueCatalogDatabaseResource s) s (TF.Attr s Text) where
    computedLocationUri =
        (_location_uri :: GlueCatalogDatabaseResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (GlueCatalogDatabaseResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: GlueCatalogDatabaseResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedParameters (GlueCatalogDatabaseResource s) s (TF.Attr s Text) where
    computedParameters =
        (_parameters :: GlueCatalogDatabaseResource s -> TF.Attr s Text)
            . TF.refValue

glueCatalogDatabaseResource :: TF.Schema TF.Resource P.AWS (GlueCatalogDatabaseResource s)
glueCatalogDatabaseResource =
    TF.newResource "aws_glue_catalog_database" $
        GlueCatalogDatabaseResource {
              _catalog_id = TF.Nil
            , _description = TF.Nil
            , _location_uri = TF.Nil
            , _name = TF.Nil
            , _parameters = TF.Nil
            }

{- | The @aws_guardduty_detector@ AWS resource.

Provides a resource to manage a GuardDuty detector. ~> NOTE: Deleting this
resource is equivalent to "disabling" GuardDuty for an AWS region, which
removes all existing findings. You can set the @enable@ attribute to @false@
to instead "suspend" monitoring and feedback reporting while keeping
existing data. See the
<https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_suspend-disable.html>
for more information.
-}
data GuarddutyDetectorResource s = GuarddutyDetectorResource {
      _enable :: !(TF.Attr s P.Bool)
    {- ^ (Optional) Enable monitoring and feedback reporting. Setting to @false@ is equivalent to "suspending" GuardDuty. Defaults to @true@ . -}
    } deriving (Show, Eq)

instance TF.ToHCL (GuarddutyDetectorResource s) where
    toHCL GuarddutyDetectorResource{..} = TF.inline $ catMaybes
        [ TF.assign "enable" <$> TF.attribute _enable
        ]

instance P.HasEnable (GuarddutyDetectorResource s) (TF.Attr s P.Bool) where
    enable =
        lens (_enable :: GuarddutyDetectorResource s -> TF.Attr s P.Bool)
             (\s a -> s { _enable = a } :: GuarddutyDetectorResource s)

instance P.HasComputedAccountId (GuarddutyDetectorResource s) s (TF.Attr s Text) where
    computedAccountId x = TF.compute (TF.refKey x) "account_id"

instance P.HasComputedEnable (GuarddutyDetectorResource s) s (TF.Attr s P.Bool) where
    computedEnable =
        (_enable :: GuarddutyDetectorResource s -> TF.Attr s P.Bool)
            . TF.refValue

instance P.HasComputedId (GuarddutyDetectorResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

guarddutyDetectorResource :: TF.Schema TF.Resource P.AWS (GuarddutyDetectorResource s)
guarddutyDetectorResource =
    TF.newResource "aws_guardduty_detector" $
        GuarddutyDetectorResource {
              _enable = TF.Nil
            }

{- | The @aws_guardduty_ipset@ AWS resource.

Provides a resource to manage a GuardDuty IPSet. ~> Note: Currently in
GuardDuty, users from member accounts cannot upload and further manage
IPSets. IPSets that are uploaded by the master account are imposed on
GuardDuty functionality in its member accounts. See the
<https://docs.aws.amazon.com/guardduty/latest/ug/create-ip-set.html>
-}
data GuarddutyIpsetResource s = GuarddutyIpsetResource {
      _activate    :: !(TF.Attr s Text)
    {- ^ (Required) Specifies whether GuardDuty is to start using the uploaded IPSet. -}
    , _detector_id :: !(TF.Attr s Text)
    {- ^ (Required) The detector ID of the GuardDuty. -}
    , _format      :: !(TF.Attr s Text)
    {- ^ (Required) The format of the file that contains the IPSet. Valid values: @TXT@ | @STIX@ | @OTX_CSV@ | @ALIEN_VAULT@ | @PROOF_POINT@ | @FIRE_EYE@ -}
    , _location    :: !(TF.Attr s Text)
    {- ^ (Required) The URI of the file that contains the IPSet. -}
    , _name        :: !(TF.Attr s Text)
    {- ^ (Required) The friendly name to identify the IPSet. -}
    } deriving (Show, Eq)

instance TF.ToHCL (GuarddutyIpsetResource s) where
    toHCL GuarddutyIpsetResource{..} = TF.inline $ catMaybes
        [ TF.assign "activate" <$> TF.attribute _activate
        , TF.assign "detector_id" <$> TF.attribute _detector_id
        , TF.assign "format" <$> TF.attribute _format
        , TF.assign "location" <$> TF.attribute _location
        , TF.assign "name" <$> TF.attribute _name
        ]

instance P.HasActivate (GuarddutyIpsetResource s) (TF.Attr s Text) where
    activate =
        lens (_activate :: GuarddutyIpsetResource s -> TF.Attr s Text)
             (\s a -> s { _activate = a } :: GuarddutyIpsetResource s)

instance P.HasDetectorId (GuarddutyIpsetResource s) (TF.Attr s Text) where
    detectorId =
        lens (_detector_id :: GuarddutyIpsetResource s -> TF.Attr s Text)
             (\s a -> s { _detector_id = a } :: GuarddutyIpsetResource s)

instance P.HasFormat (GuarddutyIpsetResource s) (TF.Attr s Text) where
    format =
        lens (_format :: GuarddutyIpsetResource s -> TF.Attr s Text)
             (\s a -> s { _format = a } :: GuarddutyIpsetResource s)

instance P.HasLocation (GuarddutyIpsetResource s) (TF.Attr s Text) where
    location =
        lens (_location :: GuarddutyIpsetResource s -> TF.Attr s Text)
             (\s a -> s { _location = a } :: GuarddutyIpsetResource s)

instance P.HasName (GuarddutyIpsetResource s) (TF.Attr s Text) where
    name =
        lens (_name :: GuarddutyIpsetResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: GuarddutyIpsetResource s)

instance P.HasComputedActivate (GuarddutyIpsetResource s) s (TF.Attr s Text) where
    computedActivate =
        (_activate :: GuarddutyIpsetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDetectorId (GuarddutyIpsetResource s) s (TF.Attr s Text) where
    computedDetectorId =
        (_detector_id :: GuarddutyIpsetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedFormat (GuarddutyIpsetResource s) s (TF.Attr s Text) where
    computedFormat =
        (_format :: GuarddutyIpsetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (GuarddutyIpsetResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedLocation (GuarddutyIpsetResource s) s (TF.Attr s Text) where
    computedLocation =
        (_location :: GuarddutyIpsetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (GuarddutyIpsetResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: GuarddutyIpsetResource s -> TF.Attr s Text)
            . TF.refValue

guarddutyIpsetResource :: TF.Schema TF.Resource P.AWS (GuarddutyIpsetResource s)
guarddutyIpsetResource =
    TF.newResource "aws_guardduty_ipset" $
        GuarddutyIpsetResource {
              _activate = TF.Nil
            , _detector_id = TF.Nil
            , _format = TF.Nil
            , _location = TF.Nil
            , _name = TF.Nil
            }

{- | The @aws_guardduty_member@ AWS resource.

Provides a resource to manage a GuardDuty member. ~> NOTE: Currently after
using this resource, you must manually invite and accept member account
invitations before GuardDuty will begin sending cross-account events. More
information for how to accomplish this via the AWS Console or API can be
found in the
<https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_accounts.html> .
Terraform implementation of member invitation and acceptance resources can
be tracked in
<https://github.com/terraform-providers/terraform-provider-aws/issues/2489>
.
-}
data GuarddutyMemberResource s = GuarddutyMemberResource {
      _account_id  :: !(TF.Attr s Text)
    {- ^ (Required) AWS account ID for member account. -}
    , _detector_id :: !(TF.Attr s Text)
    {- ^ (Required) The detector ID of the GuardDuty account where you want to create member accounts. -}
    , _email       :: !(TF.Attr s Text)
    {- ^ (Required) Email address for member account. -}
    } deriving (Show, Eq)

instance TF.ToHCL (GuarddutyMemberResource s) where
    toHCL GuarddutyMemberResource{..} = TF.inline $ catMaybes
        [ TF.assign "account_id" <$> TF.attribute _account_id
        , TF.assign "detector_id" <$> TF.attribute _detector_id
        , TF.assign "email" <$> TF.attribute _email
        ]

instance P.HasAccountId (GuarddutyMemberResource s) (TF.Attr s Text) where
    accountId =
        lens (_account_id :: GuarddutyMemberResource s -> TF.Attr s Text)
             (\s a -> s { _account_id = a } :: GuarddutyMemberResource s)

instance P.HasDetectorId (GuarddutyMemberResource s) (TF.Attr s Text) where
    detectorId =
        lens (_detector_id :: GuarddutyMemberResource s -> TF.Attr s Text)
             (\s a -> s { _detector_id = a } :: GuarddutyMemberResource s)

instance P.HasEmail (GuarddutyMemberResource s) (TF.Attr s Text) where
    email =
        lens (_email :: GuarddutyMemberResource s -> TF.Attr s Text)
             (\s a -> s { _email = a } :: GuarddutyMemberResource s)

instance P.HasComputedAccountId (GuarddutyMemberResource s) s (TF.Attr s Text) where
    computedAccountId =
        (_account_id :: GuarddutyMemberResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDetectorId (GuarddutyMemberResource s) s (TF.Attr s Text) where
    computedDetectorId =
        (_detector_id :: GuarddutyMemberResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEmail (GuarddutyMemberResource s) s (TF.Attr s Text) where
    computedEmail =
        (_email :: GuarddutyMemberResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (GuarddutyMemberResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

guarddutyMemberResource :: TF.Schema TF.Resource P.AWS (GuarddutyMemberResource s)
guarddutyMemberResource =
    TF.newResource "aws_guardduty_member" $
        GuarddutyMemberResource {
              _account_id = TF.Nil
            , _detector_id = TF.Nil
            , _email = TF.Nil
            }

{- | The @aws_guardduty_threatintelset@ AWS resource.

Provides a resource to manage a GuardDuty ThreatIntelSet. ~> Note: Currently
in GuardDuty, users from member accounts cannot upload and further manage
ThreatIntelSets. ThreatIntelSets that are uploaded by the master account are
imposed on GuardDuty functionality in its member accounts. See the
<https://docs.aws.amazon.com/guardduty/latest/ug/create-threat-intel-set.html>
-}
data GuarddutyThreatintelsetResource s = GuarddutyThreatintelsetResource {
      _activate    :: !(TF.Attr s Text)
    {- ^ (Required) Specifies whether GuardDuty is to start using the uploaded ThreatIntelSet. -}
    , _detector_id :: !(TF.Attr s Text)
    {- ^ (Required) The detector ID of the GuardDuty. -}
    , _format      :: !(TF.Attr s Text)
    {- ^ (Required) The format of the file that contains the ThreatIntelSet. Valid values: @TXT@ | @STIX@ | @OTX_CSV@ | @ALIEN_VAULT@ | @PROOF_POINT@ | @FIRE_EYE@ -}
    , _location    :: !(TF.Attr s Text)
    {- ^ (Required) The URI of the file that contains the ThreatIntelSet. -}
    , _name        :: !(TF.Attr s Text)
    {- ^ (Required) The friendly name to identify the ThreatIntelSet. -}
    } deriving (Show, Eq)

instance TF.ToHCL (GuarddutyThreatintelsetResource s) where
    toHCL GuarddutyThreatintelsetResource{..} = TF.inline $ catMaybes
        [ TF.assign "activate" <$> TF.attribute _activate
        , TF.assign "detector_id" <$> TF.attribute _detector_id
        , TF.assign "format" <$> TF.attribute _format
        , TF.assign "location" <$> TF.attribute _location
        , TF.assign "name" <$> TF.attribute _name
        ]

instance P.HasActivate (GuarddutyThreatintelsetResource s) (TF.Attr s Text) where
    activate =
        lens (_activate :: GuarddutyThreatintelsetResource s -> TF.Attr s Text)
             (\s a -> s { _activate = a } :: GuarddutyThreatintelsetResource s)

instance P.HasDetectorId (GuarddutyThreatintelsetResource s) (TF.Attr s Text) where
    detectorId =
        lens (_detector_id :: GuarddutyThreatintelsetResource s -> TF.Attr s Text)
             (\s a -> s { _detector_id = a } :: GuarddutyThreatintelsetResource s)

instance P.HasFormat (GuarddutyThreatintelsetResource s) (TF.Attr s Text) where
    format =
        lens (_format :: GuarddutyThreatintelsetResource s -> TF.Attr s Text)
             (\s a -> s { _format = a } :: GuarddutyThreatintelsetResource s)

instance P.HasLocation (GuarddutyThreatintelsetResource s) (TF.Attr s Text) where
    location =
        lens (_location :: GuarddutyThreatintelsetResource s -> TF.Attr s Text)
             (\s a -> s { _location = a } :: GuarddutyThreatintelsetResource s)

instance P.HasName (GuarddutyThreatintelsetResource s) (TF.Attr s Text) where
    name =
        lens (_name :: GuarddutyThreatintelsetResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: GuarddutyThreatintelsetResource s)

instance P.HasComputedActivate (GuarddutyThreatintelsetResource s) s (TF.Attr s Text) where
    computedActivate =
        (_activate :: GuarddutyThreatintelsetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDetectorId (GuarddutyThreatintelsetResource s) s (TF.Attr s Text) where
    computedDetectorId =
        (_detector_id :: GuarddutyThreatintelsetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedFormat (GuarddutyThreatintelsetResource s) s (TF.Attr s Text) where
    computedFormat =
        (_format :: GuarddutyThreatintelsetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (GuarddutyThreatintelsetResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedLocation (GuarddutyThreatintelsetResource s) s (TF.Attr s Text) where
    computedLocation =
        (_location :: GuarddutyThreatintelsetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (GuarddutyThreatintelsetResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: GuarddutyThreatintelsetResource s -> TF.Attr s Text)
            . TF.refValue

guarddutyThreatintelsetResource :: TF.Schema TF.Resource P.AWS (GuarddutyThreatintelsetResource s)
guarddutyThreatintelsetResource =
    TF.newResource "aws_guardduty_threatintelset" $
        GuarddutyThreatintelsetResource {
              _activate = TF.Nil
            , _detector_id = TF.Nil
            , _format = TF.Nil
            , _location = TF.Nil
            , _name = TF.Nil
            }

{- | The @aws_iam_access_key@ AWS resource.

Provides an IAM access key. This is a set of credentials that allow API
requests to be made as an IAM user.
-}
data IamAccessKeyResource s = IamAccessKeyResource {
      _pgp_key :: !(TF.Attr s Text)
    {- ^ (Optional) Either a base-64 encoded PGP public key, or a keybase username in the form @keybase:some_person_that_exists@ . -}
    , _user    :: !(TF.Attr s Text)
    {- ^ (Required) The IAM user to associate with this access key. -}
    } deriving (Show, Eq)

instance TF.ToHCL (IamAccessKeyResource s) where
    toHCL IamAccessKeyResource{..} = TF.inline $ catMaybes
        [ TF.assign "pgp_key" <$> TF.attribute _pgp_key
        , TF.assign "user" <$> TF.attribute _user
        ]

instance P.HasPgpKey (IamAccessKeyResource s) (TF.Attr s Text) where
    pgpKey =
        lens (_pgp_key :: IamAccessKeyResource s -> TF.Attr s Text)
             (\s a -> s { _pgp_key = a } :: IamAccessKeyResource s)

instance P.HasUser (IamAccessKeyResource s) (TF.Attr s Text) where
    user =
        lens (_user :: IamAccessKeyResource s -> TF.Attr s Text)
             (\s a -> s { _user = a } :: IamAccessKeyResource s)

instance P.HasComputedEncryptedSecret (IamAccessKeyResource s) s (TF.Attr s Text) where
    computedEncryptedSecret x = TF.compute (TF.refKey x) "encrypted_secret"

instance P.HasComputedId (IamAccessKeyResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedKeyFingerprint (IamAccessKeyResource s) s (TF.Attr s Text) where
    computedKeyFingerprint x = TF.compute (TF.refKey x) "key_fingerprint"

instance P.HasComputedPgpKey (IamAccessKeyResource s) s (TF.Attr s Text) where
    computedPgpKey =
        (_pgp_key :: IamAccessKeyResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSecret (IamAccessKeyResource s) s (TF.Attr s Text) where
    computedSecret x = TF.compute (TF.refKey x) "secret"

instance P.HasComputedSesSmtpPassword (IamAccessKeyResource s) s (TF.Attr s Text) where
    computedSesSmtpPassword x = TF.compute (TF.refKey x) "ses_smtp_password"

instance P.HasComputedStatus (IamAccessKeyResource s) s (TF.Attr s Text) where
    computedStatus x = TF.compute (TF.refKey x) "status"

instance P.HasComputedUser (IamAccessKeyResource s) s (TF.Attr s Text) where
    computedUser x = TF.compute (TF.refKey x) "user"

iamAccessKeyResource :: TF.Schema TF.Resource P.AWS (IamAccessKeyResource s)
iamAccessKeyResource =
    TF.newResource "aws_iam_access_key" $
        IamAccessKeyResource {
              _pgp_key = TF.Nil
            , _user = TF.Nil
            }

{- | The @aws_iam_account_alias@ AWS resource.

-> Note: There is only a single account alias per AWS account. Manages the
account alias for the AWS Account.
-}
data IamAccountAliasResource s = IamAccountAliasResource {
      _account_alias :: !(TF.Attr s Text)
    {- ^ (Required) The account alias -}
    } deriving (Show, Eq)

instance TF.ToHCL (IamAccountAliasResource s) where
    toHCL IamAccountAliasResource{..} = TF.inline $ catMaybes
        [ TF.assign "account_alias" <$> TF.attribute _account_alias
        ]

instance P.HasAccountAlias (IamAccountAliasResource s) (TF.Attr s Text) where
    accountAlias =
        lens (_account_alias :: IamAccountAliasResource s -> TF.Attr s Text)
             (\s a -> s { _account_alias = a } :: IamAccountAliasResource s)

instance P.HasComputedAccountAlias (IamAccountAliasResource s) s (TF.Attr s Text) where
    computedAccountAlias =
        (_account_alias :: IamAccountAliasResource s -> TF.Attr s Text)
            . TF.refValue

iamAccountAliasResource :: TF.Schema TF.Resource P.AWS (IamAccountAliasResource s)
iamAccountAliasResource =
    TF.newResource "aws_iam_account_alias" $
        IamAccountAliasResource {
              _account_alias = TF.Nil
            }

{- | The @aws_iam_account_password_policy@ AWS resource.

-> Note: There is only a single policy allowed per AWS account. An existing
policy will be lost when using this resource as an effect of this
limitation. Manages Password Policy for the AWS Account. See more about
<http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_passwords_account-policy.html>
in the official AWS docs.
-}
data IamAccountPasswordPolicyResource s = IamAccountPasswordPolicyResource {
      _allow_users_to_change_password :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to allow users to change their own password -}
    , _hard_expiry                    :: !(TF.Attr s Text)
    {- ^ (Optional) Whether users are prevented from setting a new password after their password has expired (i.e. require administrator reset) -}
    , _max_password_age               :: !(TF.Attr s Text)
    {- ^ (Optional) The number of days that an user password is valid. -}
    , _minimum_password_length        :: !(TF.Attr s Text)
    {- ^ (Optional) Minimum length to require for user passwords. -}
    , _password_reuse_prevention      :: !(TF.Attr s Text)
    {- ^ (Optional) The number of previous passwords that users are prevented from reusing. -}
    , _require_lowercase_characters   :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to require lowercase characters for user passwords. -}
    , _require_numbers                :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to require numbers for user passwords. -}
    , _require_symbols                :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to require symbols for user passwords. -}
    , _require_uppercase_characters   :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to require uppercase characters for user passwords. -}
    } deriving (Show, Eq)

instance TF.ToHCL (IamAccountPasswordPolicyResource s) where
    toHCL IamAccountPasswordPolicyResource{..} = TF.inline $ catMaybes
        [ TF.assign "allow_users_to_change_password" <$> TF.attribute _allow_users_to_change_password
        , TF.assign "hard_expiry" <$> TF.attribute _hard_expiry
        , TF.assign "max_password_age" <$> TF.attribute _max_password_age
        , TF.assign "minimum_password_length" <$> TF.attribute _minimum_password_length
        , TF.assign "password_reuse_prevention" <$> TF.attribute _password_reuse_prevention
        , TF.assign "require_lowercase_characters" <$> TF.attribute _require_lowercase_characters
        , TF.assign "require_numbers" <$> TF.attribute _require_numbers
        , TF.assign "require_symbols" <$> TF.attribute _require_symbols
        , TF.assign "require_uppercase_characters" <$> TF.attribute _require_uppercase_characters
        ]

instance P.HasAllowUsersToChangePassword (IamAccountPasswordPolicyResource s) (TF.Attr s Text) where
    allowUsersToChangePassword =
        lens (_allow_users_to_change_password :: IamAccountPasswordPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _allow_users_to_change_password = a } :: IamAccountPasswordPolicyResource s)

instance P.HasHardExpiry (IamAccountPasswordPolicyResource s) (TF.Attr s Text) where
    hardExpiry =
        lens (_hard_expiry :: IamAccountPasswordPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _hard_expiry = a } :: IamAccountPasswordPolicyResource s)

instance P.HasMaxPasswordAge (IamAccountPasswordPolicyResource s) (TF.Attr s Text) where
    maxPasswordAge =
        lens (_max_password_age :: IamAccountPasswordPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _max_password_age = a } :: IamAccountPasswordPolicyResource s)

instance P.HasMinimumPasswordLength (IamAccountPasswordPolicyResource s) (TF.Attr s Text) where
    minimumPasswordLength =
        lens (_minimum_password_length :: IamAccountPasswordPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _minimum_password_length = a } :: IamAccountPasswordPolicyResource s)

instance P.HasPasswordReusePrevention (IamAccountPasswordPolicyResource s) (TF.Attr s Text) where
    passwordReusePrevention =
        lens (_password_reuse_prevention :: IamAccountPasswordPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _password_reuse_prevention = a } :: IamAccountPasswordPolicyResource s)

instance P.HasRequireLowercaseCharacters (IamAccountPasswordPolicyResource s) (TF.Attr s Text) where
    requireLowercaseCharacters =
        lens (_require_lowercase_characters :: IamAccountPasswordPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _require_lowercase_characters = a } :: IamAccountPasswordPolicyResource s)

instance P.HasRequireNumbers (IamAccountPasswordPolicyResource s) (TF.Attr s Text) where
    requireNumbers =
        lens (_require_numbers :: IamAccountPasswordPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _require_numbers = a } :: IamAccountPasswordPolicyResource s)

instance P.HasRequireSymbols (IamAccountPasswordPolicyResource s) (TF.Attr s Text) where
    requireSymbols =
        lens (_require_symbols :: IamAccountPasswordPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _require_symbols = a } :: IamAccountPasswordPolicyResource s)

instance P.HasRequireUppercaseCharacters (IamAccountPasswordPolicyResource s) (TF.Attr s Text) where
    requireUppercaseCharacters =
        lens (_require_uppercase_characters :: IamAccountPasswordPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _require_uppercase_characters = a } :: IamAccountPasswordPolicyResource s)

instance P.HasComputedAllowUsersToChangePassword (IamAccountPasswordPolicyResource s) s (TF.Attr s Text) where
    computedAllowUsersToChangePassword =
        (_allow_users_to_change_password :: IamAccountPasswordPolicyResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedExpirePasswords (IamAccountPasswordPolicyResource s) s (TF.Attr s Text) where
    computedExpirePasswords x = TF.compute (TF.refKey x) "expire_passwords"

instance P.HasComputedHardExpiry (IamAccountPasswordPolicyResource s) s (TF.Attr s Text) where
    computedHardExpiry =
        (_hard_expiry :: IamAccountPasswordPolicyResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedMaxPasswordAge (IamAccountPasswordPolicyResource s) s (TF.Attr s Text) where
    computedMaxPasswordAge =
        (_max_password_age :: IamAccountPasswordPolicyResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedMinimumPasswordLength (IamAccountPasswordPolicyResource s) s (TF.Attr s Text) where
    computedMinimumPasswordLength =
        (_minimum_password_length :: IamAccountPasswordPolicyResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPasswordReusePrevention (IamAccountPasswordPolicyResource s) s (TF.Attr s Text) where
    computedPasswordReusePrevention =
        (_password_reuse_prevention :: IamAccountPasswordPolicyResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRequireLowercaseCharacters (IamAccountPasswordPolicyResource s) s (TF.Attr s Text) where
    computedRequireLowercaseCharacters =
        (_require_lowercase_characters :: IamAccountPasswordPolicyResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRequireNumbers (IamAccountPasswordPolicyResource s) s (TF.Attr s Text) where
    computedRequireNumbers =
        (_require_numbers :: IamAccountPasswordPolicyResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRequireSymbols (IamAccountPasswordPolicyResource s) s (TF.Attr s Text) where
    computedRequireSymbols =
        (_require_symbols :: IamAccountPasswordPolicyResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRequireUppercaseCharacters (IamAccountPasswordPolicyResource s) s (TF.Attr s Text) where
    computedRequireUppercaseCharacters =
        (_require_uppercase_characters :: IamAccountPasswordPolicyResource s -> TF.Attr s Text)
            . TF.refValue

iamAccountPasswordPolicyResource :: TF.Schema TF.Resource P.AWS (IamAccountPasswordPolicyResource s)
iamAccountPasswordPolicyResource =
    TF.newResource "aws_iam_account_password_policy" $
        IamAccountPasswordPolicyResource {
              _allow_users_to_change_password = TF.Nil
            , _hard_expiry = TF.Nil
            , _max_password_age = TF.Nil
            , _minimum_password_length = TF.Nil
            , _password_reuse_prevention = TF.Nil
            , _require_lowercase_characters = TF.Nil
            , _require_numbers = TF.Nil
            , _require_symbols = TF.Nil
            , _require_uppercase_characters = TF.Nil
            }

{- | The @aws_iam_group_membership@ AWS resource.

Provides a top level resource to manage IAM Group membership for IAM Users.
For more information on managing IAM Groups or IAM Users, see
</docs/providers/aws/r/iam_group.html> or
</docs/providers/aws/r/iam_user.html>
-}
data IamGroupMembershipResource s = IamGroupMembershipResource {
      _group :: !(TF.Attr s Text)
    {- ^  (Required) The IAM Group name to attach the list of @users@ to -}
    , _name  :: !(TF.Attr s Text)
    {- ^ (Required) The name to identify the Group Membership -}
    , _users :: !(TF.Attr s Text)
    {- ^ (Required) A list of IAM User names to associate with the Group -}
    } deriving (Show, Eq)

instance TF.ToHCL (IamGroupMembershipResource s) where
    toHCL IamGroupMembershipResource{..} = TF.inline $ catMaybes
        [ TF.assign "group" <$> TF.attribute _group
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "users" <$> TF.attribute _users
        ]

instance P.HasGroup (IamGroupMembershipResource s) (TF.Attr s Text) where
    group =
        lens (_group :: IamGroupMembershipResource s -> TF.Attr s Text)
             (\s a -> s { _group = a } :: IamGroupMembershipResource s)

instance P.HasName (IamGroupMembershipResource s) (TF.Attr s Text) where
    name =
        lens (_name :: IamGroupMembershipResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: IamGroupMembershipResource s)

instance P.HasUsers (IamGroupMembershipResource s) (TF.Attr s Text) where
    users =
        lens (_users :: IamGroupMembershipResource s -> TF.Attr s Text)
             (\s a -> s { _users = a } :: IamGroupMembershipResource s)

instance P.HasComputedGroup (IamGroupMembershipResource s) s (TF.Attr s Text) where
    computedGroup x = TF.compute (TF.refKey x) "group"

instance P.HasComputedName (IamGroupMembershipResource s) s (TF.Attr s Text) where
    computedName x = TF.compute (TF.refKey x) "name"

instance P.HasComputedUsers (IamGroupMembershipResource s) s (TF.Attr s Text) where
    computedUsers x = TF.compute (TF.refKey x) "users"

iamGroupMembershipResource :: TF.Schema TF.Resource P.AWS (IamGroupMembershipResource s)
iamGroupMembershipResource =
    TF.newResource "aws_iam_group_membership" $
        IamGroupMembershipResource {
              _group = TF.Nil
            , _name = TF.Nil
            , _users = TF.Nil
            }

{- | The @aws_iam_group_policy_attachment@ AWS resource.

Attaches a Managed IAM Policy to an IAM group
-}
data IamGroupPolicyAttachmentResource s = IamGroupPolicyAttachmentResource {
      _group      :: !(TF.Attr s Text)
    {- ^ (Required) - The group the policy should be applied to -}
    , _policy_arn :: !(TF.Attr s Text)
    {- ^ (Required) - The ARN of the policy you want to apply -}
    } deriving (Show, Eq)

instance TF.ToHCL (IamGroupPolicyAttachmentResource s) where
    toHCL IamGroupPolicyAttachmentResource{..} = TF.inline $ catMaybes
        [ TF.assign "group" <$> TF.attribute _group
        , TF.assign "policy_arn" <$> TF.attribute _policy_arn
        ]

instance P.HasGroup (IamGroupPolicyAttachmentResource s) (TF.Attr s Text) where
    group =
        lens (_group :: IamGroupPolicyAttachmentResource s -> TF.Attr s Text)
             (\s a -> s { _group = a } :: IamGroupPolicyAttachmentResource s)

instance P.HasPolicyArn (IamGroupPolicyAttachmentResource s) (TF.Attr s Text) where
    policyArn =
        lens (_policy_arn :: IamGroupPolicyAttachmentResource s -> TF.Attr s Text)
             (\s a -> s { _policy_arn = a } :: IamGroupPolicyAttachmentResource s)

instance P.HasComputedGroup (IamGroupPolicyAttachmentResource s) s (TF.Attr s Text) where
    computedGroup =
        (_group :: IamGroupPolicyAttachmentResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPolicyArn (IamGroupPolicyAttachmentResource s) s (TF.Attr s Text) where
    computedPolicyArn =
        (_policy_arn :: IamGroupPolicyAttachmentResource s -> TF.Attr s Text)
            . TF.refValue

iamGroupPolicyAttachmentResource :: TF.Schema TF.Resource P.AWS (IamGroupPolicyAttachmentResource s)
iamGroupPolicyAttachmentResource =
    TF.newResource "aws_iam_group_policy_attachment" $
        IamGroupPolicyAttachmentResource {
              _group = TF.Nil
            , _policy_arn = TF.Nil
            }

{- | The @aws_iam_group_policy@ AWS resource.

Provides an IAM policy attached to a group.
-}
data IamGroupPolicyResource s = IamGroupPolicyResource {
      _group       :: !(TF.Attr s Text)
    {- ^ (Required) The IAM group to attach to the policy. -}
    , _name        :: !(TF.Attr s Text)
    {- ^ (Optional) The name of the policy. If omitted, Terraform will assign a random, unique name. -}
    , _name_prefix :: !(TF.Attr s Text)
    {- ^ (Optional) Creates a unique name beginning with the specified prefix. Conflicts with @name@ . -}
    , _policy      :: !(TF.Attr s Text)
    {- ^ (Required) The policy document. This is a JSON formatted string. The heredoc syntax or @file@ function is helpful here. -}
    } deriving (Show, Eq)

instance TF.ToHCL (IamGroupPolicyResource s) where
    toHCL IamGroupPolicyResource{..} = TF.inline $ catMaybes
        [ TF.assign "group" <$> TF.attribute _group
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "name_prefix" <$> TF.attribute _name_prefix
        , TF.assign "policy" <$> TF.attribute _policy
        ]

instance P.HasGroup (IamGroupPolicyResource s) (TF.Attr s Text) where
    group =
        lens (_group :: IamGroupPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _group = a } :: IamGroupPolicyResource s)

instance P.HasName (IamGroupPolicyResource s) (TF.Attr s Text) where
    name =
        lens (_name :: IamGroupPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: IamGroupPolicyResource s)

instance P.HasNamePrefix (IamGroupPolicyResource s) (TF.Attr s Text) where
    namePrefix =
        lens (_name_prefix :: IamGroupPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _name_prefix = a } :: IamGroupPolicyResource s)

instance P.HasPolicy (IamGroupPolicyResource s) (TF.Attr s Text) where
    policy =
        lens (_policy :: IamGroupPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _policy = a } :: IamGroupPolicyResource s)

instance P.HasComputedGroup (IamGroupPolicyResource s) s (TF.Attr s Text) where
    computedGroup x = TF.compute (TF.refKey x) "group"

instance P.HasComputedId (IamGroupPolicyResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (IamGroupPolicyResource s) s (TF.Attr s Text) where
    computedName x = TF.compute (TF.refKey x) "name"

instance P.HasComputedNamePrefix (IamGroupPolicyResource s) s (TF.Attr s Text) where
    computedNamePrefix =
        (_name_prefix :: IamGroupPolicyResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPolicy (IamGroupPolicyResource s) s (TF.Attr s Text) where
    computedPolicy x = TF.compute (TF.refKey x) "policy"

iamGroupPolicyResource :: TF.Schema TF.Resource P.AWS (IamGroupPolicyResource s)
iamGroupPolicyResource =
    TF.newResource "aws_iam_group_policy" $
        IamGroupPolicyResource {
              _group = TF.Nil
            , _name = TF.Nil
            , _name_prefix = TF.Nil
            , _policy = TF.Nil
            }

{- | The @aws_iam_group@ AWS resource.

Provides an IAM group.
-}
data IamGroupResource s = IamGroupResource {
      _name :: !(TF.Attr s Text)
    {- ^ (Required) The group's name. The name must consist of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: @=,.@-_.@ . Group names are not distinguished by case. For example, you cannot create groups named both "ADMINS" and "admins". -}
    , _path :: !(TF.Attr s Text)
    {- ^ (Optional, default "/") Path in which to create the group. -}
    } deriving (Show, Eq)

instance TF.ToHCL (IamGroupResource s) where
    toHCL IamGroupResource{..} = TF.inline $ catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "path" <$> TF.attribute _path
        ]

instance P.HasName (IamGroupResource s) (TF.Attr s Text) where
    name =
        lens (_name :: IamGroupResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: IamGroupResource s)

instance P.HasPath (IamGroupResource s) (TF.Attr s Text) where
    path =
        lens (_path :: IamGroupResource s -> TF.Attr s Text)
             (\s a -> s { _path = a } :: IamGroupResource s)

instance P.HasComputedArn (IamGroupResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedId (IamGroupResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (IamGroupResource s) s (TF.Attr s Text) where
    computedName x = TF.compute (TF.refKey x) "name"

instance P.HasComputedPath (IamGroupResource s) s (TF.Attr s Text) where
    computedPath x = TF.compute (TF.refKey x) "path"

instance P.HasComputedUniqueId (IamGroupResource s) s (TF.Attr s Text) where
    computedUniqueId x = TF.compute (TF.refKey x) "unique_id"

iamGroupResource :: TF.Schema TF.Resource P.AWS (IamGroupResource s)
iamGroupResource =
    TF.newResource "aws_iam_group" $
        IamGroupResource {
              _name = TF.Nil
            , _path = TF.Nil
            }

{- | The @aws_iam_instance_profile@ AWS resource.

Provides an IAM instance profile. ~> NOTE: Either @role@ or @roles@ (
deprecated ) must be specified.
-}
data IamInstanceProfileResource s = IamInstanceProfileResource {
      _name        :: !(TF.Attr s Text)
    {- ^ (Optional, Forces new resource) The profile's name. If omitted, Terraform will assign a random, unique name. -}
    , _name_prefix :: !(TF.Attr s Text)
    {- ^ (Optional, Forces new resource) Creates a unique name beginning with the specified prefix. Conflicts with @name@ . -}
    , _path        :: !(TF.Attr s Text)
    {- ^ (Optional, default "/") Path in which to create the profile. -}
    , _role        :: !(TF.Attr s Text)
    {- ^ (Optional) The role name to include in the profile. -}
    , _roles       :: !(TF.Attr s Text)
    {- ^ - ( Deprecated ) A list of role names to include in the profile.  The current default is 1.  If you see an error message similar to @Cannot exceed quota for InstanceSessionsPerInstanceProfile: 1@ , then you must contact AWS support and ask for a limit increase. WARNING: This is deprecated since <https://github.com/hashicorp/terraform/blob/master/CHANGELOG.md#093-april-12-2017> , as >= 2 roles are not possible. See <https://github.com/hashicorp/terraform/issues/11575> . -}
    } deriving (Show, Eq)

instance TF.ToHCL (IamInstanceProfileResource s) where
    toHCL IamInstanceProfileResource{..} = TF.inline $ catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "name_prefix" <$> TF.attribute _name_prefix
        , TF.assign "path" <$> TF.attribute _path
        , TF.assign "role" <$> TF.attribute _role
        , TF.assign "roles" <$> TF.attribute _roles
        ]

instance P.HasName (IamInstanceProfileResource s) (TF.Attr s Text) where
    name =
        lens (_name :: IamInstanceProfileResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: IamInstanceProfileResource s)

instance P.HasNamePrefix (IamInstanceProfileResource s) (TF.Attr s Text) where
    namePrefix =
        lens (_name_prefix :: IamInstanceProfileResource s -> TF.Attr s Text)
             (\s a -> s { _name_prefix = a } :: IamInstanceProfileResource s)

instance P.HasPath (IamInstanceProfileResource s) (TF.Attr s Text) where
    path =
        lens (_path :: IamInstanceProfileResource s -> TF.Attr s Text)
             (\s a -> s { _path = a } :: IamInstanceProfileResource s)

instance P.HasRole (IamInstanceProfileResource s) (TF.Attr s Text) where
    role =
        lens (_role :: IamInstanceProfileResource s -> TF.Attr s Text)
             (\s a -> s { _role = a } :: IamInstanceProfileResource s)

instance P.HasRoles (IamInstanceProfileResource s) (TF.Attr s Text) where
    roles =
        lens (_roles :: IamInstanceProfileResource s -> TF.Attr s Text)
             (\s a -> s { _roles = a } :: IamInstanceProfileResource s)

instance P.HasComputedArn (IamInstanceProfileResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedCreateDate (IamInstanceProfileResource s) s (TF.Attr s Text) where
    computedCreateDate x = TF.compute (TF.refKey x) "create_date"

instance P.HasComputedId (IamInstanceProfileResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (IamInstanceProfileResource s) s (TF.Attr s Text) where
    computedName x = TF.compute (TF.refKey x) "name"

instance P.HasComputedNamePrefix (IamInstanceProfileResource s) s (TF.Attr s Text) where
    computedNamePrefix =
        (_name_prefix :: IamInstanceProfileResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPath (IamInstanceProfileResource s) s (TF.Attr s Text) where
    computedPath x = TF.compute (TF.refKey x) "path"

instance P.HasComputedRole (IamInstanceProfileResource s) s (TF.Attr s Text) where
    computedRole x = TF.compute (TF.refKey x) "role"

instance P.HasComputedRoles (IamInstanceProfileResource s) s (TF.Attr s Text) where
    computedRoles x = TF.compute (TF.refKey x) "roles"

instance P.HasComputedUniqueId (IamInstanceProfileResource s) s (TF.Attr s Text) where
    computedUniqueId x = TF.compute (TF.refKey x) "unique_id"

iamInstanceProfileResource :: TF.Schema TF.Resource P.AWS (IamInstanceProfileResource s)
iamInstanceProfileResource =
    TF.newResource "aws_iam_instance_profile" $
        IamInstanceProfileResource {
              _name = TF.Nil
            , _name_prefix = TF.Nil
            , _path = TF.Nil
            , _role = TF.Nil
            , _roles = TF.Nil
            }

{- | The @aws_iam_openid_connect_provider@ AWS resource.

Provides an IAM OpenID Connect provider.
-}
data IamOpenidConnectProviderResource s = IamOpenidConnectProviderResource {
      _client_id_list  :: !(TF.Attr s Text)
    {- ^ (Required) A list of client IDs (also known as audiences). When a mobile or web app registers with an OpenID Connect provider, they establish a value that identifies the application. (This is the value that's sent as the client_id parameter on OAuth requests.) -}
    , _thumbprint_list :: !(TF.Attr s Text)
    {- ^ (Required) A list of server certificate thumbprints for the OpenID Connect (OIDC) identity provider's server certificate(s). -}
    , _url             :: !(TF.Attr s Text)
    {- ^ (Required) The URL of the identity provider. Corresponds to the iss claim. -}
    } deriving (Show, Eq)

instance TF.ToHCL (IamOpenidConnectProviderResource s) where
    toHCL IamOpenidConnectProviderResource{..} = TF.inline $ catMaybes
        [ TF.assign "client_id_list" <$> TF.attribute _client_id_list
        , TF.assign "thumbprint_list" <$> TF.attribute _thumbprint_list
        , TF.assign "url" <$> TF.attribute _url
        ]

instance P.HasClientIdList (IamOpenidConnectProviderResource s) (TF.Attr s Text) where
    clientIdList =
        lens (_client_id_list :: IamOpenidConnectProviderResource s -> TF.Attr s Text)
             (\s a -> s { _client_id_list = a } :: IamOpenidConnectProviderResource s)

instance P.HasThumbprintList (IamOpenidConnectProviderResource s) (TF.Attr s Text) where
    thumbprintList =
        lens (_thumbprint_list :: IamOpenidConnectProviderResource s -> TF.Attr s Text)
             (\s a -> s { _thumbprint_list = a } :: IamOpenidConnectProviderResource s)

instance P.HasUrl (IamOpenidConnectProviderResource s) (TF.Attr s Text) where
    url =
        lens (_url :: IamOpenidConnectProviderResource s -> TF.Attr s Text)
             (\s a -> s { _url = a } :: IamOpenidConnectProviderResource s)

instance P.HasComputedArn (IamOpenidConnectProviderResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedClientIdList (IamOpenidConnectProviderResource s) s (TF.Attr s Text) where
    computedClientIdList =
        (_client_id_list :: IamOpenidConnectProviderResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedThumbprintList (IamOpenidConnectProviderResource s) s (TF.Attr s Text) where
    computedThumbprintList =
        (_thumbprint_list :: IamOpenidConnectProviderResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedUrl (IamOpenidConnectProviderResource s) s (TF.Attr s Text) where
    computedUrl =
        (_url :: IamOpenidConnectProviderResource s -> TF.Attr s Text)
            . TF.refValue

iamOpenidConnectProviderResource :: TF.Schema TF.Resource P.AWS (IamOpenidConnectProviderResource s)
iamOpenidConnectProviderResource =
    TF.newResource "aws_iam_openid_connect_provider" $
        IamOpenidConnectProviderResource {
              _client_id_list = TF.Nil
            , _thumbprint_list = TF.Nil
            , _url = TF.Nil
            }

{- | The @aws_iam_policy_attachment@ AWS resource.

Attaches a Managed IAM Policy to user(s), role(s), and/or group(s) !>
WARNING: The aws_iam_policy_attachment resource creates exclusive
attachments of IAM policies. Across the entire AWS account, all of the
users/roles/groups to which a single policy is attached must be declared by
a single aws_iam_policy_attachment resource. This means that even any
users/roles/groups that have the attached policy via some mechanism other
than Terraform will have that attached policy revoked by Terraform. Consider
@aws_iam_role_policy_attachment@ , @iam_user_policy_attachment@ , or
@iam_group_policy_attachment@ instead. These resources do not enforce
exclusive attachment of an IAM policy.
-}
data IamPolicyAttachmentResource s = IamPolicyAttachmentResource {
      _groups     :: !(TF.Attr s Text)
    {- ^ (Optional) - The group(s) the policy should be applied to -}
    , _name       :: !(TF.Attr s Text)
    {- ^ (Required) - The name of the policy. This cannot be an empty string. -}
    , _policy_arn :: !(TF.Attr s Text)
    {- ^ (Required) - The ARN of the policy you want to apply -}
    , _roles      :: !(P.Maybe [TF.Attr s Text])
    {- ^ (Optional) - The role(s) the policy should be applied to -}
    , _users      :: !(TF.Attr s Text)
    {- ^ (Optional) - The user(s) the policy should be applied to -}
    } deriving (Show, Eq)

instance TF.ToHCL (IamPolicyAttachmentResource s) where
    toHCL IamPolicyAttachmentResource{..} = TF.inline $ catMaybes
        [ TF.assign "groups" <$> TF.attribute _groups
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "policy_arn" <$> TF.attribute _policy_arn
        , TF.assign "roles" <$> TF.repeated _roles
        , TF.assign "users" <$> TF.attribute _users
        ]

instance P.HasGroups (IamPolicyAttachmentResource s) (TF.Attr s Text) where
    groups =
        lens (_groups :: IamPolicyAttachmentResource s -> TF.Attr s Text)
             (\s a -> s { _groups = a } :: IamPolicyAttachmentResource s)

instance P.HasName (IamPolicyAttachmentResource s) (TF.Attr s Text) where
    name =
        lens (_name :: IamPolicyAttachmentResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: IamPolicyAttachmentResource s)

instance P.HasPolicyArn (IamPolicyAttachmentResource s) (TF.Attr s Text) where
    policyArn =
        lens (_policy_arn :: IamPolicyAttachmentResource s -> TF.Attr s Text)
             (\s a -> s { _policy_arn = a } :: IamPolicyAttachmentResource s)

instance P.HasRoles (IamPolicyAttachmentResource s) (P.Maybe [TF.Attr s Text]) where
    roles =
        lens (_roles :: IamPolicyAttachmentResource s -> P.Maybe [TF.Attr s Text])
             (\s a -> s { _roles = a } :: IamPolicyAttachmentResource s)

instance P.HasUsers (IamPolicyAttachmentResource s) (TF.Attr s Text) where
    users =
        lens (_users :: IamPolicyAttachmentResource s -> TF.Attr s Text)
             (\s a -> s { _users = a } :: IamPolicyAttachmentResource s)

instance P.HasComputedGroups (IamPolicyAttachmentResource s) s (TF.Attr s Text) where
    computedGroups =
        (_groups :: IamPolicyAttachmentResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (IamPolicyAttachmentResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (IamPolicyAttachmentResource s) s (TF.Attr s Text) where
    computedName x = TF.compute (TF.refKey x) "name"

instance P.HasComputedPolicyArn (IamPolicyAttachmentResource s) s (TF.Attr s Text) where
    computedPolicyArn =
        (_policy_arn :: IamPolicyAttachmentResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRoles (IamPolicyAttachmentResource s) s (P.Maybe [TF.Attr s Text]) where
    computedRoles =
        (_roles :: IamPolicyAttachmentResource s -> P.Maybe [TF.Attr s Text])
            . TF.refValue

instance P.HasComputedUsers (IamPolicyAttachmentResource s) s (TF.Attr s Text) where
    computedUsers =
        (_users :: IamPolicyAttachmentResource s -> TF.Attr s Text)
            . TF.refValue

iamPolicyAttachmentResource :: TF.Schema TF.Resource P.AWS (IamPolicyAttachmentResource s)
iamPolicyAttachmentResource =
    TF.newResource "aws_iam_policy_attachment" $
        IamPolicyAttachmentResource {
              _groups = TF.Nil
            , _name = TF.Nil
            , _policy_arn = TF.Nil
            , _roles = P.Nothing
            , _users = TF.Nil
            }

{- | The @aws_iam_policy@ AWS resource.

Provides an IAM policy.
-}
data IamPolicyResource s = IamPolicyResource {
      _description :: !(TF.Attr s Text)
    {- ^ (Optional) Description of the IAM policy. -}
    , _name        :: !(TF.Attr s Text)
    {- ^ (Optional, Forces new resource) The name of the policy. If omitted, Terraform will assign a random, unique name. -}
    , _name_prefix :: !(TF.Attr s Text)
    {- ^ (Optional, Forces new resource) Creates a unique name beginning with the specified prefix. Conflicts with @name@ . -}
    , _path        :: !(TF.Attr s Text)
    {- ^ (Optional, default "/") Path in which to create the policy. See <https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html> for more information. -}
    , _policy      :: !(TF.Attr s P.IamPolicy)
    {- ^ (Required) The policy document. This is a JSON formatted string. The heredoc syntax, @file@ function, or the </docs/providers/aws/d/iam_policy_document.html> are all helpful here. -}
    } deriving (Show, Eq)

instance TF.ToHCL (IamPolicyResource s) where
    toHCL IamPolicyResource{..} = TF.inline $ catMaybes
        [ TF.assign "description" <$> TF.attribute _description
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "name_prefix" <$> TF.attribute _name_prefix
        , TF.assign "path" <$> TF.attribute _path
        , TF.assign "policy" <$> TF.attribute _policy
        ]

instance P.HasDescription (IamPolicyResource s) (TF.Attr s Text) where
    description =
        lens (_description :: IamPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: IamPolicyResource s)

instance P.HasName (IamPolicyResource s) (TF.Attr s Text) where
    name =
        lens (_name :: IamPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: IamPolicyResource s)

instance P.HasNamePrefix (IamPolicyResource s) (TF.Attr s Text) where
    namePrefix =
        lens (_name_prefix :: IamPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _name_prefix = a } :: IamPolicyResource s)

instance P.HasPath (IamPolicyResource s) (TF.Attr s Text) where
    path =
        lens (_path :: IamPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _path = a } :: IamPolicyResource s)

instance P.HasPolicy (IamPolicyResource s) (TF.Attr s P.IamPolicy) where
    policy =
        lens (_policy :: IamPolicyResource s -> TF.Attr s P.IamPolicy)
             (\s a -> s { _policy = a } :: IamPolicyResource s)

instance P.HasComputedArn (IamPolicyResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedDescription (IamPolicyResource s) s (TF.Attr s Text) where
    computedDescription x = TF.compute (TF.refKey x) "description"

instance P.HasComputedId (IamPolicyResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (IamPolicyResource s) s (TF.Attr s Text) where
    computedName x = TF.compute (TF.refKey x) "name"

instance P.HasComputedNamePrefix (IamPolicyResource s) s (TF.Attr s Text) where
    computedNamePrefix =
        (_name_prefix :: IamPolicyResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPath (IamPolicyResource s) s (TF.Attr s Text) where
    computedPath x = TF.compute (TF.refKey x) "path"

instance P.HasComputedPolicy (IamPolicyResource s) s (TF.Attr s Text) where
    computedPolicy x = TF.compute (TF.refKey x) "policy"

iamPolicyResource :: TF.Schema TF.Resource P.AWS (IamPolicyResource s)
iamPolicyResource =
    TF.newResource "aws_iam_policy" $
        IamPolicyResource {
              _description = TF.Nil
            , _name = TF.Nil
            , _name_prefix = TF.Nil
            , _path = TF.Nil
            , _policy = TF.Nil
            }

{- | The @aws_iam_role_policy_attachment@ AWS resource.

Attaches a Managed IAM Policy to an IAM role
-}
data IamRolePolicyAttachmentResource s = IamRolePolicyAttachmentResource {
      _policy_arn :: !(TF.Attr s Text)
    {- ^ (Required) - The ARN of the policy you want to apply -}
    , _role       :: !(TF.Attr s Text)
    {- ^ (Required) - The role the policy should be applied to -}
    } deriving (Show, Eq)

instance TF.ToHCL (IamRolePolicyAttachmentResource s) where
    toHCL IamRolePolicyAttachmentResource{..} = TF.inline $ catMaybes
        [ TF.assign "policy_arn" <$> TF.attribute _policy_arn
        , TF.assign "role" <$> TF.attribute _role
        ]

instance P.HasPolicyArn (IamRolePolicyAttachmentResource s) (TF.Attr s Text) where
    policyArn =
        lens (_policy_arn :: IamRolePolicyAttachmentResource s -> TF.Attr s Text)
             (\s a -> s { _policy_arn = a } :: IamRolePolicyAttachmentResource s)

instance P.HasRole (IamRolePolicyAttachmentResource s) (TF.Attr s Text) where
    role =
        lens (_role :: IamRolePolicyAttachmentResource s -> TF.Attr s Text)
             (\s a -> s { _role = a } :: IamRolePolicyAttachmentResource s)

instance P.HasComputedPolicyArn (IamRolePolicyAttachmentResource s) s (TF.Attr s Text) where
    computedPolicyArn =
        (_policy_arn :: IamRolePolicyAttachmentResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRole (IamRolePolicyAttachmentResource s) s (TF.Attr s Text) where
    computedRole =
        (_role :: IamRolePolicyAttachmentResource s -> TF.Attr s Text)
            . TF.refValue

iamRolePolicyAttachmentResource :: TF.Schema TF.Resource P.AWS (IamRolePolicyAttachmentResource s)
iamRolePolicyAttachmentResource =
    TF.newResource "aws_iam_role_policy_attachment" $
        IamRolePolicyAttachmentResource {
              _policy_arn = TF.Nil
            , _role = TF.Nil
            }

{- | The @aws_iam_role_policy@ AWS resource.

Provides an IAM role policy.
-}
data IamRolePolicyResource s = IamRolePolicyResource {
      _name        :: !(TF.Attr s Text)
    {- ^ (Optional) The name of the role policy. If omitted, Terraform will assign a random, unique name. -}
    , _name_prefix :: !(TF.Attr s Text)
    {- ^ (Optional) Creates a unique name beginning with the specified prefix. Conflicts with @name@ . -}
    , _policy      :: !(TF.Attr s Text)
    {- ^ (Required) The policy document. This is a JSON formatted string. The heredoc syntax or @file@ function is helpful here. -}
    , _role        :: !(TF.Attr s Text)
    {- ^ (Required) The IAM role to attach to the policy. -}
    } deriving (Show, Eq)

instance TF.ToHCL (IamRolePolicyResource s) where
    toHCL IamRolePolicyResource{..} = TF.inline $ catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "name_prefix" <$> TF.attribute _name_prefix
        , TF.assign "policy" <$> TF.attribute _policy
        , TF.assign "role" <$> TF.attribute _role
        ]

instance P.HasName (IamRolePolicyResource s) (TF.Attr s Text) where
    name =
        lens (_name :: IamRolePolicyResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: IamRolePolicyResource s)

instance P.HasNamePrefix (IamRolePolicyResource s) (TF.Attr s Text) where
    namePrefix =
        lens (_name_prefix :: IamRolePolicyResource s -> TF.Attr s Text)
             (\s a -> s { _name_prefix = a } :: IamRolePolicyResource s)

instance P.HasPolicy (IamRolePolicyResource s) (TF.Attr s Text) where
    policy =
        lens (_policy :: IamRolePolicyResource s -> TF.Attr s Text)
             (\s a -> s { _policy = a } :: IamRolePolicyResource s)

instance P.HasRole (IamRolePolicyResource s) (TF.Attr s Text) where
    role =
        lens (_role :: IamRolePolicyResource s -> TF.Attr s Text)
             (\s a -> s { _role = a } :: IamRolePolicyResource s)

instance P.HasComputedId (IamRolePolicyResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (IamRolePolicyResource s) s (TF.Attr s Text) where
    computedName x = TF.compute (TF.refKey x) "name"

instance P.HasComputedNamePrefix (IamRolePolicyResource s) s (TF.Attr s Text) where
    computedNamePrefix =
        (_name_prefix :: IamRolePolicyResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPolicy (IamRolePolicyResource s) s (TF.Attr s Text) where
    computedPolicy x = TF.compute (TF.refKey x) "policy"

instance P.HasComputedRole (IamRolePolicyResource s) s (TF.Attr s Text) where
    computedRole x = TF.compute (TF.refKey x) "role"

iamRolePolicyResource :: TF.Schema TF.Resource P.AWS (IamRolePolicyResource s)
iamRolePolicyResource =
    TF.newResource "aws_iam_role_policy" $
        IamRolePolicyResource {
              _name = TF.Nil
            , _name_prefix = TF.Nil
            , _policy = TF.Nil
            , _role = TF.Nil
            }

{- | The @aws_iam_role@ AWS resource.

Provides an IAM role.
-}
data IamRoleResource s = IamRoleResource {
      _assume_role_policy :: !(TF.Attr s P.IamPolicy)
    {- ^ (Required) The policy that grants an entity permission to assume the role. -}
    , _name               :: !(TF.Attr s Text)
    {- ^ (Optional, Forces new resource) The name of the role. If omitted, Terraform will assign a random, unique name. -}
    , _name_prefix        :: !(TF.Attr s Text)
    {- ^ (Optional, Forces new resource) Creates a unique name beginning with the specified prefix. Conflicts with @name@ . -}
    } deriving (Show, Eq)

instance TF.ToHCL (IamRoleResource s) where
    toHCL IamRoleResource{..} = TF.inline $ catMaybes
        [ TF.assign "assume_role_policy" <$> TF.attribute _assume_role_policy
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "name_prefix" <$> TF.attribute _name_prefix
        ]

instance P.HasAssumeRolePolicy (IamRoleResource s) (TF.Attr s P.IamPolicy) where
    assumeRolePolicy =
        lens (_assume_role_policy :: IamRoleResource s -> TF.Attr s P.IamPolicy)
             (\s a -> s { _assume_role_policy = a } :: IamRoleResource s)

instance P.HasName (IamRoleResource s) (TF.Attr s Text) where
    name =
        lens (_name :: IamRoleResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: IamRoleResource s)

instance P.HasNamePrefix (IamRoleResource s) (TF.Attr s Text) where
    namePrefix =
        lens (_name_prefix :: IamRoleResource s -> TF.Attr s Text)
             (\s a -> s { _name_prefix = a } :: IamRoleResource s)

instance P.HasComputedArn (IamRoleResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedAssumeRolePolicy (IamRoleResource s) s (TF.Attr s P.IamPolicy) where
    computedAssumeRolePolicy =
        (_assume_role_policy :: IamRoleResource s -> TF.Attr s P.IamPolicy)
            . TF.refValue

instance P.HasComputedCreateDate (IamRoleResource s) s (TF.Attr s Text) where
    computedCreateDate x = TF.compute (TF.refKey x) "create_date"

instance P.HasComputedDescription (IamRoleResource s) s (TF.Attr s Text) where
    computedDescription x = TF.compute (TF.refKey x) "description"

instance P.HasComputedName (IamRoleResource s) s (TF.Attr s Text) where
    computedName x = TF.compute (TF.refKey x) "name"

instance P.HasComputedNamePrefix (IamRoleResource s) s (TF.Attr s Text) where
    computedNamePrefix =
        (_name_prefix :: IamRoleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedUniqueId (IamRoleResource s) s (TF.Attr s Text) where
    computedUniqueId x = TF.compute (TF.refKey x) "unique_id"

iamRoleResource :: TF.Schema TF.Resource P.AWS (IamRoleResource s)
iamRoleResource =
    TF.newResource "aws_iam_role" $
        IamRoleResource {
              _assume_role_policy = TF.Nil
            , _name = TF.Nil
            , _name_prefix = TF.Nil
            }

{- | The @aws_iam_saml_provider@ AWS resource.

Provides an IAM SAML provider.
-}
data IamSamlProviderResource s = IamSamlProviderResource {
      _name                   :: !(TF.Attr s Text)
    {- ^ (Required) The name of the provider to create. -}
    , _saml_metadata_document :: !(TF.Attr s Text)
    {- ^ (Required) An XML document generated by an identity provider that supports SAML 2.0. -}
    } deriving (Show, Eq)

instance TF.ToHCL (IamSamlProviderResource s) where
    toHCL IamSamlProviderResource{..} = TF.inline $ catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "saml_metadata_document" <$> TF.attribute _saml_metadata_document
        ]

instance P.HasName (IamSamlProviderResource s) (TF.Attr s Text) where
    name =
        lens (_name :: IamSamlProviderResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: IamSamlProviderResource s)

instance P.HasSamlMetadataDocument (IamSamlProviderResource s) (TF.Attr s Text) where
    samlMetadataDocument =
        lens (_saml_metadata_document :: IamSamlProviderResource s -> TF.Attr s Text)
             (\s a -> s { _saml_metadata_document = a } :: IamSamlProviderResource s)

instance P.HasComputedArn (IamSamlProviderResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedName (IamSamlProviderResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: IamSamlProviderResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSamlMetadataDocument (IamSamlProviderResource s) s (TF.Attr s Text) where
    computedSamlMetadataDocument =
        (_saml_metadata_document :: IamSamlProviderResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedValidUntil (IamSamlProviderResource s) s (TF.Attr s Text) where
    computedValidUntil x = TF.compute (TF.refKey x) "valid_until"

iamSamlProviderResource :: TF.Schema TF.Resource P.AWS (IamSamlProviderResource s)
iamSamlProviderResource =
    TF.newResource "aws_iam_saml_provider" $
        IamSamlProviderResource {
              _name = TF.Nil
            , _saml_metadata_document = TF.Nil
            }

{- | The @aws_iam_server_certificate@ AWS resource.

Provides an IAM Server Certificate resource to upload Server Certificates.
Certs uploaded to IAM can easily work with other AWS services such as:
-}
data IamServerCertificateResource s = IamServerCertificateResource {
      _certificate_body  :: !(TF.Attr s Text)
    {- ^ (Required) The contents of the public key certificate in PEM-encoded format. -}
    , _certificate_chain :: !(TF.Attr s Text)
    {- ^ (Optional) The contents of the certificate chain. This is typically a concatenation of the PEM-encoded public key certificates of the chain. -}
    , _name              :: !(TF.Attr s Text)
    {- ^ (Optional) The name of the Server Certificate. Do not include the path in this value. If omitted, Terraform will assign a random, unique name. -}
    , _name_prefix       :: !(TF.Attr s Text)
    {- ^ (Optional) Creates a unique name beginning with the specified prefix. Conflicts with @name@ . -}
    , _path              :: !(TF.Attr s Text)
    {- ^ (Optional) The IAM path for the server certificate.  If it is not included, it defaults to a slash (/). If this certificate is for use with AWS CloudFront, the path must be in format @/cloudfront/your_path_here@ . See <https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html> for more details on IAM Paths. -}
    , _private_key       :: !(TF.Attr s Text)
    {- ^ (Required) The contents of the private key in PEM-encoded format. -}
    } deriving (Show, Eq)

instance TF.ToHCL (IamServerCertificateResource s) where
    toHCL IamServerCertificateResource{..} = TF.inline $ catMaybes
        [ TF.assign "certificate_body" <$> TF.attribute _certificate_body
        , TF.assign "certificate_chain" <$> TF.attribute _certificate_chain
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "name_prefix" <$> TF.attribute _name_prefix
        , TF.assign "path" <$> TF.attribute _path
        , TF.assign "private_key" <$> TF.attribute _private_key
        ]

instance P.HasCertificateBody (IamServerCertificateResource s) (TF.Attr s Text) where
    certificateBody =
        lens (_certificate_body :: IamServerCertificateResource s -> TF.Attr s Text)
             (\s a -> s { _certificate_body = a } :: IamServerCertificateResource s)

instance P.HasCertificateChain (IamServerCertificateResource s) (TF.Attr s Text) where
    certificateChain =
        lens (_certificate_chain :: IamServerCertificateResource s -> TF.Attr s Text)
             (\s a -> s { _certificate_chain = a } :: IamServerCertificateResource s)

instance P.HasName (IamServerCertificateResource s) (TF.Attr s Text) where
    name =
        lens (_name :: IamServerCertificateResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: IamServerCertificateResource s)

instance P.HasNamePrefix (IamServerCertificateResource s) (TF.Attr s Text) where
    namePrefix =
        lens (_name_prefix :: IamServerCertificateResource s -> TF.Attr s Text)
             (\s a -> s { _name_prefix = a } :: IamServerCertificateResource s)

instance P.HasPath (IamServerCertificateResource s) (TF.Attr s Text) where
    path =
        lens (_path :: IamServerCertificateResource s -> TF.Attr s Text)
             (\s a -> s { _path = a } :: IamServerCertificateResource s)

instance P.HasPrivateKey (IamServerCertificateResource s) (TF.Attr s Text) where
    privateKey =
        lens (_private_key :: IamServerCertificateResource s -> TF.Attr s Text)
             (\s a -> s { _private_key = a } :: IamServerCertificateResource s)

instance P.HasComputedArn (IamServerCertificateResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedCertificateBody (IamServerCertificateResource s) s (TF.Attr s Text) where
    computedCertificateBody =
        (_certificate_body :: IamServerCertificateResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCertificateChain (IamServerCertificateResource s) s (TF.Attr s Text) where
    computedCertificateChain =
        (_certificate_chain :: IamServerCertificateResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (IamServerCertificateResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (IamServerCertificateResource s) s (TF.Attr s Text) where
    computedName x = TF.compute (TF.refKey x) "name"

instance P.HasComputedNamePrefix (IamServerCertificateResource s) s (TF.Attr s Text) where
    computedNamePrefix =
        (_name_prefix :: IamServerCertificateResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPath (IamServerCertificateResource s) s (TF.Attr s Text) where
    computedPath =
        (_path :: IamServerCertificateResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPrivateKey (IamServerCertificateResource s) s (TF.Attr s Text) where
    computedPrivateKey =
        (_private_key :: IamServerCertificateResource s -> TF.Attr s Text)
            . TF.refValue

iamServerCertificateResource :: TF.Schema TF.Resource P.AWS (IamServerCertificateResource s)
iamServerCertificateResource =
    TF.newResource "aws_iam_server_certificate" $
        IamServerCertificateResource {
              _certificate_body = TF.Nil
            , _certificate_chain = TF.Nil
            , _name = TF.Nil
            , _name_prefix = TF.Nil
            , _path = TF.Nil
            , _private_key = TF.Nil
            }

{- | The @aws_iam_user_login_profile@ AWS resource.

Provides one-time creation of a IAM user login profile, and uses PGP to
encrypt the password for safe transport to the user. PGP keys can be
obtained from Keybase.
-}
data IamUserLoginProfileResource s = IamUserLoginProfileResource {
      _password_length         :: !(TF.Attr s Text)
    {- ^ (Optional, default 20) The length of the generated password. -}
    , _password_reset_required :: !(TF.Attr s Text)
    {- ^ (Optional, default "true") Whether the user should be forced to reset the generated password on first login. -}
    , _pgp_key                 :: !(TF.Attr s Text)
    {- ^ (Required) Either a base-64 encoded PGP public key, or a keybase username in the form @keybase:username@ . -}
    , _user                    :: !(TF.Attr s Text)
    {- ^ (Required) The IAM user's name. -}
    } deriving (Show, Eq)

instance TF.ToHCL (IamUserLoginProfileResource s) where
    toHCL IamUserLoginProfileResource{..} = TF.inline $ catMaybes
        [ TF.assign "password_length" <$> TF.attribute _password_length
        , TF.assign "password_reset_required" <$> TF.attribute _password_reset_required
        , TF.assign "pgp_key" <$> TF.attribute _pgp_key
        , TF.assign "user" <$> TF.attribute _user
        ]

instance P.HasPasswordLength (IamUserLoginProfileResource s) (TF.Attr s Text) where
    passwordLength =
        lens (_password_length :: IamUserLoginProfileResource s -> TF.Attr s Text)
             (\s a -> s { _password_length = a } :: IamUserLoginProfileResource s)

instance P.HasPasswordResetRequired (IamUserLoginProfileResource s) (TF.Attr s Text) where
    passwordResetRequired =
        lens (_password_reset_required :: IamUserLoginProfileResource s -> TF.Attr s Text)
             (\s a -> s { _password_reset_required = a } :: IamUserLoginProfileResource s)

instance P.HasPgpKey (IamUserLoginProfileResource s) (TF.Attr s Text) where
    pgpKey =
        lens (_pgp_key :: IamUserLoginProfileResource s -> TF.Attr s Text)
             (\s a -> s { _pgp_key = a } :: IamUserLoginProfileResource s)

instance P.HasUser (IamUserLoginProfileResource s) (TF.Attr s Text) where
    user =
        lens (_user :: IamUserLoginProfileResource s -> TF.Attr s Text)
             (\s a -> s { _user = a } :: IamUserLoginProfileResource s)

instance P.HasComputedEncryptedPassword (IamUserLoginProfileResource s) s (TF.Attr s Text) where
    computedEncryptedPassword x = TF.compute (TF.refKey x) "encrypted_password"

instance P.HasComputedKeyFingerprint (IamUserLoginProfileResource s) s (TF.Attr s Text) where
    computedKeyFingerprint x = TF.compute (TF.refKey x) "key_fingerprint"

instance P.HasComputedPasswordLength (IamUserLoginProfileResource s) s (TF.Attr s Text) where
    computedPasswordLength =
        (_password_length :: IamUserLoginProfileResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPasswordResetRequired (IamUserLoginProfileResource s) s (TF.Attr s Text) where
    computedPasswordResetRequired =
        (_password_reset_required :: IamUserLoginProfileResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPgpKey (IamUserLoginProfileResource s) s (TF.Attr s Text) where
    computedPgpKey =
        (_pgp_key :: IamUserLoginProfileResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedUser (IamUserLoginProfileResource s) s (TF.Attr s Text) where
    computedUser =
        (_user :: IamUserLoginProfileResource s -> TF.Attr s Text)
            . TF.refValue

iamUserLoginProfileResource :: TF.Schema TF.Resource P.AWS (IamUserLoginProfileResource s)
iamUserLoginProfileResource =
    TF.newResource "aws_iam_user_login_profile" $
        IamUserLoginProfileResource {
              _password_length = TF.Nil
            , _password_reset_required = TF.Nil
            , _pgp_key = TF.Nil
            , _user = TF.Nil
            }

{- | The @aws_iam_user_policy_attachment@ AWS resource.

Attaches a Managed IAM Policy to an IAM user
-}
data IamUserPolicyAttachmentResource s = IamUserPolicyAttachmentResource {
      _policy_arn :: !(TF.Attr s Text)
    {- ^ (Required) - The ARN of the policy you want to apply -}
    , _user       :: !(TF.Attr s Text)
    {- ^ (Required) - The user the policy should be applied to -}
    } deriving (Show, Eq)

instance TF.ToHCL (IamUserPolicyAttachmentResource s) where
    toHCL IamUserPolicyAttachmentResource{..} = TF.inline $ catMaybes
        [ TF.assign "policy_arn" <$> TF.attribute _policy_arn
        , TF.assign "user" <$> TF.attribute _user
        ]

instance P.HasPolicyArn (IamUserPolicyAttachmentResource s) (TF.Attr s Text) where
    policyArn =
        lens (_policy_arn :: IamUserPolicyAttachmentResource s -> TF.Attr s Text)
             (\s a -> s { _policy_arn = a } :: IamUserPolicyAttachmentResource s)

instance P.HasUser (IamUserPolicyAttachmentResource s) (TF.Attr s Text) where
    user =
        lens (_user :: IamUserPolicyAttachmentResource s -> TF.Attr s Text)
             (\s a -> s { _user = a } :: IamUserPolicyAttachmentResource s)

instance P.HasComputedPolicyArn (IamUserPolicyAttachmentResource s) s (TF.Attr s Text) where
    computedPolicyArn =
        (_policy_arn :: IamUserPolicyAttachmentResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedUser (IamUserPolicyAttachmentResource s) s (TF.Attr s Text) where
    computedUser =
        (_user :: IamUserPolicyAttachmentResource s -> TF.Attr s Text)
            . TF.refValue

iamUserPolicyAttachmentResource :: TF.Schema TF.Resource P.AWS (IamUserPolicyAttachmentResource s)
iamUserPolicyAttachmentResource =
    TF.newResource "aws_iam_user_policy_attachment" $
        IamUserPolicyAttachmentResource {
              _policy_arn = TF.Nil
            , _user = TF.Nil
            }

{- | The @aws_iam_user_policy@ AWS resource.

Provides an IAM policy attached to a user.
-}
data IamUserPolicyResource s = IamUserPolicyResource {
      _name        :: !(TF.Attr s Text)
    {- ^ (Optional) The name of the policy. If omitted, Terraform will assign a random, unique name. -}
    , _name_prefix :: !(TF.Attr s Text)
    {- ^ (Optional, Forces new resource) Creates a unique name beginning with the specified prefix. Conflicts with @name@ . -}
    , _policy      :: !(TF.Attr s Text)
    {- ^ (Required) The policy document. This is a JSON formatted string. The heredoc syntax or @file@ function is helpful here. -}
    , _user        :: !(TF.Attr s Text)
    {- ^ (Required) IAM user to which to attach this policy. -}
    } deriving (Show, Eq)

instance TF.ToHCL (IamUserPolicyResource s) where
    toHCL IamUserPolicyResource{..} = TF.inline $ catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "name_prefix" <$> TF.attribute _name_prefix
        , TF.assign "policy" <$> TF.attribute _policy
        , TF.assign "user" <$> TF.attribute _user
        ]

instance P.HasName (IamUserPolicyResource s) (TF.Attr s Text) where
    name =
        lens (_name :: IamUserPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: IamUserPolicyResource s)

instance P.HasNamePrefix (IamUserPolicyResource s) (TF.Attr s Text) where
    namePrefix =
        lens (_name_prefix :: IamUserPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _name_prefix = a } :: IamUserPolicyResource s)

instance P.HasPolicy (IamUserPolicyResource s) (TF.Attr s Text) where
    policy =
        lens (_policy :: IamUserPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _policy = a } :: IamUserPolicyResource s)

instance P.HasUser (IamUserPolicyResource s) (TF.Attr s Text) where
    user =
        lens (_user :: IamUserPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _user = a } :: IamUserPolicyResource s)

instance P.HasComputedName (IamUserPolicyResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: IamUserPolicyResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedNamePrefix (IamUserPolicyResource s) s (TF.Attr s Text) where
    computedNamePrefix =
        (_name_prefix :: IamUserPolicyResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPolicy (IamUserPolicyResource s) s (TF.Attr s Text) where
    computedPolicy =
        (_policy :: IamUserPolicyResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedUser (IamUserPolicyResource s) s (TF.Attr s Text) where
    computedUser =
        (_user :: IamUserPolicyResource s -> TF.Attr s Text)
            . TF.refValue

iamUserPolicyResource :: TF.Schema TF.Resource P.AWS (IamUserPolicyResource s)
iamUserPolicyResource =
    TF.newResource "aws_iam_user_policy" $
        IamUserPolicyResource {
              _name = TF.Nil
            , _name_prefix = TF.Nil
            , _policy = TF.Nil
            , _user = TF.Nil
            }

{- | The @aws_iam_user@ AWS resource.

Provides an IAM user.
-}
data IamUserResource s = IamUserResource {
      _force_destroy :: !(TF.Attr s Text)
    {- ^ (Optional, default false) When destroying this user, destroy even if it has non-Terraform-managed IAM access keys, login profile or MFA devices. Without @force_destroy@ a user with non-Terraform-managed access keys and login profile will fail to be destroyed. -}
    , _name          :: !(TF.Attr s Text)
    {- ^ (Required) The user's name. The name must consist of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: @=,.@-_.@ . User names are not distinguished by case. For example, you cannot create users named both "TESTUSER" and "testuser". -}
    , _path          :: !(TF.Attr s Text)
    {- ^ (Optional, default "/") Path in which to create the user. -}
    } deriving (Show, Eq)

instance TF.ToHCL (IamUserResource s) where
    toHCL IamUserResource{..} = TF.inline $ catMaybes
        [ TF.assign "force_destroy" <$> TF.attribute _force_destroy
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "path" <$> TF.attribute _path
        ]

instance P.HasForceDestroy (IamUserResource s) (TF.Attr s Text) where
    forceDestroy =
        lens (_force_destroy :: IamUserResource s -> TF.Attr s Text)
             (\s a -> s { _force_destroy = a } :: IamUserResource s)

instance P.HasName (IamUserResource s) (TF.Attr s Text) where
    name =
        lens (_name :: IamUserResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: IamUserResource s)

instance P.HasPath (IamUserResource s) (TF.Attr s Text) where
    path =
        lens (_path :: IamUserResource s -> TF.Attr s Text)
             (\s a -> s { _path = a } :: IamUserResource s)

instance P.HasComputedArn (IamUserResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedForceDestroy (IamUserResource s) s (TF.Attr s Text) where
    computedForceDestroy =
        (_force_destroy :: IamUserResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (IamUserResource s) s (TF.Attr s Text) where
    computedName x = TF.compute (TF.refKey x) "name"

instance P.HasComputedPath (IamUserResource s) s (TF.Attr s Text) where
    computedPath =
        (_path :: IamUserResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedUniqueId (IamUserResource s) s (TF.Attr s Text) where
    computedUniqueId x = TF.compute (TF.refKey x) "unique_id"

iamUserResource :: TF.Schema TF.Resource P.AWS (IamUserResource s)
iamUserResource =
    TF.newResource "aws_iam_user" $
        IamUserResource {
              _force_destroy = TF.Nil
            , _name = TF.Nil
            , _path = TF.Nil
            }

{- | The @aws_iam_user_ssh_key@ AWS resource.

Uploads an SSH public key and associates it with the specified IAM user.
-}
data IamUserSshKeyResource s = IamUserSshKeyResource {
      _encoding   :: !(TF.Attr s Text)
    {- ^ (Required) Specifies the public key encoding format to use in the response. To retrieve the public key in ssh-rsa format, use @SSH@ . To retrieve the public key in PEM format, use @PEM@ . -}
    , _public_key :: !(TF.Attr s Text)
    {- ^ (Required) The SSH public key. The public key must be encoded in ssh-rsa format or PEM format. -}
    , _status     :: !(TF.Attr s Text)
    {- ^ (Optional) The status to assign to the SSH public key. Active means the key can be used for authentication with an AWS CodeCommit repository. Inactive means the key cannot be used. Default is @active@ . -}
    , _username   :: !(TF.Attr s Text)
    {- ^ (Required) The name of the IAM user to associate the SSH public key with. -}
    } deriving (Show, Eq)

instance TF.ToHCL (IamUserSshKeyResource s) where
    toHCL IamUserSshKeyResource{..} = TF.inline $ catMaybes
        [ TF.assign "encoding" <$> TF.attribute _encoding
        , TF.assign "public_key" <$> TF.attribute _public_key
        , TF.assign "status" <$> TF.attribute _status
        , TF.assign "username" <$> TF.attribute _username
        ]

instance P.HasEncoding (IamUserSshKeyResource s) (TF.Attr s Text) where
    encoding =
        lens (_encoding :: IamUserSshKeyResource s -> TF.Attr s Text)
             (\s a -> s { _encoding = a } :: IamUserSshKeyResource s)

instance P.HasPublicKey (IamUserSshKeyResource s) (TF.Attr s Text) where
    publicKey =
        lens (_public_key :: IamUserSshKeyResource s -> TF.Attr s Text)
             (\s a -> s { _public_key = a } :: IamUserSshKeyResource s)

instance P.HasStatus (IamUserSshKeyResource s) (TF.Attr s Text) where
    status =
        lens (_status :: IamUserSshKeyResource s -> TF.Attr s Text)
             (\s a -> s { _status = a } :: IamUserSshKeyResource s)

instance P.HasUsername (IamUserSshKeyResource s) (TF.Attr s Text) where
    username =
        lens (_username :: IamUserSshKeyResource s -> TF.Attr s Text)
             (\s a -> s { _username = a } :: IamUserSshKeyResource s)

instance P.HasComputedEncoding (IamUserSshKeyResource s) s (TF.Attr s Text) where
    computedEncoding =
        (_encoding :: IamUserSshKeyResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedFingerprint (IamUserSshKeyResource s) s (TF.Attr s Text) where
    computedFingerprint x = TF.compute (TF.refKey x) "fingerprint"

instance P.HasComputedPublicKey (IamUserSshKeyResource s) s (TF.Attr s Text) where
    computedPublicKey =
        (_public_key :: IamUserSshKeyResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSshPublicKeyId (IamUserSshKeyResource s) s (TF.Attr s Text) where
    computedSshPublicKeyId x = TF.compute (TF.refKey x) "ssh_public_key_id"

instance P.HasComputedStatus (IamUserSshKeyResource s) s (TF.Attr s Text) where
    computedStatus =
        (_status :: IamUserSshKeyResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedUsername (IamUserSshKeyResource s) s (TF.Attr s Text) where
    computedUsername =
        (_username :: IamUserSshKeyResource s -> TF.Attr s Text)
            . TF.refValue

iamUserSshKeyResource :: TF.Schema TF.Resource P.AWS (IamUserSshKeyResource s)
iamUserSshKeyResource =
    TF.newResource "aws_iam_user_ssh_key" $
        IamUserSshKeyResource {
              _encoding = TF.Nil
            , _public_key = TF.Nil
            , _status = TF.Nil
            , _username = TF.Nil
            }

{- | The @aws_inspector_assessment_target@ AWS resource.

Provides a Inspector assessment target
-}
data InspectorAssessmentTargetResource s = InspectorAssessmentTargetResource {
      _name               :: !(TF.Attr s Text)
    {- ^ (Required) The name of the assessment target. -}
    , _resource_group_arn :: !(TF.Attr s Text)
    {- ^ (Required )- The resource group ARN stating tags for instance matching. -}
    } deriving (Show, Eq)

instance TF.ToHCL (InspectorAssessmentTargetResource s) where
    toHCL InspectorAssessmentTargetResource{..} = TF.inline $ catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "resource_group_arn" <$> TF.attribute _resource_group_arn
        ]

instance P.HasName (InspectorAssessmentTargetResource s) (TF.Attr s Text) where
    name =
        lens (_name :: InspectorAssessmentTargetResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: InspectorAssessmentTargetResource s)

instance P.HasResourceGroupArn (InspectorAssessmentTargetResource s) (TF.Attr s Text) where
    resourceGroupArn =
        lens (_resource_group_arn :: InspectorAssessmentTargetResource s -> TF.Attr s Text)
             (\s a -> s { _resource_group_arn = a } :: InspectorAssessmentTargetResource s)

instance P.HasComputedArn (InspectorAssessmentTargetResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedName (InspectorAssessmentTargetResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: InspectorAssessmentTargetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedResourceGroupArn (InspectorAssessmentTargetResource s) s (TF.Attr s Text) where
    computedResourceGroupArn =
        (_resource_group_arn :: InspectorAssessmentTargetResource s -> TF.Attr s Text)
            . TF.refValue

inspectorAssessmentTargetResource :: TF.Schema TF.Resource P.AWS (InspectorAssessmentTargetResource s)
inspectorAssessmentTargetResource =
    TF.newResource "aws_inspector_assessment_target" $
        InspectorAssessmentTargetResource {
              _name = TF.Nil
            , _resource_group_arn = TF.Nil
            }

{- | The @aws_inspector_assessment_template@ AWS resource.

Provides a Inspector assessment template
-}
data InspectorAssessmentTemplateResource s = InspectorAssessmentTemplateResource {
      _duration           :: !(TF.Attr s Text)
    {- ^ (Required) The duration of the inspector run. -}
    , _name               :: !(TF.Attr s Text)
    {- ^ (Required) The name of the assessment template. -}
    , _rules_package_arns :: !(TF.Attr s Text)
    {- ^ (Required) The rules to be used during the run. -}
    , _target_arn         :: !(TF.Attr s Text)
    {- ^ (Required) The assessment target ARN to attach the template to. -}
    } deriving (Show, Eq)

instance TF.ToHCL (InspectorAssessmentTemplateResource s) where
    toHCL InspectorAssessmentTemplateResource{..} = TF.inline $ catMaybes
        [ TF.assign "duration" <$> TF.attribute _duration
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "rules_package_arns" <$> TF.attribute _rules_package_arns
        , TF.assign "target_arn" <$> TF.attribute _target_arn
        ]

instance P.HasDuration (InspectorAssessmentTemplateResource s) (TF.Attr s Text) where
    duration =
        lens (_duration :: InspectorAssessmentTemplateResource s -> TF.Attr s Text)
             (\s a -> s { _duration = a } :: InspectorAssessmentTemplateResource s)

instance P.HasName (InspectorAssessmentTemplateResource s) (TF.Attr s Text) where
    name =
        lens (_name :: InspectorAssessmentTemplateResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: InspectorAssessmentTemplateResource s)

instance P.HasRulesPackageArns (InspectorAssessmentTemplateResource s) (TF.Attr s Text) where
    rulesPackageArns =
        lens (_rules_package_arns :: InspectorAssessmentTemplateResource s -> TF.Attr s Text)
             (\s a -> s { _rules_package_arns = a } :: InspectorAssessmentTemplateResource s)

instance P.HasTargetArn (InspectorAssessmentTemplateResource s) (TF.Attr s Text) where
    targetArn =
        lens (_target_arn :: InspectorAssessmentTemplateResource s -> TF.Attr s Text)
             (\s a -> s { _target_arn = a } :: InspectorAssessmentTemplateResource s)

instance P.HasComputedArn (InspectorAssessmentTemplateResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedDuration (InspectorAssessmentTemplateResource s) s (TF.Attr s Text) where
    computedDuration =
        (_duration :: InspectorAssessmentTemplateResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (InspectorAssessmentTemplateResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: InspectorAssessmentTemplateResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRulesPackageArns (InspectorAssessmentTemplateResource s) s (TF.Attr s Text) where
    computedRulesPackageArns =
        (_rules_package_arns :: InspectorAssessmentTemplateResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTargetArn (InspectorAssessmentTemplateResource s) s (TF.Attr s Text) where
    computedTargetArn =
        (_target_arn :: InspectorAssessmentTemplateResource s -> TF.Attr s Text)
            . TF.refValue

inspectorAssessmentTemplateResource :: TF.Schema TF.Resource P.AWS (InspectorAssessmentTemplateResource s)
inspectorAssessmentTemplateResource =
    TF.newResource "aws_inspector_assessment_template" $
        InspectorAssessmentTemplateResource {
              _duration = TF.Nil
            , _name = TF.Nil
            , _rules_package_arns = TF.Nil
            , _target_arn = TF.Nil
            }

{- | The @aws_inspector_resource_group@ AWS resource.

Provides a Inspector resource group
-}
data InspectorResourceGroupResource s = InspectorResourceGroupResource {
      _tags :: !(TF.Attr s P.Tags)
    {- ^ (Required) The tags on your EC2 Instance. -}
    } deriving (Show, Eq)

instance TF.ToHCL (InspectorResourceGroupResource s) where
    toHCL InspectorResourceGroupResource{..} = TF.inline $ catMaybes
        [ TF.assign "tags" <$> TF.attribute _tags
        ]

instance P.HasTags (InspectorResourceGroupResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: InspectorResourceGroupResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: InspectorResourceGroupResource s)

instance P.HasComputedArn (InspectorResourceGroupResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedTags (InspectorResourceGroupResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: InspectorResourceGroupResource s -> TF.Attr s P.Tags)
            . TF.refValue

inspectorResourceGroupResource :: TF.Schema TF.Resource P.AWS (InspectorResourceGroupResource s)
inspectorResourceGroupResource =
    TF.newResource "aws_inspector_resource_group" $
        InspectorResourceGroupResource {
              _tags = TF.Nil
            }

{- | The @aws_instance@ AWS resource.

Provides an EC2 instance resource. This allows instances to be created,
updated, and deleted. Instances also support </docs/provisioners/index.html>
.
-}
data InstanceResource s = InstanceResource {
      _ami                                  :: !(TF.Attr s Text)
    {- ^ (Required) The AMI to use for the instance. -}
    , _associate_public_ip_address          :: !(TF.Attr s Text)
    {- ^ (Optional) Associate a public ip address with an instance in a VPC.  Boolean value. -}
    , _availability_zone                    :: !(TF.Attr s P.Zone)
    {- ^ (Optional) The AZ to start the instance in. -}
    , _disable_api_termination              :: !(TF.Attr s Text)
    {- ^ (Optional) If true, enables <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/terminating-instances.html#Using_ChangingDisableAPITermination> -}
    , _ebs_block_device                     :: !(TF.Attr s Text)
    {- ^ (Optional) Additional EBS block devices to attach to the instance.  See <#block-devices> below for details. -}
    , _ebs_optimized                        :: !(TF.Attr s Text)
    {- ^ (Optional) If true, the launched EC2 instance will be EBS-optimized. -}
    , _ephemeral_block_device               :: !(TF.Attr s Text)
    {- ^ (Optional) Customize Ephemeral (also known as "Instance Store") volumes on the instance. See <#block-devices> below for details. -}
    , _iam_instance_profile                 :: !(TF.Attr s Text)
    {- ^ (Optional) The IAM Instance Profile to launch the instance with. Specified as the name of the Instance Profile. Ensure your credentials have the correct permission to assign the instance profile according to the <http://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_switch-role-ec2.html#roles-usingrole-ec2instance-permissions> , notably @iam:PassRole@ . -}
    , _instance_initiated_shutdown_behavior :: !(TF.Attr s Text)
    {- ^ (Optional) Shutdown behavior for the instance. Amazon defaults this to @stop@ for EBS-backed instances and @terminate@ for instance-store instances. Cannot be set on instance-store instances. See <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/terminating-instances.html#Using_ChangingInstanceInitiatedShutdownBehavior> for more information. -}
    , _instance_type                        :: !(TF.Attr s Text)
    {- ^ (Required) The type of instance to start. Updates to this field will trigger a stop/start of the EC2 instance. -}
    , _ipv6_address_count                   :: !(TF.Attr s Text)
    {- ^ (Optional) A number of IPv6 addresses to associate with the primary network interface. Amazon EC2 chooses the IPv6 addresses from the range of your subnet. -}
    , _ipv6_addresses                       :: !(TF.Attr s Text)
    {- ^ (Optional) Specify one or more IPv6 addresses from the range of the subnet to associate with the primary network interface -}
    , _key_name                             :: !(TF.Attr s Text)
    {- ^ (Optional) The key name to use for the instance. -}
    , _monitoring                           :: !(TF.Attr s Text)
    {- ^ (Optional) If true, the launched EC2 instance will have detailed monitoring enabled. (Available since v0.6.0) -}
    , _network_interface                    :: !(TF.Attr s Text)
    {- ^ (Optional) Customize network interfaces to be attached at instance boot time. See <#network-interfaces> below for more details. -}
    , _placement_group                      :: !(TF.Attr s Text)
    {- ^ (Optional) The Placement Group to start the instance in. -}
    , _private_ip                           :: !(TF.Attr s Text)
    {- ^ (Optional) Private IP address to associate with the instance in a VPC. -}
    , _root_block_device                    :: !(TF.Attr s Text)
    {- ^ (Optional) Customize details about the root block device of the instance. See <#block-devices> below for details. -}
    , _security_groups                      :: !(TF.Attr s Text)
    {- ^ (Optional) A list of security group names to associate with. If you are creating Instances in a VPC, use @vpc_security_group_ids@ instead. -}
    , _source_dest_check                    :: !(TF.Attr s Text)
    {- ^ (Optional) Controls if traffic is routed to the instance when the destination address does not match the instance. Used for NAT or VPNs. Defaults true. -}
    , _subnet_id                            :: !(TF.Attr s Text)
    {- ^ (Optional) The VPC Subnet ID to launch in. -}
    , _tags                                 :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    , _tenancy                              :: !(TF.Attr s Text)
    {- ^ (Optional) The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of dedicated runs on single-tenant hardware. The host tenancy is not supported for the import-instance command. -}
    , _user_data                            :: !(TF.Attr s Text)
    {- ^ (Optional) The user data to provide when launching the instance. Do not pass gzip-compressed data via this argument; see @user_data_base64@ instead. -}
    , _user_data_base64                     :: !(TF.Attr s Text)
    {- ^ (Optional) Can be used instead of @user_data@ to pass base64-encoded binary data directly. Use this instead of @user_data@ whenever the value is not a valid UTF-8 string. For example, gzip-encoded user data must be base64-encoded and passed via this argument to avoid corruption. -}
    , _volume_tags                          :: !(TF.Attr s Text)
    {- ^ (Optional) A mapping of tags to assign to the devices created by the instance at launch time. -}
    , _vpc_security_group_ids               :: !(TF.Attr s Text)
    {- ^ (Optional) A list of security group IDs to associate with. -}
    } deriving (Show, Eq)

instance TF.ToHCL (InstanceResource s) where
    toHCL InstanceResource{..} = TF.inline $ catMaybes
        [ TF.assign "ami" <$> TF.attribute _ami
        , TF.assign "associate_public_ip_address" <$> TF.attribute _associate_public_ip_address
        , TF.assign "availability_zone" <$> TF.attribute _availability_zone
        , TF.assign "disable_api_termination" <$> TF.attribute _disable_api_termination
        , TF.assign "ebs_block_device" <$> TF.attribute _ebs_block_device
        , TF.assign "ebs_optimized" <$> TF.attribute _ebs_optimized
        , TF.assign "ephemeral_block_device" <$> TF.attribute _ephemeral_block_device
        , TF.assign "iam_instance_profile" <$> TF.attribute _iam_instance_profile
        , TF.assign "instance_initiated_shutdown_behavior" <$> TF.attribute _instance_initiated_shutdown_behavior
        , TF.assign "instance_type" <$> TF.attribute _instance_type
        , TF.assign "ipv6_address_count" <$> TF.attribute _ipv6_address_count
        , TF.assign "ipv6_addresses" <$> TF.attribute _ipv6_addresses
        , TF.assign "key_name" <$> TF.attribute _key_name
        , TF.assign "monitoring" <$> TF.attribute _monitoring
        , TF.assign "network_interface" <$> TF.attribute _network_interface
        , TF.assign "placement_group" <$> TF.attribute _placement_group
        , TF.assign "private_ip" <$> TF.attribute _private_ip
        , TF.assign "root_block_device" <$> TF.attribute _root_block_device
        , TF.assign "security_groups" <$> TF.attribute _security_groups
        , TF.assign "source_dest_check" <$> TF.attribute _source_dest_check
        , TF.assign "subnet_id" <$> TF.attribute _subnet_id
        , TF.assign "tags" <$> TF.attribute _tags
        , TF.assign "tenancy" <$> TF.attribute _tenancy
        , TF.assign "user_data" <$> TF.attribute _user_data
        , TF.assign "user_data_base64" <$> TF.attribute _user_data_base64
        , TF.assign "volume_tags" <$> TF.attribute _volume_tags
        , TF.assign "vpc_security_group_ids" <$> TF.attribute _vpc_security_group_ids
        ]

instance P.HasAmi (InstanceResource s) (TF.Attr s Text) where
    ami =
        lens (_ami :: InstanceResource s -> TF.Attr s Text)
             (\s a -> s { _ami = a } :: InstanceResource s)

instance P.HasAssociatePublicIpAddress (InstanceResource s) (TF.Attr s Text) where
    associatePublicIpAddress =
        lens (_associate_public_ip_address :: InstanceResource s -> TF.Attr s Text)
             (\s a -> s { _associate_public_ip_address = a } :: InstanceResource s)

instance P.HasAvailabilityZone (InstanceResource s) (TF.Attr s P.Zone) where
    availabilityZone =
        lens (_availability_zone :: InstanceResource s -> TF.Attr s P.Zone)
             (\s a -> s { _availability_zone = a } :: InstanceResource s)

instance P.HasDisableApiTermination (InstanceResource s) (TF.Attr s Text) where
    disableApiTermination =
        lens (_disable_api_termination :: InstanceResource s -> TF.Attr s Text)
             (\s a -> s { _disable_api_termination = a } :: InstanceResource s)

instance P.HasEbsBlockDevice (InstanceResource s) (TF.Attr s Text) where
    ebsBlockDevice =
        lens (_ebs_block_device :: InstanceResource s -> TF.Attr s Text)
             (\s a -> s { _ebs_block_device = a } :: InstanceResource s)

instance P.HasEbsOptimized (InstanceResource s) (TF.Attr s Text) where
    ebsOptimized =
        lens (_ebs_optimized :: InstanceResource s -> TF.Attr s Text)
             (\s a -> s { _ebs_optimized = a } :: InstanceResource s)

instance P.HasEphemeralBlockDevice (InstanceResource s) (TF.Attr s Text) where
    ephemeralBlockDevice =
        lens (_ephemeral_block_device :: InstanceResource s -> TF.Attr s Text)
             (\s a -> s { _ephemeral_block_device = a } :: InstanceResource s)

instance P.HasIamInstanceProfile (InstanceResource s) (TF.Attr s Text) where
    iamInstanceProfile =
        lens (_iam_instance_profile :: InstanceResource s -> TF.Attr s Text)
             (\s a -> s { _iam_instance_profile = a } :: InstanceResource s)

instance P.HasInstanceInitiatedShutdownBehavior (InstanceResource s) (TF.Attr s Text) where
    instanceInitiatedShutdownBehavior =
        lens (_instance_initiated_shutdown_behavior :: InstanceResource s -> TF.Attr s Text)
             (\s a -> s { _instance_initiated_shutdown_behavior = a } :: InstanceResource s)

instance P.HasInstanceType (InstanceResource s) (TF.Attr s Text) where
    instanceType =
        lens (_instance_type :: InstanceResource s -> TF.Attr s Text)
             (\s a -> s { _instance_type = a } :: InstanceResource s)

instance P.HasIpv6AddressCount (InstanceResource s) (TF.Attr s Text) where
    ipv6AddressCount =
        lens (_ipv6_address_count :: InstanceResource s -> TF.Attr s Text)
             (\s a -> s { _ipv6_address_count = a } :: InstanceResource s)

instance P.HasIpv6Addresses (InstanceResource s) (TF.Attr s Text) where
    ipv6Addresses =
        lens (_ipv6_addresses :: InstanceResource s -> TF.Attr s Text)
             (\s a -> s { _ipv6_addresses = a } :: InstanceResource s)

instance P.HasKeyName (InstanceResource s) (TF.Attr s Text) where
    keyName =
        lens (_key_name :: InstanceResource s -> TF.Attr s Text)
             (\s a -> s { _key_name = a } :: InstanceResource s)

instance P.HasMonitoring (InstanceResource s) (TF.Attr s Text) where
    monitoring =
        lens (_monitoring :: InstanceResource s -> TF.Attr s Text)
             (\s a -> s { _monitoring = a } :: InstanceResource s)

instance P.HasNetworkInterface (InstanceResource s) (TF.Attr s Text) where
    networkInterface =
        lens (_network_interface :: InstanceResource s -> TF.Attr s Text)
             (\s a -> s { _network_interface = a } :: InstanceResource s)

instance P.HasPlacementGroup (InstanceResource s) (TF.Attr s Text) where
    placementGroup =
        lens (_placement_group :: InstanceResource s -> TF.Attr s Text)
             (\s a -> s { _placement_group = a } :: InstanceResource s)

instance P.HasPrivateIp (InstanceResource s) (TF.Attr s Text) where
    privateIp =
        lens (_private_ip :: InstanceResource s -> TF.Attr s Text)
             (\s a -> s { _private_ip = a } :: InstanceResource s)

instance P.HasRootBlockDevice (InstanceResource s) (TF.Attr s Text) where
    rootBlockDevice =
        lens (_root_block_device :: InstanceResource s -> TF.Attr s Text)
             (\s a -> s { _root_block_device = a } :: InstanceResource s)

instance P.HasSecurityGroups (InstanceResource s) (TF.Attr s Text) where
    securityGroups =
        lens (_security_groups :: InstanceResource s -> TF.Attr s Text)
             (\s a -> s { _security_groups = a } :: InstanceResource s)

instance P.HasSourceDestCheck (InstanceResource s) (TF.Attr s Text) where
    sourceDestCheck =
        lens (_source_dest_check :: InstanceResource s -> TF.Attr s Text)
             (\s a -> s { _source_dest_check = a } :: InstanceResource s)

instance P.HasSubnetId (InstanceResource s) (TF.Attr s Text) where
    subnetId =
        lens (_subnet_id :: InstanceResource s -> TF.Attr s Text)
             (\s a -> s { _subnet_id = a } :: InstanceResource s)

instance P.HasTags (InstanceResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: InstanceResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: InstanceResource s)

instance P.HasTenancy (InstanceResource s) (TF.Attr s Text) where
    tenancy =
        lens (_tenancy :: InstanceResource s -> TF.Attr s Text)
             (\s a -> s { _tenancy = a } :: InstanceResource s)

instance P.HasUserData (InstanceResource s) (TF.Attr s Text) where
    userData =
        lens (_user_data :: InstanceResource s -> TF.Attr s Text)
             (\s a -> s { _user_data = a } :: InstanceResource s)

instance P.HasUserDataBase64 (InstanceResource s) (TF.Attr s Text) where
    userDataBase64 =
        lens (_user_data_base64 :: InstanceResource s -> TF.Attr s Text)
             (\s a -> s { _user_data_base64 = a } :: InstanceResource s)

instance P.HasVolumeTags (InstanceResource s) (TF.Attr s Text) where
    volumeTags =
        lens (_volume_tags :: InstanceResource s -> TF.Attr s Text)
             (\s a -> s { _volume_tags = a } :: InstanceResource s)

instance P.HasVpcSecurityGroupIds (InstanceResource s) (TF.Attr s Text) where
    vpcSecurityGroupIds =
        lens (_vpc_security_group_ids :: InstanceResource s -> TF.Attr s Text)
             (\s a -> s { _vpc_security_group_ids = a } :: InstanceResource s)

instance P.HasComputedAmi (InstanceResource s) s (TF.Attr s Text) where
    computedAmi =
        (_ami :: InstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAssociatePublicIpAddress (InstanceResource s) s (TF.Attr s Text) where
    computedAssociatePublicIpAddress =
        (_associate_public_ip_address :: InstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAvailabilityZone (InstanceResource s) s (TF.Attr s P.Zone) where
    computedAvailabilityZone x = TF.compute (TF.refKey x) "availability_zone"

instance P.HasComputedDisableApiTermination (InstanceResource s) s (TF.Attr s Text) where
    computedDisableApiTermination =
        (_disable_api_termination :: InstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEbsBlockDevice (InstanceResource s) s (TF.Attr s Text) where
    computedEbsBlockDevice =
        (_ebs_block_device :: InstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEbsOptimized (InstanceResource s) s (TF.Attr s Text) where
    computedEbsOptimized =
        (_ebs_optimized :: InstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEphemeralBlockDevice (InstanceResource s) s (TF.Attr s Text) where
    computedEphemeralBlockDevice =
        (_ephemeral_block_device :: InstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedIamInstanceProfile (InstanceResource s) s (TF.Attr s Text) where
    computedIamInstanceProfile =
        (_iam_instance_profile :: InstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (InstanceResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedInstanceInitiatedShutdownBehavior (InstanceResource s) s (TF.Attr s Text) where
    computedInstanceInitiatedShutdownBehavior =
        (_instance_initiated_shutdown_behavior :: InstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedInstanceType (InstanceResource s) s (TF.Attr s Text) where
    computedInstanceType =
        (_instance_type :: InstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedIpv6AddressCount (InstanceResource s) s (TF.Attr s Text) where
    computedIpv6AddressCount =
        (_ipv6_address_count :: InstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedIpv6Addresses (InstanceResource s) s (TF.Attr s Text) where
    computedIpv6Addresses x = TF.compute (TF.refKey x) "ipv6_addresses"

instance P.HasComputedKeyName (InstanceResource s) s (TF.Attr s Text) where
    computedKeyName x = TF.compute (TF.refKey x) "key_name"

instance P.HasComputedMonitoring (InstanceResource s) s (TF.Attr s Text) where
    computedMonitoring =
        (_monitoring :: InstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedNetworkInterface (InstanceResource s) s (TF.Attr s Text) where
    computedNetworkInterface =
        (_network_interface :: InstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedNetworkInterfaceId (InstanceResource s) s (TF.Attr s Text) where
    computedNetworkInterfaceId x = TF.compute (TF.refKey x) "network_interface_id"

instance P.HasComputedPlacementGroup (InstanceResource s) s (TF.Attr s Text) where
    computedPlacementGroup x = TF.compute (TF.refKey x) "placement_group"

instance P.HasComputedPrimaryNetworkInterfaceId (InstanceResource s) s (TF.Attr s Text) where
    computedPrimaryNetworkInterfaceId x = TF.compute (TF.refKey x) "primary_network_interface_id"

instance P.HasComputedPrivateDns (InstanceResource s) s (TF.Attr s Text) where
    computedPrivateDns x = TF.compute (TF.refKey x) "private_dns"

instance P.HasComputedPrivateIp (InstanceResource s) s (TF.Attr s Text) where
    computedPrivateIp x = TF.compute (TF.refKey x) "private_ip"

instance P.HasComputedPublicDns (InstanceResource s) s (TF.Attr s Text) where
    computedPublicDns x = TF.compute (TF.refKey x) "public_dns"

instance P.HasComputedPublicIp (InstanceResource s) s (TF.Attr s Text) where
    computedPublicIp x = TF.compute (TF.refKey x) "public_ip"

instance P.HasComputedRootBlockDevice (InstanceResource s) s (TF.Attr s Text) where
    computedRootBlockDevice =
        (_root_block_device :: InstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSecurityGroups (InstanceResource s) s (TF.Attr s Text) where
    computedSecurityGroups x = TF.compute (TF.refKey x) "security_groups"

instance P.HasComputedSourceDestCheck (InstanceResource s) s (TF.Attr s Text) where
    computedSourceDestCheck =
        (_source_dest_check :: InstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSubnetId (InstanceResource s) s (TF.Attr s Text) where
    computedSubnetId x = TF.compute (TF.refKey x) "subnet_id"

instance P.HasComputedTags (InstanceResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: InstanceResource s -> TF.Attr s P.Tags)
            . TF.refValue

instance P.HasComputedTenancy (InstanceResource s) s (TF.Attr s Text) where
    computedTenancy =
        (_tenancy :: InstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedUserData (InstanceResource s) s (TF.Attr s Text) where
    computedUserData =
        (_user_data :: InstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedUserDataBase64 (InstanceResource s) s (TF.Attr s Text) where
    computedUserDataBase64 =
        (_user_data_base64 :: InstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedVolumeTags (InstanceResource s) s (TF.Attr s Text) where
    computedVolumeTags =
        (_volume_tags :: InstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedVpcSecurityGroupIds (InstanceResource s) s (TF.Attr s Text) where
    computedVpcSecurityGroupIds x = TF.compute (TF.refKey x) "vpc_security_group_ids"

instanceResource :: TF.Schema TF.Resource P.AWS (InstanceResource s)
instanceResource =
    TF.newResource "aws_instance" $
        InstanceResource {
              _ami = TF.Nil
            , _associate_public_ip_address = TF.Nil
            , _availability_zone = TF.Nil
            , _disable_api_termination = TF.Nil
            , _ebs_block_device = TF.Nil
            , _ebs_optimized = TF.Nil
            , _ephemeral_block_device = TF.Nil
            , _iam_instance_profile = TF.Nil
            , _instance_initiated_shutdown_behavior = TF.Nil
            , _instance_type = TF.Nil
            , _ipv6_address_count = TF.Nil
            , _ipv6_addresses = TF.Nil
            , _key_name = TF.Nil
            , _monitoring = TF.Nil
            , _network_interface = TF.Nil
            , _placement_group = TF.Nil
            , _private_ip = TF.Nil
            , _root_block_device = TF.Nil
            , _security_groups = TF.Nil
            , _source_dest_check = TF.Nil
            , _subnet_id = TF.Nil
            , _tags = TF.Nil
            , _tenancy = TF.Nil
            , _user_data = TF.Nil
            , _user_data_base64 = TF.Nil
            , _volume_tags = TF.Nil
            , _vpc_security_group_ids = TF.Nil
            }

{- | The @aws_internet_gateway@ AWS resource.

Provides a resource to create a VPC Internet Gateway.
-}
data InternetGatewayResource s = InternetGatewayResource {
      _tags   :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    , _vpc_id :: !(TF.Attr s Text)
    {- ^ (Required) The VPC ID to create in. -}
    } deriving (Show, Eq)

instance TF.ToHCL (InternetGatewayResource s) where
    toHCL InternetGatewayResource{..} = TF.inline $ catMaybes
        [ TF.assign "tags" <$> TF.attribute _tags
        , TF.assign "vpc_id" <$> TF.attribute _vpc_id
        ]

instance P.HasTags (InternetGatewayResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: InternetGatewayResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: InternetGatewayResource s)

instance P.HasVpcId (InternetGatewayResource s) (TF.Attr s Text) where
    vpcId =
        lens (_vpc_id :: InternetGatewayResource s -> TF.Attr s Text)
             (\s a -> s { _vpc_id = a } :: InternetGatewayResource s)

instance P.HasComputedId (InternetGatewayResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedTags (InternetGatewayResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: InternetGatewayResource s -> TF.Attr s P.Tags)
            . TF.refValue

instance P.HasComputedVpcId (InternetGatewayResource s) s (TF.Attr s Text) where
    computedVpcId =
        (_vpc_id :: InternetGatewayResource s -> TF.Attr s Text)
            . TF.refValue

internetGatewayResource :: TF.Schema TF.Resource P.AWS (InternetGatewayResource s)
internetGatewayResource =
    TF.newResource "aws_internet_gateway" $
        InternetGatewayResource {
              _tags = TF.Nil
            , _vpc_id = TF.Nil
            }

{- | The @aws_iot_certificate@ AWS resource.

Creates and manages an AWS IoT certificate.
-}
data IotCertificateResource s = IotCertificateResource {
      _active :: !(TF.Attr s Text)
    {- ^ (Required)  Boolean flag to indicate if the certificate should be active -}
    , _csr    :: !(TF.Attr s Text)
    {- ^ (Required) The certificate signing request. Review the [IoT API Reference Guide] (http://docs.aws.amazon.com/iot/latest/apireference/API_CreateCertificateFromCsr.html) for more information on creating a certificate from a certificate signing request (CSR). -}
    } deriving (Show, Eq)

instance TF.ToHCL (IotCertificateResource s) where
    toHCL IotCertificateResource{..} = TF.inline $ catMaybes
        [ TF.assign "active" <$> TF.attribute _active
        , TF.assign "csr" <$> TF.attribute _csr
        ]

instance P.HasActive (IotCertificateResource s) (TF.Attr s Text) where
    active =
        lens (_active :: IotCertificateResource s -> TF.Attr s Text)
             (\s a -> s { _active = a } :: IotCertificateResource s)

instance P.HasCsr (IotCertificateResource s) (TF.Attr s Text) where
    csr =
        lens (_csr :: IotCertificateResource s -> TF.Attr s Text)
             (\s a -> s { _csr = a } :: IotCertificateResource s)

instance P.HasComputedActive (IotCertificateResource s) s (TF.Attr s Text) where
    computedActive =
        (_active :: IotCertificateResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedArn (IotCertificateResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedCsr (IotCertificateResource s) s (TF.Attr s Text) where
    computedCsr =
        (_csr :: IotCertificateResource s -> TF.Attr s Text)
            . TF.refValue

iotCertificateResource :: TF.Schema TF.Resource P.AWS (IotCertificateResource s)
iotCertificateResource =
    TF.newResource "aws_iot_certificate" $
        IotCertificateResource {
              _active = TF.Nil
            , _csr = TF.Nil
            }

{- | The @aws_iot_policy@ AWS resource.

Provides an IoT policy.
-}
data IotPolicyResource s = IotPolicyResource {
      _name   :: !(TF.Attr s Text)
    {- ^ (Required) The name of the policy. -}
    , _policy :: !(TF.Attr s Text)
    {- ^ (Required) The policy document. This is a JSON formatted string. The heredoc syntax or @file@ function is helpful here. Use the [IoT Developer Guide] (http://docs.aws.amazon.com/iot/latest/developerguide/iot-policies.html) for more information on IoT Policies -}
    } deriving (Show, Eq)

instance TF.ToHCL (IotPolicyResource s) where
    toHCL IotPolicyResource{..} = TF.inline $ catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "policy" <$> TF.attribute _policy
        ]

instance P.HasName (IotPolicyResource s) (TF.Attr s Text) where
    name =
        lens (_name :: IotPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: IotPolicyResource s)

instance P.HasPolicy (IotPolicyResource s) (TF.Attr s Text) where
    policy =
        lens (_policy :: IotPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _policy = a } :: IotPolicyResource s)

instance P.HasComputedArn (IotPolicyResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedDefaultVersionId (IotPolicyResource s) s (TF.Attr s Text) where
    computedDefaultVersionId x = TF.compute (TF.refKey x) "default_version_id"

instance P.HasComputedName (IotPolicyResource s) s (TF.Attr s Text) where
    computedName x = TF.compute (TF.refKey x) "name"

instance P.HasComputedPolicy (IotPolicyResource s) s (TF.Attr s Text) where
    computedPolicy x = TF.compute (TF.refKey x) "policy"

iotPolicyResource :: TF.Schema TF.Resource P.AWS (IotPolicyResource s)
iotPolicyResource =
    TF.newResource "aws_iot_policy" $
        IotPolicyResource {
              _name = TF.Nil
            , _policy = TF.Nil
            }

{- | The @aws_iot_topic_rule@ AWS resource.


-}
data IotTopicRuleResource s = IotTopicRuleResource {
      _description :: !(TF.Attr s Text)
    {- ^ (Optional) The description of the rule. -}
    , _enabled     :: !(TF.Attr s P.Bool)
    {- ^ (Required) Specifies whether the rule is enabled. -}
    , _name        :: !(TF.Attr s Text)
    {- ^ (Required) The name of the rule. -}
    , _sql         :: !(TF.Attr s Text)
    {- ^ (Required) The SQL statement used to query the topic. For more information, see AWS IoT SQL Reference (http://docs.aws.amazon.com/iot/latest/developerguide/iot-rules.html#aws-iot-sql-reference) in the AWS IoT Developer Guide. -}
    , _sql_version :: !(TF.Attr s Text)
    {- ^ (Required) The version of the SQL rules engine to use when evaluating the rule. -}
    } deriving (Show, Eq)

instance TF.ToHCL (IotTopicRuleResource s) where
    toHCL IotTopicRuleResource{..} = TF.inline $ catMaybes
        [ TF.assign "description" <$> TF.attribute _description
        , TF.assign "enabled" <$> TF.attribute _enabled
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "sql" <$> TF.attribute _sql
        , TF.assign "sql_version" <$> TF.attribute _sql_version
        ]

instance P.HasDescription (IotTopicRuleResource s) (TF.Attr s Text) where
    description =
        lens (_description :: IotTopicRuleResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: IotTopicRuleResource s)

instance P.HasEnabled (IotTopicRuleResource s) (TF.Attr s P.Bool) where
    enabled =
        lens (_enabled :: IotTopicRuleResource s -> TF.Attr s P.Bool)
             (\s a -> s { _enabled = a } :: IotTopicRuleResource s)

instance P.HasName (IotTopicRuleResource s) (TF.Attr s Text) where
    name =
        lens (_name :: IotTopicRuleResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: IotTopicRuleResource s)

instance P.HasSql (IotTopicRuleResource s) (TF.Attr s Text) where
    sql =
        lens (_sql :: IotTopicRuleResource s -> TF.Attr s Text)
             (\s a -> s { _sql = a } :: IotTopicRuleResource s)

instance P.HasSqlVersion (IotTopicRuleResource s) (TF.Attr s Text) where
    sqlVersion =
        lens (_sql_version :: IotTopicRuleResource s -> TF.Attr s Text)
             (\s a -> s { _sql_version = a } :: IotTopicRuleResource s)

instance P.HasComputedArn (IotTopicRuleResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedDescription (IotTopicRuleResource s) s (TF.Attr s Text) where
    computedDescription =
        (_description :: IotTopicRuleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEnabled (IotTopicRuleResource s) s (TF.Attr s P.Bool) where
    computedEnabled =
        (_enabled :: IotTopicRuleResource s -> TF.Attr s P.Bool)
            . TF.refValue

instance P.HasComputedId (IotTopicRuleResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (IotTopicRuleResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: IotTopicRuleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSql (IotTopicRuleResource s) s (TF.Attr s Text) where
    computedSql =
        (_sql :: IotTopicRuleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSqlVersion (IotTopicRuleResource s) s (TF.Attr s Text) where
    computedSqlVersion =
        (_sql_version :: IotTopicRuleResource s -> TF.Attr s Text)
            . TF.refValue

iotTopicRuleResource :: TF.Schema TF.Resource P.AWS (IotTopicRuleResource s)
iotTopicRuleResource =
    TF.newResource "aws_iot_topic_rule" $
        IotTopicRuleResource {
              _description = TF.Nil
            , _enabled = TF.Nil
            , _name = TF.Nil
            , _sql = TF.Nil
            , _sql_version = TF.Nil
            }

{- | The @aws_key_pair@ AWS resource.

Provides an
<https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html>
resource. A key pair is used to control login access to EC2 instances.
Currently this resource requires an existing user-supplied key pair. This
key pair's public key will be registered with AWS to allow logging-in to EC2
instances. When importing an existing key pair the public key material may
be in any format supported by AWS. Supported formats (per the
<https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html#how-to-generate-your-own-key-and-import-it-to-aws>
) are:
-}
data KeyPairResource s = KeyPairResource {
      _key_name        :: !(TF.Attr s Text)
    {- ^ (Optional) The name for the key pair. -}
    , _key_name_prefix :: !(TF.Attr s Text)
    {- ^ (Optional) Creates a unique name beginning with the specified prefix. Conflicts with @key_name@ . -}
    , _public_key      :: !(TF.Attr s Text)
    {- ^ (Required) The public key material. -}
    } deriving (Show, Eq)

instance TF.ToHCL (KeyPairResource s) where
    toHCL KeyPairResource{..} = TF.inline $ catMaybes
        [ TF.assign "key_name" <$> TF.attribute _key_name
        , TF.assign "key_name_prefix" <$> TF.attribute _key_name_prefix
        , TF.assign "public_key" <$> TF.attribute _public_key
        ]

instance P.HasKeyName (KeyPairResource s) (TF.Attr s Text) where
    keyName =
        lens (_key_name :: KeyPairResource s -> TF.Attr s Text)
             (\s a -> s { _key_name = a } :: KeyPairResource s)

instance P.HasKeyNamePrefix (KeyPairResource s) (TF.Attr s Text) where
    keyNamePrefix =
        lens (_key_name_prefix :: KeyPairResource s -> TF.Attr s Text)
             (\s a -> s { _key_name_prefix = a } :: KeyPairResource s)

instance P.HasPublicKey (KeyPairResource s) (TF.Attr s Text) where
    publicKey =
        lens (_public_key :: KeyPairResource s -> TF.Attr s Text)
             (\s a -> s { _public_key = a } :: KeyPairResource s)

instance P.HasComputedFingerprint (KeyPairResource s) s (TF.Attr s Text) where
    computedFingerprint x = TF.compute (TF.refKey x) "fingerprint"

instance P.HasComputedKeyName (KeyPairResource s) s (TF.Attr s Text) where
    computedKeyName x = TF.compute (TF.refKey x) "key_name"

instance P.HasComputedKeyNamePrefix (KeyPairResource s) s (TF.Attr s Text) where
    computedKeyNamePrefix =
        (_key_name_prefix :: KeyPairResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPublicKey (KeyPairResource s) s (TF.Attr s Text) where
    computedPublicKey =
        (_public_key :: KeyPairResource s -> TF.Attr s Text)
            . TF.refValue

keyPairResource :: TF.Schema TF.Resource P.AWS (KeyPairResource s)
keyPairResource =
    TF.newResource "aws_key_pair" $
        KeyPairResource {
              _key_name = TF.Nil
            , _key_name_prefix = TF.Nil
            , _public_key = TF.Nil
            }

{- | The @aws_kinesis_firehose_delivery_stream@ AWS resource.

Provides a Kinesis Firehose Delivery Stream resource. Amazon Kinesis
Firehose is a fully managed, elastic service to easily deliver real-time
data streams to destinations such as Amazon S3 and Amazon Redshift. For more
details, see the <https://aws.amazon.com/documentation/firehose/> .
-}
data KinesisFirehoseDeliveryStreamResource s = KinesisFirehoseDeliveryStreamResource {
      _destination                  :: !(TF.Attr s Text)
    {- ^  (Required) This is the destination to where the data is delivered. The only options are @s3@ (Deprecated, use @extended_s3@ instead), @extended_s3@ , @redshift@ , and @elasticsearch@ . -}
    , _extended_s3_configuration    :: !(TF.Attr s Text)
    {- ^ (Optional, only Required when @destination@ is @extended_s3@ ) Enhanced configuration options for the s3 destination. More details are given below. -}
    , _kinesis_source_configuration :: !(TF.Attr s Text)
    {- ^ (Optional) Allows the ability to specify the kinesis stream that is used as the source of the firehose delivery stream. -}
    , _name                         :: !(TF.Attr s Text)
    {- ^ (Required) A name to identify the stream. This is unique to the AWS account and region the Stream is created in. -}
    , _redshift_configuration       :: !(TF.Attr s Text)
    {- ^ (Optional) Configuration options if redshift is the destination. Using @redshift_configuration@ requires the user to also specify a @s3_configuration@ block. More details are given below. -}
    , _s3_configuration             :: !(TF.Attr s Text)
    {- ^ (Optional, Deprecated, see/use @extended_s3_configuration@ unless @destination@ is @redshift@ ) Configuration options for the s3 destination (or the intermediate bucket if the destination is redshift). More details are given below. -}
    } deriving (Show, Eq)

instance TF.ToHCL (KinesisFirehoseDeliveryStreamResource s) where
    toHCL KinesisFirehoseDeliveryStreamResource{..} = TF.inline $ catMaybes
        [ TF.assign "destination" <$> TF.attribute _destination
        , TF.assign "extended_s3_configuration" <$> TF.attribute _extended_s3_configuration
        , TF.assign "kinesis_source_configuration" <$> TF.attribute _kinesis_source_configuration
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "redshift_configuration" <$> TF.attribute _redshift_configuration
        , TF.assign "s3_configuration" <$> TF.attribute _s3_configuration
        ]

instance P.HasDestination (KinesisFirehoseDeliveryStreamResource s) (TF.Attr s Text) where
    destination =
        lens (_destination :: KinesisFirehoseDeliveryStreamResource s -> TF.Attr s Text)
             (\s a -> s { _destination = a } :: KinesisFirehoseDeliveryStreamResource s)

instance P.HasExtendedS3Configuration (KinesisFirehoseDeliveryStreamResource s) (TF.Attr s Text) where
    extendedS3Configuration =
        lens (_extended_s3_configuration :: KinesisFirehoseDeliveryStreamResource s -> TF.Attr s Text)
             (\s a -> s { _extended_s3_configuration = a } :: KinesisFirehoseDeliveryStreamResource s)

instance P.HasKinesisSourceConfiguration (KinesisFirehoseDeliveryStreamResource s) (TF.Attr s Text) where
    kinesisSourceConfiguration =
        lens (_kinesis_source_configuration :: KinesisFirehoseDeliveryStreamResource s -> TF.Attr s Text)
             (\s a -> s { _kinesis_source_configuration = a } :: KinesisFirehoseDeliveryStreamResource s)

instance P.HasName (KinesisFirehoseDeliveryStreamResource s) (TF.Attr s Text) where
    name =
        lens (_name :: KinesisFirehoseDeliveryStreamResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: KinesisFirehoseDeliveryStreamResource s)

instance P.HasRedshiftConfiguration (KinesisFirehoseDeliveryStreamResource s) (TF.Attr s Text) where
    redshiftConfiguration =
        lens (_redshift_configuration :: KinesisFirehoseDeliveryStreamResource s -> TF.Attr s Text)
             (\s a -> s { _redshift_configuration = a } :: KinesisFirehoseDeliveryStreamResource s)

instance P.HasS3Configuration (KinesisFirehoseDeliveryStreamResource s) (TF.Attr s Text) where
    s3Configuration =
        lens (_s3_configuration :: KinesisFirehoseDeliveryStreamResource s -> TF.Attr s Text)
             (\s a -> s { _s3_configuration = a } :: KinesisFirehoseDeliveryStreamResource s)

instance P.HasComputedArn (KinesisFirehoseDeliveryStreamResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedDestination (KinesisFirehoseDeliveryStreamResource s) s (TF.Attr s Text) where
    computedDestination =
        (_destination :: KinesisFirehoseDeliveryStreamResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedExtendedS3Configuration (KinesisFirehoseDeliveryStreamResource s) s (TF.Attr s Text) where
    computedExtendedS3Configuration =
        (_extended_s3_configuration :: KinesisFirehoseDeliveryStreamResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedKinesisSourceConfiguration (KinesisFirehoseDeliveryStreamResource s) s (TF.Attr s Text) where
    computedKinesisSourceConfiguration =
        (_kinesis_source_configuration :: KinesisFirehoseDeliveryStreamResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (KinesisFirehoseDeliveryStreamResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: KinesisFirehoseDeliveryStreamResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRedshiftConfiguration (KinesisFirehoseDeliveryStreamResource s) s (TF.Attr s Text) where
    computedRedshiftConfiguration =
        (_redshift_configuration :: KinesisFirehoseDeliveryStreamResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedS3Configuration (KinesisFirehoseDeliveryStreamResource s) s (TF.Attr s Text) where
    computedS3Configuration =
        (_s3_configuration :: KinesisFirehoseDeliveryStreamResource s -> TF.Attr s Text)
            . TF.refValue

kinesisFirehoseDeliveryStreamResource :: TF.Schema TF.Resource P.AWS (KinesisFirehoseDeliveryStreamResource s)
kinesisFirehoseDeliveryStreamResource =
    TF.newResource "aws_kinesis_firehose_delivery_stream" $
        KinesisFirehoseDeliveryStreamResource {
              _destination = TF.Nil
            , _extended_s3_configuration = TF.Nil
            , _kinesis_source_configuration = TF.Nil
            , _name = TF.Nil
            , _redshift_configuration = TF.Nil
            , _s3_configuration = TF.Nil
            }

{- | The @aws_kinesis_stream@ AWS resource.

Provides a Kinesis Stream resource. Amazon Kinesis is a managed service that
scales elastically for real-time processing of streaming big data. For more
details, see the <https://aws.amazon.com/documentation/kinesis/> .
-}
data KinesisStreamResource s = KinesisStreamResource {
      _encryption_type     :: !(TF.Attr s Text)
    {- ^ (Optional) The encryption type to use. The only acceptable values are @NONE@ or @KMS@ . The default value is @NONE@ . -}
    , _kms_key_id          :: !(TF.Attr s Text)
    {- ^ (Optional) The GUID for the customer-managed KMS key to use for encryption. You can also use a Kinesis-owned master key by specifying the alias aws/kinesis. -}
    , _name                :: !(TF.Attr s Text)
    {- ^ (Required) A name to identify the stream. This is unique to the AWS account and region the Stream is created in. -}
    , _retention_period    :: !(TF.Attr s Text)
    {- ^ (Optional) Length of time data records are accessible after they are added to the stream. The maximum value of a stream's retention period is 168 hours. Minimum value is 24. Default is 24. -}
    , _shard_count         :: !(TF.Attr s Text)
    {- ^ (Required) The number of shards that the stream will use. Amazon has guidlines for specifying the Stream size that should be referenced when creating a Kinesis stream. See <https://docs.aws.amazon.com/kinesis/latest/dev/amazon-kinesis-streams.html> for more. -}
    , _shard_level_metrics :: !(TF.Attr s Text)
    {- ^ (Optional) A list of shard-level CloudWatch metrics which can be enabled for the stream. See <https://docs.aws.amazon.com/streams/latest/dev/monitoring-with-cloudwatch.html> for more. Note that the value ALL should not be used; instead you should provide an explicit list of metrics you wish to enable. -}
    , _tags                :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    } deriving (Show, Eq)

instance TF.ToHCL (KinesisStreamResource s) where
    toHCL KinesisStreamResource{..} = TF.inline $ catMaybes
        [ TF.assign "encryption_type" <$> TF.attribute _encryption_type
        , TF.assign "kms_key_id" <$> TF.attribute _kms_key_id
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "retention_period" <$> TF.attribute _retention_period
        , TF.assign "shard_count" <$> TF.attribute _shard_count
        , TF.assign "shard_level_metrics" <$> TF.attribute _shard_level_metrics
        , TF.assign "tags" <$> TF.attribute _tags
        ]

instance P.HasEncryptionType (KinesisStreamResource s) (TF.Attr s Text) where
    encryptionType =
        lens (_encryption_type :: KinesisStreamResource s -> TF.Attr s Text)
             (\s a -> s { _encryption_type = a } :: KinesisStreamResource s)

instance P.HasKmsKeyId (KinesisStreamResource s) (TF.Attr s Text) where
    kmsKeyId =
        lens (_kms_key_id :: KinesisStreamResource s -> TF.Attr s Text)
             (\s a -> s { _kms_key_id = a } :: KinesisStreamResource s)

instance P.HasName (KinesisStreamResource s) (TF.Attr s Text) where
    name =
        lens (_name :: KinesisStreamResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: KinesisStreamResource s)

instance P.HasRetentionPeriod (KinesisStreamResource s) (TF.Attr s Text) where
    retentionPeriod =
        lens (_retention_period :: KinesisStreamResource s -> TF.Attr s Text)
             (\s a -> s { _retention_period = a } :: KinesisStreamResource s)

instance P.HasShardCount (KinesisStreamResource s) (TF.Attr s Text) where
    shardCount =
        lens (_shard_count :: KinesisStreamResource s -> TF.Attr s Text)
             (\s a -> s { _shard_count = a } :: KinesisStreamResource s)

instance P.HasShardLevelMetrics (KinesisStreamResource s) (TF.Attr s Text) where
    shardLevelMetrics =
        lens (_shard_level_metrics :: KinesisStreamResource s -> TF.Attr s Text)
             (\s a -> s { _shard_level_metrics = a } :: KinesisStreamResource s)

instance P.HasTags (KinesisStreamResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: KinesisStreamResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: KinesisStreamResource s)

instance P.HasComputedArn (KinesisStreamResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedEncryptionType (KinesisStreamResource s) s (TF.Attr s Text) where
    computedEncryptionType =
        (_encryption_type :: KinesisStreamResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (KinesisStreamResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedKmsKeyId (KinesisStreamResource s) s (TF.Attr s Text) where
    computedKmsKeyId =
        (_kms_key_id :: KinesisStreamResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (KinesisStreamResource s) s (TF.Attr s Text) where
    computedName x = TF.compute (TF.refKey x) "name"

instance P.HasComputedRetentionPeriod (KinesisStreamResource s) s (TF.Attr s Text) where
    computedRetentionPeriod =
        (_retention_period :: KinesisStreamResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedShardCount (KinesisStreamResource s) s (TF.Attr s Text) where
    computedShardCount x = TF.compute (TF.refKey x) "shard_count"

instance P.HasComputedShardLevelMetrics (KinesisStreamResource s) s (TF.Attr s Text) where
    computedShardLevelMetrics =
        (_shard_level_metrics :: KinesisStreamResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (KinesisStreamResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: KinesisStreamResource s -> TF.Attr s P.Tags)
            . TF.refValue

kinesisStreamResource :: TF.Schema TF.Resource P.AWS (KinesisStreamResource s)
kinesisStreamResource =
    TF.newResource "aws_kinesis_stream" $
        KinesisStreamResource {
              _encryption_type = TF.Nil
            , _kms_key_id = TF.Nil
            , _name = TF.Nil
            , _retention_period = TF.Nil
            , _shard_count = TF.Nil
            , _shard_level_metrics = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_kms_alias@ AWS resource.

Provides an alias for a KMS customer master key. AWS Console enforces 1-to-1
mapping between aliases & keys, but API (hence Terraform too) allows you to
create as many aliases as the
<http://docs.aws.amazon.com/kms/latest/developerguide/limits.html> allow
you.
-}
data KmsAliasResource s = KmsAliasResource {
      _name          :: !(TF.Attr s Text)
    {- ^ (Optional) The display name of the alias. The name must start with the word "alias" followed by a forward slash (alias/) -}
    , _name_prefix   :: !(TF.Attr s Text)
    {- ^ (Optional) Creates an unique alias beginning with the specified prefix. The name must start with the word "alias" followed by a forward slash (alias/).  Conflicts with @name@ . -}
    , _target_key_id :: !(TF.Attr s Text)
    {- ^ (Required) Identifier for the key for which the alias is for, can be either an ARN or key_id. -}
    } deriving (Show, Eq)

instance TF.ToHCL (KmsAliasResource s) where
    toHCL KmsAliasResource{..} = TF.inline $ catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "name_prefix" <$> TF.attribute _name_prefix
        , TF.assign "target_key_id" <$> TF.attribute _target_key_id
        ]

instance P.HasName (KmsAliasResource s) (TF.Attr s Text) where
    name =
        lens (_name :: KmsAliasResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: KmsAliasResource s)

instance P.HasNamePrefix (KmsAliasResource s) (TF.Attr s Text) where
    namePrefix =
        lens (_name_prefix :: KmsAliasResource s -> TF.Attr s Text)
             (\s a -> s { _name_prefix = a } :: KmsAliasResource s)

instance P.HasTargetKeyId (KmsAliasResource s) (TF.Attr s Text) where
    targetKeyId =
        lens (_target_key_id :: KmsAliasResource s -> TF.Attr s Text)
             (\s a -> s { _target_key_id = a } :: KmsAliasResource s)

instance P.HasComputedArn (KmsAliasResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedName (KmsAliasResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: KmsAliasResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedNamePrefix (KmsAliasResource s) s (TF.Attr s Text) where
    computedNamePrefix =
        (_name_prefix :: KmsAliasResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTargetKeyArn (KmsAliasResource s) s (TF.Attr s Text) where
    computedTargetKeyArn x = TF.compute (TF.refKey x) "target_key_arn"

instance P.HasComputedTargetKeyId (KmsAliasResource s) s (TF.Attr s Text) where
    computedTargetKeyId =
        (_target_key_id :: KmsAliasResource s -> TF.Attr s Text)
            . TF.refValue

kmsAliasResource :: TF.Schema TF.Resource P.AWS (KmsAliasResource s)
kmsAliasResource =
    TF.newResource "aws_kms_alias" $
        KmsAliasResource {
              _name = TF.Nil
            , _name_prefix = TF.Nil
            , _target_key_id = TF.Nil
            }

{- | The @aws_kms_key@ AWS resource.

Provides a KMS customer master key.
-}
data KmsKeyResource s = KmsKeyResource {
      _deletion_window_in_days :: !(TF.Attr s Text)
    {- ^ (Optional) Duration in days after which the key is deleted after destruction of the resource, must be between 7 and 30 days. Defaults to 30 days. -}
    , _description             :: !(TF.Attr s Text)
    {- ^ (Optional) The description of the key as viewed in AWS console. -}
    , _enable_key_rotation     :: !(TF.Attr s P.Bool)
    {- ^ (Optional) Specifies whether <http://docs.aws.amazon.com/kms/latest/developerguide/rotate-keys.html> is enabled. Defaults to false. -}
    , _is_enabled              :: !(TF.Attr s P.Bool)
    {- ^ (Optional) Specifies whether the key is enabled. Defaults to true. -}
    , _key_usage               :: !(TF.Attr s Text)
    {- ^ (Optional) Specifies the intended use of the key. Defaults to ENCRYPT_DECRYPT, and only symmetric encryption and decryption are supported. -}
    , _policy                  :: !(TF.Attr s Text)
    {- ^ (Optional) A valid policy JSON document. -}
    , _tags                    :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the object. -}
    } deriving (Show, Eq)

instance TF.ToHCL (KmsKeyResource s) where
    toHCL KmsKeyResource{..} = TF.inline $ catMaybes
        [ TF.assign "deletion_window_in_days" <$> TF.attribute _deletion_window_in_days
        , TF.assign "description" <$> TF.attribute _description
        , TF.assign "enable_key_rotation" <$> TF.attribute _enable_key_rotation
        , TF.assign "is_enabled" <$> TF.attribute _is_enabled
        , TF.assign "key_usage" <$> TF.attribute _key_usage
        , TF.assign "policy" <$> TF.attribute _policy
        , TF.assign "tags" <$> TF.attribute _tags
        ]

instance P.HasDeletionWindowInDays (KmsKeyResource s) (TF.Attr s Text) where
    deletionWindowInDays =
        lens (_deletion_window_in_days :: KmsKeyResource s -> TF.Attr s Text)
             (\s a -> s { _deletion_window_in_days = a } :: KmsKeyResource s)

instance P.HasDescription (KmsKeyResource s) (TF.Attr s Text) where
    description =
        lens (_description :: KmsKeyResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: KmsKeyResource s)

instance P.HasEnableKeyRotation (KmsKeyResource s) (TF.Attr s P.Bool) where
    enableKeyRotation =
        lens (_enable_key_rotation :: KmsKeyResource s -> TF.Attr s P.Bool)
             (\s a -> s { _enable_key_rotation = a } :: KmsKeyResource s)

instance P.HasIsEnabled (KmsKeyResource s) (TF.Attr s P.Bool) where
    isEnabled =
        lens (_is_enabled :: KmsKeyResource s -> TF.Attr s P.Bool)
             (\s a -> s { _is_enabled = a } :: KmsKeyResource s)

instance P.HasKeyUsage (KmsKeyResource s) (TF.Attr s Text) where
    keyUsage =
        lens (_key_usage :: KmsKeyResource s -> TF.Attr s Text)
             (\s a -> s { _key_usage = a } :: KmsKeyResource s)

instance P.HasPolicy (KmsKeyResource s) (TF.Attr s Text) where
    policy =
        lens (_policy :: KmsKeyResource s -> TF.Attr s Text)
             (\s a -> s { _policy = a } :: KmsKeyResource s)

instance P.HasTags (KmsKeyResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: KmsKeyResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: KmsKeyResource s)

instance P.HasComputedArn (KmsKeyResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedDeletionWindowInDays (KmsKeyResource s) s (TF.Attr s Text) where
    computedDeletionWindowInDays =
        (_deletion_window_in_days :: KmsKeyResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDescription (KmsKeyResource s) s (TF.Attr s Text) where
    computedDescription =
        (_description :: KmsKeyResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEnableKeyRotation (KmsKeyResource s) s (TF.Attr s P.Bool) where
    computedEnableKeyRotation =
        (_enable_key_rotation :: KmsKeyResource s -> TF.Attr s P.Bool)
            . TF.refValue

instance P.HasComputedIsEnabled (KmsKeyResource s) s (TF.Attr s P.Bool) where
    computedIsEnabled =
        (_is_enabled :: KmsKeyResource s -> TF.Attr s P.Bool)
            . TF.refValue

instance P.HasComputedKeyId (KmsKeyResource s) s (TF.Attr s Text) where
    computedKeyId x = TF.compute (TF.refKey x) "key_id"

instance P.HasComputedKeyUsage (KmsKeyResource s) s (TF.Attr s Text) where
    computedKeyUsage =
        (_key_usage :: KmsKeyResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPolicy (KmsKeyResource s) s (TF.Attr s Text) where
    computedPolicy =
        (_policy :: KmsKeyResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (KmsKeyResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: KmsKeyResource s -> TF.Attr s P.Tags)
            . TF.refValue

kmsKeyResource :: TF.Schema TF.Resource P.AWS (KmsKeyResource s)
kmsKeyResource =
    TF.newResource "aws_kms_key" $
        KmsKeyResource {
              _deletion_window_in_days = TF.Nil
            , _description = TF.Nil
            , _enable_key_rotation = TF.Nil
            , _is_enabled = TF.Nil
            , _key_usage = TF.Nil
            , _policy = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_lambda_alias@ AWS resource.

Creates a Lambda function alias. Creates an alias that points to the
specified Lambda function version. For information about Lambda and how to
use it, see <http://docs.aws.amazon.com/lambda/latest/dg/welcome.html> For
information about function aliases, see
<http://docs.aws.amazon.com/lambda/latest/dg/API_CreateAlias.html> in the
API docs.
-}
data LambdaAliasResource s = LambdaAliasResource {
      _description      :: !(TF.Attr s Text)
    {- ^ (Optional) Description of the alias. -}
    , _function_name    :: !(TF.Attr s Text)
    {- ^ (Required) The function ARN of the Lambda function for which you want to create an alias. -}
    , _function_version :: !(TF.Attr s Text)
    {- ^ (Required) Lambda function version for which you are creating the alias. Pattern: @(\$LATEST|[0-9]+)@ . -}
    , _name             :: !(TF.Attr s Text)
    {- ^ (Required) Name for the alias you are creating. Pattern: @(?!^[0-9]+$)([a-zA-Z0-9-_]+)@ -}
    } deriving (Show, Eq)

instance TF.ToHCL (LambdaAliasResource s) where
    toHCL LambdaAliasResource{..} = TF.inline $ catMaybes
        [ TF.assign "description" <$> TF.attribute _description
        , TF.assign "function_name" <$> TF.attribute _function_name
        , TF.assign "function_version" <$> TF.attribute _function_version
        , TF.assign "name" <$> TF.attribute _name
        ]

instance P.HasDescription (LambdaAliasResource s) (TF.Attr s Text) where
    description =
        lens (_description :: LambdaAliasResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: LambdaAliasResource s)

instance P.HasFunctionName (LambdaAliasResource s) (TF.Attr s Text) where
    functionName =
        lens (_function_name :: LambdaAliasResource s -> TF.Attr s Text)
             (\s a -> s { _function_name = a } :: LambdaAliasResource s)

instance P.HasFunctionVersion (LambdaAliasResource s) (TF.Attr s Text) where
    functionVersion =
        lens (_function_version :: LambdaAliasResource s -> TF.Attr s Text)
             (\s a -> s { _function_version = a } :: LambdaAliasResource s)

instance P.HasName (LambdaAliasResource s) (TF.Attr s Text) where
    name =
        lens (_name :: LambdaAliasResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: LambdaAliasResource s)

instance P.HasComputedArn (LambdaAliasResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedDescription (LambdaAliasResource s) s (TF.Attr s Text) where
    computedDescription =
        (_description :: LambdaAliasResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedFunctionName (LambdaAliasResource s) s (TF.Attr s Text) where
    computedFunctionName =
        (_function_name :: LambdaAliasResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedFunctionVersion (LambdaAliasResource s) s (TF.Attr s Text) where
    computedFunctionVersion =
        (_function_version :: LambdaAliasResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (LambdaAliasResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: LambdaAliasResource s -> TF.Attr s Text)
            . TF.refValue

lambdaAliasResource :: TF.Schema TF.Resource P.AWS (LambdaAliasResource s)
lambdaAliasResource =
    TF.newResource "aws_lambda_alias" $
        LambdaAliasResource {
              _description = TF.Nil
            , _function_name = TF.Nil
            , _function_version = TF.Nil
            , _name = TF.Nil
            }

{- | The @aws_lambda_event_source_mapping@ AWS resource.

Provides a Lambda event source mapping. This allows Lambda functions to get
events from Kinesis and DynamoDB. For information about Lambda and how to
use it, see <http://docs.aws.amazon.com/lambda/latest/dg/welcome.html> For
information about event source mappings, see
<http://docs.aws.amazon.com/lambda/latest/dg/API_CreateEventSourceMapping.html>
in the API docs.
-}
data LambdaEventSourceMappingResource s = LambdaEventSourceMappingResource {
      _batch_size        :: !(TF.Attr s Text)
    {- ^ (Optional) The largest number of records that Lambda will retrieve from your event source at the time of invocation. Defaults to @100@ . -}
    , _enabled           :: !(TF.Attr s P.Bool)
    {- ^ (Optional) Determines if the mapping will be enabled on creation. Defaults to @true@ . -}
    , _event_source_arn  :: !(TF.Attr s Text)
    {- ^ (Required) The event source ARN - can either be a Kinesis or DynamoDB stream. -}
    , _function_name     :: !(TF.Attr s Text)
    {- ^ (Required) The name or the ARN of the Lambda function that will be subscribing to events. -}
    , _starting_position :: !(TF.Attr s Text)
    {- ^ (Required) The position in the stream where AWS Lambda should start reading. Can be one of either @TRIM_HORIZON@ or @LATEST@ . -}
    } deriving (Show, Eq)

instance TF.ToHCL (LambdaEventSourceMappingResource s) where
    toHCL LambdaEventSourceMappingResource{..} = TF.inline $ catMaybes
        [ TF.assign "batch_size" <$> TF.attribute _batch_size
        , TF.assign "enabled" <$> TF.attribute _enabled
        , TF.assign "event_source_arn" <$> TF.attribute _event_source_arn
        , TF.assign "function_name" <$> TF.attribute _function_name
        , TF.assign "starting_position" <$> TF.attribute _starting_position
        ]

instance P.HasBatchSize (LambdaEventSourceMappingResource s) (TF.Attr s Text) where
    batchSize =
        lens (_batch_size :: LambdaEventSourceMappingResource s -> TF.Attr s Text)
             (\s a -> s { _batch_size = a } :: LambdaEventSourceMappingResource s)

instance P.HasEnabled (LambdaEventSourceMappingResource s) (TF.Attr s P.Bool) where
    enabled =
        lens (_enabled :: LambdaEventSourceMappingResource s -> TF.Attr s P.Bool)
             (\s a -> s { _enabled = a } :: LambdaEventSourceMappingResource s)

instance P.HasEventSourceArn (LambdaEventSourceMappingResource s) (TF.Attr s Text) where
    eventSourceArn =
        lens (_event_source_arn :: LambdaEventSourceMappingResource s -> TF.Attr s Text)
             (\s a -> s { _event_source_arn = a } :: LambdaEventSourceMappingResource s)

instance P.HasFunctionName (LambdaEventSourceMappingResource s) (TF.Attr s Text) where
    functionName =
        lens (_function_name :: LambdaEventSourceMappingResource s -> TF.Attr s Text)
             (\s a -> s { _function_name = a } :: LambdaEventSourceMappingResource s)

instance P.HasStartingPosition (LambdaEventSourceMappingResource s) (TF.Attr s Text) where
    startingPosition =
        lens (_starting_position :: LambdaEventSourceMappingResource s -> TF.Attr s Text)
             (\s a -> s { _starting_position = a } :: LambdaEventSourceMappingResource s)

instance P.HasComputedBatchSize (LambdaEventSourceMappingResource s) s (TF.Attr s Text) where
    computedBatchSize =
        (_batch_size :: LambdaEventSourceMappingResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEnabled (LambdaEventSourceMappingResource s) s (TF.Attr s P.Bool) where
    computedEnabled =
        (_enabled :: LambdaEventSourceMappingResource s -> TF.Attr s P.Bool)
            . TF.refValue

instance P.HasComputedEventSourceArn (LambdaEventSourceMappingResource s) s (TF.Attr s Text) where
    computedEventSourceArn =
        (_event_source_arn :: LambdaEventSourceMappingResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedFunctionArn (LambdaEventSourceMappingResource s) s (TF.Attr s Text) where
    computedFunctionArn x = TF.compute (TF.refKey x) "function_arn"

instance P.HasComputedFunctionName (LambdaEventSourceMappingResource s) s (TF.Attr s Text) where
    computedFunctionName =
        (_function_name :: LambdaEventSourceMappingResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedLastModified (LambdaEventSourceMappingResource s) s (TF.Attr s Text) where
    computedLastModified x = TF.compute (TF.refKey x) "last_modified"

instance P.HasComputedLastProcessingResult (LambdaEventSourceMappingResource s) s (TF.Attr s Text) where
    computedLastProcessingResult x = TF.compute (TF.refKey x) "last_processing_result"

instance P.HasComputedStartingPosition (LambdaEventSourceMappingResource s) s (TF.Attr s Text) where
    computedStartingPosition =
        (_starting_position :: LambdaEventSourceMappingResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedState (LambdaEventSourceMappingResource s) s (TF.Attr s Text) where
    computedState x = TF.compute (TF.refKey x) "state"

instance P.HasComputedStateTransitionReason (LambdaEventSourceMappingResource s) s (TF.Attr s Text) where
    computedStateTransitionReason x = TF.compute (TF.refKey x) "state_transition_reason"

instance P.HasComputedUuid (LambdaEventSourceMappingResource s) s (TF.Attr s Text) where
    computedUuid x = TF.compute (TF.refKey x) "uuid"

lambdaEventSourceMappingResource :: TF.Schema TF.Resource P.AWS (LambdaEventSourceMappingResource s)
lambdaEventSourceMappingResource =
    TF.newResource "aws_lambda_event_source_mapping" $
        LambdaEventSourceMappingResource {
              _batch_size = TF.Nil
            , _enabled = TF.Nil
            , _event_source_arn = TF.Nil
            , _function_name = TF.Nil
            , _starting_position = TF.Nil
            }

{- | The @aws_lambda_function@ AWS resource.

Provides a Lambda Function resource. Lambda allows you to trigger execution
of code in response to events in AWS. The Lambda Function itself includes
source code and runtime configuration. For information about Lambda and how
to use it, see <https://docs.aws.amazon.com/lambda/latest/dg/welcome.html>
-}
data LambdaFunctionResource s = LambdaFunctionResource {
      _dead_letter_config             :: !(TF.Attr s Text)
    {- ^ (Optional) Nested block to configure the function's dead letter queue . See details below. -}
    , _description                    :: !(TF.Attr s Text)
    {- ^ (Optional) Description of what your Lambda Function does. -}
    , _environment                    :: !(TF.Attr s Text)
    {- ^ (Optional) The Lambda environment's configuration settings. Fields documented below. -}
    , _filename                       :: !(TF.Attr s Text)
    {- ^ (Optional) The path to the function's deployment package within the local filesystem. If defined, The @s3_@ -prefixed options cannot be used. -}
    , _function_name                  :: !(TF.Attr s Text)
    {- ^ (Required) A unique name for your Lambda Function. -}
    , _handler                        :: !(TF.Attr s Text)
    {- ^ (Required) The function <https://docs.aws.amazon.com/lambda/latest/dg/walkthrough-custom-events-create-test-function.html> in your code. -}
    , _kms_key_arn                    :: !(TF.Attr s Text)
    {- ^ (Optional) The ARN for the KMS encryption key. -}
    , _memory_size                    :: !(TF.Attr s Text)
    {- ^ (Optional) Amount of memory in MB your Lambda Function can use at runtime. Defaults to @128@ . See <https://docs.aws.amazon.com/lambda/latest/dg/limits.html> -}
    , _publish                        :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to publish creation/change as new Lambda Function Version. Defaults to @false@ . -}
    , _reserved_concurrent_executions :: !(TF.Attr s Text)
    {- ^ (Optional) The amount of reserved concurrent executions for this lambda function. Defaults to Unreserved Concurrency Limits. See <https://docs.aws.amazon.com/lambda/latest/dg/concurrent-executions.html> -}
    , _role                           :: !(TF.Attr s Text)
    {- ^ (Required) IAM role attached to the Lambda Function. This governs both who / what can invoke your Lambda Function, as well as what resources our Lambda Function has access to. See <https://docs.aws.amazon.com/lambda/latest/dg/intro-permission-model.html> for more details. -}
    , _runtime                        :: !(TF.Attr s Text)
    {- ^ (Required) See <https://docs.aws.amazon.com/lambda/latest/dg/API_CreateFunction.html#SSS-CreateFunction-request-Runtime> for valid values. -}
    , _s3_bucket                      :: !(TF.Attr s Text)
    {- ^ (Optional) The S3 bucket location containing the function's deployment package. Conflicts with @filename@ . -}
    , _s3_key                         :: !(TF.Attr s Text)
    {- ^ (Optional) The S3 key of an object containing the function's deployment package. Conflicts with @filename@ . -}
    , _s3_object_version              :: !(TF.Attr s Text)
    {- ^ (Optional) The object version containing the function's deployment package. Conflicts with @filename@ . -}
    , _source_code_hash               :: !(TF.Attr s Text)
    {- ^ (Optional) Used to trigger updates. Must be set to a base64-encoded SHA256 hash of the package file specified with either @filename@ or @s3_key@ . The usual way to set this is @${base64sha256(file("file.zip"))}@ , where "file.zip" is the local filename of the lambda function source archive. -}
    , _tags                           :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the object. -}
    , _timeout                        :: !(TF.Attr s Text)
    {- ^ (Optional) The amount of time your Lambda Function has to run in seconds. Defaults to @3@ . See <https://docs.aws.amazon.com/lambda/latest/dg/limits.html> -}
    , _vpc_config                     :: !(TF.Attr s Text)
    {- ^ (Optional) Provide this to allow your function to access your VPC. Fields documented below. See <http://docs.aws.amazon.com/lambda/latest/dg/vpc.html> -}
    } deriving (Show, Eq)

instance TF.ToHCL (LambdaFunctionResource s) where
    toHCL LambdaFunctionResource{..} = TF.inline $ catMaybes
        [ TF.assign "dead_letter_config" <$> TF.attribute _dead_letter_config
        , TF.assign "description" <$> TF.attribute _description
        , TF.assign "environment" <$> TF.attribute _environment
        , TF.assign "filename" <$> TF.attribute _filename
        , TF.assign "function_name" <$> TF.attribute _function_name
        , TF.assign "handler" <$> TF.attribute _handler
        , TF.assign "kms_key_arn" <$> TF.attribute _kms_key_arn
        , TF.assign "memory_size" <$> TF.attribute _memory_size
        , TF.assign "publish" <$> TF.attribute _publish
        , TF.assign "reserved_concurrent_executions" <$> TF.attribute _reserved_concurrent_executions
        , TF.assign "role" <$> TF.attribute _role
        , TF.assign "runtime" <$> TF.attribute _runtime
        , TF.assign "s3_bucket" <$> TF.attribute _s3_bucket
        , TF.assign "s3_key" <$> TF.attribute _s3_key
        , TF.assign "s3_object_version" <$> TF.attribute _s3_object_version
        , TF.assign "source_code_hash" <$> TF.attribute _source_code_hash
        , TF.assign "tags" <$> TF.attribute _tags
        , TF.assign "timeout" <$> TF.attribute _timeout
        , TF.assign "vpc_config" <$> TF.attribute _vpc_config
        ]

instance P.HasDeadLetterConfig (LambdaFunctionResource s) (TF.Attr s Text) where
    deadLetterConfig =
        lens (_dead_letter_config :: LambdaFunctionResource s -> TF.Attr s Text)
             (\s a -> s { _dead_letter_config = a } :: LambdaFunctionResource s)

instance P.HasDescription (LambdaFunctionResource s) (TF.Attr s Text) where
    description =
        lens (_description :: LambdaFunctionResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: LambdaFunctionResource s)

instance P.HasEnvironment (LambdaFunctionResource s) (TF.Attr s Text) where
    environment =
        lens (_environment :: LambdaFunctionResource s -> TF.Attr s Text)
             (\s a -> s { _environment = a } :: LambdaFunctionResource s)

instance P.HasFilename (LambdaFunctionResource s) (TF.Attr s Text) where
    filename =
        lens (_filename :: LambdaFunctionResource s -> TF.Attr s Text)
             (\s a -> s { _filename = a } :: LambdaFunctionResource s)

instance P.HasFunctionName (LambdaFunctionResource s) (TF.Attr s Text) where
    functionName =
        lens (_function_name :: LambdaFunctionResource s -> TF.Attr s Text)
             (\s a -> s { _function_name = a } :: LambdaFunctionResource s)

instance P.HasHandler (LambdaFunctionResource s) (TF.Attr s Text) where
    handler =
        lens (_handler :: LambdaFunctionResource s -> TF.Attr s Text)
             (\s a -> s { _handler = a } :: LambdaFunctionResource s)

instance P.HasKmsKeyArn (LambdaFunctionResource s) (TF.Attr s Text) where
    kmsKeyArn =
        lens (_kms_key_arn :: LambdaFunctionResource s -> TF.Attr s Text)
             (\s a -> s { _kms_key_arn = a } :: LambdaFunctionResource s)

instance P.HasMemorySize (LambdaFunctionResource s) (TF.Attr s Text) where
    memorySize =
        lens (_memory_size :: LambdaFunctionResource s -> TF.Attr s Text)
             (\s a -> s { _memory_size = a } :: LambdaFunctionResource s)

instance P.HasPublish (LambdaFunctionResource s) (TF.Attr s Text) where
    publish =
        lens (_publish :: LambdaFunctionResource s -> TF.Attr s Text)
             (\s a -> s { _publish = a } :: LambdaFunctionResource s)

instance P.HasReservedConcurrentExecutions (LambdaFunctionResource s) (TF.Attr s Text) where
    reservedConcurrentExecutions =
        lens (_reserved_concurrent_executions :: LambdaFunctionResource s -> TF.Attr s Text)
             (\s a -> s { _reserved_concurrent_executions = a } :: LambdaFunctionResource s)

instance P.HasRole (LambdaFunctionResource s) (TF.Attr s Text) where
    role =
        lens (_role :: LambdaFunctionResource s -> TF.Attr s Text)
             (\s a -> s { _role = a } :: LambdaFunctionResource s)

instance P.HasRuntime (LambdaFunctionResource s) (TF.Attr s Text) where
    runtime =
        lens (_runtime :: LambdaFunctionResource s -> TF.Attr s Text)
             (\s a -> s { _runtime = a } :: LambdaFunctionResource s)

instance P.HasS3Bucket (LambdaFunctionResource s) (TF.Attr s Text) where
    s3Bucket =
        lens (_s3_bucket :: LambdaFunctionResource s -> TF.Attr s Text)
             (\s a -> s { _s3_bucket = a } :: LambdaFunctionResource s)

instance P.HasS3Key (LambdaFunctionResource s) (TF.Attr s Text) where
    s3Key =
        lens (_s3_key :: LambdaFunctionResource s -> TF.Attr s Text)
             (\s a -> s { _s3_key = a } :: LambdaFunctionResource s)

instance P.HasS3ObjectVersion (LambdaFunctionResource s) (TF.Attr s Text) where
    s3ObjectVersion =
        lens (_s3_object_version :: LambdaFunctionResource s -> TF.Attr s Text)
             (\s a -> s { _s3_object_version = a } :: LambdaFunctionResource s)

instance P.HasSourceCodeHash (LambdaFunctionResource s) (TF.Attr s Text) where
    sourceCodeHash =
        lens (_source_code_hash :: LambdaFunctionResource s -> TF.Attr s Text)
             (\s a -> s { _source_code_hash = a } :: LambdaFunctionResource s)

instance P.HasTags (LambdaFunctionResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: LambdaFunctionResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: LambdaFunctionResource s)

instance P.HasTimeout (LambdaFunctionResource s) (TF.Attr s Text) where
    timeout =
        lens (_timeout :: LambdaFunctionResource s -> TF.Attr s Text)
             (\s a -> s { _timeout = a } :: LambdaFunctionResource s)

instance P.HasVpcConfig (LambdaFunctionResource s) (TF.Attr s Text) where
    vpcConfig =
        lens (_vpc_config :: LambdaFunctionResource s -> TF.Attr s Text)
             (\s a -> s { _vpc_config = a } :: LambdaFunctionResource s)

instance P.HasComputedArn (LambdaFunctionResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedDeadLetterConfig (LambdaFunctionResource s) s (TF.Attr s Text) where
    computedDeadLetterConfig =
        (_dead_letter_config :: LambdaFunctionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDescription (LambdaFunctionResource s) s (TF.Attr s Text) where
    computedDescription =
        (_description :: LambdaFunctionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEnvironment (LambdaFunctionResource s) s (TF.Attr s Text) where
    computedEnvironment =
        (_environment :: LambdaFunctionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedFilename (LambdaFunctionResource s) s (TF.Attr s Text) where
    computedFilename =
        (_filename :: LambdaFunctionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedFunctionName (LambdaFunctionResource s) s (TF.Attr s Text) where
    computedFunctionName =
        (_function_name :: LambdaFunctionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedHandler (LambdaFunctionResource s) s (TF.Attr s Text) where
    computedHandler =
        (_handler :: LambdaFunctionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedInvokeArn (LambdaFunctionResource s) s (TF.Attr s Text) where
    computedInvokeArn x = TF.compute (TF.refKey x) "invoke_arn"

instance P.HasComputedKmsKeyArn (LambdaFunctionResource s) s (TF.Attr s Text) where
    computedKmsKeyArn x = TF.compute (TF.refKey x) "kms_key_arn"

instance P.HasComputedLastModified (LambdaFunctionResource s) s (TF.Attr s Text) where
    computedLastModified x = TF.compute (TF.refKey x) "last_modified"

instance P.HasComputedMemorySize (LambdaFunctionResource s) s (TF.Attr s Text) where
    computedMemorySize =
        (_memory_size :: LambdaFunctionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPublish (LambdaFunctionResource s) s (TF.Attr s Text) where
    computedPublish =
        (_publish :: LambdaFunctionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedQualifiedArn (LambdaFunctionResource s) s (TF.Attr s Text) where
    computedQualifiedArn x = TF.compute (TF.refKey x) "qualified_arn"

instance P.HasComputedReservedConcurrentExecutions (LambdaFunctionResource s) s (TF.Attr s Text) where
    computedReservedConcurrentExecutions =
        (_reserved_concurrent_executions :: LambdaFunctionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRole (LambdaFunctionResource s) s (TF.Attr s Text) where
    computedRole =
        (_role :: LambdaFunctionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRuntime (LambdaFunctionResource s) s (TF.Attr s Text) where
    computedRuntime =
        (_runtime :: LambdaFunctionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedS3Bucket (LambdaFunctionResource s) s (TF.Attr s Text) where
    computedS3Bucket =
        (_s3_bucket :: LambdaFunctionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedS3Key (LambdaFunctionResource s) s (TF.Attr s Text) where
    computedS3Key =
        (_s3_key :: LambdaFunctionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedS3ObjectVersion (LambdaFunctionResource s) s (TF.Attr s Text) where
    computedS3ObjectVersion =
        (_s3_object_version :: LambdaFunctionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSourceCodeHash (LambdaFunctionResource s) s (TF.Attr s Text) where
    computedSourceCodeHash x = TF.compute (TF.refKey x) "source_code_hash"

instance P.HasComputedTags (LambdaFunctionResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: LambdaFunctionResource s -> TF.Attr s P.Tags)
            . TF.refValue

instance P.HasComputedTimeout (LambdaFunctionResource s) s (TF.Attr s Text) where
    computedTimeout =
        (_timeout :: LambdaFunctionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedVersion (LambdaFunctionResource s) s (TF.Attr s Text) where
    computedVersion x = TF.compute (TF.refKey x) "version"

instance P.HasComputedVpcConfig (LambdaFunctionResource s) s (TF.Attr s Text) where
    computedVpcConfig =
        (_vpc_config :: LambdaFunctionResource s -> TF.Attr s Text)
            . TF.refValue

lambdaFunctionResource :: TF.Schema TF.Resource P.AWS (LambdaFunctionResource s)
lambdaFunctionResource =
    TF.newResource "aws_lambda_function" $
        LambdaFunctionResource {
              _dead_letter_config = TF.Nil
            , _description = TF.Nil
            , _environment = TF.Nil
            , _filename = TF.Nil
            , _function_name = TF.Nil
            , _handler = TF.Nil
            , _kms_key_arn = TF.Nil
            , _memory_size = TF.Nil
            , _publish = TF.Nil
            , _reserved_concurrent_executions = TF.Nil
            , _role = TF.Nil
            , _runtime = TF.Nil
            , _s3_bucket = TF.Nil
            , _s3_key = TF.Nil
            , _s3_object_version = TF.Nil
            , _source_code_hash = TF.Nil
            , _tags = TF.Nil
            , _timeout = TF.Nil
            , _vpc_config = TF.Nil
            }

{- | The @aws_lambda_permission@ AWS resource.

Creates a Lambda permission to allow external sources invoking the Lambda
function (e.g. CloudWatch Event Rule, SNS or S3).
-}
data LambdaPermissionResource s = LambdaPermissionResource {
      _action         :: !(TF.Attr s Text)
    {- ^ (Required) The AWS Lambda action you want to allow in this statement. (e.g. @lambda:InvokeFunction@ ) -}
    , _function_name  :: !(TF.Attr s Text)
    {- ^ (Required) Name of the Lambda function whose resource policy you are updating -}
    , _principal      :: !(TF.Attr s Text)
    {- ^ (Required) The principal who is getting this permission. e.g. @s3.amazonaws.com@ , an AWS account ID, or any valid AWS service principal such as @events.amazonaws.com@ or @sns.amazonaws.com@ . -}
    , _qualifier      :: !(TF.Attr s Text)
    {- ^ (Optional) Query parameter to specify function version or alias name. The permission will then apply to the specific qualified ARN. e.g. @arn:aws:lambda:aws-region:acct-id:function:function-name:2@ -}
    , _source_account :: !(TF.Attr s Text)
    {- ^ (Optional) The AWS account ID (without a hyphen) of the source owner. -}
    , _source_arn     :: !(TF.Attr s Text)
    {- ^ (Optional) When granting Amazon S3 or CloudWatch Events permission to invoke your function, you should specify this field with the Amazon Resource Name (ARN) for the S3 Bucket or CloudWatch Events Rule as its value.  This ensures that only events generated from the specified bucket or rule can invoke the function. API Gateway ARNs have a unique structure described <http://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-control-access-using-iam-policies-to-invoke-api.html> . -}
    , _statement_id   :: !(TF.Attr s Text)
    {- ^ (Required) A unique statement identifier. -}
    } deriving (Show, Eq)

instance TF.ToHCL (LambdaPermissionResource s) where
    toHCL LambdaPermissionResource{..} = TF.inline $ catMaybes
        [ TF.assign "action" <$> TF.attribute _action
        , TF.assign "function_name" <$> TF.attribute _function_name
        , TF.assign "principal" <$> TF.attribute _principal
        , TF.assign "qualifier" <$> TF.attribute _qualifier
        , TF.assign "source_account" <$> TF.attribute _source_account
        , TF.assign "source_arn" <$> TF.attribute _source_arn
        , TF.assign "statement_id" <$> TF.attribute _statement_id
        ]

instance P.HasAction (LambdaPermissionResource s) (TF.Attr s Text) where
    action =
        lens (_action :: LambdaPermissionResource s -> TF.Attr s Text)
             (\s a -> s { _action = a } :: LambdaPermissionResource s)

instance P.HasFunctionName (LambdaPermissionResource s) (TF.Attr s Text) where
    functionName =
        lens (_function_name :: LambdaPermissionResource s -> TF.Attr s Text)
             (\s a -> s { _function_name = a } :: LambdaPermissionResource s)

instance P.HasPrincipal (LambdaPermissionResource s) (TF.Attr s Text) where
    principal =
        lens (_principal :: LambdaPermissionResource s -> TF.Attr s Text)
             (\s a -> s { _principal = a } :: LambdaPermissionResource s)

instance P.HasQualifier (LambdaPermissionResource s) (TF.Attr s Text) where
    qualifier =
        lens (_qualifier :: LambdaPermissionResource s -> TF.Attr s Text)
             (\s a -> s { _qualifier = a } :: LambdaPermissionResource s)

instance P.HasSourceAccount (LambdaPermissionResource s) (TF.Attr s Text) where
    sourceAccount =
        lens (_source_account :: LambdaPermissionResource s -> TF.Attr s Text)
             (\s a -> s { _source_account = a } :: LambdaPermissionResource s)

instance P.HasSourceArn (LambdaPermissionResource s) (TF.Attr s Text) where
    sourceArn =
        lens (_source_arn :: LambdaPermissionResource s -> TF.Attr s Text)
             (\s a -> s { _source_arn = a } :: LambdaPermissionResource s)

instance P.HasStatementId (LambdaPermissionResource s) (TF.Attr s Text) where
    statementId =
        lens (_statement_id :: LambdaPermissionResource s -> TF.Attr s Text)
             (\s a -> s { _statement_id = a } :: LambdaPermissionResource s)

instance P.HasComputedAction (LambdaPermissionResource s) s (TF.Attr s Text) where
    computedAction =
        (_action :: LambdaPermissionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedFunctionName (LambdaPermissionResource s) s (TF.Attr s Text) where
    computedFunctionName =
        (_function_name :: LambdaPermissionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPrincipal (LambdaPermissionResource s) s (TF.Attr s Text) where
    computedPrincipal =
        (_principal :: LambdaPermissionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedQualifier (LambdaPermissionResource s) s (TF.Attr s Text) where
    computedQualifier =
        (_qualifier :: LambdaPermissionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSourceAccount (LambdaPermissionResource s) s (TF.Attr s Text) where
    computedSourceAccount =
        (_source_account :: LambdaPermissionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSourceArn (LambdaPermissionResource s) s (TF.Attr s Text) where
    computedSourceArn =
        (_source_arn :: LambdaPermissionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedStatementId (LambdaPermissionResource s) s (TF.Attr s Text) where
    computedStatementId =
        (_statement_id :: LambdaPermissionResource s -> TF.Attr s Text)
            . TF.refValue

lambdaPermissionResource :: TF.Schema TF.Resource P.AWS (LambdaPermissionResource s)
lambdaPermissionResource =
    TF.newResource "aws_lambda_permission" $
        LambdaPermissionResource {
              _action = TF.Nil
            , _function_name = TF.Nil
            , _principal = TF.Nil
            , _qualifier = TF.Nil
            , _source_account = TF.Nil
            , _source_arn = TF.Nil
            , _statement_id = TF.Nil
            }

{- | The @aws_launch_configuration@ AWS resource.

Provides a resource to create a new launch configuration, used for
autoscaling groups.
-}
data LaunchConfigurationResource s = LaunchConfigurationResource {
      _associate_public_ip_address      :: !(TF.Attr s Text)
    {- ^ (Optional) Associate a public ip address with an instance in a VPC. -}
    , _ebs_block_device                 :: !(TF.Attr s Text)
    {- ^ (Optional) Additional EBS block devices to attach to the instance.  See <#block-devices> below for details. -}
    , _ebs_optimized                    :: !(TF.Attr s Text)
    {- ^ (Optional) If true, the launched EC2 instance will be EBS-optimized. -}
    , _enable_monitoring                :: !(TF.Attr s P.Bool)
    {- ^ (Optional) Enables/disables detailed monitoring. This is enabled by default. -}
    , _ephemeral_block_device           :: !(TF.Attr s Text)
    {- ^ (Optional) Customize Ephemeral (also known as "Instance Store") volumes on the instance. See <#block-devices> below for details. -}
    , _iam_instance_profile             :: !(TF.Attr s Text)
    {- ^ (Optional) The IAM instance profile to associate with launched instances. -}
    , _image_id                         :: !(TF.Attr s Text)
    {- ^ (Required) The EC2 image ID to launch. -}
    , _instance_type                    :: !(TF.Attr s Text)
    {- ^ (Required) The size of instance to launch. -}
    , _key_name                         :: !(TF.Attr s Text)
    {- ^ (Optional) The key name that should be used for the instance. -}
    , _name                             :: !(TF.Attr s Text)
    {- ^ (Optional) The name of the launch configuration. If you leave this blank, Terraform will auto-generate a unique name. -}
    , _name_prefix                      :: !(TF.Attr s Text)
    {- ^ (Optional) Creates a unique name beginning with the specified prefix. Conflicts with @name@ . -}
    , _placement_tenancy                :: !(TF.Attr s Text)
    {- ^ (Optional) The tenancy of the instance. Valid values are @"default"@ or @"dedicated"@ , see <http://docs.aws.amazon.com/AutoScaling/latest/APIReference/API_CreateLaunchConfiguration.html> for more details -}
    , _root_block_device                :: !(TF.Attr s Text)
    {- ^ (Optional) Customize details about the root block device of the instance. See <#block-devices> below for details. -}
    , _security_groups                  :: !(TF.Attr s Text)
    {- ^ (Optional) A list of associated security group IDS. -}
    , _spot_price                       :: !(TF.Attr s Text)
    {- ^ (Optional) The price to use for reserving spot instances. -}
    , _user_data                        :: !(TF.Attr s Text)
    {- ^ (Optional) The user data to provide when launching the instance. -}
    , _vpc_classic_link_id              :: !(TF.Attr s Text)
    {- ^ (Optional) The ID of a ClassicLink-enabled VPC. Only applies to EC2-Classic instances. (eg. @vpc-2730681a@ ) -}
    , _vpc_classic_link_security_groups :: !(TF.Attr s Text)
    {- ^ (Optional) The IDs of one or more security groups for the specified ClassicLink-enabled VPC (eg. @sg-46ae3d11@ ). -}
    } deriving (Show, Eq)

instance TF.ToHCL (LaunchConfigurationResource s) where
    toHCL LaunchConfigurationResource{..} = TF.inline $ catMaybes
        [ TF.assign "associate_public_ip_address" <$> TF.attribute _associate_public_ip_address
        , TF.assign "ebs_block_device" <$> TF.attribute _ebs_block_device
        , TF.assign "ebs_optimized" <$> TF.attribute _ebs_optimized
        , TF.assign "enable_monitoring" <$> TF.attribute _enable_monitoring
        , TF.assign "ephemeral_block_device" <$> TF.attribute _ephemeral_block_device
        , TF.assign "iam_instance_profile" <$> TF.attribute _iam_instance_profile
        , TF.assign "image_id" <$> TF.attribute _image_id
        , TF.assign "instance_type" <$> TF.attribute _instance_type
        , TF.assign "key_name" <$> TF.attribute _key_name
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "name_prefix" <$> TF.attribute _name_prefix
        , TF.assign "placement_tenancy" <$> TF.attribute _placement_tenancy
        , TF.assign "root_block_device" <$> TF.attribute _root_block_device
        , TF.assign "security_groups" <$> TF.attribute _security_groups
        , TF.assign "spot_price" <$> TF.attribute _spot_price
        , TF.assign "user_data" <$> TF.attribute _user_data
        , TF.assign "vpc_classic_link_id" <$> TF.attribute _vpc_classic_link_id
        , TF.assign "vpc_classic_link_security_groups" <$> TF.attribute _vpc_classic_link_security_groups
        ]

instance P.HasAssociatePublicIpAddress (LaunchConfigurationResource s) (TF.Attr s Text) where
    associatePublicIpAddress =
        lens (_associate_public_ip_address :: LaunchConfigurationResource s -> TF.Attr s Text)
             (\s a -> s { _associate_public_ip_address = a } :: LaunchConfigurationResource s)

instance P.HasEbsBlockDevice (LaunchConfigurationResource s) (TF.Attr s Text) where
    ebsBlockDevice =
        lens (_ebs_block_device :: LaunchConfigurationResource s -> TF.Attr s Text)
             (\s a -> s { _ebs_block_device = a } :: LaunchConfigurationResource s)

instance P.HasEbsOptimized (LaunchConfigurationResource s) (TF.Attr s Text) where
    ebsOptimized =
        lens (_ebs_optimized :: LaunchConfigurationResource s -> TF.Attr s Text)
             (\s a -> s { _ebs_optimized = a } :: LaunchConfigurationResource s)

instance P.HasEnableMonitoring (LaunchConfigurationResource s) (TF.Attr s P.Bool) where
    enableMonitoring =
        lens (_enable_monitoring :: LaunchConfigurationResource s -> TF.Attr s P.Bool)
             (\s a -> s { _enable_monitoring = a } :: LaunchConfigurationResource s)

instance P.HasEphemeralBlockDevice (LaunchConfigurationResource s) (TF.Attr s Text) where
    ephemeralBlockDevice =
        lens (_ephemeral_block_device :: LaunchConfigurationResource s -> TF.Attr s Text)
             (\s a -> s { _ephemeral_block_device = a } :: LaunchConfigurationResource s)

instance P.HasIamInstanceProfile (LaunchConfigurationResource s) (TF.Attr s Text) where
    iamInstanceProfile =
        lens (_iam_instance_profile :: LaunchConfigurationResource s -> TF.Attr s Text)
             (\s a -> s { _iam_instance_profile = a } :: LaunchConfigurationResource s)

instance P.HasImageId (LaunchConfigurationResource s) (TF.Attr s Text) where
    imageId =
        lens (_image_id :: LaunchConfigurationResource s -> TF.Attr s Text)
             (\s a -> s { _image_id = a } :: LaunchConfigurationResource s)

instance P.HasInstanceType (LaunchConfigurationResource s) (TF.Attr s Text) where
    instanceType =
        lens (_instance_type :: LaunchConfigurationResource s -> TF.Attr s Text)
             (\s a -> s { _instance_type = a } :: LaunchConfigurationResource s)

instance P.HasKeyName (LaunchConfigurationResource s) (TF.Attr s Text) where
    keyName =
        lens (_key_name :: LaunchConfigurationResource s -> TF.Attr s Text)
             (\s a -> s { _key_name = a } :: LaunchConfigurationResource s)

instance P.HasName (LaunchConfigurationResource s) (TF.Attr s Text) where
    name =
        lens (_name :: LaunchConfigurationResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: LaunchConfigurationResource s)

instance P.HasNamePrefix (LaunchConfigurationResource s) (TF.Attr s Text) where
    namePrefix =
        lens (_name_prefix :: LaunchConfigurationResource s -> TF.Attr s Text)
             (\s a -> s { _name_prefix = a } :: LaunchConfigurationResource s)

instance P.HasPlacementTenancy (LaunchConfigurationResource s) (TF.Attr s Text) where
    placementTenancy =
        lens (_placement_tenancy :: LaunchConfigurationResource s -> TF.Attr s Text)
             (\s a -> s { _placement_tenancy = a } :: LaunchConfigurationResource s)

instance P.HasRootBlockDevice (LaunchConfigurationResource s) (TF.Attr s Text) where
    rootBlockDevice =
        lens (_root_block_device :: LaunchConfigurationResource s -> TF.Attr s Text)
             (\s a -> s { _root_block_device = a } :: LaunchConfigurationResource s)

instance P.HasSecurityGroups (LaunchConfigurationResource s) (TF.Attr s Text) where
    securityGroups =
        lens (_security_groups :: LaunchConfigurationResource s -> TF.Attr s Text)
             (\s a -> s { _security_groups = a } :: LaunchConfigurationResource s)

instance P.HasSpotPrice (LaunchConfigurationResource s) (TF.Attr s Text) where
    spotPrice =
        lens (_spot_price :: LaunchConfigurationResource s -> TF.Attr s Text)
             (\s a -> s { _spot_price = a } :: LaunchConfigurationResource s)

instance P.HasUserData (LaunchConfigurationResource s) (TF.Attr s Text) where
    userData =
        lens (_user_data :: LaunchConfigurationResource s -> TF.Attr s Text)
             (\s a -> s { _user_data = a } :: LaunchConfigurationResource s)

instance P.HasVpcClassicLinkId (LaunchConfigurationResource s) (TF.Attr s Text) where
    vpcClassicLinkId =
        lens (_vpc_classic_link_id :: LaunchConfigurationResource s -> TF.Attr s Text)
             (\s a -> s { _vpc_classic_link_id = a } :: LaunchConfigurationResource s)

instance P.HasVpcClassicLinkSecurityGroups (LaunchConfigurationResource s) (TF.Attr s Text) where
    vpcClassicLinkSecurityGroups =
        lens (_vpc_classic_link_security_groups :: LaunchConfigurationResource s -> TF.Attr s Text)
             (\s a -> s { _vpc_classic_link_security_groups = a } :: LaunchConfigurationResource s)

instance P.HasComputedAssociatePublicIpAddress (LaunchConfigurationResource s) s (TF.Attr s Text) where
    computedAssociatePublicIpAddress =
        (_associate_public_ip_address :: LaunchConfigurationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEbsBlockDevice (LaunchConfigurationResource s) s (TF.Attr s Text) where
    computedEbsBlockDevice =
        (_ebs_block_device :: LaunchConfigurationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEbsOptimized (LaunchConfigurationResource s) s (TF.Attr s Text) where
    computedEbsOptimized =
        (_ebs_optimized :: LaunchConfigurationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEnableMonitoring (LaunchConfigurationResource s) s (TF.Attr s P.Bool) where
    computedEnableMonitoring =
        (_enable_monitoring :: LaunchConfigurationResource s -> TF.Attr s P.Bool)
            . TF.refValue

instance P.HasComputedEphemeralBlockDevice (LaunchConfigurationResource s) s (TF.Attr s Text) where
    computedEphemeralBlockDevice =
        (_ephemeral_block_device :: LaunchConfigurationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedIamInstanceProfile (LaunchConfigurationResource s) s (TF.Attr s Text) where
    computedIamInstanceProfile =
        (_iam_instance_profile :: LaunchConfigurationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (LaunchConfigurationResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedImageId (LaunchConfigurationResource s) s (TF.Attr s Text) where
    computedImageId =
        (_image_id :: LaunchConfigurationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedInstanceType (LaunchConfigurationResource s) s (TF.Attr s Text) where
    computedInstanceType =
        (_instance_type :: LaunchConfigurationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedKeyName (LaunchConfigurationResource s) s (TF.Attr s Text) where
    computedKeyName =
        (_key_name :: LaunchConfigurationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (LaunchConfigurationResource s) s (TF.Attr s Text) where
    computedName x = TF.compute (TF.refKey x) "name"

instance P.HasComputedNamePrefix (LaunchConfigurationResource s) s (TF.Attr s Text) where
    computedNamePrefix =
        (_name_prefix :: LaunchConfigurationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPlacementTenancy (LaunchConfigurationResource s) s (TF.Attr s Text) where
    computedPlacementTenancy =
        (_placement_tenancy :: LaunchConfigurationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRootBlockDevice (LaunchConfigurationResource s) s (TF.Attr s Text) where
    computedRootBlockDevice =
        (_root_block_device :: LaunchConfigurationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSecurityGroups (LaunchConfigurationResource s) s (TF.Attr s Text) where
    computedSecurityGroups =
        (_security_groups :: LaunchConfigurationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSpotPrice (LaunchConfigurationResource s) s (TF.Attr s Text) where
    computedSpotPrice =
        (_spot_price :: LaunchConfigurationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedUserData (LaunchConfigurationResource s) s (TF.Attr s Text) where
    computedUserData =
        (_user_data :: LaunchConfigurationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedVpcClassicLinkId (LaunchConfigurationResource s) s (TF.Attr s Text) where
    computedVpcClassicLinkId =
        (_vpc_classic_link_id :: LaunchConfigurationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedVpcClassicLinkSecurityGroups (LaunchConfigurationResource s) s (TF.Attr s Text) where
    computedVpcClassicLinkSecurityGroups =
        (_vpc_classic_link_security_groups :: LaunchConfigurationResource s -> TF.Attr s Text)
            . TF.refValue

launchConfigurationResource :: TF.Schema TF.Resource P.AWS (LaunchConfigurationResource s)
launchConfigurationResource =
    TF.newResource "aws_launch_configuration" $
        LaunchConfigurationResource {
              _associate_public_ip_address = TF.Nil
            , _ebs_block_device = TF.Nil
            , _ebs_optimized = TF.Nil
            , _enable_monitoring = TF.Nil
            , _ephemeral_block_device = TF.Nil
            , _iam_instance_profile = TF.Nil
            , _image_id = TF.Nil
            , _instance_type = TF.Nil
            , _key_name = TF.Nil
            , _name = TF.Nil
            , _name_prefix = TF.Nil
            , _placement_tenancy = TF.Nil
            , _root_block_device = TF.Nil
            , _security_groups = TF.Nil
            , _spot_price = TF.Nil
            , _user_data = TF.Nil
            , _vpc_classic_link_id = TF.Nil
            , _vpc_classic_link_security_groups = TF.Nil
            }

{- | The @aws_lb_cookie_stickiness_policy@ AWS resource.

Provides a load balancer cookie stickiness policy, which allows an ELB to
control the sticky session lifetime of the browser.
-}
data LbCookieStickinessPolicyResource s = LbCookieStickinessPolicyResource {
      _cookie_expiration_period :: !(TF.Attr s Text)
    {- ^ (Optional) The time period after which the session cookie should be considered stale, expressed in seconds. -}
    , _lb_port                  :: !(TF.Attr s P.Word16)
    {- ^ (Required) The load balancer port to which the policy should be applied. This must be an active listener on the load balancer. -}
    , _load_balancer            :: !(TF.Attr s Text)
    {- ^ (Required) The load balancer to which the policy should be attached. -}
    , _name                     :: !(TF.Attr s Text)
    {- ^ (Required) The name of the stickiness policy. -}
    } deriving (Show, Eq)

instance TF.ToHCL (LbCookieStickinessPolicyResource s) where
    toHCL LbCookieStickinessPolicyResource{..} = TF.inline $ catMaybes
        [ TF.assign "cookie_expiration_period" <$> TF.attribute _cookie_expiration_period
        , TF.assign "lb_port" <$> TF.attribute _lb_port
        , TF.assign "load_balancer" <$> TF.attribute _load_balancer
        , TF.assign "name" <$> TF.attribute _name
        ]

instance P.HasCookieExpirationPeriod (LbCookieStickinessPolicyResource s) (TF.Attr s Text) where
    cookieExpirationPeriod =
        lens (_cookie_expiration_period :: LbCookieStickinessPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _cookie_expiration_period = a } :: LbCookieStickinessPolicyResource s)

instance P.HasLbPort (LbCookieStickinessPolicyResource s) (TF.Attr s P.Word16) where
    lbPort =
        lens (_lb_port :: LbCookieStickinessPolicyResource s -> TF.Attr s P.Word16)
             (\s a -> s { _lb_port = a } :: LbCookieStickinessPolicyResource s)

instance P.HasLoadBalancer (LbCookieStickinessPolicyResource s) (TF.Attr s Text) where
    loadBalancer =
        lens (_load_balancer :: LbCookieStickinessPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _load_balancer = a } :: LbCookieStickinessPolicyResource s)

instance P.HasName (LbCookieStickinessPolicyResource s) (TF.Attr s Text) where
    name =
        lens (_name :: LbCookieStickinessPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: LbCookieStickinessPolicyResource s)

instance P.HasComputedCookieExpirationPeriod (LbCookieStickinessPolicyResource s) s (TF.Attr s Text) where
    computedCookieExpirationPeriod x = TF.compute (TF.refKey x) "cookie_expiration_period"

instance P.HasComputedId (LbCookieStickinessPolicyResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedLbPort (LbCookieStickinessPolicyResource s) s (TF.Attr s P.Word16) where
    computedLbPort x = TF.compute (TF.refKey x) "lb_port"

instance P.HasComputedLoadBalancer (LbCookieStickinessPolicyResource s) s (TF.Attr s Text) where
    computedLoadBalancer x = TF.compute (TF.refKey x) "load_balancer"

instance P.HasComputedName (LbCookieStickinessPolicyResource s) s (TF.Attr s Text) where
    computedName x = TF.compute (TF.refKey x) "name"

lbCookieStickinessPolicyResource :: TF.Schema TF.Resource P.AWS (LbCookieStickinessPolicyResource s)
lbCookieStickinessPolicyResource =
    TF.newResource "aws_lb_cookie_stickiness_policy" $
        LbCookieStickinessPolicyResource {
              _cookie_expiration_period = TF.Nil
            , _lb_port = TF.Nil
            , _load_balancer = TF.Nil
            , _name = TF.Nil
            }

{- | The @aws_lb_listener@ AWS resource.

Provides a Load Balancer Listener resource. ~> Note:  @aws_alb_listener@ is
known as @aws_lb_listener@ . The functionality is identical.
-}
data LbListenerResource s = LbListenerResource {
      _certificate_arn   :: !(TF.Attr s Text)
    {- ^ (Optional) The ARN of the SSL server certificate. Exactly one certificate is required if the protocol is HTTPS. -}
    , _default_action    :: !(TF.Attr s Text)
    {- ^ (Required) An Action block. Action blocks are documented below. -}
    , _load_balancer_arn :: !(TF.Attr s Text)
    {- ^ (Required, Forces New Resource) The ARN of the load balancer. -}
    , _port              :: !(TF.Attr s Text)
    {- ^ (Required) The port on which the load balancer is listening. -}
    , _protocol          :: !(TF.Attr s Text)
    {- ^ (Optional) The protocol for connections from clients to the load balancer. Valid values are @TCP@ , @HTTP@ and @HTTPS@ . Defaults to @HTTP@ . -}
    , _ssl_policy        :: !(TF.Attr s Text)
    {- ^ (Optional) The name of the SSL Policy for the listener. Required if @protocol@ is @HTTPS@ . -}
    } deriving (Show, Eq)

instance TF.ToHCL (LbListenerResource s) where
    toHCL LbListenerResource{..} = TF.inline $ catMaybes
        [ TF.assign "certificate_arn" <$> TF.attribute _certificate_arn
        , TF.assign "default_action" <$> TF.attribute _default_action
        , TF.assign "load_balancer_arn" <$> TF.attribute _load_balancer_arn
        , TF.assign "port" <$> TF.attribute _port
        , TF.assign "protocol" <$> TF.attribute _protocol
        , TF.assign "ssl_policy" <$> TF.attribute _ssl_policy
        ]

instance P.HasCertificateArn (LbListenerResource s) (TF.Attr s Text) where
    certificateArn =
        lens (_certificate_arn :: LbListenerResource s -> TF.Attr s Text)
             (\s a -> s { _certificate_arn = a } :: LbListenerResource s)

instance P.HasDefaultAction (LbListenerResource s) (TF.Attr s Text) where
    defaultAction =
        lens (_default_action :: LbListenerResource s -> TF.Attr s Text)
             (\s a -> s { _default_action = a } :: LbListenerResource s)

instance P.HasLoadBalancerArn (LbListenerResource s) (TF.Attr s Text) where
    loadBalancerArn =
        lens (_load_balancer_arn :: LbListenerResource s -> TF.Attr s Text)
             (\s a -> s { _load_balancer_arn = a } :: LbListenerResource s)

instance P.HasPort (LbListenerResource s) (TF.Attr s Text) where
    port =
        lens (_port :: LbListenerResource s -> TF.Attr s Text)
             (\s a -> s { _port = a } :: LbListenerResource s)

instance P.HasProtocol (LbListenerResource s) (TF.Attr s Text) where
    protocol =
        lens (_protocol :: LbListenerResource s -> TF.Attr s Text)
             (\s a -> s { _protocol = a } :: LbListenerResource s)

instance P.HasSslPolicy (LbListenerResource s) (TF.Attr s Text) where
    sslPolicy =
        lens (_ssl_policy :: LbListenerResource s -> TF.Attr s Text)
             (\s a -> s { _ssl_policy = a } :: LbListenerResource s)

instance P.HasComputedArn (LbListenerResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedCertificateArn (LbListenerResource s) s (TF.Attr s Text) where
    computedCertificateArn =
        (_certificate_arn :: LbListenerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDefaultAction (LbListenerResource s) s (TF.Attr s Text) where
    computedDefaultAction =
        (_default_action :: LbListenerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (LbListenerResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedLoadBalancerArn (LbListenerResource s) s (TF.Attr s Text) where
    computedLoadBalancerArn =
        (_load_balancer_arn :: LbListenerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPort (LbListenerResource s) s (TF.Attr s Text) where
    computedPort =
        (_port :: LbListenerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedProtocol (LbListenerResource s) s (TF.Attr s Text) where
    computedProtocol =
        (_protocol :: LbListenerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSslPolicy (LbListenerResource s) s (TF.Attr s Text) where
    computedSslPolicy =
        (_ssl_policy :: LbListenerResource s -> TF.Attr s Text)
            . TF.refValue

lbListenerResource :: TF.Schema TF.Resource P.AWS (LbListenerResource s)
lbListenerResource =
    TF.newResource "aws_lb_listener" $
        LbListenerResource {
              _certificate_arn = TF.Nil
            , _default_action = TF.Nil
            , _load_balancer_arn = TF.Nil
            , _port = TF.Nil
            , _protocol = TF.Nil
            , _ssl_policy = TF.Nil
            }

{- | The @aws_lb_listener_rule@ AWS resource.

Provides a Load Balancer Listener Rule resource. ~> Note:
@aws_alb_listener_rule@ is known as @aws_lb_listener_rule@ . The
functionality is identical.
-}
data LbListenerRuleResource s = LbListenerRuleResource {
      _action       :: !(TF.Attr s Text)
    {- ^ (Required) An Action block. Action blocks are documented below. -}
    , _condition    :: !(TF.Attr s Text)
    {- ^ (Required) A Condition block. Condition blocks are documented below. -}
    , _listener_arn :: !(TF.Attr s Text)
    {- ^ (Required, Forces New Resource) The ARN of the listener to which to attach the rule. -}
    , _priority     :: !(TF.Attr s Text)
    {- ^ (Required) The priority for the rule between @1@ and @50000@ . A listener can't have multiple rules with the same priority. -}
    } deriving (Show, Eq)

instance TF.ToHCL (LbListenerRuleResource s) where
    toHCL LbListenerRuleResource{..} = TF.inline $ catMaybes
        [ TF.assign "action" <$> TF.attribute _action
        , TF.assign "condition" <$> TF.attribute _condition
        , TF.assign "listener_arn" <$> TF.attribute _listener_arn
        , TF.assign "priority" <$> TF.attribute _priority
        ]

instance P.HasAction (LbListenerRuleResource s) (TF.Attr s Text) where
    action =
        lens (_action :: LbListenerRuleResource s -> TF.Attr s Text)
             (\s a -> s { _action = a } :: LbListenerRuleResource s)

instance P.HasCondition (LbListenerRuleResource s) (TF.Attr s Text) where
    condition =
        lens (_condition :: LbListenerRuleResource s -> TF.Attr s Text)
             (\s a -> s { _condition = a } :: LbListenerRuleResource s)

instance P.HasListenerArn (LbListenerRuleResource s) (TF.Attr s Text) where
    listenerArn =
        lens (_listener_arn :: LbListenerRuleResource s -> TF.Attr s Text)
             (\s a -> s { _listener_arn = a } :: LbListenerRuleResource s)

instance P.HasPriority (LbListenerRuleResource s) (TF.Attr s Text) where
    priority =
        lens (_priority :: LbListenerRuleResource s -> TF.Attr s Text)
             (\s a -> s { _priority = a } :: LbListenerRuleResource s)

instance P.HasComputedAction (LbListenerRuleResource s) s (TF.Attr s Text) where
    computedAction =
        (_action :: LbListenerRuleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedArn (LbListenerRuleResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedCondition (LbListenerRuleResource s) s (TF.Attr s Text) where
    computedCondition =
        (_condition :: LbListenerRuleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (LbListenerRuleResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedListenerArn (LbListenerRuleResource s) s (TF.Attr s Text) where
    computedListenerArn =
        (_listener_arn :: LbListenerRuleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPriority (LbListenerRuleResource s) s (TF.Attr s Text) where
    computedPriority =
        (_priority :: LbListenerRuleResource s -> TF.Attr s Text)
            . TF.refValue

lbListenerRuleResource :: TF.Schema TF.Resource P.AWS (LbListenerRuleResource s)
lbListenerRuleResource =
    TF.newResource "aws_lb_listener_rule" $
        LbListenerRuleResource {
              _action = TF.Nil
            , _condition = TF.Nil
            , _listener_arn = TF.Nil
            , _priority = TF.Nil
            }

{- | The @aws_lb@ AWS resource.

Provides a Load Balancer resource. ~> Note:  @aws_alb@ is known as @aws_lb@
. The functionality is identical.
-}
data LbResource s = LbResource {
      _access_logs                :: !(TF.Attr s Text)
    {- ^ (Optional) An Access Logs block. Access Logs documented below. -}
    , _enable_deletion_protection :: !(TF.Attr s P.Bool)
    {- ^ (Optional) If true, deletion of the load balancer will be disabled via the AWS API. This will prevent Terraform from deleting the load balancer. Defaults to @false@ . -}
    , _idle_timeout               :: !(TF.Attr s Text)
    {- ^ (Optional) The time in seconds that the connection is allowed to be idle. Default: 60. -}
    , _internal                   :: !(TF.Attr s Text)
    {- ^ (Optional) If true, the LB will be internal. -}
    , _ip_address_type            :: !(TF.Attr s Text)
    {- ^ (Optional) The type of IP addresses used by the subnets for your load balancer. The possible values are @ipv4@ and @dualstack@ -}
    , _load_balancer_type         :: !(TF.Attr s Text)
    {- ^ (Optional) The type of load balancer to create. Possible values are @application@ or @network@ . The default value is @application@ . -}
    , _name                       :: !(TF.Attr s Text)
    {- ^ (Optional) The name of the LB. This name must be unique within your AWS account, can have a maximum of 32 characters, must contain only alphanumeric characters or hyphens, and must not begin or end with a hyphen. If not specified, Terraform will autogenerate a name beginning with @tf-lb@ . -}
    , _name_prefix                :: !(TF.Attr s Text)
    {- ^ (Optional) Creates a unique name beginning with the specified prefix. Conflicts with @name@ . -}
    , _security_groups            :: !(TF.Attr s Text)
    {- ^ (Optional) A list of security group IDs to assign to the LB. Only valid for Load Balancers of type @application@ . -}
    , _subnet_mapping             :: !(TF.Attr s Text)
    {- ^ (Optional) A subnet mapping block as documented below. -}
    , _subnets                    :: !(TF.Attr s Text)
    {- ^ (Optional) A list of subnet IDs to attach to the LB. Subnets cannot be updated for Load Balancers of type @network@ . Changing this value will for load balancers of type @network@ will force a recreation of the resource. -}
    , _tags                       :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    } deriving (Show, Eq)

instance TF.ToHCL (LbResource s) where
    toHCL LbResource{..} = TF.inline $ catMaybes
        [ TF.assign "access_logs" <$> TF.attribute _access_logs
        , TF.assign "enable_deletion_protection" <$> TF.attribute _enable_deletion_protection
        , TF.assign "idle_timeout" <$> TF.attribute _idle_timeout
        , TF.assign "internal" <$> TF.attribute _internal
        , TF.assign "ip_address_type" <$> TF.attribute _ip_address_type
        , TF.assign "load_balancer_type" <$> TF.attribute _load_balancer_type
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "name_prefix" <$> TF.attribute _name_prefix
        , TF.assign "security_groups" <$> TF.attribute _security_groups
        , TF.assign "subnet_mapping" <$> TF.attribute _subnet_mapping
        , TF.assign "subnets" <$> TF.attribute _subnets
        , TF.assign "tags" <$> TF.attribute _tags
        ]

instance P.HasAccessLogs (LbResource s) (TF.Attr s Text) where
    accessLogs =
        lens (_access_logs :: LbResource s -> TF.Attr s Text)
             (\s a -> s { _access_logs = a } :: LbResource s)

instance P.HasEnableDeletionProtection (LbResource s) (TF.Attr s P.Bool) where
    enableDeletionProtection =
        lens (_enable_deletion_protection :: LbResource s -> TF.Attr s P.Bool)
             (\s a -> s { _enable_deletion_protection = a } :: LbResource s)

instance P.HasIdleTimeout (LbResource s) (TF.Attr s Text) where
    idleTimeout =
        lens (_idle_timeout :: LbResource s -> TF.Attr s Text)
             (\s a -> s { _idle_timeout = a } :: LbResource s)

instance P.HasInternal (LbResource s) (TF.Attr s Text) where
    internal =
        lens (_internal :: LbResource s -> TF.Attr s Text)
             (\s a -> s { _internal = a } :: LbResource s)

instance P.HasIpAddressType (LbResource s) (TF.Attr s Text) where
    ipAddressType =
        lens (_ip_address_type :: LbResource s -> TF.Attr s Text)
             (\s a -> s { _ip_address_type = a } :: LbResource s)

instance P.HasLoadBalancerType (LbResource s) (TF.Attr s Text) where
    loadBalancerType =
        lens (_load_balancer_type :: LbResource s -> TF.Attr s Text)
             (\s a -> s { _load_balancer_type = a } :: LbResource s)

instance P.HasName (LbResource s) (TF.Attr s Text) where
    name =
        lens (_name :: LbResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: LbResource s)

instance P.HasNamePrefix (LbResource s) (TF.Attr s Text) where
    namePrefix =
        lens (_name_prefix :: LbResource s -> TF.Attr s Text)
             (\s a -> s { _name_prefix = a } :: LbResource s)

instance P.HasSecurityGroups (LbResource s) (TF.Attr s Text) where
    securityGroups =
        lens (_security_groups :: LbResource s -> TF.Attr s Text)
             (\s a -> s { _security_groups = a } :: LbResource s)

instance P.HasSubnetMapping (LbResource s) (TF.Attr s Text) where
    subnetMapping =
        lens (_subnet_mapping :: LbResource s -> TF.Attr s Text)
             (\s a -> s { _subnet_mapping = a } :: LbResource s)

instance P.HasSubnets (LbResource s) (TF.Attr s Text) where
    subnets =
        lens (_subnets :: LbResource s -> TF.Attr s Text)
             (\s a -> s { _subnets = a } :: LbResource s)

instance P.HasTags (LbResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: LbResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: LbResource s)

instance P.HasComputedAccessLogs (LbResource s) s (TF.Attr s Text) where
    computedAccessLogs =
        (_access_logs :: LbResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedArn (LbResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedArnSuffix (LbResource s) s (TF.Attr s Text) where
    computedArnSuffix x = TF.compute (TF.refKey x) "arn_suffix"

instance P.HasComputedCanonicalHostedZoneId (LbResource s) s (TF.Attr s Text) where
    computedCanonicalHostedZoneId x = TF.compute (TF.refKey x) "canonical_hosted_zone_id"

instance P.HasComputedDnsName (LbResource s) s (TF.Attr s Text) where
    computedDnsName x = TF.compute (TF.refKey x) "dns_name"

instance P.HasComputedEnableDeletionProtection (LbResource s) s (TF.Attr s P.Bool) where
    computedEnableDeletionProtection =
        (_enable_deletion_protection :: LbResource s -> TF.Attr s P.Bool)
            . TF.refValue

instance P.HasComputedId (LbResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedIdleTimeout (LbResource s) s (TF.Attr s Text) where
    computedIdleTimeout =
        (_idle_timeout :: LbResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedInternal (LbResource s) s (TF.Attr s Text) where
    computedInternal =
        (_internal :: LbResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedIpAddressType (LbResource s) s (TF.Attr s Text) where
    computedIpAddressType =
        (_ip_address_type :: LbResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedLoadBalancerType (LbResource s) s (TF.Attr s Text) where
    computedLoadBalancerType =
        (_load_balancer_type :: LbResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (LbResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: LbResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedNamePrefix (LbResource s) s (TF.Attr s Text) where
    computedNamePrefix =
        (_name_prefix :: LbResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSecurityGroups (LbResource s) s (TF.Attr s Text) where
    computedSecurityGroups =
        (_security_groups :: LbResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSubnetMapping (LbResource s) s (TF.Attr s Text) where
    computedSubnetMapping =
        (_subnet_mapping :: LbResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSubnets (LbResource s) s (TF.Attr s Text) where
    computedSubnets =
        (_subnets :: LbResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (LbResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: LbResource s -> TF.Attr s P.Tags)
            . TF.refValue

instance P.HasComputedZoneId (LbResource s) s (TF.Attr s Text) where
    computedZoneId x = TF.compute (TF.refKey x) "zone_id"

lbResource :: TF.Schema TF.Resource P.AWS (LbResource s)
lbResource =
    TF.newResource "aws_lb" $
        LbResource {
              _access_logs = TF.Nil
            , _enable_deletion_protection = TF.Nil
            , _idle_timeout = TF.Nil
            , _internal = TF.Nil
            , _ip_address_type = TF.Nil
            , _load_balancer_type = TF.Nil
            , _name = TF.Nil
            , _name_prefix = TF.Nil
            , _security_groups = TF.Nil
            , _subnet_mapping = TF.Nil
            , _subnets = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_lb_ssl_negotiation_policy@ AWS resource.

Provides a load balancer SSL negotiation policy, which allows an ELB to
control the ciphers and protocols that are supported during SSL negotiations
between a client and a load balancer.
-}
data LbSslNegotiationPolicyResource s = LbSslNegotiationPolicyResource {
      _attribute     :: !(TF.Attr s Text)
    {- ^ (Optional) An SSL Negotiation policy attribute. Each has two properties: -}
    , _lb_port       :: !(TF.Attr s P.Word16)
    {- ^ (Required) The load balancer port to which the policy should be applied. This must be an active listener on the load balancer. -}
    , _load_balancer :: !(TF.Attr s Text)
    {- ^ (Required) The load balancer to which the policy should be attached. -}
    , _name          :: !(TF.Attr s Text)
    {- ^ (Required) The name of the SSL negotiation policy. -}
    } deriving (Show, Eq)

instance TF.ToHCL (LbSslNegotiationPolicyResource s) where
    toHCL LbSslNegotiationPolicyResource{..} = TF.inline $ catMaybes
        [ TF.assign "attribute" <$> TF.attribute _attribute
        , TF.assign "lb_port" <$> TF.attribute _lb_port
        , TF.assign "load_balancer" <$> TF.attribute _load_balancer
        , TF.assign "name" <$> TF.attribute _name
        ]

instance P.HasAttribute (LbSslNegotiationPolicyResource s) (TF.Attr s Text) where
    attribute =
        lens (_attribute :: LbSslNegotiationPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _attribute = a } :: LbSslNegotiationPolicyResource s)

instance P.HasLbPort (LbSslNegotiationPolicyResource s) (TF.Attr s P.Word16) where
    lbPort =
        lens (_lb_port :: LbSslNegotiationPolicyResource s -> TF.Attr s P.Word16)
             (\s a -> s { _lb_port = a } :: LbSslNegotiationPolicyResource s)

instance P.HasLoadBalancer (LbSslNegotiationPolicyResource s) (TF.Attr s Text) where
    loadBalancer =
        lens (_load_balancer :: LbSslNegotiationPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _load_balancer = a } :: LbSslNegotiationPolicyResource s)

instance P.HasName (LbSslNegotiationPolicyResource s) (TF.Attr s Text) where
    name =
        lens (_name :: LbSslNegotiationPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: LbSslNegotiationPolicyResource s)

instance P.HasComputedAttribute (LbSslNegotiationPolicyResource s) s (TF.Attr s Text) where
    computedAttribute x = TF.compute (TF.refKey x) "attribute"

instance P.HasComputedId (LbSslNegotiationPolicyResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedLbPort (LbSslNegotiationPolicyResource s) s (TF.Attr s P.Word16) where
    computedLbPort x = TF.compute (TF.refKey x) "lb_port"

instance P.HasComputedLoadBalancer (LbSslNegotiationPolicyResource s) s (TF.Attr s Text) where
    computedLoadBalancer x = TF.compute (TF.refKey x) "load_balancer"

instance P.HasComputedName (LbSslNegotiationPolicyResource s) s (TF.Attr s Text) where
    computedName x = TF.compute (TF.refKey x) "name"

lbSslNegotiationPolicyResource :: TF.Schema TF.Resource P.AWS (LbSslNegotiationPolicyResource s)
lbSslNegotiationPolicyResource =
    TF.newResource "aws_lb_ssl_negotiation_policy" $
        LbSslNegotiationPolicyResource {
              _attribute = TF.Nil
            , _lb_port = TF.Nil
            , _load_balancer = TF.Nil
            , _name = TF.Nil
            }

{- | The @aws_lb_target_group_attachment@ AWS resource.

Provides the ability to register instances and containers with a LB target
group ~> Note:  @aws_alb_target_group_attachment@ is known as
@aws_lb_target_group_attachment@ . The functionality is identical.
-}
data LbTargetGroupAttachmentResource s = LbTargetGroupAttachmentResource {
      _availability_zone :: !(TF.Attr s P.Zone)
    {- ^ (Optional) The Availability Zone where the IP address of the target is to be registered. -}
    , _port              :: !(TF.Attr s Text)
    {- ^ (Optional) The port on which targets receive traffic. -}
    , _target_group_arn  :: !(TF.Attr s Text)
    {- ^ (Required) The ARN of the target group with which to register targets -}
    , _target_id         :: !(TF.Attr s Text)
    {- ^ (Required) The ID of the target. This is the Instance ID for an instance, or the container ID for an ECS container. If the target type is ip, specify an IP address. -}
    } deriving (Show, Eq)

instance TF.ToHCL (LbTargetGroupAttachmentResource s) where
    toHCL LbTargetGroupAttachmentResource{..} = TF.inline $ catMaybes
        [ TF.assign "availability_zone" <$> TF.attribute _availability_zone
        , TF.assign "port" <$> TF.attribute _port
        , TF.assign "target_group_arn" <$> TF.attribute _target_group_arn
        , TF.assign "target_id" <$> TF.attribute _target_id
        ]

instance P.HasAvailabilityZone (LbTargetGroupAttachmentResource s) (TF.Attr s P.Zone) where
    availabilityZone =
        lens (_availability_zone :: LbTargetGroupAttachmentResource s -> TF.Attr s P.Zone)
             (\s a -> s { _availability_zone = a } :: LbTargetGroupAttachmentResource s)

instance P.HasPort (LbTargetGroupAttachmentResource s) (TF.Attr s Text) where
    port =
        lens (_port :: LbTargetGroupAttachmentResource s -> TF.Attr s Text)
             (\s a -> s { _port = a } :: LbTargetGroupAttachmentResource s)

instance P.HasTargetGroupArn (LbTargetGroupAttachmentResource s) (TF.Attr s Text) where
    targetGroupArn =
        lens (_target_group_arn :: LbTargetGroupAttachmentResource s -> TF.Attr s Text)
             (\s a -> s { _target_group_arn = a } :: LbTargetGroupAttachmentResource s)

instance P.HasTargetId (LbTargetGroupAttachmentResource s) (TF.Attr s Text) where
    targetId =
        lens (_target_id :: LbTargetGroupAttachmentResource s -> TF.Attr s Text)
             (\s a -> s { _target_id = a } :: LbTargetGroupAttachmentResource s)

instance P.HasComputedAvailabilityZone (LbTargetGroupAttachmentResource s) s (TF.Attr s P.Zone) where
    computedAvailabilityZone =
        (_availability_zone :: LbTargetGroupAttachmentResource s -> TF.Attr s P.Zone)
            . TF.refValue

instance P.HasComputedId (LbTargetGroupAttachmentResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedPort (LbTargetGroupAttachmentResource s) s (TF.Attr s Text) where
    computedPort =
        (_port :: LbTargetGroupAttachmentResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTargetGroupArn (LbTargetGroupAttachmentResource s) s (TF.Attr s Text) where
    computedTargetGroupArn =
        (_target_group_arn :: LbTargetGroupAttachmentResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTargetId (LbTargetGroupAttachmentResource s) s (TF.Attr s Text) where
    computedTargetId =
        (_target_id :: LbTargetGroupAttachmentResource s -> TF.Attr s Text)
            . TF.refValue

lbTargetGroupAttachmentResource :: TF.Schema TF.Resource P.AWS (LbTargetGroupAttachmentResource s)
lbTargetGroupAttachmentResource =
    TF.newResource "aws_lb_target_group_attachment" $
        LbTargetGroupAttachmentResource {
              _availability_zone = TF.Nil
            , _port = TF.Nil
            , _target_group_arn = TF.Nil
            , _target_id = TF.Nil
            }

{- | The @aws_lb_target_group@ AWS resource.

Provides a Target Group resource for use with Load Balancer resources. ~>
Note:  @aws_alb_target_group@ is known as @aws_lb_target_group@ . The
functionality is identical.
-}
data LbTargetGroupResource s = LbTargetGroupResource {
      _deregistration_delay :: !(TF.Attr s Text)
    {- ^ (Optional) The amount time for Elastic Load Balancing to wait before changing the state of a deregistering target from draining to unused. The range is 0-3600 seconds. The default value is 300 seconds. -}
    , _health_check         :: !(TF.Attr s Text)
    {- ^ (Optional) A Health Check block. Health Check blocks are documented below. -}
    , _name                 :: !(TF.Attr s Text)
    {- ^ (Optional, Forces new resource) The name of the target group. If omitted, Terraform will assign a random, unique name. -}
    , _name_prefix          :: !(TF.Attr s Text)
    {- ^ (Optional, Forces new resource) Creates a unique name beginning with the specified prefix. Conflicts with @name@ . Cannot be longer than 6 characters. -}
    , _port                 :: !(TF.Attr s Text)
    {- ^ (Required) The port on which targets receive traffic, unless overridden when registering a specific target. -}
    , _protocol             :: !(TF.Attr s Text)
    {- ^ (Required) The protocol to use for routing traffic to the targets. -}
    , _stickiness           :: !(TF.Attr s Text)
    {- ^ (Optional) A Stickiness block. Stickiness blocks are documented below. @stickiness@ is only valid if used with Load Balancers of type @Application@ -}
    , _tags                 :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    , _target_type          :: !(TF.Attr s Text)
    {- ^ (Optional) The type of target that you must specify when registering targets with this target group. The possible values are @instance@ (targets are specified by instance ID) or @ip@ (targets are specified by IP address). The default is @instance@ . Note that you can't specify targets for a target group using both instance IDs and IP addresses. If the target type is @ip@ , specify IP addresses from the subnets of the virtual private cloud (VPC) for the target group, the RFC 1918 range (10.0.0.0/8, 172.16.0.0/12, and 192.168.0.0/16), and the RFC 6598 range (100.64.0.0/10). You can't specify publicly routable IP addresses. -}
    , _vpc_id               :: !(TF.Attr s Text)
    {- ^ (Required) The identifier of the VPC in which to create the target group. -}
    } deriving (Show, Eq)

instance TF.ToHCL (LbTargetGroupResource s) where
    toHCL LbTargetGroupResource{..} = TF.inline $ catMaybes
        [ TF.assign "deregistration_delay" <$> TF.attribute _deregistration_delay
        , TF.assign "health_check" <$> TF.attribute _health_check
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "name_prefix" <$> TF.attribute _name_prefix
        , TF.assign "port" <$> TF.attribute _port
        , TF.assign "protocol" <$> TF.attribute _protocol
        , TF.assign "stickiness" <$> TF.attribute _stickiness
        , TF.assign "tags" <$> TF.attribute _tags
        , TF.assign "target_type" <$> TF.attribute _target_type
        , TF.assign "vpc_id" <$> TF.attribute _vpc_id
        ]

instance P.HasDeregistrationDelay (LbTargetGroupResource s) (TF.Attr s Text) where
    deregistrationDelay =
        lens (_deregistration_delay :: LbTargetGroupResource s -> TF.Attr s Text)
             (\s a -> s { _deregistration_delay = a } :: LbTargetGroupResource s)

instance P.HasHealthCheck (LbTargetGroupResource s) (TF.Attr s Text) where
    healthCheck =
        lens (_health_check :: LbTargetGroupResource s -> TF.Attr s Text)
             (\s a -> s { _health_check = a } :: LbTargetGroupResource s)

instance P.HasName (LbTargetGroupResource s) (TF.Attr s Text) where
    name =
        lens (_name :: LbTargetGroupResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: LbTargetGroupResource s)

instance P.HasNamePrefix (LbTargetGroupResource s) (TF.Attr s Text) where
    namePrefix =
        lens (_name_prefix :: LbTargetGroupResource s -> TF.Attr s Text)
             (\s a -> s { _name_prefix = a } :: LbTargetGroupResource s)

instance P.HasPort (LbTargetGroupResource s) (TF.Attr s Text) where
    port =
        lens (_port :: LbTargetGroupResource s -> TF.Attr s Text)
             (\s a -> s { _port = a } :: LbTargetGroupResource s)

instance P.HasProtocol (LbTargetGroupResource s) (TF.Attr s Text) where
    protocol =
        lens (_protocol :: LbTargetGroupResource s -> TF.Attr s Text)
             (\s a -> s { _protocol = a } :: LbTargetGroupResource s)

instance P.HasStickiness (LbTargetGroupResource s) (TF.Attr s Text) where
    stickiness =
        lens (_stickiness :: LbTargetGroupResource s -> TF.Attr s Text)
             (\s a -> s { _stickiness = a } :: LbTargetGroupResource s)

instance P.HasTags (LbTargetGroupResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: LbTargetGroupResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: LbTargetGroupResource s)

instance P.HasTargetType (LbTargetGroupResource s) (TF.Attr s Text) where
    targetType =
        lens (_target_type :: LbTargetGroupResource s -> TF.Attr s Text)
             (\s a -> s { _target_type = a } :: LbTargetGroupResource s)

instance P.HasVpcId (LbTargetGroupResource s) (TF.Attr s Text) where
    vpcId =
        lens (_vpc_id :: LbTargetGroupResource s -> TF.Attr s Text)
             (\s a -> s { _vpc_id = a } :: LbTargetGroupResource s)

instance P.HasComputedArn (LbTargetGroupResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedArnSuffix (LbTargetGroupResource s) s (TF.Attr s Text) where
    computedArnSuffix x = TF.compute (TF.refKey x) "arn_suffix"

instance P.HasComputedDeregistrationDelay (LbTargetGroupResource s) s (TF.Attr s Text) where
    computedDeregistrationDelay =
        (_deregistration_delay :: LbTargetGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedHealthCheck (LbTargetGroupResource s) s (TF.Attr s Text) where
    computedHealthCheck =
        (_health_check :: LbTargetGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (LbTargetGroupResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (LbTargetGroupResource s) s (TF.Attr s Text) where
    computedName x = TF.compute (TF.refKey x) "name"

instance P.HasComputedNamePrefix (LbTargetGroupResource s) s (TF.Attr s Text) where
    computedNamePrefix =
        (_name_prefix :: LbTargetGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPort (LbTargetGroupResource s) s (TF.Attr s Text) where
    computedPort =
        (_port :: LbTargetGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedProtocol (LbTargetGroupResource s) s (TF.Attr s Text) where
    computedProtocol =
        (_protocol :: LbTargetGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedStickiness (LbTargetGroupResource s) s (TF.Attr s Text) where
    computedStickiness =
        (_stickiness :: LbTargetGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (LbTargetGroupResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: LbTargetGroupResource s -> TF.Attr s P.Tags)
            . TF.refValue

instance P.HasComputedTargetType (LbTargetGroupResource s) s (TF.Attr s Text) where
    computedTargetType =
        (_target_type :: LbTargetGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedVpcId (LbTargetGroupResource s) s (TF.Attr s Text) where
    computedVpcId =
        (_vpc_id :: LbTargetGroupResource s -> TF.Attr s Text)
            . TF.refValue

lbTargetGroupResource :: TF.Schema TF.Resource P.AWS (LbTargetGroupResource s)
lbTargetGroupResource =
    TF.newResource "aws_lb_target_group" $
        LbTargetGroupResource {
              _deregistration_delay = TF.Nil
            , _health_check = TF.Nil
            , _name = TF.Nil
            , _name_prefix = TF.Nil
            , _port = TF.Nil
            , _protocol = TF.Nil
            , _stickiness = TF.Nil
            , _tags = TF.Nil
            , _target_type = TF.Nil
            , _vpc_id = TF.Nil
            }

{- | The @aws_lightsail_domain@ AWS resource.

Creates a domain resource for the specified domain (e.g., example.com). You
cannot register a new domain name using Lightsail. You must register a
domain name using Amazon Route 53 or another domain name registrar. If you
have already registered your domain, you can enter its name in this
parameter to manage the DNS records for that domain. ~> Note: Lightsail is
currently only supported in a limited number of AWS Regions, please see
<https://lightsail.aws.amazon.com/ls/docs/overview/article/understanding-regions-and-availability-zones-in-amazon-lightsail>
for more details
-}
data LightsailDomainResource s = LightsailDomainResource {
      _domain_name :: !(TF.Attr s Text)
    {- ^ (Required) The name of the Lightsail domain to manage -}
    } deriving (Show, Eq)

instance TF.ToHCL (LightsailDomainResource s) where
    toHCL LightsailDomainResource{..} = TF.inline $ catMaybes
        [ TF.assign "domain_name" <$> TF.attribute _domain_name
        ]

instance P.HasDomainName (LightsailDomainResource s) (TF.Attr s Text) where
    domainName =
        lens (_domain_name :: LightsailDomainResource s -> TF.Attr s Text)
             (\s a -> s { _domain_name = a } :: LightsailDomainResource s)

instance P.HasComputedArn (LightsailDomainResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedDomainName (LightsailDomainResource s) s (TF.Attr s Text) where
    computedDomainName =
        (_domain_name :: LightsailDomainResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (LightsailDomainResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

lightsailDomainResource :: TF.Schema TF.Resource P.AWS (LightsailDomainResource s)
lightsailDomainResource =
    TF.newResource "aws_lightsail_domain" $
        LightsailDomainResource {
              _domain_name = TF.Nil
            }

{- | The @aws_lightsail_instance@ AWS resource.

Provides a Lightsail Instance. Amazon Lightsail is a service to provide easy
virtual private servers with custom software already setup. See
<https://lightsail.aws.amazon.com/ls/docs/getting-started/article/what-is-amazon-lightsail>
for more information. ~> Note: Lightsail is currently only supported in a
limited number of AWS Regions, please see
<https://lightsail.aws.amazon.com/ls/docs/overview/article/understanding-regions-and-availability-zones-in-amazon-lightsail>
for more details
-}
data LightsailInstanceResource s = LightsailInstanceResource {
      _availability_zone :: !(TF.Attr s P.Zone)
    {- ^ (Required) The Availability Zone in which to create your instance. At this time, must be in @us-east-1@ , @us-east-2@ , @us-west-2@ , @eu-west-1@ , @eu-west-2@ , @eu-central-1@ , @ap-southeast-1@ , @ap-southeast-2@ , @ap-northeast-1@ , @ap-south-1@ regions -}
    , _blueprint_id      :: !(TF.Attr s Text)
    {- ^ (Required) The ID for a virtual private server image (see list below) -}
    , _bundle_id         :: !(TF.Attr s Text)
    {- ^ (Required) The bundle of specification information (see list below) -}
    , _key_pair_name     :: !(TF.Attr s Text)
    {- ^ (Required) The name of your key pair. Created in the Lightsail console (cannot use @aws_key_pair@ at this time) -}
    , _name              :: !(TF.Attr s Text)
    {- ^ (Required) The name of the Lightsail Instance -}
    , _user_data         :: !(TF.Attr s Text)
    {- ^ (Optional) launch script to configure server with additional user data -}
    } deriving (Show, Eq)

instance TF.ToHCL (LightsailInstanceResource s) where
    toHCL LightsailInstanceResource{..} = TF.inline $ catMaybes
        [ TF.assign "availability_zone" <$> TF.attribute _availability_zone
        , TF.assign "blueprint_id" <$> TF.attribute _blueprint_id
        , TF.assign "bundle_id" <$> TF.attribute _bundle_id
        , TF.assign "key_pair_name" <$> TF.attribute _key_pair_name
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "user_data" <$> TF.attribute _user_data
        ]

instance P.HasAvailabilityZone (LightsailInstanceResource s) (TF.Attr s P.Zone) where
    availabilityZone =
        lens (_availability_zone :: LightsailInstanceResource s -> TF.Attr s P.Zone)
             (\s a -> s { _availability_zone = a } :: LightsailInstanceResource s)

instance P.HasBlueprintId (LightsailInstanceResource s) (TF.Attr s Text) where
    blueprintId =
        lens (_blueprint_id :: LightsailInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _blueprint_id = a } :: LightsailInstanceResource s)

instance P.HasBundleId (LightsailInstanceResource s) (TF.Attr s Text) where
    bundleId =
        lens (_bundle_id :: LightsailInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _bundle_id = a } :: LightsailInstanceResource s)

instance P.HasKeyPairName (LightsailInstanceResource s) (TF.Attr s Text) where
    keyPairName =
        lens (_key_pair_name :: LightsailInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _key_pair_name = a } :: LightsailInstanceResource s)

instance P.HasName (LightsailInstanceResource s) (TF.Attr s Text) where
    name =
        lens (_name :: LightsailInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: LightsailInstanceResource s)

instance P.HasUserData (LightsailInstanceResource s) (TF.Attr s Text) where
    userData =
        lens (_user_data :: LightsailInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _user_data = a } :: LightsailInstanceResource s)

instance P.HasComputedAvailabilityZone (LightsailInstanceResource s) s (TF.Attr s P.Zone) where
    computedAvailabilityZone =
        (_availability_zone :: LightsailInstanceResource s -> TF.Attr s P.Zone)
            . TF.refValue

instance P.HasComputedBlueprintId (LightsailInstanceResource s) s (TF.Attr s Text) where
    computedBlueprintId =
        (_blueprint_id :: LightsailInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedBundleId (LightsailInstanceResource s) s (TF.Attr s Text) where
    computedBundleId =
        (_bundle_id :: LightsailInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedKeyPairName (LightsailInstanceResource s) s (TF.Attr s Text) where
    computedKeyPairName =
        (_key_pair_name :: LightsailInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (LightsailInstanceResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: LightsailInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedUserData (LightsailInstanceResource s) s (TF.Attr s Text) where
    computedUserData =
        (_user_data :: LightsailInstanceResource s -> TF.Attr s Text)
            . TF.refValue

lightsailInstanceResource :: TF.Schema TF.Resource P.AWS (LightsailInstanceResource s)
lightsailInstanceResource =
    TF.newResource "aws_lightsail_instance" $
        LightsailInstanceResource {
              _availability_zone = TF.Nil
            , _blueprint_id = TF.Nil
            , _bundle_id = TF.Nil
            , _key_pair_name = TF.Nil
            , _name = TF.Nil
            , _user_data = TF.Nil
            }

{- | The @aws_lightsail_key_pair@ AWS resource.

Provides a Lightsail Key Pair, for use with Lightsail Instances. These key
pairs are seperate from EC2 Key Pairs, and must be created or imported for
use with Lightsail. ~> Note: Lightsail is currently only supported in a
limited number of AWS Regions, please see
<https://lightsail.aws.amazon.com/ls/docs/overview/article/understanding-regions-and-availability-zones-in-amazon-lightsail>
for more details
-}
data LightsailKeyPairResource s = LightsailKeyPairResource {
      _name       :: !(TF.Attr s Text)
    {- ^ (Optional) The name of the Lightsail Key Pair. If omitted, a unique name will be generated by Terraform -}
    , _pgp_key    :: !(TF.Attr s Text)
    {- ^ (Optional) An optional PGP key to encrypt the resulting private key material. Only used when creating a new key pair -}
    , _public_key :: !(TF.Attr s Text)
    {- ^ (Required) The public key material. This public key will be imported into Lightsail -}
    } deriving (Show, Eq)

instance TF.ToHCL (LightsailKeyPairResource s) where
    toHCL LightsailKeyPairResource{..} = TF.inline $ catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "pgp_key" <$> TF.attribute _pgp_key
        , TF.assign "public_key" <$> TF.attribute _public_key
        ]

instance P.HasName (LightsailKeyPairResource s) (TF.Attr s Text) where
    name =
        lens (_name :: LightsailKeyPairResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: LightsailKeyPairResource s)

instance P.HasPgpKey (LightsailKeyPairResource s) (TF.Attr s Text) where
    pgpKey =
        lens (_pgp_key :: LightsailKeyPairResource s -> TF.Attr s Text)
             (\s a -> s { _pgp_key = a } :: LightsailKeyPairResource s)

instance P.HasPublicKey (LightsailKeyPairResource s) (TF.Attr s Text) where
    publicKey =
        lens (_public_key :: LightsailKeyPairResource s -> TF.Attr s Text)
             (\s a -> s { _public_key = a } :: LightsailKeyPairResource s)

instance P.HasComputedArn (LightsailKeyPairResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedEncryptedFingerprint (LightsailKeyPairResource s) s (TF.Attr s Text) where
    computedEncryptedFingerprint x = TF.compute (TF.refKey x) "encrypted_fingerprint"

instance P.HasComputedEncryptedPrivateKey (LightsailKeyPairResource s) s (TF.Attr s Text) where
    computedEncryptedPrivateKey x = TF.compute (TF.refKey x) "encrypted_private_key"

instance P.HasComputedFingerprint (LightsailKeyPairResource s) s (TF.Attr s Text) where
    computedFingerprint x = TF.compute (TF.refKey x) "fingerprint"

instance P.HasComputedId (LightsailKeyPairResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (LightsailKeyPairResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: LightsailKeyPairResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPgpKey (LightsailKeyPairResource s) s (TF.Attr s Text) where
    computedPgpKey =
        (_pgp_key :: LightsailKeyPairResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPrivateKey (LightsailKeyPairResource s) s (TF.Attr s Text) where
    computedPrivateKey x = TF.compute (TF.refKey x) "private_key"

instance P.HasComputedPublicKey (LightsailKeyPairResource s) s (TF.Attr s Text) where
    computedPublicKey x = TF.compute (TF.refKey x) "public_key"

lightsailKeyPairResource :: TF.Schema TF.Resource P.AWS (LightsailKeyPairResource s)
lightsailKeyPairResource =
    TF.newResource "aws_lightsail_key_pair" $
        LightsailKeyPairResource {
              _name = TF.Nil
            , _pgp_key = TF.Nil
            , _public_key = TF.Nil
            }

{- | The @aws_lightsail_static_ip_attachment@ AWS resource.

Provides a static IP address attachment - relationship between a Lightsail
static IP & Lightsail instance. ~> Note: Lightsail is currently only
supported in a limited number of AWS Regions, please see
<https://lightsail.aws.amazon.com/ls/docs/overview/article/understanding-regions-and-availability-zones-in-amazon-lightsail>
for more details
-}
data LightsailStaticIpAttachmentResource s = LightsailStaticIpAttachmentResource {
      _instance_name  :: !(TF.Attr s Text)
    {- ^ (Required) The name of the Lightsail instance to attach the IP to -}
    , _static_ip_name :: !(TF.Attr s Text)
    {- ^ (Required) The name of the allocated static IP -}
    } deriving (Show, Eq)

instance TF.ToHCL (LightsailStaticIpAttachmentResource s) where
    toHCL LightsailStaticIpAttachmentResource{..} = TF.inline $ catMaybes
        [ TF.assign "instance_name" <$> TF.attribute _instance_name
        , TF.assign "static_ip_name" <$> TF.attribute _static_ip_name
        ]

instance P.HasInstanceName (LightsailStaticIpAttachmentResource s) (TF.Attr s Text) where
    instanceName =
        lens (_instance_name :: LightsailStaticIpAttachmentResource s -> TF.Attr s Text)
             (\s a -> s { _instance_name = a } :: LightsailStaticIpAttachmentResource s)

instance P.HasStaticIpName (LightsailStaticIpAttachmentResource s) (TF.Attr s Text) where
    staticIpName =
        lens (_static_ip_name :: LightsailStaticIpAttachmentResource s -> TF.Attr s Text)
             (\s a -> s { _static_ip_name = a } :: LightsailStaticIpAttachmentResource s)

instance P.HasComputedArn (LightsailStaticIpAttachmentResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedInstanceName (LightsailStaticIpAttachmentResource s) s (TF.Attr s Text) where
    computedInstanceName =
        (_instance_name :: LightsailStaticIpAttachmentResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedIpAddress (LightsailStaticIpAttachmentResource s) s (TF.Attr s Text) where
    computedIpAddress x = TF.compute (TF.refKey x) "ip_address"

instance P.HasComputedStaticIpName (LightsailStaticIpAttachmentResource s) s (TF.Attr s Text) where
    computedStaticIpName =
        (_static_ip_name :: LightsailStaticIpAttachmentResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSupportCode (LightsailStaticIpAttachmentResource s) s (TF.Attr s Text) where
    computedSupportCode x = TF.compute (TF.refKey x) "support_code"

lightsailStaticIpAttachmentResource :: TF.Schema TF.Resource P.AWS (LightsailStaticIpAttachmentResource s)
lightsailStaticIpAttachmentResource =
    TF.newResource "aws_lightsail_static_ip_attachment" $
        LightsailStaticIpAttachmentResource {
              _instance_name = TF.Nil
            , _static_ip_name = TF.Nil
            }

{- | The @aws_lightsail_static_ip@ AWS resource.

Allocates a static IP address. ~> Note: Lightsail is currently only
supported in a limited number of AWS Regions, please see
<https://lightsail.aws.amazon.com/ls/docs/overview/article/understanding-regions-and-availability-zones-in-amazon-lightsail>
for more details
-}
data LightsailStaticIpResource s = LightsailStaticIpResource {
      _name :: !(TF.Attr s Text)
    {- ^ (Required) The name for the allocated static IP -}
    } deriving (Show, Eq)

instance TF.ToHCL (LightsailStaticIpResource s) where
    toHCL LightsailStaticIpResource{..} = TF.inline $ catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        ]

instance P.HasName (LightsailStaticIpResource s) (TF.Attr s Text) where
    name =
        lens (_name :: LightsailStaticIpResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: LightsailStaticIpResource s)

instance P.HasComputedArn (LightsailStaticIpResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedIpAddress (LightsailStaticIpResource s) s (TF.Attr s Text) where
    computedIpAddress x = TF.compute (TF.refKey x) "ip_address"

instance P.HasComputedName (LightsailStaticIpResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: LightsailStaticIpResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSupportCode (LightsailStaticIpResource s) s (TF.Attr s Text) where
    computedSupportCode x = TF.compute (TF.refKey x) "support_code"

lightsailStaticIpResource :: TF.Schema TF.Resource P.AWS (LightsailStaticIpResource s)
lightsailStaticIpResource =
    TF.newResource "aws_lightsail_static_ip" $
        LightsailStaticIpResource {
              _name = TF.Nil
            }

{- | The @aws_main_route_table_association@ AWS resource.

Provides a resource for managing the main routing table of a VPC.
-}
data MainRouteTableAssociationResource s = MainRouteTableAssociationResource {
      _route_table_id :: !(TF.Attr s Text)
    {- ^ (Required) The ID of the Route Table to set as the new main route table for the target VPC -}
    , _vpc_id         :: !(TF.Attr s Text)
    {- ^ (Required) The ID of the VPC whose main route table should be set -}
    } deriving (Show, Eq)

instance TF.ToHCL (MainRouteTableAssociationResource s) where
    toHCL MainRouteTableAssociationResource{..} = TF.inline $ catMaybes
        [ TF.assign "route_table_id" <$> TF.attribute _route_table_id
        , TF.assign "vpc_id" <$> TF.attribute _vpc_id
        ]

instance P.HasRouteTableId (MainRouteTableAssociationResource s) (TF.Attr s Text) where
    routeTableId =
        lens (_route_table_id :: MainRouteTableAssociationResource s -> TF.Attr s Text)
             (\s a -> s { _route_table_id = a } :: MainRouteTableAssociationResource s)

instance P.HasVpcId (MainRouteTableAssociationResource s) (TF.Attr s Text) where
    vpcId =
        lens (_vpc_id :: MainRouteTableAssociationResource s -> TF.Attr s Text)
             (\s a -> s { _vpc_id = a } :: MainRouteTableAssociationResource s)

instance P.HasComputedId (MainRouteTableAssociationResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedOriginalRouteTableId (MainRouteTableAssociationResource s) s (TF.Attr s Text) where
    computedOriginalRouteTableId x = TF.compute (TF.refKey x) "original_route_table_id"

instance P.HasComputedRouteTableId (MainRouteTableAssociationResource s) s (TF.Attr s Text) where
    computedRouteTableId =
        (_route_table_id :: MainRouteTableAssociationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedVpcId (MainRouteTableAssociationResource s) s (TF.Attr s Text) where
    computedVpcId =
        (_vpc_id :: MainRouteTableAssociationResource s -> TF.Attr s Text)
            . TF.refValue

mainRouteTableAssociationResource :: TF.Schema TF.Resource P.AWS (MainRouteTableAssociationResource s)
mainRouteTableAssociationResource =
    TF.newResource "aws_main_route_table_association" $
        MainRouteTableAssociationResource {
              _route_table_id = TF.Nil
            , _vpc_id = TF.Nil
            }

{- | The @aws_media_store_container@ AWS resource.

Provides a MediaStore Container.
-}
data MediaStoreContainerResource s = MediaStoreContainerResource {
      _name :: !(TF.Attr s Text)
    {- ^ (Required) The name of the container. Must contain alphanumeric characters or underscores. -}
    } deriving (Show, Eq)

instance TF.ToHCL (MediaStoreContainerResource s) where
    toHCL MediaStoreContainerResource{..} = TF.inline $ catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        ]

instance P.HasName (MediaStoreContainerResource s) (TF.Attr s Text) where
    name =
        lens (_name :: MediaStoreContainerResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: MediaStoreContainerResource s)

instance P.HasComputedArn (MediaStoreContainerResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedEndpoint (MediaStoreContainerResource s) s (TF.Attr s Text) where
    computedEndpoint x = TF.compute (TF.refKey x) "endpoint"

instance P.HasComputedName (MediaStoreContainerResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: MediaStoreContainerResource s -> TF.Attr s Text)
            . TF.refValue

mediaStoreContainerResource :: TF.Schema TF.Resource P.AWS (MediaStoreContainerResource s)
mediaStoreContainerResource =
    TF.newResource "aws_media_store_container" $
        MediaStoreContainerResource {
              _name = TF.Nil
            }

{- | The @aws_mq_broker@ AWS resource.

Provides an MQ Broker Resource. This resources also manages users for the
broker. For more information on Amazon MQ, see
<https://docs.aws.amazon.com/amazon-mq/latest/developer-guide/welcome.html>
. Changes to an MQ Broker can occur when you change a parameter, such as
@configuration@ or @user@ , and are reflected in the next maintenance
window. Because of this, Terraform may report a difference in its planning
phase because a modification has not yet taken place. You can use the
@apply_immediately@ flag to instruct the service to apply the change
immediately (see documentation below). ~> Note: using @apply_immediately@
can result in a brief downtime as the broker reboots. ~> Note: All arguments
including the username and password will be stored in the raw state as
plain-text. </docs/state/sensitive-data.html> .
-}
data MqBrokerResource s = MqBrokerResource {
      _apply_immediately             :: !(TF.Attr s Text)
    {- ^ (Optional) Specifies whether any broker modifications are applied immediately, or during the next maintenance window. Default is @false@ . -}
    , _auto_minor_version_upgrade    :: !(TF.Attr s Text)
    {- ^ (Optional) Enables automatic upgrades to new minor versions for brokers, as Apache releases the versions. -}
    , _broker_name                   :: !(TF.Attr s Text)
    {- ^ (Required) The name of the broker. -}
    , _configuration                 :: !(TF.Attr s Text)
    {- ^ (Optional) Configuration of the broker. See below. -}
    , _deployment_mode               :: !(TF.Attr s Text)
    {- ^ (Optional) The deployment mode of the broker. Supported: @SINGLE_INSTANCE@ and @ACTIVE_STANDBY_MULTI_AZ@ . Defaults to @SINGLE_INSTANCE@ . -}
    , _engine_type                   :: !(TF.Attr s Text)
    {- ^ (Required) The type of broker engine. Currently, Amazon MQ supports only @ActiveMQ@ . -}
    , _engine_version                :: !(TF.Attr s Text)
    {- ^ (Required) The version of the broker engine. Currently, Amazon MQ supports only @5.15.0@ . -}
    , _host_instance_type            :: !(TF.Attr s Text)
    {- ^ (Required) The broker's instance type. e.g. @mq.t2.micro@ or @mq.m4.large@ -}
    , _maintenance_window_start_time :: !(TF.Attr s Text)
    {- ^ (Optional) Maintenance window start time. See below. -}
    , _publicly_accessible           :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to enable connections from applications outside of the VPC that hosts the broker's subnets. -}
    , _security_groups               :: !(TF.Attr s Text)
    {- ^ (Required) The list of security group IDs assigned to the broker. -}
    , _subnet_ids                    :: !(TF.Attr s Text)
    {- ^ (Optional) The list of subnet IDs in which to launch the broker. A @SINGLE_INSTANCE@ deployment requires one subnet. An @ACTIVE_STANDBY_MULTI_AZ@ deployment requires two subnets. -}
    , _user                          :: !(TF.Attr s Text)
    {- ^ (Optional) The list of all ActiveMQ usernames for the specified broker. See below. -}
    } deriving (Show, Eq)

instance TF.ToHCL (MqBrokerResource s) where
    toHCL MqBrokerResource{..} = TF.inline $ catMaybes
        [ TF.assign "apply_immediately" <$> TF.attribute _apply_immediately
        , TF.assign "auto_minor_version_upgrade" <$> TF.attribute _auto_minor_version_upgrade
        , TF.assign "broker_name" <$> TF.attribute _broker_name
        , TF.assign "configuration" <$> TF.attribute _configuration
        , TF.assign "deployment_mode" <$> TF.attribute _deployment_mode
        , TF.assign "engine_type" <$> TF.attribute _engine_type
        , TF.assign "engine_version" <$> TF.attribute _engine_version
        , TF.assign "host_instance_type" <$> TF.attribute _host_instance_type
        , TF.assign "maintenance_window_start_time" <$> TF.attribute _maintenance_window_start_time
        , TF.assign "publicly_accessible" <$> TF.attribute _publicly_accessible
        , TF.assign "security_groups" <$> TF.attribute _security_groups
        , TF.assign "subnet_ids" <$> TF.attribute _subnet_ids
        , TF.assign "user" <$> TF.attribute _user
        ]

instance P.HasApplyImmediately (MqBrokerResource s) (TF.Attr s Text) where
    applyImmediately =
        lens (_apply_immediately :: MqBrokerResource s -> TF.Attr s Text)
             (\s a -> s { _apply_immediately = a } :: MqBrokerResource s)

instance P.HasAutoMinorVersionUpgrade (MqBrokerResource s) (TF.Attr s Text) where
    autoMinorVersionUpgrade =
        lens (_auto_minor_version_upgrade :: MqBrokerResource s -> TF.Attr s Text)
             (\s a -> s { _auto_minor_version_upgrade = a } :: MqBrokerResource s)

instance P.HasBrokerName (MqBrokerResource s) (TF.Attr s Text) where
    brokerName =
        lens (_broker_name :: MqBrokerResource s -> TF.Attr s Text)
             (\s a -> s { _broker_name = a } :: MqBrokerResource s)

instance P.HasConfiguration (MqBrokerResource s) (TF.Attr s Text) where
    configuration =
        lens (_configuration :: MqBrokerResource s -> TF.Attr s Text)
             (\s a -> s { _configuration = a } :: MqBrokerResource s)

instance P.HasDeploymentMode (MqBrokerResource s) (TF.Attr s Text) where
    deploymentMode =
        lens (_deployment_mode :: MqBrokerResource s -> TF.Attr s Text)
             (\s a -> s { _deployment_mode = a } :: MqBrokerResource s)

instance P.HasEngineType (MqBrokerResource s) (TF.Attr s Text) where
    engineType =
        lens (_engine_type :: MqBrokerResource s -> TF.Attr s Text)
             (\s a -> s { _engine_type = a } :: MqBrokerResource s)

instance P.HasEngineVersion (MqBrokerResource s) (TF.Attr s Text) where
    engineVersion =
        lens (_engine_version :: MqBrokerResource s -> TF.Attr s Text)
             (\s a -> s { _engine_version = a } :: MqBrokerResource s)

instance P.HasHostInstanceType (MqBrokerResource s) (TF.Attr s Text) where
    hostInstanceType =
        lens (_host_instance_type :: MqBrokerResource s -> TF.Attr s Text)
             (\s a -> s { _host_instance_type = a } :: MqBrokerResource s)

instance P.HasMaintenanceWindowStartTime (MqBrokerResource s) (TF.Attr s Text) where
    maintenanceWindowStartTime =
        lens (_maintenance_window_start_time :: MqBrokerResource s -> TF.Attr s Text)
             (\s a -> s { _maintenance_window_start_time = a } :: MqBrokerResource s)

instance P.HasPubliclyAccessible (MqBrokerResource s) (TF.Attr s Text) where
    publiclyAccessible =
        lens (_publicly_accessible :: MqBrokerResource s -> TF.Attr s Text)
             (\s a -> s { _publicly_accessible = a } :: MqBrokerResource s)

instance P.HasSecurityGroups (MqBrokerResource s) (TF.Attr s Text) where
    securityGroups =
        lens (_security_groups :: MqBrokerResource s -> TF.Attr s Text)
             (\s a -> s { _security_groups = a } :: MqBrokerResource s)

instance P.HasSubnetIds (MqBrokerResource s) (TF.Attr s Text) where
    subnetIds =
        lens (_subnet_ids :: MqBrokerResource s -> TF.Attr s Text)
             (\s a -> s { _subnet_ids = a } :: MqBrokerResource s)

instance P.HasUser (MqBrokerResource s) (TF.Attr s Text) where
    user =
        lens (_user :: MqBrokerResource s -> TF.Attr s Text)
             (\s a -> s { _user = a } :: MqBrokerResource s)

instance P.HasComputedApplyImmediately (MqBrokerResource s) s (TF.Attr s Text) where
    computedApplyImmediately =
        (_apply_immediately :: MqBrokerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedArn (MqBrokerResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedAutoMinorVersionUpgrade (MqBrokerResource s) s (TF.Attr s Text) where
    computedAutoMinorVersionUpgrade =
        (_auto_minor_version_upgrade :: MqBrokerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedBrokerName (MqBrokerResource s) s (TF.Attr s Text) where
    computedBrokerName =
        (_broker_name :: MqBrokerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedConfiguration (MqBrokerResource s) s (TF.Attr s Text) where
    computedConfiguration =
        (_configuration :: MqBrokerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDeploymentMode (MqBrokerResource s) s (TF.Attr s Text) where
    computedDeploymentMode =
        (_deployment_mode :: MqBrokerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEngineType (MqBrokerResource s) s (TF.Attr s Text) where
    computedEngineType =
        (_engine_type :: MqBrokerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEngineVersion (MqBrokerResource s) s (TF.Attr s Text) where
    computedEngineVersion =
        (_engine_version :: MqBrokerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedHostInstanceType (MqBrokerResource s) s (TF.Attr s Text) where
    computedHostInstanceType =
        (_host_instance_type :: MqBrokerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (MqBrokerResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedInstances (MqBrokerResource s) s (TF.Attr s Text) where
    computedInstances x = TF.compute (TF.refKey x) "instances"

instance P.HasComputedMaintenanceWindowStartTime (MqBrokerResource s) s (TF.Attr s Text) where
    computedMaintenanceWindowStartTime =
        (_maintenance_window_start_time :: MqBrokerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPubliclyAccessible (MqBrokerResource s) s (TF.Attr s Text) where
    computedPubliclyAccessible =
        (_publicly_accessible :: MqBrokerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSecurityGroups (MqBrokerResource s) s (TF.Attr s Text) where
    computedSecurityGroups =
        (_security_groups :: MqBrokerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSubnetIds (MqBrokerResource s) s (TF.Attr s Text) where
    computedSubnetIds =
        (_subnet_ids :: MqBrokerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedUser (MqBrokerResource s) s (TF.Attr s Text) where
    computedUser =
        (_user :: MqBrokerResource s -> TF.Attr s Text)
            . TF.refValue

mqBrokerResource :: TF.Schema TF.Resource P.AWS (MqBrokerResource s)
mqBrokerResource =
    TF.newResource "aws_mq_broker" $
        MqBrokerResource {
              _apply_immediately = TF.Nil
            , _auto_minor_version_upgrade = TF.Nil
            , _broker_name = TF.Nil
            , _configuration = TF.Nil
            , _deployment_mode = TF.Nil
            , _engine_type = TF.Nil
            , _engine_version = TF.Nil
            , _host_instance_type = TF.Nil
            , _maintenance_window_start_time = TF.Nil
            , _publicly_accessible = TF.Nil
            , _security_groups = TF.Nil
            , _subnet_ids = TF.Nil
            , _user = TF.Nil
            }

{- | The @aws_mq_configuration@ AWS resource.

Provides an MQ Configuration Resource. For more information on Amazon MQ,
see
<https://docs.aws.amazon.com/amazon-mq/latest/developer-guide/welcome.html>
.
-}
data MqConfigurationResource s = MqConfigurationResource {
      _data'          :: !(TF.Attr s Text)
    {- ^ (Required) The broker configuration in XML format. See <https://docs.aws.amazon.com/amazon-mq/latest/developer-guide/amazon-mq-broker-configuration-parameters.html> for supported parameters and format of the XML. -}
    , _description    :: !(TF.Attr s Text)
    {- ^ (Optional) The description of the configuration. -}
    , _engine_type    :: !(TF.Attr s Text)
    {- ^ (Required) The type of broker engine. -}
    , _engine_version :: !(TF.Attr s Text)
    {- ^ (Required) The version of the broker engine. -}
    , _name           :: !(TF.Attr s Text)
    {- ^ (Required) The name of the configuration -}
    } deriving (Show, Eq)

instance TF.ToHCL (MqConfigurationResource s) where
    toHCL MqConfigurationResource{..} = TF.inline $ catMaybes
        [ TF.assign "data" <$> TF.attribute _data'
        , TF.assign "description" <$> TF.attribute _description
        , TF.assign "engine_type" <$> TF.attribute _engine_type
        , TF.assign "engine_version" <$> TF.attribute _engine_version
        , TF.assign "name" <$> TF.attribute _name
        ]

instance P.HasData' (MqConfigurationResource s) (TF.Attr s Text) where
    data' =
        lens (_data' :: MqConfigurationResource s -> TF.Attr s Text)
             (\s a -> s { _data' = a } :: MqConfigurationResource s)

instance P.HasDescription (MqConfigurationResource s) (TF.Attr s Text) where
    description =
        lens (_description :: MqConfigurationResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: MqConfigurationResource s)

instance P.HasEngineType (MqConfigurationResource s) (TF.Attr s Text) where
    engineType =
        lens (_engine_type :: MqConfigurationResource s -> TF.Attr s Text)
             (\s a -> s { _engine_type = a } :: MqConfigurationResource s)

instance P.HasEngineVersion (MqConfigurationResource s) (TF.Attr s Text) where
    engineVersion =
        lens (_engine_version :: MqConfigurationResource s -> TF.Attr s Text)
             (\s a -> s { _engine_version = a } :: MqConfigurationResource s)

instance P.HasName (MqConfigurationResource s) (TF.Attr s Text) where
    name =
        lens (_name :: MqConfigurationResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: MqConfigurationResource s)

instance P.HasComputedArn (MqConfigurationResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedData' (MqConfigurationResource s) s (TF.Attr s Text) where
    computedData' =
        (_data' :: MqConfigurationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDescription (MqConfigurationResource s) s (TF.Attr s Text) where
    computedDescription =
        (_description :: MqConfigurationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEngineType (MqConfigurationResource s) s (TF.Attr s Text) where
    computedEngineType =
        (_engine_type :: MqConfigurationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEngineVersion (MqConfigurationResource s) s (TF.Attr s Text) where
    computedEngineVersion =
        (_engine_version :: MqConfigurationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (MqConfigurationResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedLatestRevision (MqConfigurationResource s) s (TF.Attr s Text) where
    computedLatestRevision x = TF.compute (TF.refKey x) "latest_revision"

instance P.HasComputedName (MqConfigurationResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: MqConfigurationResource s -> TF.Attr s Text)
            . TF.refValue

mqConfigurationResource :: TF.Schema TF.Resource P.AWS (MqConfigurationResource s)
mqConfigurationResource =
    TF.newResource "aws_mq_configuration" $
        MqConfigurationResource {
              _data' = TF.Nil
            , _description = TF.Nil
            , _engine_type = TF.Nil
            , _engine_version = TF.Nil
            , _name = TF.Nil
            }

{- | The @aws_nat_gateway@ AWS resource.

Provides a resource to create a VPC NAT Gateway.
-}
data NatGatewayResource s = NatGatewayResource {
      _allocation_id :: !(TF.Attr s Text)
    {- ^ (Required) The Allocation ID of the Elastic IP address for the gateway. -}
    , _subnet_id     :: !(TF.Attr s Text)
    {- ^ (Required) The Subnet ID of the subnet in which to place the gateway. -}
    , _tags          :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    } deriving (Show, Eq)

instance TF.ToHCL (NatGatewayResource s) where
    toHCL NatGatewayResource{..} = TF.inline $ catMaybes
        [ TF.assign "allocation_id" <$> TF.attribute _allocation_id
        , TF.assign "subnet_id" <$> TF.attribute _subnet_id
        , TF.assign "tags" <$> TF.attribute _tags
        ]

instance P.HasAllocationId (NatGatewayResource s) (TF.Attr s Text) where
    allocationId =
        lens (_allocation_id :: NatGatewayResource s -> TF.Attr s Text)
             (\s a -> s { _allocation_id = a } :: NatGatewayResource s)

instance P.HasSubnetId (NatGatewayResource s) (TF.Attr s Text) where
    subnetId =
        lens (_subnet_id :: NatGatewayResource s -> TF.Attr s Text)
             (\s a -> s { _subnet_id = a } :: NatGatewayResource s)

instance P.HasTags (NatGatewayResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: NatGatewayResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: NatGatewayResource s)

instance P.HasComputedAllocationId (NatGatewayResource s) s (TF.Attr s Text) where
    computedAllocationId x = TF.compute (TF.refKey x) "allocation_id"

instance P.HasComputedId (NatGatewayResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedNetworkInterfaceId (NatGatewayResource s) s (TF.Attr s Text) where
    computedNetworkInterfaceId x = TF.compute (TF.refKey x) "network_interface_id"

instance P.HasComputedPrivateIp (NatGatewayResource s) s (TF.Attr s Text) where
    computedPrivateIp x = TF.compute (TF.refKey x) "private_ip"

instance P.HasComputedPublicIp (NatGatewayResource s) s (TF.Attr s Text) where
    computedPublicIp x = TF.compute (TF.refKey x) "public_ip"

instance P.HasComputedSubnetId (NatGatewayResource s) s (TF.Attr s Text) where
    computedSubnetId x = TF.compute (TF.refKey x) "subnet_id"

instance P.HasComputedTags (NatGatewayResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: NatGatewayResource s -> TF.Attr s P.Tags)
            . TF.refValue

natGatewayResource :: TF.Schema TF.Resource P.AWS (NatGatewayResource s)
natGatewayResource =
    TF.newResource "aws_nat_gateway" $
        NatGatewayResource {
              _allocation_id = TF.Nil
            , _subnet_id = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_network_acl@ AWS resource.

Provides an network ACL resource. You might set up network ACLs with rules
similar to your security groups in order to add an additional layer of
security to your VPC.
-}
data NetworkAclResource s = NetworkAclResource {
      _egress     :: !(TF.Attr s Text)
    {- ^ (Optional) Specifies an egress rule. Parameters defined below. -}
    , _ingress    :: !(TF.Attr s Text)
    {- ^ (Optional) Specifies an ingress rule. Parameters defined below. -}
    , _subnet_id  :: !(TF.Attr s Text)
    {- ^ (Optional, Deprecated) The ID of the associated Subnet. This attribute is deprecated, please use the @subnet_ids@ attribute instead -}
    , _subnet_ids :: !(TF.Attr s Text)
    {- ^ (Optional) A list of Subnet IDs to apply the ACL to -}
    , _tags       :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    , _vpc_id     :: !(TF.Attr s Text)
    {- ^ (Required) The ID of the associated VPC. -}
    } deriving (Show, Eq)

instance TF.ToHCL (NetworkAclResource s) where
    toHCL NetworkAclResource{..} = TF.inline $ catMaybes
        [ TF.assign "egress" <$> TF.attribute _egress
        , TF.assign "ingress" <$> TF.attribute _ingress
        , TF.assign "subnet_id" <$> TF.attribute _subnet_id
        , TF.assign "subnet_ids" <$> TF.attribute _subnet_ids
        , TF.assign "tags" <$> TF.attribute _tags
        , TF.assign "vpc_id" <$> TF.attribute _vpc_id
        ]

instance P.HasEgress (NetworkAclResource s) (TF.Attr s Text) where
    egress =
        lens (_egress :: NetworkAclResource s -> TF.Attr s Text)
             (\s a -> s { _egress = a } :: NetworkAclResource s)

instance P.HasIngress (NetworkAclResource s) (TF.Attr s Text) where
    ingress =
        lens (_ingress :: NetworkAclResource s -> TF.Attr s Text)
             (\s a -> s { _ingress = a } :: NetworkAclResource s)

instance P.HasSubnetId (NetworkAclResource s) (TF.Attr s Text) where
    subnetId =
        lens (_subnet_id :: NetworkAclResource s -> TF.Attr s Text)
             (\s a -> s { _subnet_id = a } :: NetworkAclResource s)

instance P.HasSubnetIds (NetworkAclResource s) (TF.Attr s Text) where
    subnetIds =
        lens (_subnet_ids :: NetworkAclResource s -> TF.Attr s Text)
             (\s a -> s { _subnet_ids = a } :: NetworkAclResource s)

instance P.HasTags (NetworkAclResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: NetworkAclResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: NetworkAclResource s)

instance P.HasVpcId (NetworkAclResource s) (TF.Attr s Text) where
    vpcId =
        lens (_vpc_id :: NetworkAclResource s -> TF.Attr s Text)
             (\s a -> s { _vpc_id = a } :: NetworkAclResource s)

instance P.HasComputedEgress (NetworkAclResource s) s (TF.Attr s Text) where
    computedEgress =
        (_egress :: NetworkAclResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (NetworkAclResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedIngress (NetworkAclResource s) s (TF.Attr s Text) where
    computedIngress =
        (_ingress :: NetworkAclResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSubnetId (NetworkAclResource s) s (TF.Attr s Text) where
    computedSubnetId =
        (_subnet_id :: NetworkAclResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSubnetIds (NetworkAclResource s) s (TF.Attr s Text) where
    computedSubnetIds =
        (_subnet_ids :: NetworkAclResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (NetworkAclResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: NetworkAclResource s -> TF.Attr s P.Tags)
            . TF.refValue

instance P.HasComputedVpcId (NetworkAclResource s) s (TF.Attr s Text) where
    computedVpcId =
        (_vpc_id :: NetworkAclResource s -> TF.Attr s Text)
            . TF.refValue

networkAclResource :: TF.Schema TF.Resource P.AWS (NetworkAclResource s)
networkAclResource =
    TF.newResource "aws_network_acl" $
        NetworkAclResource {
              _egress = TF.Nil
            , _ingress = TF.Nil
            , _subnet_id = TF.Nil
            , _subnet_ids = TF.Nil
            , _tags = TF.Nil
            , _vpc_id = TF.Nil
            }

{- | The @aws_network_acl_rule@ AWS resource.

Creates an entry (a rule) in a network ACL with the specified rule number.
-}
data NetworkAclRuleResource s = NetworkAclRuleResource {
      _cidr_block      :: !(TF.Attr s P.CIDR)
    {- ^ (Optional) The network range to allow or deny, in CIDR notation (for example 172.16.0.0/24 ). -}
    , _egress          :: !(TF.Attr s Text)
    {- ^ (Optional, bool) Indicates whether this is an egress rule (rule is applied to traffic leaving the subnet). Default @false@ . -}
    , _from_port       :: !(TF.Attr s P.Word16)
    {- ^ (Optional) The from port to match. -}
    , _icmp_code       :: !(TF.Attr s Text)
    {- ^ (Optional) ICMP protocol: The ICMP code. Required if specifying ICMP for the protocol. e.g. -1 -}
    , _icmp_type       :: !(TF.Attr s Text)
    {- ^ (Optional) ICMP protocol: The ICMP type. Required if specifying ICMP for the protocol. e.g. -1 -}
    , _ipv6_cidr_block :: !(TF.Attr s P.CIDR)
    {- ^ (Optional) The IPv6 CIDR block to allow or deny. -}
    , _network_acl_id  :: !(TF.Attr s Text)
    {- ^ (Required) The ID of the network ACL. -}
    , _protocol        :: !(TF.Attr s Text)
    {- ^ (Required) The protocol. A value of -1 means all protocols. -}
    , _rule_action     :: !(TF.Attr s Text)
    {- ^ (Required) Indicates whether to allow or deny the traffic that matches the rule. Accepted values: @allow@ | @deny@ -}
    , _rule_number     :: !(TF.Attr s Text)
    {- ^ (Required) The rule number for the entry (for example, 100). ACL entries are processed in ascending order by rule number. -}
    , _to_port         :: !(TF.Attr s P.Word16)
    {- ^ (Optional) The to port to match. -}
    } deriving (Show, Eq)

instance TF.ToHCL (NetworkAclRuleResource s) where
    toHCL NetworkAclRuleResource{..} = TF.inline $ catMaybes
        [ TF.assign "cidr_block" <$> TF.attribute _cidr_block
        , TF.assign "egress" <$> TF.attribute _egress
        , TF.assign "from_port" <$> TF.attribute _from_port
        , TF.assign "icmp_code" <$> TF.attribute _icmp_code
        , TF.assign "icmp_type" <$> TF.attribute _icmp_type
        , TF.assign "ipv6_cidr_block" <$> TF.attribute _ipv6_cidr_block
        , TF.assign "network_acl_id" <$> TF.attribute _network_acl_id
        , TF.assign "protocol" <$> TF.attribute _protocol
        , TF.assign "rule_action" <$> TF.attribute _rule_action
        , TF.assign "rule_number" <$> TF.attribute _rule_number
        , TF.assign "to_port" <$> TF.attribute _to_port
        ]

instance P.HasCidrBlock (NetworkAclRuleResource s) (TF.Attr s P.CIDR) where
    cidrBlock =
        lens (_cidr_block :: NetworkAclRuleResource s -> TF.Attr s P.CIDR)
             (\s a -> s { _cidr_block = a } :: NetworkAclRuleResource s)

instance P.HasEgress (NetworkAclRuleResource s) (TF.Attr s Text) where
    egress =
        lens (_egress :: NetworkAclRuleResource s -> TF.Attr s Text)
             (\s a -> s { _egress = a } :: NetworkAclRuleResource s)

instance P.HasFromPort (NetworkAclRuleResource s) (TF.Attr s P.Word16) where
    fromPort =
        lens (_from_port :: NetworkAclRuleResource s -> TF.Attr s P.Word16)
             (\s a -> s { _from_port = a } :: NetworkAclRuleResource s)

instance P.HasIcmpCode (NetworkAclRuleResource s) (TF.Attr s Text) where
    icmpCode =
        lens (_icmp_code :: NetworkAclRuleResource s -> TF.Attr s Text)
             (\s a -> s { _icmp_code = a } :: NetworkAclRuleResource s)

instance P.HasIcmpType (NetworkAclRuleResource s) (TF.Attr s Text) where
    icmpType =
        lens (_icmp_type :: NetworkAclRuleResource s -> TF.Attr s Text)
             (\s a -> s { _icmp_type = a } :: NetworkAclRuleResource s)

instance P.HasIpv6CidrBlock (NetworkAclRuleResource s) (TF.Attr s P.CIDR) where
    ipv6CidrBlock =
        lens (_ipv6_cidr_block :: NetworkAclRuleResource s -> TF.Attr s P.CIDR)
             (\s a -> s { _ipv6_cidr_block = a } :: NetworkAclRuleResource s)

instance P.HasNetworkAclId (NetworkAclRuleResource s) (TF.Attr s Text) where
    networkAclId =
        lens (_network_acl_id :: NetworkAclRuleResource s -> TF.Attr s Text)
             (\s a -> s { _network_acl_id = a } :: NetworkAclRuleResource s)

instance P.HasProtocol (NetworkAclRuleResource s) (TF.Attr s Text) where
    protocol =
        lens (_protocol :: NetworkAclRuleResource s -> TF.Attr s Text)
             (\s a -> s { _protocol = a } :: NetworkAclRuleResource s)

instance P.HasRuleAction (NetworkAclRuleResource s) (TF.Attr s Text) where
    ruleAction =
        lens (_rule_action :: NetworkAclRuleResource s -> TF.Attr s Text)
             (\s a -> s { _rule_action = a } :: NetworkAclRuleResource s)

instance P.HasRuleNumber (NetworkAclRuleResource s) (TF.Attr s Text) where
    ruleNumber =
        lens (_rule_number :: NetworkAclRuleResource s -> TF.Attr s Text)
             (\s a -> s { _rule_number = a } :: NetworkAclRuleResource s)

instance P.HasToPort (NetworkAclRuleResource s) (TF.Attr s P.Word16) where
    toPort =
        lens (_to_port :: NetworkAclRuleResource s -> TF.Attr s P.Word16)
             (\s a -> s { _to_port = a } :: NetworkAclRuleResource s)

instance P.HasComputedCidrBlock (NetworkAclRuleResource s) s (TF.Attr s P.CIDR) where
    computedCidrBlock =
        (_cidr_block :: NetworkAclRuleResource s -> TF.Attr s P.CIDR)
            . TF.refValue

instance P.HasComputedEgress (NetworkAclRuleResource s) s (TF.Attr s Text) where
    computedEgress =
        (_egress :: NetworkAclRuleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedFromPort (NetworkAclRuleResource s) s (TF.Attr s P.Word16) where
    computedFromPort =
        (_from_port :: NetworkAclRuleResource s -> TF.Attr s P.Word16)
            . TF.refValue

instance P.HasComputedIcmpCode (NetworkAclRuleResource s) s (TF.Attr s Text) where
    computedIcmpCode =
        (_icmp_code :: NetworkAclRuleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedIcmpType (NetworkAclRuleResource s) s (TF.Attr s Text) where
    computedIcmpType =
        (_icmp_type :: NetworkAclRuleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (NetworkAclRuleResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedIpv6CidrBlock (NetworkAclRuleResource s) s (TF.Attr s P.CIDR) where
    computedIpv6CidrBlock =
        (_ipv6_cidr_block :: NetworkAclRuleResource s -> TF.Attr s P.CIDR)
            . TF.refValue

instance P.HasComputedNetworkAclId (NetworkAclRuleResource s) s (TF.Attr s Text) where
    computedNetworkAclId =
        (_network_acl_id :: NetworkAclRuleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedProtocol (NetworkAclRuleResource s) s (TF.Attr s Text) where
    computedProtocol =
        (_protocol :: NetworkAclRuleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRuleAction (NetworkAclRuleResource s) s (TF.Attr s Text) where
    computedRuleAction =
        (_rule_action :: NetworkAclRuleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRuleNumber (NetworkAclRuleResource s) s (TF.Attr s Text) where
    computedRuleNumber =
        (_rule_number :: NetworkAclRuleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedToPort (NetworkAclRuleResource s) s (TF.Attr s P.Word16) where
    computedToPort =
        (_to_port :: NetworkAclRuleResource s -> TF.Attr s P.Word16)
            . TF.refValue

networkAclRuleResource :: TF.Schema TF.Resource P.AWS (NetworkAclRuleResource s)
networkAclRuleResource =
    TF.newResource "aws_network_acl_rule" $
        NetworkAclRuleResource {
              _cidr_block = TF.Nil
            , _egress = TF.Nil
            , _from_port = TF.Nil
            , _icmp_code = TF.Nil
            , _icmp_type = TF.Nil
            , _ipv6_cidr_block = TF.Nil
            , _network_acl_id = TF.Nil
            , _protocol = TF.Nil
            , _rule_action = TF.Nil
            , _rule_number = TF.Nil
            , _to_port = TF.Nil
            }

{- | The @aws_network_interface_attachment@ AWS resource.

Attach an Elastic network interface (ENI) resource with EC2 instance.
-}
data NetworkInterfaceAttachmentResource s = NetworkInterfaceAttachmentResource {
      _device_index         :: !(TF.Attr s Text)
    {- ^ (Required) Network interface index (int). -}
    , _instance_id          :: !(TF.Attr s Text)
    {- ^ (Required) Instance ID to attach. -}
    , _network_interface_id :: !(TF.Attr s Text)
    {- ^ (Required) ENI ID to attach. -}
    } deriving (Show, Eq)

instance TF.ToHCL (NetworkInterfaceAttachmentResource s) where
    toHCL NetworkInterfaceAttachmentResource{..} = TF.inline $ catMaybes
        [ TF.assign "device_index" <$> TF.attribute _device_index
        , TF.assign "instance_id" <$> TF.attribute _instance_id
        , TF.assign "network_interface_id" <$> TF.attribute _network_interface_id
        ]

instance P.HasDeviceIndex (NetworkInterfaceAttachmentResource s) (TF.Attr s Text) where
    deviceIndex =
        lens (_device_index :: NetworkInterfaceAttachmentResource s -> TF.Attr s Text)
             (\s a -> s { _device_index = a } :: NetworkInterfaceAttachmentResource s)

instance P.HasInstanceId (NetworkInterfaceAttachmentResource s) (TF.Attr s Text) where
    instanceId =
        lens (_instance_id :: NetworkInterfaceAttachmentResource s -> TF.Attr s Text)
             (\s a -> s { _instance_id = a } :: NetworkInterfaceAttachmentResource s)

instance P.HasNetworkInterfaceId (NetworkInterfaceAttachmentResource s) (TF.Attr s Text) where
    networkInterfaceId =
        lens (_network_interface_id :: NetworkInterfaceAttachmentResource s -> TF.Attr s Text)
             (\s a -> s { _network_interface_id = a } :: NetworkInterfaceAttachmentResource s)

instance P.HasComputedAttachmentId (NetworkInterfaceAttachmentResource s) s (TF.Attr s Text) where
    computedAttachmentId x = TF.compute (TF.refKey x) "attachment_id"

instance P.HasComputedDeviceIndex (NetworkInterfaceAttachmentResource s) s (TF.Attr s Text) where
    computedDeviceIndex =
        (_device_index :: NetworkInterfaceAttachmentResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedInstanceId (NetworkInterfaceAttachmentResource s) s (TF.Attr s Text) where
    computedInstanceId x = TF.compute (TF.refKey x) "instance_id"

instance P.HasComputedNetworkInterfaceId (NetworkInterfaceAttachmentResource s) s (TF.Attr s Text) where
    computedNetworkInterfaceId x = TF.compute (TF.refKey x) "network_interface_id"

instance P.HasComputedStatus (NetworkInterfaceAttachmentResource s) s (TF.Attr s Text) where
    computedStatus x = TF.compute (TF.refKey x) "status"

networkInterfaceAttachmentResource :: TF.Schema TF.Resource P.AWS (NetworkInterfaceAttachmentResource s)
networkInterfaceAttachmentResource =
    TF.newResource "aws_network_interface_attachment" $
        NetworkInterfaceAttachmentResource {
              _device_index = TF.Nil
            , _instance_id = TF.Nil
            , _network_interface_id = TF.Nil
            }

{- | The @aws_network_interface@ AWS resource.

Provides an Elastic network interface (ENI) resource.
-}
data NetworkInterfaceResource s = NetworkInterfaceResource {
      _attachment        :: !(TF.Attr s Text)
    {- ^ (Optional) Block to define the attachment of the ENI. Documented below. -}
    , _description       :: !(TF.Attr s Text)
    {- ^ (Optional) A description for the network interface. -}
    , _private_ips       :: !(TF.Attr s Text)
    {- ^ (Optional) List of private IPs to assign to the ENI. -}
    , _private_ips_count :: !(TF.Attr s Text)
    {- ^ (Optional) Number of private IPs to assign to the ENI. -}
    , _security_groups   :: !(TF.Attr s Text)
    {- ^ (Optional) List of security group IDs to assign to the ENI. -}
    , _source_dest_check :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to enable source destination checking for the ENI. Default true. -}
    , _subnet_id         :: !(TF.Attr s Text)
    {- ^ (Required) Subnet ID to create the ENI in. -}
    , _tags              :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    } deriving (Show, Eq)

instance TF.ToHCL (NetworkInterfaceResource s) where
    toHCL NetworkInterfaceResource{..} = TF.inline $ catMaybes
        [ TF.assign "attachment" <$> TF.attribute _attachment
        , TF.assign "description" <$> TF.attribute _description
        , TF.assign "private_ips" <$> TF.attribute _private_ips
        , TF.assign "private_ips_count" <$> TF.attribute _private_ips_count
        , TF.assign "security_groups" <$> TF.attribute _security_groups
        , TF.assign "source_dest_check" <$> TF.attribute _source_dest_check
        , TF.assign "subnet_id" <$> TF.attribute _subnet_id
        , TF.assign "tags" <$> TF.attribute _tags
        ]

instance P.HasAttachment (NetworkInterfaceResource s) (TF.Attr s Text) where
    attachment =
        lens (_attachment :: NetworkInterfaceResource s -> TF.Attr s Text)
             (\s a -> s { _attachment = a } :: NetworkInterfaceResource s)

instance P.HasDescription (NetworkInterfaceResource s) (TF.Attr s Text) where
    description =
        lens (_description :: NetworkInterfaceResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: NetworkInterfaceResource s)

instance P.HasPrivateIps (NetworkInterfaceResource s) (TF.Attr s Text) where
    privateIps =
        lens (_private_ips :: NetworkInterfaceResource s -> TF.Attr s Text)
             (\s a -> s { _private_ips = a } :: NetworkInterfaceResource s)

instance P.HasPrivateIpsCount (NetworkInterfaceResource s) (TF.Attr s Text) where
    privateIpsCount =
        lens (_private_ips_count :: NetworkInterfaceResource s -> TF.Attr s Text)
             (\s a -> s { _private_ips_count = a } :: NetworkInterfaceResource s)

instance P.HasSecurityGroups (NetworkInterfaceResource s) (TF.Attr s Text) where
    securityGroups =
        lens (_security_groups :: NetworkInterfaceResource s -> TF.Attr s Text)
             (\s a -> s { _security_groups = a } :: NetworkInterfaceResource s)

instance P.HasSourceDestCheck (NetworkInterfaceResource s) (TF.Attr s Text) where
    sourceDestCheck =
        lens (_source_dest_check :: NetworkInterfaceResource s -> TF.Attr s Text)
             (\s a -> s { _source_dest_check = a } :: NetworkInterfaceResource s)

instance P.HasSubnetId (NetworkInterfaceResource s) (TF.Attr s Text) where
    subnetId =
        lens (_subnet_id :: NetworkInterfaceResource s -> TF.Attr s Text)
             (\s a -> s { _subnet_id = a } :: NetworkInterfaceResource s)

instance P.HasTags (NetworkInterfaceResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: NetworkInterfaceResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: NetworkInterfaceResource s)

instance P.HasComputedAttachment (NetworkInterfaceResource s) s (TF.Attr s Text) where
    computedAttachment x = TF.compute (TF.refKey x) "attachment"

instance P.HasComputedDescription (NetworkInterfaceResource s) s (TF.Attr s Text) where
    computedDescription x = TF.compute (TF.refKey x) "description"

instance P.HasComputedId (NetworkInterfaceResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedPrivateIps (NetworkInterfaceResource s) s (TF.Attr s Text) where
    computedPrivateIps x = TF.compute (TF.refKey x) "private_ips"

instance P.HasComputedPrivateIpsCount (NetworkInterfaceResource s) s (TF.Attr s Text) where
    computedPrivateIpsCount =
        (_private_ips_count :: NetworkInterfaceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSecurityGroups (NetworkInterfaceResource s) s (TF.Attr s Text) where
    computedSecurityGroups x = TF.compute (TF.refKey x) "security_groups"

instance P.HasComputedSourceDestCheck (NetworkInterfaceResource s) s (TF.Attr s Text) where
    computedSourceDestCheck x = TF.compute (TF.refKey x) "source_dest_check"

instance P.HasComputedSubnetId (NetworkInterfaceResource s) s (TF.Attr s Text) where
    computedSubnetId x = TF.compute (TF.refKey x) "subnet_id"

instance P.HasComputedTags (NetworkInterfaceResource s) s (TF.Attr s P.Tags) where
    computedTags x = TF.compute (TF.refKey x) "tags"

networkInterfaceResource :: TF.Schema TF.Resource P.AWS (NetworkInterfaceResource s)
networkInterfaceResource =
    TF.newResource "aws_network_interface" $
        NetworkInterfaceResource {
              _attachment = TF.Nil
            , _description = TF.Nil
            , _private_ips = TF.Nil
            , _private_ips_count = TF.Nil
            , _security_groups = TF.Nil
            , _source_dest_check = TF.Nil
            , _subnet_id = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_network_interface_sg_attachment@ AWS resource.

This resource attaches a security group to an Elastic Network Interface
(ENI). It can be used to attach a security group to any existing ENI, be it
a secondary ENI or one attached as the primary interface on an instance. ~>
NOTE on instances, interfaces, and security groups: Terraform currently
provides the capability to assign security groups via the
</docs/providers/aws/d/instance.html> and the
</docs/providers/aws/r/network_interface.html> resources. Using this
resource in conjunction with security groups provided in-line in those
resources will cause conflicts, and will lead to spurious diffs and
undefined behavior - please use one or the other.
-}
data NetworkInterfaceSgAttachmentResource s = NetworkInterfaceSgAttachmentResource {
      _network_interface_id :: !(TF.Attr s Text)
    {- ^ (Required) The ID of the network interface to attach to. -}
    , _security_group_id    :: !(TF.Attr s Text)
    {- ^ (Required) The ID of the security group. -}
    } deriving (Show, Eq)

instance TF.ToHCL (NetworkInterfaceSgAttachmentResource s) where
    toHCL NetworkInterfaceSgAttachmentResource{..} = TF.inline $ catMaybes
        [ TF.assign "network_interface_id" <$> TF.attribute _network_interface_id
        , TF.assign "security_group_id" <$> TF.attribute _security_group_id
        ]

instance P.HasNetworkInterfaceId (NetworkInterfaceSgAttachmentResource s) (TF.Attr s Text) where
    networkInterfaceId =
        lens (_network_interface_id :: NetworkInterfaceSgAttachmentResource s -> TF.Attr s Text)
             (\s a -> s { _network_interface_id = a } :: NetworkInterfaceSgAttachmentResource s)

instance P.HasSecurityGroupId (NetworkInterfaceSgAttachmentResource s) (TF.Attr s Text) where
    securityGroupId =
        lens (_security_group_id :: NetworkInterfaceSgAttachmentResource s -> TF.Attr s Text)
             (\s a -> s { _security_group_id = a } :: NetworkInterfaceSgAttachmentResource s)

instance P.HasComputedNetworkInterfaceId (NetworkInterfaceSgAttachmentResource s) s (TF.Attr s Text) where
    computedNetworkInterfaceId =
        (_network_interface_id :: NetworkInterfaceSgAttachmentResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSecurityGroupId (NetworkInterfaceSgAttachmentResource s) s (TF.Attr s Text) where
    computedSecurityGroupId =
        (_security_group_id :: NetworkInterfaceSgAttachmentResource s -> TF.Attr s Text)
            . TF.refValue

networkInterfaceSgAttachmentResource :: TF.Schema TF.Resource P.AWS (NetworkInterfaceSgAttachmentResource s)
networkInterfaceSgAttachmentResource =
    TF.newResource "aws_network_interface_sg_attachment" $
        NetworkInterfaceSgAttachmentResource {
              _network_interface_id = TF.Nil
            , _security_group_id = TF.Nil
            }

{- | The @aws_opsworks_application@ AWS resource.

Provides an OpsWorks application resource.
-}
data OpsworksApplicationResource s = OpsworksApplicationResource {
      _app_source                :: !(TF.Attr s Text)
    {- ^ (Optional) SCM configuration of the app as described below. -}
    , _auto_bundle_on_deploy     :: !(TF.Attr s Text)
    {- ^ (Optional) Run bundle install when deploying for application of type @rails@ . -}
    , _aws_flow_ruby_settings    :: !(TF.Attr s Text)
    {- ^ (Optional) Specify activity and workflow workers for your app using the aws-flow gem. -}
    , _data_source_arn           :: !(TF.Attr s Text)
    {- ^ (Optional) The data source's ARN. -}
    , _data_source_database_name :: !(TF.Attr s Text)
    {- ^ (Optional) The database name. -}
    , _data_source_type          :: !(TF.Attr s Text)
    {- ^ (Optional) The data source's type one of @AutoSelectOpsworksMysqlInstance@ , @OpsworksMysqlInstance@ , or @RdsDbInstance@ . -}
    , _description               :: !(TF.Attr s Text)
    {- ^ (Optional) A description of the app. -}
    , _document_root             :: !(TF.Attr s Text)
    {- ^ (Optional) Subfolder for the document root for application of type @rails@ . -}
    , _domains                   :: !(TF.Attr s Text)
    {- ^ -  (Optional) A list of virtual host alias. -}
    , _enable_ssl                :: !(TF.Attr s P.Bool)
    {- ^ (Optional) Whether to enable SSL for the app. This must be set in order to let @ssl_configuration.private_key@ , @ssl_configuration.certificate@ and @ssl_configuration.chain@ take effect. -}
    , _environment               :: !(TF.Attr s Text)
    {- ^ (Optional) Object to define environment variables.  Object is described below. -}
    , _name                      :: !(TF.Attr s Text)
    {- ^ (Required) A human-readable name for the application. -}
    , _rails_env                 :: !(TF.Attr s Text)
    {- ^ (Required if @type@ = @rails@ ) The name of the Rails environment for application of type @rails@ . -}
    , _short_name                :: !(TF.Attr s Text)
    {- ^ (Required) A short, machine-readable name for the application. This can only be defined on resource creation and ignored on resource update. -}
    , _ssl_configuration         :: !(TF.Attr s Text)
    {- ^ (Optional) The SSL configuration of the app. Object is described below. -}
    , _stack_id                  :: !(TF.Attr s Text)
    {- ^ (Required) The id of the stack the application will belong to. -}
    , _type'                     :: !(TF.Attr s Text)
    {- ^ (Required) Opsworks application type. One of @aws-flow-ruby@ , @java@ , @rails@ , @php@ , @nodejs@ , @static@ or @other@ . -}
    } deriving (Show, Eq)

instance TF.ToHCL (OpsworksApplicationResource s) where
    toHCL OpsworksApplicationResource{..} = TF.inline $ catMaybes
        [ TF.assign "app_source" <$> TF.attribute _app_source
        , TF.assign "auto_bundle_on_deploy" <$> TF.attribute _auto_bundle_on_deploy
        , TF.assign "aws_flow_ruby_settings" <$> TF.attribute _aws_flow_ruby_settings
        , TF.assign "data_source_arn" <$> TF.attribute _data_source_arn
        , TF.assign "data_source_database_name" <$> TF.attribute _data_source_database_name
        , TF.assign "data_source_type" <$> TF.attribute _data_source_type
        , TF.assign "description" <$> TF.attribute _description
        , TF.assign "document_root" <$> TF.attribute _document_root
        , TF.assign "domains" <$> TF.attribute _domains
        , TF.assign "enable_ssl" <$> TF.attribute _enable_ssl
        , TF.assign "environment" <$> TF.attribute _environment
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "rails_env" <$> TF.attribute _rails_env
        , TF.assign "short_name" <$> TF.attribute _short_name
        , TF.assign "ssl_configuration" <$> TF.attribute _ssl_configuration
        , TF.assign "stack_id" <$> TF.attribute _stack_id
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance P.HasAppSource (OpsworksApplicationResource s) (TF.Attr s Text) where
    appSource =
        lens (_app_source :: OpsworksApplicationResource s -> TF.Attr s Text)
             (\s a -> s { _app_source = a } :: OpsworksApplicationResource s)

instance P.HasAutoBundleOnDeploy (OpsworksApplicationResource s) (TF.Attr s Text) where
    autoBundleOnDeploy =
        lens (_auto_bundle_on_deploy :: OpsworksApplicationResource s -> TF.Attr s Text)
             (\s a -> s { _auto_bundle_on_deploy = a } :: OpsworksApplicationResource s)

instance P.HasAwsFlowRubySettings (OpsworksApplicationResource s) (TF.Attr s Text) where
    awsFlowRubySettings =
        lens (_aws_flow_ruby_settings :: OpsworksApplicationResource s -> TF.Attr s Text)
             (\s a -> s { _aws_flow_ruby_settings = a } :: OpsworksApplicationResource s)

instance P.HasDataSourceArn (OpsworksApplicationResource s) (TF.Attr s Text) where
    dataSourceArn =
        lens (_data_source_arn :: OpsworksApplicationResource s -> TF.Attr s Text)
             (\s a -> s { _data_source_arn = a } :: OpsworksApplicationResource s)

instance P.HasDataSourceDatabaseName (OpsworksApplicationResource s) (TF.Attr s Text) where
    dataSourceDatabaseName =
        lens (_data_source_database_name :: OpsworksApplicationResource s -> TF.Attr s Text)
             (\s a -> s { _data_source_database_name = a } :: OpsworksApplicationResource s)

instance P.HasDataSourceType (OpsworksApplicationResource s) (TF.Attr s Text) where
    dataSourceType =
        lens (_data_source_type :: OpsworksApplicationResource s -> TF.Attr s Text)
             (\s a -> s { _data_source_type = a } :: OpsworksApplicationResource s)

instance P.HasDescription (OpsworksApplicationResource s) (TF.Attr s Text) where
    description =
        lens (_description :: OpsworksApplicationResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: OpsworksApplicationResource s)

instance P.HasDocumentRoot (OpsworksApplicationResource s) (TF.Attr s Text) where
    documentRoot =
        lens (_document_root :: OpsworksApplicationResource s -> TF.Attr s Text)
             (\s a -> s { _document_root = a } :: OpsworksApplicationResource s)

instance P.HasDomains (OpsworksApplicationResource s) (TF.Attr s Text) where
    domains =
        lens (_domains :: OpsworksApplicationResource s -> TF.Attr s Text)
             (\s a -> s { _domains = a } :: OpsworksApplicationResource s)

instance P.HasEnableSsl (OpsworksApplicationResource s) (TF.Attr s P.Bool) where
    enableSsl =
        lens (_enable_ssl :: OpsworksApplicationResource s -> TF.Attr s P.Bool)
             (\s a -> s { _enable_ssl = a } :: OpsworksApplicationResource s)

instance P.HasEnvironment (OpsworksApplicationResource s) (TF.Attr s Text) where
    environment =
        lens (_environment :: OpsworksApplicationResource s -> TF.Attr s Text)
             (\s a -> s { _environment = a } :: OpsworksApplicationResource s)

instance P.HasName (OpsworksApplicationResource s) (TF.Attr s Text) where
    name =
        lens (_name :: OpsworksApplicationResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: OpsworksApplicationResource s)

instance P.HasRailsEnv (OpsworksApplicationResource s) (TF.Attr s Text) where
    railsEnv =
        lens (_rails_env :: OpsworksApplicationResource s -> TF.Attr s Text)
             (\s a -> s { _rails_env = a } :: OpsworksApplicationResource s)

instance P.HasShortName (OpsworksApplicationResource s) (TF.Attr s Text) where
    shortName =
        lens (_short_name :: OpsworksApplicationResource s -> TF.Attr s Text)
             (\s a -> s { _short_name = a } :: OpsworksApplicationResource s)

instance P.HasSslConfiguration (OpsworksApplicationResource s) (TF.Attr s Text) where
    sslConfiguration =
        lens (_ssl_configuration :: OpsworksApplicationResource s -> TF.Attr s Text)
             (\s a -> s { _ssl_configuration = a } :: OpsworksApplicationResource s)

instance P.HasStackId (OpsworksApplicationResource s) (TF.Attr s Text) where
    stackId =
        lens (_stack_id :: OpsworksApplicationResource s -> TF.Attr s Text)
             (\s a -> s { _stack_id = a } :: OpsworksApplicationResource s)

instance P.HasType' (OpsworksApplicationResource s) (TF.Attr s Text) where
    type' =
        lens (_type' :: OpsworksApplicationResource s -> TF.Attr s Text)
             (\s a -> s { _type' = a } :: OpsworksApplicationResource s)

instance P.HasComputedAppSource (OpsworksApplicationResource s) s (TF.Attr s Text) where
    computedAppSource =
        (_app_source :: OpsworksApplicationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAutoBundleOnDeploy (OpsworksApplicationResource s) s (TF.Attr s Text) where
    computedAutoBundleOnDeploy =
        (_auto_bundle_on_deploy :: OpsworksApplicationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAwsFlowRubySettings (OpsworksApplicationResource s) s (TF.Attr s Text) where
    computedAwsFlowRubySettings =
        (_aws_flow_ruby_settings :: OpsworksApplicationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDataSourceArn (OpsworksApplicationResource s) s (TF.Attr s Text) where
    computedDataSourceArn =
        (_data_source_arn :: OpsworksApplicationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDataSourceDatabaseName (OpsworksApplicationResource s) s (TF.Attr s Text) where
    computedDataSourceDatabaseName =
        (_data_source_database_name :: OpsworksApplicationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDataSourceType (OpsworksApplicationResource s) s (TF.Attr s Text) where
    computedDataSourceType =
        (_data_source_type :: OpsworksApplicationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDescription (OpsworksApplicationResource s) s (TF.Attr s Text) where
    computedDescription =
        (_description :: OpsworksApplicationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDocumentRoot (OpsworksApplicationResource s) s (TF.Attr s Text) where
    computedDocumentRoot =
        (_document_root :: OpsworksApplicationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDomains (OpsworksApplicationResource s) s (TF.Attr s Text) where
    computedDomains =
        (_domains :: OpsworksApplicationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEnableSsl (OpsworksApplicationResource s) s (TF.Attr s P.Bool) where
    computedEnableSsl =
        (_enable_ssl :: OpsworksApplicationResource s -> TF.Attr s P.Bool)
            . TF.refValue

instance P.HasComputedEnvironment (OpsworksApplicationResource s) s (TF.Attr s Text) where
    computedEnvironment =
        (_environment :: OpsworksApplicationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (OpsworksApplicationResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (OpsworksApplicationResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: OpsworksApplicationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRailsEnv (OpsworksApplicationResource s) s (TF.Attr s Text) where
    computedRailsEnv =
        (_rails_env :: OpsworksApplicationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedShortName (OpsworksApplicationResource s) s (TF.Attr s Text) where
    computedShortName =
        (_short_name :: OpsworksApplicationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSslConfiguration (OpsworksApplicationResource s) s (TF.Attr s Text) where
    computedSslConfiguration =
        (_ssl_configuration :: OpsworksApplicationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedStackId (OpsworksApplicationResource s) s (TF.Attr s Text) where
    computedStackId =
        (_stack_id :: OpsworksApplicationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedType' (OpsworksApplicationResource s) s (TF.Attr s Text) where
    computedType' =
        (_type' :: OpsworksApplicationResource s -> TF.Attr s Text)
            . TF.refValue

opsworksApplicationResource :: TF.Schema TF.Resource P.AWS (OpsworksApplicationResource s)
opsworksApplicationResource =
    TF.newResource "aws_opsworks_application" $
        OpsworksApplicationResource {
              _app_source = TF.Nil
            , _auto_bundle_on_deploy = TF.Nil
            , _aws_flow_ruby_settings = TF.Nil
            , _data_source_arn = TF.Nil
            , _data_source_database_name = TF.Nil
            , _data_source_type = TF.Nil
            , _description = TF.Nil
            , _document_root = TF.Nil
            , _domains = TF.Nil
            , _enable_ssl = TF.Nil
            , _environment = TF.Nil
            , _name = TF.Nil
            , _rails_env = TF.Nil
            , _short_name = TF.Nil
            , _ssl_configuration = TF.Nil
            , _stack_id = TF.Nil
            , _type' = TF.Nil
            }

{- | The @aws_opsworks_custom_layer@ AWS resource.

Provides an OpsWorks custom layer resource.
-}
data OpsworksCustomLayerResource s = OpsworksCustomLayerResource {
      _auto_assign_elastic_ips     :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to automatically assign an elastic IP address to the layer's instances. -}
    , _auto_assign_public_ips      :: !(TF.Attr s Text)
    {- ^ (Optional) For stacks belonging to a VPC, whether to automatically assign a public IP address to each of the layer's instances. -}
    , _auto_healing                :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to enable auto-healing for the layer. -}
    , _custom_instance_profile_arn :: !(TF.Attr s Text)
    {- ^ (Optional) The ARN of an IAM profile that will be used for the layer's instances. -}
    , _custom_json                 :: !(TF.Attr s Text)
    {- ^ (Optional) Custom JSON attributes to apply to the layer. -}
    , _custom_security_group_ids   :: !(TF.Attr s Text)
    {- ^ (Optional) Ids for a set of security groups to apply to the layer's instances. -}
    , _drain_elb_on_shutdown       :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to enable Elastic Load Balancing connection draining. -}
    , _ebs_volume                  :: !(TF.Attr s Text)
    {- ^ (Optional) @ebs_volume@ blocks, as described below, will each create an EBS volume and connect it to the layer's instances. -}
    , _elastic_load_balancer       :: !(TF.Attr s Text)
    {- ^ (Optional) Name of an Elastic Load Balancer to attach to this layer -}
    , _install_updates_on_boot     :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to install OS and package updates on each instance when it boots. -}
    , _instance_shutdown_timeout   :: !(TF.Attr s Text)
    {- ^ (Optional) The time, in seconds, that OpsWorks will wait for Chef to complete after triggering the Shutdown event. -}
    , _name                        :: !(TF.Attr s Text)
    {- ^ (Required) A human-readable name for the layer. -}
    , _short_name                  :: !(TF.Attr s Text)
    {- ^ (Required) A short, machine-readable name for the layer, which will be used to identify it in the Chef node JSON. -}
    , _stack_id                    :: !(TF.Attr s Text)
    {- ^ (Required) The id of the stack the layer will belong to. -}
    , _system_packages             :: !(TF.Attr s Text)
    {- ^ (Optional) Names of a set of system packages to install on the layer's instances. -}
    , _use_ebs_optimized_instances :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to use EBS-optimized instances. -}
    } deriving (Show, Eq)

instance TF.ToHCL (OpsworksCustomLayerResource s) where
    toHCL OpsworksCustomLayerResource{..} = TF.inline $ catMaybes
        [ TF.assign "auto_assign_elastic_ips" <$> TF.attribute _auto_assign_elastic_ips
        , TF.assign "auto_assign_public_ips" <$> TF.attribute _auto_assign_public_ips
        , TF.assign "auto_healing" <$> TF.attribute _auto_healing
        , TF.assign "custom_instance_profile_arn" <$> TF.attribute _custom_instance_profile_arn
        , TF.assign "custom_json" <$> TF.attribute _custom_json
        , TF.assign "custom_security_group_ids" <$> TF.attribute _custom_security_group_ids
        , TF.assign "drain_elb_on_shutdown" <$> TF.attribute _drain_elb_on_shutdown
        , TF.assign "ebs_volume" <$> TF.attribute _ebs_volume
        , TF.assign "elastic_load_balancer" <$> TF.attribute _elastic_load_balancer
        , TF.assign "install_updates_on_boot" <$> TF.attribute _install_updates_on_boot
        , TF.assign "instance_shutdown_timeout" <$> TF.attribute _instance_shutdown_timeout
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "short_name" <$> TF.attribute _short_name
        , TF.assign "stack_id" <$> TF.attribute _stack_id
        , TF.assign "system_packages" <$> TF.attribute _system_packages
        , TF.assign "use_ebs_optimized_instances" <$> TF.attribute _use_ebs_optimized_instances
        ]

instance P.HasAutoAssignElasticIps (OpsworksCustomLayerResource s) (TF.Attr s Text) where
    autoAssignElasticIps =
        lens (_auto_assign_elastic_ips :: OpsworksCustomLayerResource s -> TF.Attr s Text)
             (\s a -> s { _auto_assign_elastic_ips = a } :: OpsworksCustomLayerResource s)

instance P.HasAutoAssignPublicIps (OpsworksCustomLayerResource s) (TF.Attr s Text) where
    autoAssignPublicIps =
        lens (_auto_assign_public_ips :: OpsworksCustomLayerResource s -> TF.Attr s Text)
             (\s a -> s { _auto_assign_public_ips = a } :: OpsworksCustomLayerResource s)

instance P.HasAutoHealing (OpsworksCustomLayerResource s) (TF.Attr s Text) where
    autoHealing =
        lens (_auto_healing :: OpsworksCustomLayerResource s -> TF.Attr s Text)
             (\s a -> s { _auto_healing = a } :: OpsworksCustomLayerResource s)

instance P.HasCustomInstanceProfileArn (OpsworksCustomLayerResource s) (TF.Attr s Text) where
    customInstanceProfileArn =
        lens (_custom_instance_profile_arn :: OpsworksCustomLayerResource s -> TF.Attr s Text)
             (\s a -> s { _custom_instance_profile_arn = a } :: OpsworksCustomLayerResource s)

instance P.HasCustomJson (OpsworksCustomLayerResource s) (TF.Attr s Text) where
    customJson =
        lens (_custom_json :: OpsworksCustomLayerResource s -> TF.Attr s Text)
             (\s a -> s { _custom_json = a } :: OpsworksCustomLayerResource s)

instance P.HasCustomSecurityGroupIds (OpsworksCustomLayerResource s) (TF.Attr s Text) where
    customSecurityGroupIds =
        lens (_custom_security_group_ids :: OpsworksCustomLayerResource s -> TF.Attr s Text)
             (\s a -> s { _custom_security_group_ids = a } :: OpsworksCustomLayerResource s)

instance P.HasDrainElbOnShutdown (OpsworksCustomLayerResource s) (TF.Attr s Text) where
    drainElbOnShutdown =
        lens (_drain_elb_on_shutdown :: OpsworksCustomLayerResource s -> TF.Attr s Text)
             (\s a -> s { _drain_elb_on_shutdown = a } :: OpsworksCustomLayerResource s)

instance P.HasEbsVolume (OpsworksCustomLayerResource s) (TF.Attr s Text) where
    ebsVolume =
        lens (_ebs_volume :: OpsworksCustomLayerResource s -> TF.Attr s Text)
             (\s a -> s { _ebs_volume = a } :: OpsworksCustomLayerResource s)

instance P.HasElasticLoadBalancer (OpsworksCustomLayerResource s) (TF.Attr s Text) where
    elasticLoadBalancer =
        lens (_elastic_load_balancer :: OpsworksCustomLayerResource s -> TF.Attr s Text)
             (\s a -> s { _elastic_load_balancer = a } :: OpsworksCustomLayerResource s)

instance P.HasInstallUpdatesOnBoot (OpsworksCustomLayerResource s) (TF.Attr s Text) where
    installUpdatesOnBoot =
        lens (_install_updates_on_boot :: OpsworksCustomLayerResource s -> TF.Attr s Text)
             (\s a -> s { _install_updates_on_boot = a } :: OpsworksCustomLayerResource s)

instance P.HasInstanceShutdownTimeout (OpsworksCustomLayerResource s) (TF.Attr s Text) where
    instanceShutdownTimeout =
        lens (_instance_shutdown_timeout :: OpsworksCustomLayerResource s -> TF.Attr s Text)
             (\s a -> s { _instance_shutdown_timeout = a } :: OpsworksCustomLayerResource s)

instance P.HasName (OpsworksCustomLayerResource s) (TF.Attr s Text) where
    name =
        lens (_name :: OpsworksCustomLayerResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: OpsworksCustomLayerResource s)

instance P.HasShortName (OpsworksCustomLayerResource s) (TF.Attr s Text) where
    shortName =
        lens (_short_name :: OpsworksCustomLayerResource s -> TF.Attr s Text)
             (\s a -> s { _short_name = a } :: OpsworksCustomLayerResource s)

instance P.HasStackId (OpsworksCustomLayerResource s) (TF.Attr s Text) where
    stackId =
        lens (_stack_id :: OpsworksCustomLayerResource s -> TF.Attr s Text)
             (\s a -> s { _stack_id = a } :: OpsworksCustomLayerResource s)

instance P.HasSystemPackages (OpsworksCustomLayerResource s) (TF.Attr s Text) where
    systemPackages =
        lens (_system_packages :: OpsworksCustomLayerResource s -> TF.Attr s Text)
             (\s a -> s { _system_packages = a } :: OpsworksCustomLayerResource s)

instance P.HasUseEbsOptimizedInstances (OpsworksCustomLayerResource s) (TF.Attr s Text) where
    useEbsOptimizedInstances =
        lens (_use_ebs_optimized_instances :: OpsworksCustomLayerResource s -> TF.Attr s Text)
             (\s a -> s { _use_ebs_optimized_instances = a } :: OpsworksCustomLayerResource s)

instance P.HasComputedAutoAssignElasticIps (OpsworksCustomLayerResource s) s (TF.Attr s Text) where
    computedAutoAssignElasticIps =
        (_auto_assign_elastic_ips :: OpsworksCustomLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAutoAssignPublicIps (OpsworksCustomLayerResource s) s (TF.Attr s Text) where
    computedAutoAssignPublicIps =
        (_auto_assign_public_ips :: OpsworksCustomLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAutoHealing (OpsworksCustomLayerResource s) s (TF.Attr s Text) where
    computedAutoHealing =
        (_auto_healing :: OpsworksCustomLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCustomInstanceProfileArn (OpsworksCustomLayerResource s) s (TF.Attr s Text) where
    computedCustomInstanceProfileArn =
        (_custom_instance_profile_arn :: OpsworksCustomLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCustomJson (OpsworksCustomLayerResource s) s (TF.Attr s Text) where
    computedCustomJson =
        (_custom_json :: OpsworksCustomLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCustomSecurityGroupIds (OpsworksCustomLayerResource s) s (TF.Attr s Text) where
    computedCustomSecurityGroupIds =
        (_custom_security_group_ids :: OpsworksCustomLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDrainElbOnShutdown (OpsworksCustomLayerResource s) s (TF.Attr s Text) where
    computedDrainElbOnShutdown =
        (_drain_elb_on_shutdown :: OpsworksCustomLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEbsVolume (OpsworksCustomLayerResource s) s (TF.Attr s Text) where
    computedEbsVolume =
        (_ebs_volume :: OpsworksCustomLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedElasticLoadBalancer (OpsworksCustomLayerResource s) s (TF.Attr s Text) where
    computedElasticLoadBalancer =
        (_elastic_load_balancer :: OpsworksCustomLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (OpsworksCustomLayerResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedInstallUpdatesOnBoot (OpsworksCustomLayerResource s) s (TF.Attr s Text) where
    computedInstallUpdatesOnBoot =
        (_install_updates_on_boot :: OpsworksCustomLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedInstanceShutdownTimeout (OpsworksCustomLayerResource s) s (TF.Attr s Text) where
    computedInstanceShutdownTimeout =
        (_instance_shutdown_timeout :: OpsworksCustomLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (OpsworksCustomLayerResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: OpsworksCustomLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedShortName (OpsworksCustomLayerResource s) s (TF.Attr s Text) where
    computedShortName =
        (_short_name :: OpsworksCustomLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedStackId (OpsworksCustomLayerResource s) s (TF.Attr s Text) where
    computedStackId =
        (_stack_id :: OpsworksCustomLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSystemPackages (OpsworksCustomLayerResource s) s (TF.Attr s Text) where
    computedSystemPackages =
        (_system_packages :: OpsworksCustomLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedUseEbsOptimizedInstances (OpsworksCustomLayerResource s) s (TF.Attr s Text) where
    computedUseEbsOptimizedInstances =
        (_use_ebs_optimized_instances :: OpsworksCustomLayerResource s -> TF.Attr s Text)
            . TF.refValue

opsworksCustomLayerResource :: TF.Schema TF.Resource P.AWS (OpsworksCustomLayerResource s)
opsworksCustomLayerResource =
    TF.newResource "aws_opsworks_custom_layer" $
        OpsworksCustomLayerResource {
              _auto_assign_elastic_ips = TF.Nil
            , _auto_assign_public_ips = TF.Nil
            , _auto_healing = TF.Nil
            , _custom_instance_profile_arn = TF.Nil
            , _custom_json = TF.Nil
            , _custom_security_group_ids = TF.Nil
            , _drain_elb_on_shutdown = TF.Nil
            , _ebs_volume = TF.Nil
            , _elastic_load_balancer = TF.Nil
            , _install_updates_on_boot = TF.Nil
            , _instance_shutdown_timeout = TF.Nil
            , _name = TF.Nil
            , _short_name = TF.Nil
            , _stack_id = TF.Nil
            , _system_packages = TF.Nil
            , _use_ebs_optimized_instances = TF.Nil
            }

{- | The @aws_opsworks_ganglia_layer@ AWS resource.

Provides an OpsWorks Ganglia layer resource.
-}
data OpsworksGangliaLayerResource s = OpsworksGangliaLayerResource {
      _auto_assign_elastic_ips     :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to automatically assign an elastic IP address to the layer's instances. -}
    , _auto_assign_public_ips      :: !(TF.Attr s Text)
    {- ^ (Optional) For stacks belonging to a VPC, whether to automatically assign a public IP address to each of the layer's instances. -}
    , _auto_healing                :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to enable auto-healing for the layer. -}
    , _custom_instance_profile_arn :: !(TF.Attr s Text)
    {- ^ (Optional) The ARN of an IAM profile that will be used for the layer's instances. -}
    , _custom_json                 :: !(TF.Attr s Text)
    {- ^ (Optional) Custom JSON attributes to apply to the layer. -}
    , _custom_security_group_ids   :: !(TF.Attr s Text)
    {- ^ (Optional) Ids for a set of security groups to apply to the layer's instances. -}
    , _drain_elb_on_shutdown       :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to enable Elastic Load Balancing connection draining. -}
    , _ebs_volume                  :: !(TF.Attr s Text)
    {- ^ (Optional) @ebs_volume@ blocks, as described below, will each create an EBS volume and connect it to the layer's instances. -}
    , _elastic_load_balancer       :: !(TF.Attr s Text)
    {- ^ (Optional) Name of an Elastic Load Balancer to attach to this layer -}
    , _install_updates_on_boot     :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to install OS and package updates on each instance when it boots. -}
    , _instance_shutdown_timeout   :: !(TF.Attr s Text)
    {- ^ (Optional) The time, in seconds, that OpsWorks will wait for Chef to complete after triggering the Shutdown event. -}
    , _name                        :: !(TF.Attr s Text)
    {- ^ (Optional) A human-readable name for the layer. -}
    , _password                    :: !(TF.Attr s Text)
    {- ^ (Required) The password to use for Ganglia. -}
    , _stack_id                    :: !(TF.Attr s Text)
    {- ^ (Required) The id of the stack the layer will belong to. -}
    , _system_packages             :: !(TF.Attr s Text)
    {- ^ (Optional) Names of a set of system packages to install on the layer's instances. -}
    , _url                         :: !(TF.Attr s Text)
    {- ^ (Optional) The URL path to use for Ganglia. Defaults to "/ganglia". -}
    , _use_ebs_optimized_instances :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to use EBS-optimized instances. -}
    , _username                    :: !(TF.Attr s Text)
    {- ^ - (Optiona) The username to use for Ganglia. Defaults to "opsworks". -}
    } deriving (Show, Eq)

instance TF.ToHCL (OpsworksGangliaLayerResource s) where
    toHCL OpsworksGangliaLayerResource{..} = TF.inline $ catMaybes
        [ TF.assign "auto_assign_elastic_ips" <$> TF.attribute _auto_assign_elastic_ips
        , TF.assign "auto_assign_public_ips" <$> TF.attribute _auto_assign_public_ips
        , TF.assign "auto_healing" <$> TF.attribute _auto_healing
        , TF.assign "custom_instance_profile_arn" <$> TF.attribute _custom_instance_profile_arn
        , TF.assign "custom_json" <$> TF.attribute _custom_json
        , TF.assign "custom_security_group_ids" <$> TF.attribute _custom_security_group_ids
        , TF.assign "drain_elb_on_shutdown" <$> TF.attribute _drain_elb_on_shutdown
        , TF.assign "ebs_volume" <$> TF.attribute _ebs_volume
        , TF.assign "elastic_load_balancer" <$> TF.attribute _elastic_load_balancer
        , TF.assign "install_updates_on_boot" <$> TF.attribute _install_updates_on_boot
        , TF.assign "instance_shutdown_timeout" <$> TF.attribute _instance_shutdown_timeout
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "password" <$> TF.attribute _password
        , TF.assign "stack_id" <$> TF.attribute _stack_id
        , TF.assign "system_packages" <$> TF.attribute _system_packages
        , TF.assign "url" <$> TF.attribute _url
        , TF.assign "use_ebs_optimized_instances" <$> TF.attribute _use_ebs_optimized_instances
        , TF.assign "username" <$> TF.attribute _username
        ]

instance P.HasAutoAssignElasticIps (OpsworksGangliaLayerResource s) (TF.Attr s Text) where
    autoAssignElasticIps =
        lens (_auto_assign_elastic_ips :: OpsworksGangliaLayerResource s -> TF.Attr s Text)
             (\s a -> s { _auto_assign_elastic_ips = a } :: OpsworksGangliaLayerResource s)

instance P.HasAutoAssignPublicIps (OpsworksGangliaLayerResource s) (TF.Attr s Text) where
    autoAssignPublicIps =
        lens (_auto_assign_public_ips :: OpsworksGangliaLayerResource s -> TF.Attr s Text)
             (\s a -> s { _auto_assign_public_ips = a } :: OpsworksGangliaLayerResource s)

instance P.HasAutoHealing (OpsworksGangliaLayerResource s) (TF.Attr s Text) where
    autoHealing =
        lens (_auto_healing :: OpsworksGangliaLayerResource s -> TF.Attr s Text)
             (\s a -> s { _auto_healing = a } :: OpsworksGangliaLayerResource s)

instance P.HasCustomInstanceProfileArn (OpsworksGangliaLayerResource s) (TF.Attr s Text) where
    customInstanceProfileArn =
        lens (_custom_instance_profile_arn :: OpsworksGangliaLayerResource s -> TF.Attr s Text)
             (\s a -> s { _custom_instance_profile_arn = a } :: OpsworksGangliaLayerResource s)

instance P.HasCustomJson (OpsworksGangliaLayerResource s) (TF.Attr s Text) where
    customJson =
        lens (_custom_json :: OpsworksGangliaLayerResource s -> TF.Attr s Text)
             (\s a -> s { _custom_json = a } :: OpsworksGangliaLayerResource s)

instance P.HasCustomSecurityGroupIds (OpsworksGangliaLayerResource s) (TF.Attr s Text) where
    customSecurityGroupIds =
        lens (_custom_security_group_ids :: OpsworksGangliaLayerResource s -> TF.Attr s Text)
             (\s a -> s { _custom_security_group_ids = a } :: OpsworksGangliaLayerResource s)

instance P.HasDrainElbOnShutdown (OpsworksGangliaLayerResource s) (TF.Attr s Text) where
    drainElbOnShutdown =
        lens (_drain_elb_on_shutdown :: OpsworksGangliaLayerResource s -> TF.Attr s Text)
             (\s a -> s { _drain_elb_on_shutdown = a } :: OpsworksGangliaLayerResource s)

instance P.HasEbsVolume (OpsworksGangliaLayerResource s) (TF.Attr s Text) where
    ebsVolume =
        lens (_ebs_volume :: OpsworksGangliaLayerResource s -> TF.Attr s Text)
             (\s a -> s { _ebs_volume = a } :: OpsworksGangliaLayerResource s)

instance P.HasElasticLoadBalancer (OpsworksGangliaLayerResource s) (TF.Attr s Text) where
    elasticLoadBalancer =
        lens (_elastic_load_balancer :: OpsworksGangliaLayerResource s -> TF.Attr s Text)
             (\s a -> s { _elastic_load_balancer = a } :: OpsworksGangliaLayerResource s)

instance P.HasInstallUpdatesOnBoot (OpsworksGangliaLayerResource s) (TF.Attr s Text) where
    installUpdatesOnBoot =
        lens (_install_updates_on_boot :: OpsworksGangliaLayerResource s -> TF.Attr s Text)
             (\s a -> s { _install_updates_on_boot = a } :: OpsworksGangliaLayerResource s)

instance P.HasInstanceShutdownTimeout (OpsworksGangliaLayerResource s) (TF.Attr s Text) where
    instanceShutdownTimeout =
        lens (_instance_shutdown_timeout :: OpsworksGangliaLayerResource s -> TF.Attr s Text)
             (\s a -> s { _instance_shutdown_timeout = a } :: OpsworksGangliaLayerResource s)

instance P.HasName (OpsworksGangliaLayerResource s) (TF.Attr s Text) where
    name =
        lens (_name :: OpsworksGangliaLayerResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: OpsworksGangliaLayerResource s)

instance P.HasPassword (OpsworksGangliaLayerResource s) (TF.Attr s Text) where
    password =
        lens (_password :: OpsworksGangliaLayerResource s -> TF.Attr s Text)
             (\s a -> s { _password = a } :: OpsworksGangliaLayerResource s)

instance P.HasStackId (OpsworksGangliaLayerResource s) (TF.Attr s Text) where
    stackId =
        lens (_stack_id :: OpsworksGangliaLayerResource s -> TF.Attr s Text)
             (\s a -> s { _stack_id = a } :: OpsworksGangliaLayerResource s)

instance P.HasSystemPackages (OpsworksGangliaLayerResource s) (TF.Attr s Text) where
    systemPackages =
        lens (_system_packages :: OpsworksGangliaLayerResource s -> TF.Attr s Text)
             (\s a -> s { _system_packages = a } :: OpsworksGangliaLayerResource s)

instance P.HasUrl (OpsworksGangliaLayerResource s) (TF.Attr s Text) where
    url =
        lens (_url :: OpsworksGangliaLayerResource s -> TF.Attr s Text)
             (\s a -> s { _url = a } :: OpsworksGangliaLayerResource s)

instance P.HasUseEbsOptimizedInstances (OpsworksGangliaLayerResource s) (TF.Attr s Text) where
    useEbsOptimizedInstances =
        lens (_use_ebs_optimized_instances :: OpsworksGangliaLayerResource s -> TF.Attr s Text)
             (\s a -> s { _use_ebs_optimized_instances = a } :: OpsworksGangliaLayerResource s)

instance P.HasUsername (OpsworksGangliaLayerResource s) (TF.Attr s Text) where
    username =
        lens (_username :: OpsworksGangliaLayerResource s -> TF.Attr s Text)
             (\s a -> s { _username = a } :: OpsworksGangliaLayerResource s)

instance P.HasComputedAutoAssignElasticIps (OpsworksGangliaLayerResource s) s (TF.Attr s Text) where
    computedAutoAssignElasticIps =
        (_auto_assign_elastic_ips :: OpsworksGangliaLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAutoAssignPublicIps (OpsworksGangliaLayerResource s) s (TF.Attr s Text) where
    computedAutoAssignPublicIps =
        (_auto_assign_public_ips :: OpsworksGangliaLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAutoHealing (OpsworksGangliaLayerResource s) s (TF.Attr s Text) where
    computedAutoHealing =
        (_auto_healing :: OpsworksGangliaLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCustomInstanceProfileArn (OpsworksGangliaLayerResource s) s (TF.Attr s Text) where
    computedCustomInstanceProfileArn =
        (_custom_instance_profile_arn :: OpsworksGangliaLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCustomJson (OpsworksGangliaLayerResource s) s (TF.Attr s Text) where
    computedCustomJson =
        (_custom_json :: OpsworksGangliaLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCustomSecurityGroupIds (OpsworksGangliaLayerResource s) s (TF.Attr s Text) where
    computedCustomSecurityGroupIds =
        (_custom_security_group_ids :: OpsworksGangliaLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDrainElbOnShutdown (OpsworksGangliaLayerResource s) s (TF.Attr s Text) where
    computedDrainElbOnShutdown =
        (_drain_elb_on_shutdown :: OpsworksGangliaLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEbsVolume (OpsworksGangliaLayerResource s) s (TF.Attr s Text) where
    computedEbsVolume =
        (_ebs_volume :: OpsworksGangliaLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedElasticLoadBalancer (OpsworksGangliaLayerResource s) s (TF.Attr s Text) where
    computedElasticLoadBalancer =
        (_elastic_load_balancer :: OpsworksGangliaLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (OpsworksGangliaLayerResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedInstallUpdatesOnBoot (OpsworksGangliaLayerResource s) s (TF.Attr s Text) where
    computedInstallUpdatesOnBoot =
        (_install_updates_on_boot :: OpsworksGangliaLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedInstanceShutdownTimeout (OpsworksGangliaLayerResource s) s (TF.Attr s Text) where
    computedInstanceShutdownTimeout =
        (_instance_shutdown_timeout :: OpsworksGangliaLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (OpsworksGangliaLayerResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: OpsworksGangliaLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPassword (OpsworksGangliaLayerResource s) s (TF.Attr s Text) where
    computedPassword =
        (_password :: OpsworksGangliaLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedStackId (OpsworksGangliaLayerResource s) s (TF.Attr s Text) where
    computedStackId =
        (_stack_id :: OpsworksGangliaLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSystemPackages (OpsworksGangliaLayerResource s) s (TF.Attr s Text) where
    computedSystemPackages =
        (_system_packages :: OpsworksGangliaLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedUrl (OpsworksGangliaLayerResource s) s (TF.Attr s Text) where
    computedUrl =
        (_url :: OpsworksGangliaLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedUseEbsOptimizedInstances (OpsworksGangliaLayerResource s) s (TF.Attr s Text) where
    computedUseEbsOptimizedInstances =
        (_use_ebs_optimized_instances :: OpsworksGangliaLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedUsername (OpsworksGangliaLayerResource s) s (TF.Attr s Text) where
    computedUsername =
        (_username :: OpsworksGangliaLayerResource s -> TF.Attr s Text)
            . TF.refValue

opsworksGangliaLayerResource :: TF.Schema TF.Resource P.AWS (OpsworksGangliaLayerResource s)
opsworksGangliaLayerResource =
    TF.newResource "aws_opsworks_ganglia_layer" $
        OpsworksGangliaLayerResource {
              _auto_assign_elastic_ips = TF.Nil
            , _auto_assign_public_ips = TF.Nil
            , _auto_healing = TF.Nil
            , _custom_instance_profile_arn = TF.Nil
            , _custom_json = TF.Nil
            , _custom_security_group_ids = TF.Nil
            , _drain_elb_on_shutdown = TF.Nil
            , _ebs_volume = TF.Nil
            , _elastic_load_balancer = TF.Nil
            , _install_updates_on_boot = TF.Nil
            , _instance_shutdown_timeout = TF.Nil
            , _name = TF.Nil
            , _password = TF.Nil
            , _stack_id = TF.Nil
            , _system_packages = TF.Nil
            , _url = TF.Nil
            , _use_ebs_optimized_instances = TF.Nil
            , _username = TF.Nil
            }

{- | The @aws_opsworks_haproxy_layer@ AWS resource.

Provides an OpsWorks haproxy layer resource.
-}
data OpsworksHaproxyLayerResource s = OpsworksHaproxyLayerResource {
      _auto_assign_elastic_ips     :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to automatically assign an elastic IP address to the layer's instances. -}
    , _auto_assign_public_ips      :: !(TF.Attr s Text)
    {- ^ (Optional) For stacks belonging to a VPC, whether to automatically assign a public IP address to each of the layer's instances. -}
    , _auto_healing                :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to enable auto-healing for the layer. -}
    , _custom_instance_profile_arn :: !(TF.Attr s Text)
    {- ^ (Optional) The ARN of an IAM profile that will be used for the layer's instances. -}
    , _custom_json                 :: !(TF.Attr s Text)
    {- ^ (Optional) Custom JSON attributes to apply to the layer. -}
    , _custom_security_group_ids   :: !(TF.Attr s Text)
    {- ^ (Optional) Ids for a set of security groups to apply to the layer's instances. -}
    , _drain_elb_on_shutdown       :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to enable Elastic Load Balancing connection draining. -}
    , _ebs_volume                  :: !(TF.Attr s Text)
    {- ^ (Optional) @ebs_volume@ blocks, as described below, will each create an EBS volume and connect it to the layer's instances. -}
    , _elastic_load_balancer       :: !(TF.Attr s Text)
    {- ^ (Optional) Name of an Elastic Load Balancer to attach to this layer -}
    , _healthcheck_method          :: !(TF.Attr s Text)
    {- ^ (Optional) HTTP method to use for instance healthchecks. Defaults to "OPTIONS". -}
    , _healthcheck_url             :: !(TF.Attr s Text)
    {- ^ (Optional) URL path to use for instance healthchecks. Defaults to "/". -}
    , _install_updates_on_boot     :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to install OS and package updates on each instance when it boots. -}
    , _instance_shutdown_timeout   :: !(TF.Attr s Text)
    {- ^ (Optional) The time, in seconds, that OpsWorks will wait for Chef to complete after triggering the Shutdown event. -}
    , _name                        :: !(TF.Attr s Text)
    {- ^ (Optional) A human-readable name for the layer. -}
    , _stack_id                    :: !(TF.Attr s Text)
    {- ^ (Required) The id of the stack the layer will belong to. -}
    , _stats_enabled               :: !(TF.Attr s P.Bool)
    {- ^ (Optional) Whether to enable HAProxy stats. -}
    , _stats_password              :: !(TF.Attr s Text)
    {- ^ (Required) The password to use for HAProxy stats. -}
    , _stats_url                   :: !(TF.Attr s Text)
    {- ^ (Optional) The HAProxy stats URL. Defaults to "/haproxy?stats". -}
    , _stats_user                  :: !(TF.Attr s Text)
    {- ^ (Optional) The username for HAProxy stats. Defaults to "opsworks". -}
    , _system_packages             :: !(TF.Attr s Text)
    {- ^ (Optional) Names of a set of system packages to install on the layer's instances. -}
    , _use_ebs_optimized_instances :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to use EBS-optimized instances. -}
    } deriving (Show, Eq)

instance TF.ToHCL (OpsworksHaproxyLayerResource s) where
    toHCL OpsworksHaproxyLayerResource{..} = TF.inline $ catMaybes
        [ TF.assign "auto_assign_elastic_ips" <$> TF.attribute _auto_assign_elastic_ips
        , TF.assign "auto_assign_public_ips" <$> TF.attribute _auto_assign_public_ips
        , TF.assign "auto_healing" <$> TF.attribute _auto_healing
        , TF.assign "custom_instance_profile_arn" <$> TF.attribute _custom_instance_profile_arn
        , TF.assign "custom_json" <$> TF.attribute _custom_json
        , TF.assign "custom_security_group_ids" <$> TF.attribute _custom_security_group_ids
        , TF.assign "drain_elb_on_shutdown" <$> TF.attribute _drain_elb_on_shutdown
        , TF.assign "ebs_volume" <$> TF.attribute _ebs_volume
        , TF.assign "elastic_load_balancer" <$> TF.attribute _elastic_load_balancer
        , TF.assign "healthcheck_method" <$> TF.attribute _healthcheck_method
        , TF.assign "healthcheck_url" <$> TF.attribute _healthcheck_url
        , TF.assign "install_updates_on_boot" <$> TF.attribute _install_updates_on_boot
        , TF.assign "instance_shutdown_timeout" <$> TF.attribute _instance_shutdown_timeout
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "stack_id" <$> TF.attribute _stack_id
        , TF.assign "stats_enabled" <$> TF.attribute _stats_enabled
        , TF.assign "stats_password" <$> TF.attribute _stats_password
        , TF.assign "stats_url" <$> TF.attribute _stats_url
        , TF.assign "stats_user" <$> TF.attribute _stats_user
        , TF.assign "system_packages" <$> TF.attribute _system_packages
        , TF.assign "use_ebs_optimized_instances" <$> TF.attribute _use_ebs_optimized_instances
        ]

instance P.HasAutoAssignElasticIps (OpsworksHaproxyLayerResource s) (TF.Attr s Text) where
    autoAssignElasticIps =
        lens (_auto_assign_elastic_ips :: OpsworksHaproxyLayerResource s -> TF.Attr s Text)
             (\s a -> s { _auto_assign_elastic_ips = a } :: OpsworksHaproxyLayerResource s)

instance P.HasAutoAssignPublicIps (OpsworksHaproxyLayerResource s) (TF.Attr s Text) where
    autoAssignPublicIps =
        lens (_auto_assign_public_ips :: OpsworksHaproxyLayerResource s -> TF.Attr s Text)
             (\s a -> s { _auto_assign_public_ips = a } :: OpsworksHaproxyLayerResource s)

instance P.HasAutoHealing (OpsworksHaproxyLayerResource s) (TF.Attr s Text) where
    autoHealing =
        lens (_auto_healing :: OpsworksHaproxyLayerResource s -> TF.Attr s Text)
             (\s a -> s { _auto_healing = a } :: OpsworksHaproxyLayerResource s)

instance P.HasCustomInstanceProfileArn (OpsworksHaproxyLayerResource s) (TF.Attr s Text) where
    customInstanceProfileArn =
        lens (_custom_instance_profile_arn :: OpsworksHaproxyLayerResource s -> TF.Attr s Text)
             (\s a -> s { _custom_instance_profile_arn = a } :: OpsworksHaproxyLayerResource s)

instance P.HasCustomJson (OpsworksHaproxyLayerResource s) (TF.Attr s Text) where
    customJson =
        lens (_custom_json :: OpsworksHaproxyLayerResource s -> TF.Attr s Text)
             (\s a -> s { _custom_json = a } :: OpsworksHaproxyLayerResource s)

instance P.HasCustomSecurityGroupIds (OpsworksHaproxyLayerResource s) (TF.Attr s Text) where
    customSecurityGroupIds =
        lens (_custom_security_group_ids :: OpsworksHaproxyLayerResource s -> TF.Attr s Text)
             (\s a -> s { _custom_security_group_ids = a } :: OpsworksHaproxyLayerResource s)

instance P.HasDrainElbOnShutdown (OpsworksHaproxyLayerResource s) (TF.Attr s Text) where
    drainElbOnShutdown =
        lens (_drain_elb_on_shutdown :: OpsworksHaproxyLayerResource s -> TF.Attr s Text)
             (\s a -> s { _drain_elb_on_shutdown = a } :: OpsworksHaproxyLayerResource s)

instance P.HasEbsVolume (OpsworksHaproxyLayerResource s) (TF.Attr s Text) where
    ebsVolume =
        lens (_ebs_volume :: OpsworksHaproxyLayerResource s -> TF.Attr s Text)
             (\s a -> s { _ebs_volume = a } :: OpsworksHaproxyLayerResource s)

instance P.HasElasticLoadBalancer (OpsworksHaproxyLayerResource s) (TF.Attr s Text) where
    elasticLoadBalancer =
        lens (_elastic_load_balancer :: OpsworksHaproxyLayerResource s -> TF.Attr s Text)
             (\s a -> s { _elastic_load_balancer = a } :: OpsworksHaproxyLayerResource s)

instance P.HasHealthcheckMethod (OpsworksHaproxyLayerResource s) (TF.Attr s Text) where
    healthcheckMethod =
        lens (_healthcheck_method :: OpsworksHaproxyLayerResource s -> TF.Attr s Text)
             (\s a -> s { _healthcheck_method = a } :: OpsworksHaproxyLayerResource s)

instance P.HasHealthcheckUrl (OpsworksHaproxyLayerResource s) (TF.Attr s Text) where
    healthcheckUrl =
        lens (_healthcheck_url :: OpsworksHaproxyLayerResource s -> TF.Attr s Text)
             (\s a -> s { _healthcheck_url = a } :: OpsworksHaproxyLayerResource s)

instance P.HasInstallUpdatesOnBoot (OpsworksHaproxyLayerResource s) (TF.Attr s Text) where
    installUpdatesOnBoot =
        lens (_install_updates_on_boot :: OpsworksHaproxyLayerResource s -> TF.Attr s Text)
             (\s a -> s { _install_updates_on_boot = a } :: OpsworksHaproxyLayerResource s)

instance P.HasInstanceShutdownTimeout (OpsworksHaproxyLayerResource s) (TF.Attr s Text) where
    instanceShutdownTimeout =
        lens (_instance_shutdown_timeout :: OpsworksHaproxyLayerResource s -> TF.Attr s Text)
             (\s a -> s { _instance_shutdown_timeout = a } :: OpsworksHaproxyLayerResource s)

instance P.HasName (OpsworksHaproxyLayerResource s) (TF.Attr s Text) where
    name =
        lens (_name :: OpsworksHaproxyLayerResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: OpsworksHaproxyLayerResource s)

instance P.HasStackId (OpsworksHaproxyLayerResource s) (TF.Attr s Text) where
    stackId =
        lens (_stack_id :: OpsworksHaproxyLayerResource s -> TF.Attr s Text)
             (\s a -> s { _stack_id = a } :: OpsworksHaproxyLayerResource s)

instance P.HasStatsEnabled (OpsworksHaproxyLayerResource s) (TF.Attr s P.Bool) where
    statsEnabled =
        lens (_stats_enabled :: OpsworksHaproxyLayerResource s -> TF.Attr s P.Bool)
             (\s a -> s { _stats_enabled = a } :: OpsworksHaproxyLayerResource s)

instance P.HasStatsPassword (OpsworksHaproxyLayerResource s) (TF.Attr s Text) where
    statsPassword =
        lens (_stats_password :: OpsworksHaproxyLayerResource s -> TF.Attr s Text)
             (\s a -> s { _stats_password = a } :: OpsworksHaproxyLayerResource s)

instance P.HasStatsUrl (OpsworksHaproxyLayerResource s) (TF.Attr s Text) where
    statsUrl =
        lens (_stats_url :: OpsworksHaproxyLayerResource s -> TF.Attr s Text)
             (\s a -> s { _stats_url = a } :: OpsworksHaproxyLayerResource s)

instance P.HasStatsUser (OpsworksHaproxyLayerResource s) (TF.Attr s Text) where
    statsUser =
        lens (_stats_user :: OpsworksHaproxyLayerResource s -> TF.Attr s Text)
             (\s a -> s { _stats_user = a } :: OpsworksHaproxyLayerResource s)

instance P.HasSystemPackages (OpsworksHaproxyLayerResource s) (TF.Attr s Text) where
    systemPackages =
        lens (_system_packages :: OpsworksHaproxyLayerResource s -> TF.Attr s Text)
             (\s a -> s { _system_packages = a } :: OpsworksHaproxyLayerResource s)

instance P.HasUseEbsOptimizedInstances (OpsworksHaproxyLayerResource s) (TF.Attr s Text) where
    useEbsOptimizedInstances =
        lens (_use_ebs_optimized_instances :: OpsworksHaproxyLayerResource s -> TF.Attr s Text)
             (\s a -> s { _use_ebs_optimized_instances = a } :: OpsworksHaproxyLayerResource s)

instance P.HasComputedAutoAssignElasticIps (OpsworksHaproxyLayerResource s) s (TF.Attr s Text) where
    computedAutoAssignElasticIps =
        (_auto_assign_elastic_ips :: OpsworksHaproxyLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAutoAssignPublicIps (OpsworksHaproxyLayerResource s) s (TF.Attr s Text) where
    computedAutoAssignPublicIps =
        (_auto_assign_public_ips :: OpsworksHaproxyLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAutoHealing (OpsworksHaproxyLayerResource s) s (TF.Attr s Text) where
    computedAutoHealing =
        (_auto_healing :: OpsworksHaproxyLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCustomInstanceProfileArn (OpsworksHaproxyLayerResource s) s (TF.Attr s Text) where
    computedCustomInstanceProfileArn =
        (_custom_instance_profile_arn :: OpsworksHaproxyLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCustomJson (OpsworksHaproxyLayerResource s) s (TF.Attr s Text) where
    computedCustomJson =
        (_custom_json :: OpsworksHaproxyLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCustomSecurityGroupIds (OpsworksHaproxyLayerResource s) s (TF.Attr s Text) where
    computedCustomSecurityGroupIds =
        (_custom_security_group_ids :: OpsworksHaproxyLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDrainElbOnShutdown (OpsworksHaproxyLayerResource s) s (TF.Attr s Text) where
    computedDrainElbOnShutdown =
        (_drain_elb_on_shutdown :: OpsworksHaproxyLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEbsVolume (OpsworksHaproxyLayerResource s) s (TF.Attr s Text) where
    computedEbsVolume =
        (_ebs_volume :: OpsworksHaproxyLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedElasticLoadBalancer (OpsworksHaproxyLayerResource s) s (TF.Attr s Text) where
    computedElasticLoadBalancer =
        (_elastic_load_balancer :: OpsworksHaproxyLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedHealthcheckMethod (OpsworksHaproxyLayerResource s) s (TF.Attr s Text) where
    computedHealthcheckMethod =
        (_healthcheck_method :: OpsworksHaproxyLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedHealthcheckUrl (OpsworksHaproxyLayerResource s) s (TF.Attr s Text) where
    computedHealthcheckUrl =
        (_healthcheck_url :: OpsworksHaproxyLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (OpsworksHaproxyLayerResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedInstallUpdatesOnBoot (OpsworksHaproxyLayerResource s) s (TF.Attr s Text) where
    computedInstallUpdatesOnBoot =
        (_install_updates_on_boot :: OpsworksHaproxyLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedInstanceShutdownTimeout (OpsworksHaproxyLayerResource s) s (TF.Attr s Text) where
    computedInstanceShutdownTimeout =
        (_instance_shutdown_timeout :: OpsworksHaproxyLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (OpsworksHaproxyLayerResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: OpsworksHaproxyLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedStackId (OpsworksHaproxyLayerResource s) s (TF.Attr s Text) where
    computedStackId =
        (_stack_id :: OpsworksHaproxyLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedStatsEnabled (OpsworksHaproxyLayerResource s) s (TF.Attr s P.Bool) where
    computedStatsEnabled =
        (_stats_enabled :: OpsworksHaproxyLayerResource s -> TF.Attr s P.Bool)
            . TF.refValue

instance P.HasComputedStatsPassword (OpsworksHaproxyLayerResource s) s (TF.Attr s Text) where
    computedStatsPassword =
        (_stats_password :: OpsworksHaproxyLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedStatsUrl (OpsworksHaproxyLayerResource s) s (TF.Attr s Text) where
    computedStatsUrl =
        (_stats_url :: OpsworksHaproxyLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedStatsUser (OpsworksHaproxyLayerResource s) s (TF.Attr s Text) where
    computedStatsUser =
        (_stats_user :: OpsworksHaproxyLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSystemPackages (OpsworksHaproxyLayerResource s) s (TF.Attr s Text) where
    computedSystemPackages =
        (_system_packages :: OpsworksHaproxyLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedUseEbsOptimizedInstances (OpsworksHaproxyLayerResource s) s (TF.Attr s Text) where
    computedUseEbsOptimizedInstances =
        (_use_ebs_optimized_instances :: OpsworksHaproxyLayerResource s -> TF.Attr s Text)
            . TF.refValue

opsworksHaproxyLayerResource :: TF.Schema TF.Resource P.AWS (OpsworksHaproxyLayerResource s)
opsworksHaproxyLayerResource =
    TF.newResource "aws_opsworks_haproxy_layer" $
        OpsworksHaproxyLayerResource {
              _auto_assign_elastic_ips = TF.Nil
            , _auto_assign_public_ips = TF.Nil
            , _auto_healing = TF.Nil
            , _custom_instance_profile_arn = TF.Nil
            , _custom_json = TF.Nil
            , _custom_security_group_ids = TF.Nil
            , _drain_elb_on_shutdown = TF.Nil
            , _ebs_volume = TF.Nil
            , _elastic_load_balancer = TF.Nil
            , _healthcheck_method = TF.Nil
            , _healthcheck_url = TF.Nil
            , _install_updates_on_boot = TF.Nil
            , _instance_shutdown_timeout = TF.Nil
            , _name = TF.Nil
            , _stack_id = TF.Nil
            , _stats_enabled = TF.Nil
            , _stats_password = TF.Nil
            , _stats_url = TF.Nil
            , _stats_user = TF.Nil
            , _system_packages = TF.Nil
            , _use_ebs_optimized_instances = TF.Nil
            }

{- | The @aws_opsworks_instance@ AWS resource.

Provides an OpsWorks instance resource.
-}
data OpsworksInstanceResource s = OpsworksInstanceResource {
      _agent_version           :: !(TF.Attr s Text)
    {- ^ (Optional) The AWS OpsWorks agent to install.  Defaults to @"INHERIT"@ . -}
    , _ami_id                  :: !(TF.Attr s Text)
    {- ^ (Optional) The AMI to use for the instance.  If an AMI is specified, @os@ must be @"Custom"@ . -}
    , _architecture            :: !(TF.Attr s Text)
    {- ^ (Optional) Machine architecture for created instances.  Can be either @"x86_64"@ (the default) or @"i386"@ -}
    , _auto_scaling_type       :: !(TF.Attr s Text)
    {- ^ (Optional) Creates load-based or time-based instances.  If set, can be either: @"load"@ or @"timer"@ . -}
    , _availability_zone       :: !(TF.Attr s P.Zone)
    {- ^ (Optional) Name of the availability zone where instances will be created by default. -}
    , _ebs_block_device        :: !(TF.Attr s Text)
    {- ^ (Optional) Additional EBS block devices to attach to the instance.  See <#block-devices> below for details. -}
    , _ebs_optimized           :: !(TF.Attr s Text)
    {- ^ (Optional) If true, the launched EC2 instance will be EBS-optimized. -}
    , _ephemeral_block_device  :: !(TF.Attr s Text)
    {- ^ (Optional) Customize Ephemeral (also known as "Instance Store") volumes on the instance. See <#block-devices> below for details. -}
    , _hostname                :: !(TF.Attr s Text)
    {- ^ (Optional) The instance's host name. -}
    , _install_updates_on_boot :: !(TF.Attr s Text)
    {- ^ (Optional) Controls where to install OS and package updates when the instance boots.  Defaults to @true@ . -}
    , _instance_type           :: !(TF.Attr s Text)
    {- ^ (Required) The type of instance to start -}
    , _layer_ids               :: !(TF.Attr s Text)
    {- ^ (Required) The ids of the layers the instance will belong to. -}
    , _os                      :: !(TF.Attr s Text)
    {- ^ (Optional) Name of operating system that will be installed. -}
    , _root_block_device       :: !(TF.Attr s Text)
    {- ^ (Optional) Customize details about the root block device of the instance. See <#block-devices> below for details. -}
    , _root_device_type        :: !(TF.Attr s Text)
    {- ^ (Optional) Name of the type of root device instances will have by default.  Can be either @"ebs"@ or @"instance-store"@ -}
    , _ssh_key_name            :: !(TF.Attr s Text)
    {- ^ (Optional) Name of the SSH keypair that instances will have by default. -}
    , _stack_id                :: !(TF.Attr s Text)
    {- ^ (Required) The id of the stack the instance will belong to. -}
    , _state                   :: !(TF.Attr s Text)
    {- ^ (Optional) The desired state of the instance.  Can be either @"running"@ or @"stopped"@ . -}
    , _subnet_id               :: !(TF.Attr s Text)
    {- ^ (Optional) Subnet ID to attach to -}
    , _tenancy                 :: !(TF.Attr s Text)
    {- ^ (Optional) Instance tenancy to use. Can be one of @"default"@ , @"dedicated"@ or @"host"@ -}
    , _virtualization_type     :: !(TF.Attr s Text)
    {- ^ (Optional) Keyword to choose what virtualization mode created instances will use. Can be either @"paravirtual"@ or @"hvm"@ . -}
    } deriving (Show, Eq)

instance TF.ToHCL (OpsworksInstanceResource s) where
    toHCL OpsworksInstanceResource{..} = TF.inline $ catMaybes
        [ TF.assign "agent_version" <$> TF.attribute _agent_version
        , TF.assign "ami_id" <$> TF.attribute _ami_id
        , TF.assign "architecture" <$> TF.attribute _architecture
        , TF.assign "auto_scaling_type" <$> TF.attribute _auto_scaling_type
        , TF.assign "availability_zone" <$> TF.attribute _availability_zone
        , TF.assign "ebs_block_device" <$> TF.attribute _ebs_block_device
        , TF.assign "ebs_optimized" <$> TF.attribute _ebs_optimized
        , TF.assign "ephemeral_block_device" <$> TF.attribute _ephemeral_block_device
        , TF.assign "hostname" <$> TF.attribute _hostname
        , TF.assign "install_updates_on_boot" <$> TF.attribute _install_updates_on_boot
        , TF.assign "instance_type" <$> TF.attribute _instance_type
        , TF.assign "layer_ids" <$> TF.attribute _layer_ids
        , TF.assign "os" <$> TF.attribute _os
        , TF.assign "root_block_device" <$> TF.attribute _root_block_device
        , TF.assign "root_device_type" <$> TF.attribute _root_device_type
        , TF.assign "ssh_key_name" <$> TF.attribute _ssh_key_name
        , TF.assign "stack_id" <$> TF.attribute _stack_id
        , TF.assign "state" <$> TF.attribute _state
        , TF.assign "subnet_id" <$> TF.attribute _subnet_id
        , TF.assign "tenancy" <$> TF.attribute _tenancy
        , TF.assign "virtualization_type" <$> TF.attribute _virtualization_type
        ]

instance P.HasAgentVersion (OpsworksInstanceResource s) (TF.Attr s Text) where
    agentVersion =
        lens (_agent_version :: OpsworksInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _agent_version = a } :: OpsworksInstanceResource s)

instance P.HasAmiId (OpsworksInstanceResource s) (TF.Attr s Text) where
    amiId =
        lens (_ami_id :: OpsworksInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _ami_id = a } :: OpsworksInstanceResource s)

instance P.HasArchitecture (OpsworksInstanceResource s) (TF.Attr s Text) where
    architecture =
        lens (_architecture :: OpsworksInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _architecture = a } :: OpsworksInstanceResource s)

instance P.HasAutoScalingType (OpsworksInstanceResource s) (TF.Attr s Text) where
    autoScalingType =
        lens (_auto_scaling_type :: OpsworksInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _auto_scaling_type = a } :: OpsworksInstanceResource s)

instance P.HasAvailabilityZone (OpsworksInstanceResource s) (TF.Attr s P.Zone) where
    availabilityZone =
        lens (_availability_zone :: OpsworksInstanceResource s -> TF.Attr s P.Zone)
             (\s a -> s { _availability_zone = a } :: OpsworksInstanceResource s)

instance P.HasEbsBlockDevice (OpsworksInstanceResource s) (TF.Attr s Text) where
    ebsBlockDevice =
        lens (_ebs_block_device :: OpsworksInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _ebs_block_device = a } :: OpsworksInstanceResource s)

instance P.HasEbsOptimized (OpsworksInstanceResource s) (TF.Attr s Text) where
    ebsOptimized =
        lens (_ebs_optimized :: OpsworksInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _ebs_optimized = a } :: OpsworksInstanceResource s)

instance P.HasEphemeralBlockDevice (OpsworksInstanceResource s) (TF.Attr s Text) where
    ephemeralBlockDevice =
        lens (_ephemeral_block_device :: OpsworksInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _ephemeral_block_device = a } :: OpsworksInstanceResource s)

instance P.HasHostname (OpsworksInstanceResource s) (TF.Attr s Text) where
    hostname =
        lens (_hostname :: OpsworksInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _hostname = a } :: OpsworksInstanceResource s)

instance P.HasInstallUpdatesOnBoot (OpsworksInstanceResource s) (TF.Attr s Text) where
    installUpdatesOnBoot =
        lens (_install_updates_on_boot :: OpsworksInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _install_updates_on_boot = a } :: OpsworksInstanceResource s)

instance P.HasInstanceType (OpsworksInstanceResource s) (TF.Attr s Text) where
    instanceType =
        lens (_instance_type :: OpsworksInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _instance_type = a } :: OpsworksInstanceResource s)

instance P.HasLayerIds (OpsworksInstanceResource s) (TF.Attr s Text) where
    layerIds =
        lens (_layer_ids :: OpsworksInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _layer_ids = a } :: OpsworksInstanceResource s)

instance P.HasOs (OpsworksInstanceResource s) (TF.Attr s Text) where
    os =
        lens (_os :: OpsworksInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _os = a } :: OpsworksInstanceResource s)

instance P.HasRootBlockDevice (OpsworksInstanceResource s) (TF.Attr s Text) where
    rootBlockDevice =
        lens (_root_block_device :: OpsworksInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _root_block_device = a } :: OpsworksInstanceResource s)

instance P.HasRootDeviceType (OpsworksInstanceResource s) (TF.Attr s Text) where
    rootDeviceType =
        lens (_root_device_type :: OpsworksInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _root_device_type = a } :: OpsworksInstanceResource s)

instance P.HasSshKeyName (OpsworksInstanceResource s) (TF.Attr s Text) where
    sshKeyName =
        lens (_ssh_key_name :: OpsworksInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _ssh_key_name = a } :: OpsworksInstanceResource s)

instance P.HasStackId (OpsworksInstanceResource s) (TF.Attr s Text) where
    stackId =
        lens (_stack_id :: OpsworksInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _stack_id = a } :: OpsworksInstanceResource s)

instance P.HasState (OpsworksInstanceResource s) (TF.Attr s Text) where
    state =
        lens (_state :: OpsworksInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _state = a } :: OpsworksInstanceResource s)

instance P.HasSubnetId (OpsworksInstanceResource s) (TF.Attr s Text) where
    subnetId =
        lens (_subnet_id :: OpsworksInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _subnet_id = a } :: OpsworksInstanceResource s)

instance P.HasTenancy (OpsworksInstanceResource s) (TF.Attr s Text) where
    tenancy =
        lens (_tenancy :: OpsworksInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _tenancy = a } :: OpsworksInstanceResource s)

instance P.HasVirtualizationType (OpsworksInstanceResource s) (TF.Attr s Text) where
    virtualizationType =
        lens (_virtualization_type :: OpsworksInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _virtualization_type = a } :: OpsworksInstanceResource s)

instance P.HasComputedAgentVersion (OpsworksInstanceResource s) s (TF.Attr s Text) where
    computedAgentVersion x = TF.compute (TF.refKey x) "agent_version"

instance P.HasComputedAmiId (OpsworksInstanceResource s) s (TF.Attr s Text) where
    computedAmiId =
        (_ami_id :: OpsworksInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedArchitecture (OpsworksInstanceResource s) s (TF.Attr s Text) where
    computedArchitecture =
        (_architecture :: OpsworksInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAutoScalingType (OpsworksInstanceResource s) s (TF.Attr s Text) where
    computedAutoScalingType =
        (_auto_scaling_type :: OpsworksInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAvailabilityZone (OpsworksInstanceResource s) s (TF.Attr s P.Zone) where
    computedAvailabilityZone x = TF.compute (TF.refKey x) "availability_zone"

instance P.HasComputedEbsBlockDevice (OpsworksInstanceResource s) s (TF.Attr s Text) where
    computedEbsBlockDevice =
        (_ebs_block_device :: OpsworksInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEbsOptimized (OpsworksInstanceResource s) s (TF.Attr s Text) where
    computedEbsOptimized =
        (_ebs_optimized :: OpsworksInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEphemeralBlockDevice (OpsworksInstanceResource s) s (TF.Attr s Text) where
    computedEphemeralBlockDevice =
        (_ephemeral_block_device :: OpsworksInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedHostname (OpsworksInstanceResource s) s (TF.Attr s Text) where
    computedHostname =
        (_hostname :: OpsworksInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (OpsworksInstanceResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedInstallUpdatesOnBoot (OpsworksInstanceResource s) s (TF.Attr s Text) where
    computedInstallUpdatesOnBoot =
        (_install_updates_on_boot :: OpsworksInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedInstanceType (OpsworksInstanceResource s) s (TF.Attr s Text) where
    computedInstanceType =
        (_instance_type :: OpsworksInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedLayerIds (OpsworksInstanceResource s) s (TF.Attr s Text) where
    computedLayerIds =
        (_layer_ids :: OpsworksInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedOs (OpsworksInstanceResource s) s (TF.Attr s Text) where
    computedOs =
        (_os :: OpsworksInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPrivateDns (OpsworksInstanceResource s) s (TF.Attr s Text) where
    computedPrivateDns x = TF.compute (TF.refKey x) "private_dns"

instance P.HasComputedPrivateIp (OpsworksInstanceResource s) s (TF.Attr s Text) where
    computedPrivateIp x = TF.compute (TF.refKey x) "private_ip"

instance P.HasComputedPublicDns (OpsworksInstanceResource s) s (TF.Attr s Text) where
    computedPublicDns x = TF.compute (TF.refKey x) "public_dns"

instance P.HasComputedPublicIp (OpsworksInstanceResource s) s (TF.Attr s Text) where
    computedPublicIp x = TF.compute (TF.refKey x) "public_ip"

instance P.HasComputedRootBlockDevice (OpsworksInstanceResource s) s (TF.Attr s Text) where
    computedRootBlockDevice =
        (_root_block_device :: OpsworksInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRootDeviceType (OpsworksInstanceResource s) s (TF.Attr s Text) where
    computedRootDeviceType =
        (_root_device_type :: OpsworksInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSecurityGroupIds (OpsworksInstanceResource s) s (TF.Attr s Text) where
    computedSecurityGroupIds x = TF.compute (TF.refKey x) "security_group_ids"

instance P.HasComputedSshKeyName (OpsworksInstanceResource s) s (TF.Attr s Text) where
    computedSshKeyName x = TF.compute (TF.refKey x) "ssh_key_name"

instance P.HasComputedStackId (OpsworksInstanceResource s) s (TF.Attr s Text) where
    computedStackId =
        (_stack_id :: OpsworksInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedState (OpsworksInstanceResource s) s (TF.Attr s Text) where
    computedState =
        (_state :: OpsworksInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSubnetId (OpsworksInstanceResource s) s (TF.Attr s Text) where
    computedSubnetId x = TF.compute (TF.refKey x) "subnet_id"

instance P.HasComputedTenancy (OpsworksInstanceResource s) s (TF.Attr s Text) where
    computedTenancy x = TF.compute (TF.refKey x) "tenancy"

instance P.HasComputedVirtualizationType (OpsworksInstanceResource s) s (TF.Attr s Text) where
    computedVirtualizationType =
        (_virtualization_type :: OpsworksInstanceResource s -> TF.Attr s Text)
            . TF.refValue

opsworksInstanceResource :: TF.Schema TF.Resource P.AWS (OpsworksInstanceResource s)
opsworksInstanceResource =
    TF.newResource "aws_opsworks_instance" $
        OpsworksInstanceResource {
              _agent_version = TF.Nil
            , _ami_id = TF.Nil
            , _architecture = TF.Nil
            , _auto_scaling_type = TF.Nil
            , _availability_zone = TF.Nil
            , _ebs_block_device = TF.Nil
            , _ebs_optimized = TF.Nil
            , _ephemeral_block_device = TF.Nil
            , _hostname = TF.Nil
            , _install_updates_on_boot = TF.Nil
            , _instance_type = TF.Nil
            , _layer_ids = TF.Nil
            , _os = TF.Nil
            , _root_block_device = TF.Nil
            , _root_device_type = TF.Nil
            , _ssh_key_name = TF.Nil
            , _stack_id = TF.Nil
            , _state = TF.Nil
            , _subnet_id = TF.Nil
            , _tenancy = TF.Nil
            , _virtualization_type = TF.Nil
            }

{- | The @aws_opsworks_java_app_layer@ AWS resource.

Provides an OpsWorks Java application layer resource.
-}
data OpsworksJavaAppLayerResource s = OpsworksJavaAppLayerResource {
      _app_server                  :: !(TF.Attr s Text)
    {- ^ (Optional) Keyword for the application container to use. Defaults to "tomcat". -}
    , _app_server_version          :: !(TF.Attr s Text)
    {- ^ (Optional) Version of the selected application container to use. Defaults to "7". -}
    , _auto_assign_elastic_ips     :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to automatically assign an elastic IP address to the layer's instances. -}
    , _auto_assign_public_ips      :: !(TF.Attr s Text)
    {- ^ (Optional) For stacks belonging to a VPC, whether to automatically assign a public IP address to each of the layer's instances. -}
    , _auto_healing                :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to enable auto-healing for the layer. -}
    , _custom_instance_profile_arn :: !(TF.Attr s Text)
    {- ^ (Optional) The ARN of an IAM profile that will be used for the layer's instances. -}
    , _custom_json                 :: !(TF.Attr s Text)
    {- ^ (Optional) Custom JSON attributes to apply to the layer. -}
    , _custom_security_group_ids   :: !(TF.Attr s Text)
    {- ^ (Optional) Ids for a set of security groups to apply to the layer's instances. -}
    , _drain_elb_on_shutdown       :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to enable Elastic Load Balancing connection draining. -}
    , _ebs_volume                  :: !(TF.Attr s Text)
    {- ^ (Optional) @ebs_volume@ blocks, as described below, will each create an EBS volume and connect it to the layer's instances. -}
    , _elastic_load_balancer       :: !(TF.Attr s Text)
    {- ^ (Optional) Name of an Elastic Load Balancer to attach to this layer -}
    , _install_updates_on_boot     :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to install OS and package updates on each instance when it boots. -}
    , _instance_shutdown_timeout   :: !(TF.Attr s Text)
    {- ^ (Optional) The time, in seconds, that OpsWorks will wait for Chef to complete after triggering the Shutdown event. -}
    , _jvm_options                 :: !(TF.Attr s Text)
    {- ^ (Optional) Options to set for the JVM. -}
    , _jvm_type                    :: !(TF.Attr s Text)
    {- ^ (Optional) Keyword for the type of JVM to use. Defaults to @openjdk@ . -}
    , _jvm_version                 :: !(TF.Attr s Text)
    {- ^ (Optional) Version of JVM to use. Defaults to "7". -}
    , _name                        :: !(TF.Attr s Text)
    {- ^ (Optional) A human-readable name for the layer. -}
    , _stack_id                    :: !(TF.Attr s Text)
    {- ^ (Required) The id of the stack the layer will belong to. -}
    , _system_packages             :: !(TF.Attr s Text)
    {- ^ (Optional) Names of a set of system packages to install on the layer's instances. -}
    , _use_ebs_optimized_instances :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to use EBS-optimized instances. -}
    } deriving (Show, Eq)

instance TF.ToHCL (OpsworksJavaAppLayerResource s) where
    toHCL OpsworksJavaAppLayerResource{..} = TF.inline $ catMaybes
        [ TF.assign "app_server" <$> TF.attribute _app_server
        , TF.assign "app_server_version" <$> TF.attribute _app_server_version
        , TF.assign "auto_assign_elastic_ips" <$> TF.attribute _auto_assign_elastic_ips
        , TF.assign "auto_assign_public_ips" <$> TF.attribute _auto_assign_public_ips
        , TF.assign "auto_healing" <$> TF.attribute _auto_healing
        , TF.assign "custom_instance_profile_arn" <$> TF.attribute _custom_instance_profile_arn
        , TF.assign "custom_json" <$> TF.attribute _custom_json
        , TF.assign "custom_security_group_ids" <$> TF.attribute _custom_security_group_ids
        , TF.assign "drain_elb_on_shutdown" <$> TF.attribute _drain_elb_on_shutdown
        , TF.assign "ebs_volume" <$> TF.attribute _ebs_volume
        , TF.assign "elastic_load_balancer" <$> TF.attribute _elastic_load_balancer
        , TF.assign "install_updates_on_boot" <$> TF.attribute _install_updates_on_boot
        , TF.assign "instance_shutdown_timeout" <$> TF.attribute _instance_shutdown_timeout
        , TF.assign "jvm_options" <$> TF.attribute _jvm_options
        , TF.assign "jvm_type" <$> TF.attribute _jvm_type
        , TF.assign "jvm_version" <$> TF.attribute _jvm_version
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "stack_id" <$> TF.attribute _stack_id
        , TF.assign "system_packages" <$> TF.attribute _system_packages
        , TF.assign "use_ebs_optimized_instances" <$> TF.attribute _use_ebs_optimized_instances
        ]

instance P.HasAppServer (OpsworksJavaAppLayerResource s) (TF.Attr s Text) where
    appServer =
        lens (_app_server :: OpsworksJavaAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _app_server = a } :: OpsworksJavaAppLayerResource s)

instance P.HasAppServerVersion (OpsworksJavaAppLayerResource s) (TF.Attr s Text) where
    appServerVersion =
        lens (_app_server_version :: OpsworksJavaAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _app_server_version = a } :: OpsworksJavaAppLayerResource s)

instance P.HasAutoAssignElasticIps (OpsworksJavaAppLayerResource s) (TF.Attr s Text) where
    autoAssignElasticIps =
        lens (_auto_assign_elastic_ips :: OpsworksJavaAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _auto_assign_elastic_ips = a } :: OpsworksJavaAppLayerResource s)

instance P.HasAutoAssignPublicIps (OpsworksJavaAppLayerResource s) (TF.Attr s Text) where
    autoAssignPublicIps =
        lens (_auto_assign_public_ips :: OpsworksJavaAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _auto_assign_public_ips = a } :: OpsworksJavaAppLayerResource s)

instance P.HasAutoHealing (OpsworksJavaAppLayerResource s) (TF.Attr s Text) where
    autoHealing =
        lens (_auto_healing :: OpsworksJavaAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _auto_healing = a } :: OpsworksJavaAppLayerResource s)

instance P.HasCustomInstanceProfileArn (OpsworksJavaAppLayerResource s) (TF.Attr s Text) where
    customInstanceProfileArn =
        lens (_custom_instance_profile_arn :: OpsworksJavaAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _custom_instance_profile_arn = a } :: OpsworksJavaAppLayerResource s)

instance P.HasCustomJson (OpsworksJavaAppLayerResource s) (TF.Attr s Text) where
    customJson =
        lens (_custom_json :: OpsworksJavaAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _custom_json = a } :: OpsworksJavaAppLayerResource s)

instance P.HasCustomSecurityGroupIds (OpsworksJavaAppLayerResource s) (TF.Attr s Text) where
    customSecurityGroupIds =
        lens (_custom_security_group_ids :: OpsworksJavaAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _custom_security_group_ids = a } :: OpsworksJavaAppLayerResource s)

instance P.HasDrainElbOnShutdown (OpsworksJavaAppLayerResource s) (TF.Attr s Text) where
    drainElbOnShutdown =
        lens (_drain_elb_on_shutdown :: OpsworksJavaAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _drain_elb_on_shutdown = a } :: OpsworksJavaAppLayerResource s)

instance P.HasEbsVolume (OpsworksJavaAppLayerResource s) (TF.Attr s Text) where
    ebsVolume =
        lens (_ebs_volume :: OpsworksJavaAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _ebs_volume = a } :: OpsworksJavaAppLayerResource s)

instance P.HasElasticLoadBalancer (OpsworksJavaAppLayerResource s) (TF.Attr s Text) where
    elasticLoadBalancer =
        lens (_elastic_load_balancer :: OpsworksJavaAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _elastic_load_balancer = a } :: OpsworksJavaAppLayerResource s)

instance P.HasInstallUpdatesOnBoot (OpsworksJavaAppLayerResource s) (TF.Attr s Text) where
    installUpdatesOnBoot =
        lens (_install_updates_on_boot :: OpsworksJavaAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _install_updates_on_boot = a } :: OpsworksJavaAppLayerResource s)

instance P.HasInstanceShutdownTimeout (OpsworksJavaAppLayerResource s) (TF.Attr s Text) where
    instanceShutdownTimeout =
        lens (_instance_shutdown_timeout :: OpsworksJavaAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _instance_shutdown_timeout = a } :: OpsworksJavaAppLayerResource s)

instance P.HasJvmOptions (OpsworksJavaAppLayerResource s) (TF.Attr s Text) where
    jvmOptions =
        lens (_jvm_options :: OpsworksJavaAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _jvm_options = a } :: OpsworksJavaAppLayerResource s)

instance P.HasJvmType (OpsworksJavaAppLayerResource s) (TF.Attr s Text) where
    jvmType =
        lens (_jvm_type :: OpsworksJavaAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _jvm_type = a } :: OpsworksJavaAppLayerResource s)

instance P.HasJvmVersion (OpsworksJavaAppLayerResource s) (TF.Attr s Text) where
    jvmVersion =
        lens (_jvm_version :: OpsworksJavaAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _jvm_version = a } :: OpsworksJavaAppLayerResource s)

instance P.HasName (OpsworksJavaAppLayerResource s) (TF.Attr s Text) where
    name =
        lens (_name :: OpsworksJavaAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: OpsworksJavaAppLayerResource s)

instance P.HasStackId (OpsworksJavaAppLayerResource s) (TF.Attr s Text) where
    stackId =
        lens (_stack_id :: OpsworksJavaAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _stack_id = a } :: OpsworksJavaAppLayerResource s)

instance P.HasSystemPackages (OpsworksJavaAppLayerResource s) (TF.Attr s Text) where
    systemPackages =
        lens (_system_packages :: OpsworksJavaAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _system_packages = a } :: OpsworksJavaAppLayerResource s)

instance P.HasUseEbsOptimizedInstances (OpsworksJavaAppLayerResource s) (TF.Attr s Text) where
    useEbsOptimizedInstances =
        lens (_use_ebs_optimized_instances :: OpsworksJavaAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _use_ebs_optimized_instances = a } :: OpsworksJavaAppLayerResource s)

instance P.HasComputedAppServer (OpsworksJavaAppLayerResource s) s (TF.Attr s Text) where
    computedAppServer =
        (_app_server :: OpsworksJavaAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAppServerVersion (OpsworksJavaAppLayerResource s) s (TF.Attr s Text) where
    computedAppServerVersion =
        (_app_server_version :: OpsworksJavaAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAutoAssignElasticIps (OpsworksJavaAppLayerResource s) s (TF.Attr s Text) where
    computedAutoAssignElasticIps =
        (_auto_assign_elastic_ips :: OpsworksJavaAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAutoAssignPublicIps (OpsworksJavaAppLayerResource s) s (TF.Attr s Text) where
    computedAutoAssignPublicIps =
        (_auto_assign_public_ips :: OpsworksJavaAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAutoHealing (OpsworksJavaAppLayerResource s) s (TF.Attr s Text) where
    computedAutoHealing =
        (_auto_healing :: OpsworksJavaAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCustomInstanceProfileArn (OpsworksJavaAppLayerResource s) s (TF.Attr s Text) where
    computedCustomInstanceProfileArn =
        (_custom_instance_profile_arn :: OpsworksJavaAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCustomJson (OpsworksJavaAppLayerResource s) s (TF.Attr s Text) where
    computedCustomJson =
        (_custom_json :: OpsworksJavaAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCustomSecurityGroupIds (OpsworksJavaAppLayerResource s) s (TF.Attr s Text) where
    computedCustomSecurityGroupIds =
        (_custom_security_group_ids :: OpsworksJavaAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDrainElbOnShutdown (OpsworksJavaAppLayerResource s) s (TF.Attr s Text) where
    computedDrainElbOnShutdown =
        (_drain_elb_on_shutdown :: OpsworksJavaAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEbsVolume (OpsworksJavaAppLayerResource s) s (TF.Attr s Text) where
    computedEbsVolume =
        (_ebs_volume :: OpsworksJavaAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedElasticLoadBalancer (OpsworksJavaAppLayerResource s) s (TF.Attr s Text) where
    computedElasticLoadBalancer =
        (_elastic_load_balancer :: OpsworksJavaAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (OpsworksJavaAppLayerResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedInstallUpdatesOnBoot (OpsworksJavaAppLayerResource s) s (TF.Attr s Text) where
    computedInstallUpdatesOnBoot =
        (_install_updates_on_boot :: OpsworksJavaAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedInstanceShutdownTimeout (OpsworksJavaAppLayerResource s) s (TF.Attr s Text) where
    computedInstanceShutdownTimeout =
        (_instance_shutdown_timeout :: OpsworksJavaAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedJvmOptions (OpsworksJavaAppLayerResource s) s (TF.Attr s Text) where
    computedJvmOptions =
        (_jvm_options :: OpsworksJavaAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedJvmType (OpsworksJavaAppLayerResource s) s (TF.Attr s Text) where
    computedJvmType =
        (_jvm_type :: OpsworksJavaAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedJvmVersion (OpsworksJavaAppLayerResource s) s (TF.Attr s Text) where
    computedJvmVersion =
        (_jvm_version :: OpsworksJavaAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (OpsworksJavaAppLayerResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: OpsworksJavaAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedStackId (OpsworksJavaAppLayerResource s) s (TF.Attr s Text) where
    computedStackId =
        (_stack_id :: OpsworksJavaAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSystemPackages (OpsworksJavaAppLayerResource s) s (TF.Attr s Text) where
    computedSystemPackages =
        (_system_packages :: OpsworksJavaAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedUseEbsOptimizedInstances (OpsworksJavaAppLayerResource s) s (TF.Attr s Text) where
    computedUseEbsOptimizedInstances =
        (_use_ebs_optimized_instances :: OpsworksJavaAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

opsworksJavaAppLayerResource :: TF.Schema TF.Resource P.AWS (OpsworksJavaAppLayerResource s)
opsworksJavaAppLayerResource =
    TF.newResource "aws_opsworks_java_app_layer" $
        OpsworksJavaAppLayerResource {
              _app_server = TF.Nil
            , _app_server_version = TF.Nil
            , _auto_assign_elastic_ips = TF.Nil
            , _auto_assign_public_ips = TF.Nil
            , _auto_healing = TF.Nil
            , _custom_instance_profile_arn = TF.Nil
            , _custom_json = TF.Nil
            , _custom_security_group_ids = TF.Nil
            , _drain_elb_on_shutdown = TF.Nil
            , _ebs_volume = TF.Nil
            , _elastic_load_balancer = TF.Nil
            , _install_updates_on_boot = TF.Nil
            , _instance_shutdown_timeout = TF.Nil
            , _jvm_options = TF.Nil
            , _jvm_type = TF.Nil
            , _jvm_version = TF.Nil
            , _name = TF.Nil
            , _stack_id = TF.Nil
            , _system_packages = TF.Nil
            , _use_ebs_optimized_instances = TF.Nil
            }

{- | The @aws_opsworks_memcached_layer@ AWS resource.

Provides an OpsWorks memcached layer resource.
-}
data OpsworksMemcachedLayerResource s = OpsworksMemcachedLayerResource {
      _allocated_memory            :: !(TF.Attr s Text)
    {- ^ (Optional) Amount of memory to allocate for the cache on each instance, in megabytes. Defaults to 512MB. -}
    , _auto_assign_elastic_ips     :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to automatically assign an elastic IP address to the layer's instances. -}
    , _auto_assign_public_ips      :: !(TF.Attr s Text)
    {- ^ (Optional) For stacks belonging to a VPC, whether to automatically assign a public IP address to each of the layer's instances. -}
    , _auto_healing                :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to enable auto-healing for the layer. -}
    , _custom_instance_profile_arn :: !(TF.Attr s Text)
    {- ^ (Optional) The ARN of an IAM profile that will be used for the layer's instances. -}
    , _custom_json                 :: !(TF.Attr s Text)
    {- ^ (Optional) Custom JSON attributes to apply to the layer. -}
    , _custom_security_group_ids   :: !(TF.Attr s Text)
    {- ^ (Optional) Ids for a set of security groups to apply to the layer's instances. -}
    , _drain_elb_on_shutdown       :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to enable Elastic Load Balancing connection draining. -}
    , _ebs_volume                  :: !(TF.Attr s Text)
    {- ^ (Optional) @ebs_volume@ blocks, as described below, will each create an EBS volume and connect it to the layer's instances. -}
    , _elastic_load_balancer       :: !(TF.Attr s Text)
    {- ^ (Optional) Name of an Elastic Load Balancer to attach to this layer -}
    , _install_updates_on_boot     :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to install OS and package updates on each instance when it boots. -}
    , _instance_shutdown_timeout   :: !(TF.Attr s Text)
    {- ^ (Optional) The time, in seconds, that OpsWorks will wait for Chef to complete after triggering the Shutdown event. -}
    , _name                        :: !(TF.Attr s Text)
    {- ^ (Optional) A human-readable name for the layer. -}
    , _stack_id                    :: !(TF.Attr s Text)
    {- ^ (Required) The id of the stack the layer will belong to. -}
    , _system_packages             :: !(TF.Attr s Text)
    {- ^ (Optional) Names of a set of system packages to install on the layer's instances. -}
    , _use_ebs_optimized_instances :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to use EBS-optimized instances. -}
    } deriving (Show, Eq)

instance TF.ToHCL (OpsworksMemcachedLayerResource s) where
    toHCL OpsworksMemcachedLayerResource{..} = TF.inline $ catMaybes
        [ TF.assign "allocated_memory" <$> TF.attribute _allocated_memory
        , TF.assign "auto_assign_elastic_ips" <$> TF.attribute _auto_assign_elastic_ips
        , TF.assign "auto_assign_public_ips" <$> TF.attribute _auto_assign_public_ips
        , TF.assign "auto_healing" <$> TF.attribute _auto_healing
        , TF.assign "custom_instance_profile_arn" <$> TF.attribute _custom_instance_profile_arn
        , TF.assign "custom_json" <$> TF.attribute _custom_json
        , TF.assign "custom_security_group_ids" <$> TF.attribute _custom_security_group_ids
        , TF.assign "drain_elb_on_shutdown" <$> TF.attribute _drain_elb_on_shutdown
        , TF.assign "ebs_volume" <$> TF.attribute _ebs_volume
        , TF.assign "elastic_load_balancer" <$> TF.attribute _elastic_load_balancer
        , TF.assign "install_updates_on_boot" <$> TF.attribute _install_updates_on_boot
        , TF.assign "instance_shutdown_timeout" <$> TF.attribute _instance_shutdown_timeout
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "stack_id" <$> TF.attribute _stack_id
        , TF.assign "system_packages" <$> TF.attribute _system_packages
        , TF.assign "use_ebs_optimized_instances" <$> TF.attribute _use_ebs_optimized_instances
        ]

instance P.HasAllocatedMemory (OpsworksMemcachedLayerResource s) (TF.Attr s Text) where
    allocatedMemory =
        lens (_allocated_memory :: OpsworksMemcachedLayerResource s -> TF.Attr s Text)
             (\s a -> s { _allocated_memory = a } :: OpsworksMemcachedLayerResource s)

instance P.HasAutoAssignElasticIps (OpsworksMemcachedLayerResource s) (TF.Attr s Text) where
    autoAssignElasticIps =
        lens (_auto_assign_elastic_ips :: OpsworksMemcachedLayerResource s -> TF.Attr s Text)
             (\s a -> s { _auto_assign_elastic_ips = a } :: OpsworksMemcachedLayerResource s)

instance P.HasAutoAssignPublicIps (OpsworksMemcachedLayerResource s) (TF.Attr s Text) where
    autoAssignPublicIps =
        lens (_auto_assign_public_ips :: OpsworksMemcachedLayerResource s -> TF.Attr s Text)
             (\s a -> s { _auto_assign_public_ips = a } :: OpsworksMemcachedLayerResource s)

instance P.HasAutoHealing (OpsworksMemcachedLayerResource s) (TF.Attr s Text) where
    autoHealing =
        lens (_auto_healing :: OpsworksMemcachedLayerResource s -> TF.Attr s Text)
             (\s a -> s { _auto_healing = a } :: OpsworksMemcachedLayerResource s)

instance P.HasCustomInstanceProfileArn (OpsworksMemcachedLayerResource s) (TF.Attr s Text) where
    customInstanceProfileArn =
        lens (_custom_instance_profile_arn :: OpsworksMemcachedLayerResource s -> TF.Attr s Text)
             (\s a -> s { _custom_instance_profile_arn = a } :: OpsworksMemcachedLayerResource s)

instance P.HasCustomJson (OpsworksMemcachedLayerResource s) (TF.Attr s Text) where
    customJson =
        lens (_custom_json :: OpsworksMemcachedLayerResource s -> TF.Attr s Text)
             (\s a -> s { _custom_json = a } :: OpsworksMemcachedLayerResource s)

instance P.HasCustomSecurityGroupIds (OpsworksMemcachedLayerResource s) (TF.Attr s Text) where
    customSecurityGroupIds =
        lens (_custom_security_group_ids :: OpsworksMemcachedLayerResource s -> TF.Attr s Text)
             (\s a -> s { _custom_security_group_ids = a } :: OpsworksMemcachedLayerResource s)

instance P.HasDrainElbOnShutdown (OpsworksMemcachedLayerResource s) (TF.Attr s Text) where
    drainElbOnShutdown =
        lens (_drain_elb_on_shutdown :: OpsworksMemcachedLayerResource s -> TF.Attr s Text)
             (\s a -> s { _drain_elb_on_shutdown = a } :: OpsworksMemcachedLayerResource s)

instance P.HasEbsVolume (OpsworksMemcachedLayerResource s) (TF.Attr s Text) where
    ebsVolume =
        lens (_ebs_volume :: OpsworksMemcachedLayerResource s -> TF.Attr s Text)
             (\s a -> s { _ebs_volume = a } :: OpsworksMemcachedLayerResource s)

instance P.HasElasticLoadBalancer (OpsworksMemcachedLayerResource s) (TF.Attr s Text) where
    elasticLoadBalancer =
        lens (_elastic_load_balancer :: OpsworksMemcachedLayerResource s -> TF.Attr s Text)
             (\s a -> s { _elastic_load_balancer = a } :: OpsworksMemcachedLayerResource s)

instance P.HasInstallUpdatesOnBoot (OpsworksMemcachedLayerResource s) (TF.Attr s Text) where
    installUpdatesOnBoot =
        lens (_install_updates_on_boot :: OpsworksMemcachedLayerResource s -> TF.Attr s Text)
             (\s a -> s { _install_updates_on_boot = a } :: OpsworksMemcachedLayerResource s)

instance P.HasInstanceShutdownTimeout (OpsworksMemcachedLayerResource s) (TF.Attr s Text) where
    instanceShutdownTimeout =
        lens (_instance_shutdown_timeout :: OpsworksMemcachedLayerResource s -> TF.Attr s Text)
             (\s a -> s { _instance_shutdown_timeout = a } :: OpsworksMemcachedLayerResource s)

instance P.HasName (OpsworksMemcachedLayerResource s) (TF.Attr s Text) where
    name =
        lens (_name :: OpsworksMemcachedLayerResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: OpsworksMemcachedLayerResource s)

instance P.HasStackId (OpsworksMemcachedLayerResource s) (TF.Attr s Text) where
    stackId =
        lens (_stack_id :: OpsworksMemcachedLayerResource s -> TF.Attr s Text)
             (\s a -> s { _stack_id = a } :: OpsworksMemcachedLayerResource s)

instance P.HasSystemPackages (OpsworksMemcachedLayerResource s) (TF.Attr s Text) where
    systemPackages =
        lens (_system_packages :: OpsworksMemcachedLayerResource s -> TF.Attr s Text)
             (\s a -> s { _system_packages = a } :: OpsworksMemcachedLayerResource s)

instance P.HasUseEbsOptimizedInstances (OpsworksMemcachedLayerResource s) (TF.Attr s Text) where
    useEbsOptimizedInstances =
        lens (_use_ebs_optimized_instances :: OpsworksMemcachedLayerResource s -> TF.Attr s Text)
             (\s a -> s { _use_ebs_optimized_instances = a } :: OpsworksMemcachedLayerResource s)

instance P.HasComputedAllocatedMemory (OpsworksMemcachedLayerResource s) s (TF.Attr s Text) where
    computedAllocatedMemory =
        (_allocated_memory :: OpsworksMemcachedLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAutoAssignElasticIps (OpsworksMemcachedLayerResource s) s (TF.Attr s Text) where
    computedAutoAssignElasticIps =
        (_auto_assign_elastic_ips :: OpsworksMemcachedLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAutoAssignPublicIps (OpsworksMemcachedLayerResource s) s (TF.Attr s Text) where
    computedAutoAssignPublicIps =
        (_auto_assign_public_ips :: OpsworksMemcachedLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAutoHealing (OpsworksMemcachedLayerResource s) s (TF.Attr s Text) where
    computedAutoHealing =
        (_auto_healing :: OpsworksMemcachedLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCustomInstanceProfileArn (OpsworksMemcachedLayerResource s) s (TF.Attr s Text) where
    computedCustomInstanceProfileArn =
        (_custom_instance_profile_arn :: OpsworksMemcachedLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCustomJson (OpsworksMemcachedLayerResource s) s (TF.Attr s Text) where
    computedCustomJson =
        (_custom_json :: OpsworksMemcachedLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCustomSecurityGroupIds (OpsworksMemcachedLayerResource s) s (TF.Attr s Text) where
    computedCustomSecurityGroupIds =
        (_custom_security_group_ids :: OpsworksMemcachedLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDrainElbOnShutdown (OpsworksMemcachedLayerResource s) s (TF.Attr s Text) where
    computedDrainElbOnShutdown =
        (_drain_elb_on_shutdown :: OpsworksMemcachedLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEbsVolume (OpsworksMemcachedLayerResource s) s (TF.Attr s Text) where
    computedEbsVolume =
        (_ebs_volume :: OpsworksMemcachedLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedElasticLoadBalancer (OpsworksMemcachedLayerResource s) s (TF.Attr s Text) where
    computedElasticLoadBalancer =
        (_elastic_load_balancer :: OpsworksMemcachedLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (OpsworksMemcachedLayerResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedInstallUpdatesOnBoot (OpsworksMemcachedLayerResource s) s (TF.Attr s Text) where
    computedInstallUpdatesOnBoot =
        (_install_updates_on_boot :: OpsworksMemcachedLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedInstanceShutdownTimeout (OpsworksMemcachedLayerResource s) s (TF.Attr s Text) where
    computedInstanceShutdownTimeout =
        (_instance_shutdown_timeout :: OpsworksMemcachedLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (OpsworksMemcachedLayerResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: OpsworksMemcachedLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedStackId (OpsworksMemcachedLayerResource s) s (TF.Attr s Text) where
    computedStackId =
        (_stack_id :: OpsworksMemcachedLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSystemPackages (OpsworksMemcachedLayerResource s) s (TF.Attr s Text) where
    computedSystemPackages =
        (_system_packages :: OpsworksMemcachedLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedUseEbsOptimizedInstances (OpsworksMemcachedLayerResource s) s (TF.Attr s Text) where
    computedUseEbsOptimizedInstances =
        (_use_ebs_optimized_instances :: OpsworksMemcachedLayerResource s -> TF.Attr s Text)
            . TF.refValue

opsworksMemcachedLayerResource :: TF.Schema TF.Resource P.AWS (OpsworksMemcachedLayerResource s)
opsworksMemcachedLayerResource =
    TF.newResource "aws_opsworks_memcached_layer" $
        OpsworksMemcachedLayerResource {
              _allocated_memory = TF.Nil
            , _auto_assign_elastic_ips = TF.Nil
            , _auto_assign_public_ips = TF.Nil
            , _auto_healing = TF.Nil
            , _custom_instance_profile_arn = TF.Nil
            , _custom_json = TF.Nil
            , _custom_security_group_ids = TF.Nil
            , _drain_elb_on_shutdown = TF.Nil
            , _ebs_volume = TF.Nil
            , _elastic_load_balancer = TF.Nil
            , _install_updates_on_boot = TF.Nil
            , _instance_shutdown_timeout = TF.Nil
            , _name = TF.Nil
            , _stack_id = TF.Nil
            , _system_packages = TF.Nil
            , _use_ebs_optimized_instances = TF.Nil
            }

{- | The @aws_opsworks_mysql_layer@ AWS resource.

Provides an OpsWorks MySQL layer resource. ~> Note: All arguments including
the root password will be stored in the raw state as plain-text.
</docs/state/sensitive-data.html> .
-}
data OpsworksMysqlLayerResource s = OpsworksMysqlLayerResource {
      _auto_assign_elastic_ips        :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to automatically assign an elastic IP address to the layer's instances. -}
    , _auto_assign_public_ips         :: !(TF.Attr s Text)
    {- ^ (Optional) For stacks belonging to a VPC, whether to automatically assign a public IP address to each of the layer's instances. -}
    , _auto_healing                   :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to enable auto-healing for the layer. -}
    , _custom_instance_profile_arn    :: !(TF.Attr s Text)
    {- ^ (Optional) The ARN of an IAM profile that will be used for the layer's instances. -}
    , _custom_json                    :: !(TF.Attr s Text)
    {- ^ (Optional) Custom JSON attributes to apply to the layer. -}
    , _custom_security_group_ids      :: !(TF.Attr s Text)
    {- ^ (Optional) Ids for a set of security groups to apply to the layer's instances. -}
    , _drain_elb_on_shutdown          :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to enable Elastic Load Balancing connection draining. -}
    , _ebs_volume                     :: !(TF.Attr s Text)
    {- ^ (Optional) @ebs_volume@ blocks, as described below, will each create an EBS volume and connect it to the layer's instances. -}
    , _elastic_load_balancer          :: !(TF.Attr s Text)
    {- ^ (Optional) Name of an Elastic Load Balancer to attach to this layer -}
    , _install_updates_on_boot        :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to install OS and package updates on each instance when it boots. -}
    , _instance_shutdown_timeout      :: !(TF.Attr s Text)
    {- ^ (Optional) The time, in seconds, that OpsWorks will wait for Chef to complete after triggering the Shutdown event. -}
    , _name                           :: !(TF.Attr s Text)
    {- ^ (Optional) A human-readable name for the layer. -}
    , _root_password                  :: !(TF.Attr s Text)
    {- ^ (Optional) Root password to use for MySQL. -}
    , _root_password_on_all_instances :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to set the root user password to all instances in the stack so they can access the instances in this layer. -}
    , _stack_id                       :: !(TF.Attr s Text)
    {- ^ (Required) The id of the stack the layer will belong to. -}
    , _system_packages                :: !(TF.Attr s Text)
    {- ^ (Optional) Names of a set of system packages to install on the layer's instances. -}
    , _use_ebs_optimized_instances    :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to use EBS-optimized instances. -}
    } deriving (Show, Eq)

instance TF.ToHCL (OpsworksMysqlLayerResource s) where
    toHCL OpsworksMysqlLayerResource{..} = TF.inline $ catMaybes
        [ TF.assign "auto_assign_elastic_ips" <$> TF.attribute _auto_assign_elastic_ips
        , TF.assign "auto_assign_public_ips" <$> TF.attribute _auto_assign_public_ips
        , TF.assign "auto_healing" <$> TF.attribute _auto_healing
        , TF.assign "custom_instance_profile_arn" <$> TF.attribute _custom_instance_profile_arn
        , TF.assign "custom_json" <$> TF.attribute _custom_json
        , TF.assign "custom_security_group_ids" <$> TF.attribute _custom_security_group_ids
        , TF.assign "drain_elb_on_shutdown" <$> TF.attribute _drain_elb_on_shutdown
        , TF.assign "ebs_volume" <$> TF.attribute _ebs_volume
        , TF.assign "elastic_load_balancer" <$> TF.attribute _elastic_load_balancer
        , TF.assign "install_updates_on_boot" <$> TF.attribute _install_updates_on_boot
        , TF.assign "instance_shutdown_timeout" <$> TF.attribute _instance_shutdown_timeout
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "root_password" <$> TF.attribute _root_password
        , TF.assign "root_password_on_all_instances" <$> TF.attribute _root_password_on_all_instances
        , TF.assign "stack_id" <$> TF.attribute _stack_id
        , TF.assign "system_packages" <$> TF.attribute _system_packages
        , TF.assign "use_ebs_optimized_instances" <$> TF.attribute _use_ebs_optimized_instances
        ]

instance P.HasAutoAssignElasticIps (OpsworksMysqlLayerResource s) (TF.Attr s Text) where
    autoAssignElasticIps =
        lens (_auto_assign_elastic_ips :: OpsworksMysqlLayerResource s -> TF.Attr s Text)
             (\s a -> s { _auto_assign_elastic_ips = a } :: OpsworksMysqlLayerResource s)

instance P.HasAutoAssignPublicIps (OpsworksMysqlLayerResource s) (TF.Attr s Text) where
    autoAssignPublicIps =
        lens (_auto_assign_public_ips :: OpsworksMysqlLayerResource s -> TF.Attr s Text)
             (\s a -> s { _auto_assign_public_ips = a } :: OpsworksMysqlLayerResource s)

instance P.HasAutoHealing (OpsworksMysqlLayerResource s) (TF.Attr s Text) where
    autoHealing =
        lens (_auto_healing :: OpsworksMysqlLayerResource s -> TF.Attr s Text)
             (\s a -> s { _auto_healing = a } :: OpsworksMysqlLayerResource s)

instance P.HasCustomInstanceProfileArn (OpsworksMysqlLayerResource s) (TF.Attr s Text) where
    customInstanceProfileArn =
        lens (_custom_instance_profile_arn :: OpsworksMysqlLayerResource s -> TF.Attr s Text)
             (\s a -> s { _custom_instance_profile_arn = a } :: OpsworksMysqlLayerResource s)

instance P.HasCustomJson (OpsworksMysqlLayerResource s) (TF.Attr s Text) where
    customJson =
        lens (_custom_json :: OpsworksMysqlLayerResource s -> TF.Attr s Text)
             (\s a -> s { _custom_json = a } :: OpsworksMysqlLayerResource s)

instance P.HasCustomSecurityGroupIds (OpsworksMysqlLayerResource s) (TF.Attr s Text) where
    customSecurityGroupIds =
        lens (_custom_security_group_ids :: OpsworksMysqlLayerResource s -> TF.Attr s Text)
             (\s a -> s { _custom_security_group_ids = a } :: OpsworksMysqlLayerResource s)

instance P.HasDrainElbOnShutdown (OpsworksMysqlLayerResource s) (TF.Attr s Text) where
    drainElbOnShutdown =
        lens (_drain_elb_on_shutdown :: OpsworksMysqlLayerResource s -> TF.Attr s Text)
             (\s a -> s { _drain_elb_on_shutdown = a } :: OpsworksMysqlLayerResource s)

instance P.HasEbsVolume (OpsworksMysqlLayerResource s) (TF.Attr s Text) where
    ebsVolume =
        lens (_ebs_volume :: OpsworksMysqlLayerResource s -> TF.Attr s Text)
             (\s a -> s { _ebs_volume = a } :: OpsworksMysqlLayerResource s)

instance P.HasElasticLoadBalancer (OpsworksMysqlLayerResource s) (TF.Attr s Text) where
    elasticLoadBalancer =
        lens (_elastic_load_balancer :: OpsworksMysqlLayerResource s -> TF.Attr s Text)
             (\s a -> s { _elastic_load_balancer = a } :: OpsworksMysqlLayerResource s)

instance P.HasInstallUpdatesOnBoot (OpsworksMysqlLayerResource s) (TF.Attr s Text) where
    installUpdatesOnBoot =
        lens (_install_updates_on_boot :: OpsworksMysqlLayerResource s -> TF.Attr s Text)
             (\s a -> s { _install_updates_on_boot = a } :: OpsworksMysqlLayerResource s)

instance P.HasInstanceShutdownTimeout (OpsworksMysqlLayerResource s) (TF.Attr s Text) where
    instanceShutdownTimeout =
        lens (_instance_shutdown_timeout :: OpsworksMysqlLayerResource s -> TF.Attr s Text)
             (\s a -> s { _instance_shutdown_timeout = a } :: OpsworksMysqlLayerResource s)

instance P.HasName (OpsworksMysqlLayerResource s) (TF.Attr s Text) where
    name =
        lens (_name :: OpsworksMysqlLayerResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: OpsworksMysqlLayerResource s)

instance P.HasRootPassword (OpsworksMysqlLayerResource s) (TF.Attr s Text) where
    rootPassword =
        lens (_root_password :: OpsworksMysqlLayerResource s -> TF.Attr s Text)
             (\s a -> s { _root_password = a } :: OpsworksMysqlLayerResource s)

instance P.HasRootPasswordOnAllInstances (OpsworksMysqlLayerResource s) (TF.Attr s Text) where
    rootPasswordOnAllInstances =
        lens (_root_password_on_all_instances :: OpsworksMysqlLayerResource s -> TF.Attr s Text)
             (\s a -> s { _root_password_on_all_instances = a } :: OpsworksMysqlLayerResource s)

instance P.HasStackId (OpsworksMysqlLayerResource s) (TF.Attr s Text) where
    stackId =
        lens (_stack_id :: OpsworksMysqlLayerResource s -> TF.Attr s Text)
             (\s a -> s { _stack_id = a } :: OpsworksMysqlLayerResource s)

instance P.HasSystemPackages (OpsworksMysqlLayerResource s) (TF.Attr s Text) where
    systemPackages =
        lens (_system_packages :: OpsworksMysqlLayerResource s -> TF.Attr s Text)
             (\s a -> s { _system_packages = a } :: OpsworksMysqlLayerResource s)

instance P.HasUseEbsOptimizedInstances (OpsworksMysqlLayerResource s) (TF.Attr s Text) where
    useEbsOptimizedInstances =
        lens (_use_ebs_optimized_instances :: OpsworksMysqlLayerResource s -> TF.Attr s Text)
             (\s a -> s { _use_ebs_optimized_instances = a } :: OpsworksMysqlLayerResource s)

instance P.HasComputedAutoAssignElasticIps (OpsworksMysqlLayerResource s) s (TF.Attr s Text) where
    computedAutoAssignElasticIps =
        (_auto_assign_elastic_ips :: OpsworksMysqlLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAutoAssignPublicIps (OpsworksMysqlLayerResource s) s (TF.Attr s Text) where
    computedAutoAssignPublicIps =
        (_auto_assign_public_ips :: OpsworksMysqlLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAutoHealing (OpsworksMysqlLayerResource s) s (TF.Attr s Text) where
    computedAutoHealing =
        (_auto_healing :: OpsworksMysqlLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCustomInstanceProfileArn (OpsworksMysqlLayerResource s) s (TF.Attr s Text) where
    computedCustomInstanceProfileArn =
        (_custom_instance_profile_arn :: OpsworksMysqlLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCustomJson (OpsworksMysqlLayerResource s) s (TF.Attr s Text) where
    computedCustomJson =
        (_custom_json :: OpsworksMysqlLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCustomSecurityGroupIds (OpsworksMysqlLayerResource s) s (TF.Attr s Text) where
    computedCustomSecurityGroupIds =
        (_custom_security_group_ids :: OpsworksMysqlLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDrainElbOnShutdown (OpsworksMysqlLayerResource s) s (TF.Attr s Text) where
    computedDrainElbOnShutdown =
        (_drain_elb_on_shutdown :: OpsworksMysqlLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEbsVolume (OpsworksMysqlLayerResource s) s (TF.Attr s Text) where
    computedEbsVolume =
        (_ebs_volume :: OpsworksMysqlLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedElasticLoadBalancer (OpsworksMysqlLayerResource s) s (TF.Attr s Text) where
    computedElasticLoadBalancer =
        (_elastic_load_balancer :: OpsworksMysqlLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (OpsworksMysqlLayerResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedInstallUpdatesOnBoot (OpsworksMysqlLayerResource s) s (TF.Attr s Text) where
    computedInstallUpdatesOnBoot =
        (_install_updates_on_boot :: OpsworksMysqlLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedInstanceShutdownTimeout (OpsworksMysqlLayerResource s) s (TF.Attr s Text) where
    computedInstanceShutdownTimeout =
        (_instance_shutdown_timeout :: OpsworksMysqlLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (OpsworksMysqlLayerResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: OpsworksMysqlLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRootPassword (OpsworksMysqlLayerResource s) s (TF.Attr s Text) where
    computedRootPassword =
        (_root_password :: OpsworksMysqlLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRootPasswordOnAllInstances (OpsworksMysqlLayerResource s) s (TF.Attr s Text) where
    computedRootPasswordOnAllInstances =
        (_root_password_on_all_instances :: OpsworksMysqlLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedStackId (OpsworksMysqlLayerResource s) s (TF.Attr s Text) where
    computedStackId =
        (_stack_id :: OpsworksMysqlLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSystemPackages (OpsworksMysqlLayerResource s) s (TF.Attr s Text) where
    computedSystemPackages =
        (_system_packages :: OpsworksMysqlLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedUseEbsOptimizedInstances (OpsworksMysqlLayerResource s) s (TF.Attr s Text) where
    computedUseEbsOptimizedInstances =
        (_use_ebs_optimized_instances :: OpsworksMysqlLayerResource s -> TF.Attr s Text)
            . TF.refValue

opsworksMysqlLayerResource :: TF.Schema TF.Resource P.AWS (OpsworksMysqlLayerResource s)
opsworksMysqlLayerResource =
    TF.newResource "aws_opsworks_mysql_layer" $
        OpsworksMysqlLayerResource {
              _auto_assign_elastic_ips = TF.Nil
            , _auto_assign_public_ips = TF.Nil
            , _auto_healing = TF.Nil
            , _custom_instance_profile_arn = TF.Nil
            , _custom_json = TF.Nil
            , _custom_security_group_ids = TF.Nil
            , _drain_elb_on_shutdown = TF.Nil
            , _ebs_volume = TF.Nil
            , _elastic_load_balancer = TF.Nil
            , _install_updates_on_boot = TF.Nil
            , _instance_shutdown_timeout = TF.Nil
            , _name = TF.Nil
            , _root_password = TF.Nil
            , _root_password_on_all_instances = TF.Nil
            , _stack_id = TF.Nil
            , _system_packages = TF.Nil
            , _use_ebs_optimized_instances = TF.Nil
            }

{- | The @aws_opsworks_nodejs_app_layer@ AWS resource.

Provides an OpsWorks NodeJS application layer resource.
-}
data OpsworksNodejsAppLayerResource s = OpsworksNodejsAppLayerResource {
      _auto_assign_elastic_ips     :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to automatically assign an elastic IP address to the layer's instances. -}
    , _auto_assign_public_ips      :: !(TF.Attr s Text)
    {- ^ (Optional) For stacks belonging to a VPC, whether to automatically assign a public IP address to each of the layer's instances. -}
    , _auto_healing                :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to enable auto-healing for the layer. -}
    , _custom_instance_profile_arn :: !(TF.Attr s Text)
    {- ^ (Optional) The ARN of an IAM profile that will be used for the layer's instances. -}
    , _custom_json                 :: !(TF.Attr s Text)
    {- ^ (Optional) Custom JSON attributes to apply to the layer. -}
    , _custom_security_group_ids   :: !(TF.Attr s Text)
    {- ^ (Optional) Ids for a set of security groups to apply to the layer's instances. -}
    , _drain_elb_on_shutdown       :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to enable Elastic Load Balancing connection draining. -}
    , _ebs_volume                  :: !(TF.Attr s Text)
    {- ^ (Optional) @ebs_volume@ blocks, as described below, will each create an EBS volume and connect it to the layer's instances. -}
    , _elastic_load_balancer       :: !(TF.Attr s Text)
    {- ^ (Optional) Name of an Elastic Load Balancer to attach to this layer -}
    , _install_updates_on_boot     :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to install OS and package updates on each instance when it boots. -}
    , _instance_shutdown_timeout   :: !(TF.Attr s Text)
    {- ^ (Optional) The time, in seconds, that OpsWorks will wait for Chef to complete after triggering the Shutdown event. -}
    , _name                        :: !(TF.Attr s Text)
    {- ^ (Optional) A human-readable name for the layer. -}
    , _nodejs_version              :: !(TF.Attr s Text)
    {- ^ (Optional) The version of NodeJS to use. Defaults to "0.10.38". -}
    , _stack_id                    :: !(TF.Attr s Text)
    {- ^ (Required) The id of the stack the layer will belong to. -}
    , _system_packages             :: !(TF.Attr s Text)
    {- ^ (Optional) Names of a set of system packages to install on the layer's instances. -}
    , _use_ebs_optimized_instances :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to use EBS-optimized instances. -}
    } deriving (Show, Eq)

instance TF.ToHCL (OpsworksNodejsAppLayerResource s) where
    toHCL OpsworksNodejsAppLayerResource{..} = TF.inline $ catMaybes
        [ TF.assign "auto_assign_elastic_ips" <$> TF.attribute _auto_assign_elastic_ips
        , TF.assign "auto_assign_public_ips" <$> TF.attribute _auto_assign_public_ips
        , TF.assign "auto_healing" <$> TF.attribute _auto_healing
        , TF.assign "custom_instance_profile_arn" <$> TF.attribute _custom_instance_profile_arn
        , TF.assign "custom_json" <$> TF.attribute _custom_json
        , TF.assign "custom_security_group_ids" <$> TF.attribute _custom_security_group_ids
        , TF.assign "drain_elb_on_shutdown" <$> TF.attribute _drain_elb_on_shutdown
        , TF.assign "ebs_volume" <$> TF.attribute _ebs_volume
        , TF.assign "elastic_load_balancer" <$> TF.attribute _elastic_load_balancer
        , TF.assign "install_updates_on_boot" <$> TF.attribute _install_updates_on_boot
        , TF.assign "instance_shutdown_timeout" <$> TF.attribute _instance_shutdown_timeout
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "nodejs_version" <$> TF.attribute _nodejs_version
        , TF.assign "stack_id" <$> TF.attribute _stack_id
        , TF.assign "system_packages" <$> TF.attribute _system_packages
        , TF.assign "use_ebs_optimized_instances" <$> TF.attribute _use_ebs_optimized_instances
        ]

instance P.HasAutoAssignElasticIps (OpsworksNodejsAppLayerResource s) (TF.Attr s Text) where
    autoAssignElasticIps =
        lens (_auto_assign_elastic_ips :: OpsworksNodejsAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _auto_assign_elastic_ips = a } :: OpsworksNodejsAppLayerResource s)

instance P.HasAutoAssignPublicIps (OpsworksNodejsAppLayerResource s) (TF.Attr s Text) where
    autoAssignPublicIps =
        lens (_auto_assign_public_ips :: OpsworksNodejsAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _auto_assign_public_ips = a } :: OpsworksNodejsAppLayerResource s)

instance P.HasAutoHealing (OpsworksNodejsAppLayerResource s) (TF.Attr s Text) where
    autoHealing =
        lens (_auto_healing :: OpsworksNodejsAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _auto_healing = a } :: OpsworksNodejsAppLayerResource s)

instance P.HasCustomInstanceProfileArn (OpsworksNodejsAppLayerResource s) (TF.Attr s Text) where
    customInstanceProfileArn =
        lens (_custom_instance_profile_arn :: OpsworksNodejsAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _custom_instance_profile_arn = a } :: OpsworksNodejsAppLayerResource s)

instance P.HasCustomJson (OpsworksNodejsAppLayerResource s) (TF.Attr s Text) where
    customJson =
        lens (_custom_json :: OpsworksNodejsAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _custom_json = a } :: OpsworksNodejsAppLayerResource s)

instance P.HasCustomSecurityGroupIds (OpsworksNodejsAppLayerResource s) (TF.Attr s Text) where
    customSecurityGroupIds =
        lens (_custom_security_group_ids :: OpsworksNodejsAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _custom_security_group_ids = a } :: OpsworksNodejsAppLayerResource s)

instance P.HasDrainElbOnShutdown (OpsworksNodejsAppLayerResource s) (TF.Attr s Text) where
    drainElbOnShutdown =
        lens (_drain_elb_on_shutdown :: OpsworksNodejsAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _drain_elb_on_shutdown = a } :: OpsworksNodejsAppLayerResource s)

instance P.HasEbsVolume (OpsworksNodejsAppLayerResource s) (TF.Attr s Text) where
    ebsVolume =
        lens (_ebs_volume :: OpsworksNodejsAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _ebs_volume = a } :: OpsworksNodejsAppLayerResource s)

instance P.HasElasticLoadBalancer (OpsworksNodejsAppLayerResource s) (TF.Attr s Text) where
    elasticLoadBalancer =
        lens (_elastic_load_balancer :: OpsworksNodejsAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _elastic_load_balancer = a } :: OpsworksNodejsAppLayerResource s)

instance P.HasInstallUpdatesOnBoot (OpsworksNodejsAppLayerResource s) (TF.Attr s Text) where
    installUpdatesOnBoot =
        lens (_install_updates_on_boot :: OpsworksNodejsAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _install_updates_on_boot = a } :: OpsworksNodejsAppLayerResource s)

instance P.HasInstanceShutdownTimeout (OpsworksNodejsAppLayerResource s) (TF.Attr s Text) where
    instanceShutdownTimeout =
        lens (_instance_shutdown_timeout :: OpsworksNodejsAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _instance_shutdown_timeout = a } :: OpsworksNodejsAppLayerResource s)

instance P.HasName (OpsworksNodejsAppLayerResource s) (TF.Attr s Text) where
    name =
        lens (_name :: OpsworksNodejsAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: OpsworksNodejsAppLayerResource s)

instance P.HasNodejsVersion (OpsworksNodejsAppLayerResource s) (TF.Attr s Text) where
    nodejsVersion =
        lens (_nodejs_version :: OpsworksNodejsAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _nodejs_version = a } :: OpsworksNodejsAppLayerResource s)

instance P.HasStackId (OpsworksNodejsAppLayerResource s) (TF.Attr s Text) where
    stackId =
        lens (_stack_id :: OpsworksNodejsAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _stack_id = a } :: OpsworksNodejsAppLayerResource s)

instance P.HasSystemPackages (OpsworksNodejsAppLayerResource s) (TF.Attr s Text) where
    systemPackages =
        lens (_system_packages :: OpsworksNodejsAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _system_packages = a } :: OpsworksNodejsAppLayerResource s)

instance P.HasUseEbsOptimizedInstances (OpsworksNodejsAppLayerResource s) (TF.Attr s Text) where
    useEbsOptimizedInstances =
        lens (_use_ebs_optimized_instances :: OpsworksNodejsAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _use_ebs_optimized_instances = a } :: OpsworksNodejsAppLayerResource s)

instance P.HasComputedAutoAssignElasticIps (OpsworksNodejsAppLayerResource s) s (TF.Attr s Text) where
    computedAutoAssignElasticIps =
        (_auto_assign_elastic_ips :: OpsworksNodejsAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAutoAssignPublicIps (OpsworksNodejsAppLayerResource s) s (TF.Attr s Text) where
    computedAutoAssignPublicIps =
        (_auto_assign_public_ips :: OpsworksNodejsAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAutoHealing (OpsworksNodejsAppLayerResource s) s (TF.Attr s Text) where
    computedAutoHealing =
        (_auto_healing :: OpsworksNodejsAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCustomInstanceProfileArn (OpsworksNodejsAppLayerResource s) s (TF.Attr s Text) where
    computedCustomInstanceProfileArn =
        (_custom_instance_profile_arn :: OpsworksNodejsAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCustomJson (OpsworksNodejsAppLayerResource s) s (TF.Attr s Text) where
    computedCustomJson =
        (_custom_json :: OpsworksNodejsAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCustomSecurityGroupIds (OpsworksNodejsAppLayerResource s) s (TF.Attr s Text) where
    computedCustomSecurityGroupIds =
        (_custom_security_group_ids :: OpsworksNodejsAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDrainElbOnShutdown (OpsworksNodejsAppLayerResource s) s (TF.Attr s Text) where
    computedDrainElbOnShutdown =
        (_drain_elb_on_shutdown :: OpsworksNodejsAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEbsVolume (OpsworksNodejsAppLayerResource s) s (TF.Attr s Text) where
    computedEbsVolume =
        (_ebs_volume :: OpsworksNodejsAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedElasticLoadBalancer (OpsworksNodejsAppLayerResource s) s (TF.Attr s Text) where
    computedElasticLoadBalancer =
        (_elastic_load_balancer :: OpsworksNodejsAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (OpsworksNodejsAppLayerResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedInstallUpdatesOnBoot (OpsworksNodejsAppLayerResource s) s (TF.Attr s Text) where
    computedInstallUpdatesOnBoot =
        (_install_updates_on_boot :: OpsworksNodejsAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedInstanceShutdownTimeout (OpsworksNodejsAppLayerResource s) s (TF.Attr s Text) where
    computedInstanceShutdownTimeout =
        (_instance_shutdown_timeout :: OpsworksNodejsAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (OpsworksNodejsAppLayerResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: OpsworksNodejsAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedNodejsVersion (OpsworksNodejsAppLayerResource s) s (TF.Attr s Text) where
    computedNodejsVersion =
        (_nodejs_version :: OpsworksNodejsAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedStackId (OpsworksNodejsAppLayerResource s) s (TF.Attr s Text) where
    computedStackId =
        (_stack_id :: OpsworksNodejsAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSystemPackages (OpsworksNodejsAppLayerResource s) s (TF.Attr s Text) where
    computedSystemPackages =
        (_system_packages :: OpsworksNodejsAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedUseEbsOptimizedInstances (OpsworksNodejsAppLayerResource s) s (TF.Attr s Text) where
    computedUseEbsOptimizedInstances =
        (_use_ebs_optimized_instances :: OpsworksNodejsAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

opsworksNodejsAppLayerResource :: TF.Schema TF.Resource P.AWS (OpsworksNodejsAppLayerResource s)
opsworksNodejsAppLayerResource =
    TF.newResource "aws_opsworks_nodejs_app_layer" $
        OpsworksNodejsAppLayerResource {
              _auto_assign_elastic_ips = TF.Nil
            , _auto_assign_public_ips = TF.Nil
            , _auto_healing = TF.Nil
            , _custom_instance_profile_arn = TF.Nil
            , _custom_json = TF.Nil
            , _custom_security_group_ids = TF.Nil
            , _drain_elb_on_shutdown = TF.Nil
            , _ebs_volume = TF.Nil
            , _elastic_load_balancer = TF.Nil
            , _install_updates_on_boot = TF.Nil
            , _instance_shutdown_timeout = TF.Nil
            , _name = TF.Nil
            , _nodejs_version = TF.Nil
            , _stack_id = TF.Nil
            , _system_packages = TF.Nil
            , _use_ebs_optimized_instances = TF.Nil
            }

{- | The @aws_opsworks_permission@ AWS resource.

Provides an OpsWorks permission resource.
-}
data OpsworksPermissionResource s = OpsworksPermissionResource {
      _allow_ssh  :: !(TF.Attr s Text)
    {- ^ (Optional) Whether the user is allowed to use SSH to communicate with the instance -}
    , _allow_sudo :: !(TF.Attr s Text)
    {- ^ (Optional) Whether the user is allowed to use sudo to elevate privileges -}
    , _level      :: !(TF.Attr s Text)
    {- ^ (Optional) The users permission level. Mus be one of @deny@ , @show@ , @deploy@ , @manage@ , @iam_only@ -}
    , _stack_id   :: !(TF.Attr s Text)
    {- ^ (Required) The stack to set the permissions for -}
    , _user_arn   :: !(TF.Attr s Text)
    {- ^ (Required) The user's IAM ARN to set permissions for -}
    } deriving (Show, Eq)

instance TF.ToHCL (OpsworksPermissionResource s) where
    toHCL OpsworksPermissionResource{..} = TF.inline $ catMaybes
        [ TF.assign "allow_ssh" <$> TF.attribute _allow_ssh
        , TF.assign "allow_sudo" <$> TF.attribute _allow_sudo
        , TF.assign "level" <$> TF.attribute _level
        , TF.assign "stack_id" <$> TF.attribute _stack_id
        , TF.assign "user_arn" <$> TF.attribute _user_arn
        ]

instance P.HasAllowSsh (OpsworksPermissionResource s) (TF.Attr s Text) where
    allowSsh =
        lens (_allow_ssh :: OpsworksPermissionResource s -> TF.Attr s Text)
             (\s a -> s { _allow_ssh = a } :: OpsworksPermissionResource s)

instance P.HasAllowSudo (OpsworksPermissionResource s) (TF.Attr s Text) where
    allowSudo =
        lens (_allow_sudo :: OpsworksPermissionResource s -> TF.Attr s Text)
             (\s a -> s { _allow_sudo = a } :: OpsworksPermissionResource s)

instance P.HasLevel (OpsworksPermissionResource s) (TF.Attr s Text) where
    level =
        lens (_level :: OpsworksPermissionResource s -> TF.Attr s Text)
             (\s a -> s { _level = a } :: OpsworksPermissionResource s)

instance P.HasStackId (OpsworksPermissionResource s) (TF.Attr s Text) where
    stackId =
        lens (_stack_id :: OpsworksPermissionResource s -> TF.Attr s Text)
             (\s a -> s { _stack_id = a } :: OpsworksPermissionResource s)

instance P.HasUserArn (OpsworksPermissionResource s) (TF.Attr s Text) where
    userArn =
        lens (_user_arn :: OpsworksPermissionResource s -> TF.Attr s Text)
             (\s a -> s { _user_arn = a } :: OpsworksPermissionResource s)

instance P.HasComputedAllowSsh (OpsworksPermissionResource s) s (TF.Attr s Text) where
    computedAllowSsh =
        (_allow_ssh :: OpsworksPermissionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAllowSudo (OpsworksPermissionResource s) s (TF.Attr s Text) where
    computedAllowSudo =
        (_allow_sudo :: OpsworksPermissionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (OpsworksPermissionResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedLevel (OpsworksPermissionResource s) s (TF.Attr s Text) where
    computedLevel =
        (_level :: OpsworksPermissionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedStackId (OpsworksPermissionResource s) s (TF.Attr s Text) where
    computedStackId =
        (_stack_id :: OpsworksPermissionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedUserArn (OpsworksPermissionResource s) s (TF.Attr s Text) where
    computedUserArn =
        (_user_arn :: OpsworksPermissionResource s -> TF.Attr s Text)
            . TF.refValue

opsworksPermissionResource :: TF.Schema TF.Resource P.AWS (OpsworksPermissionResource s)
opsworksPermissionResource =
    TF.newResource "aws_opsworks_permission" $
        OpsworksPermissionResource {
              _allow_ssh = TF.Nil
            , _allow_sudo = TF.Nil
            , _level = TF.Nil
            , _stack_id = TF.Nil
            , _user_arn = TF.Nil
            }

{- | The @aws_opsworks_php_app_layer@ AWS resource.

Provides an OpsWorks PHP application layer resource.
-}
data OpsworksPhpAppLayerResource s = OpsworksPhpAppLayerResource {
      _auto_assign_elastic_ips     :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to automatically assign an elastic IP address to the layer's instances. -}
    , _auto_assign_public_ips      :: !(TF.Attr s Text)
    {- ^ (Optional) For stacks belonging to a VPC, whether to automatically assign a public IP address to each of the layer's instances. -}
    , _auto_healing                :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to enable auto-healing for the layer. -}
    , _custom_instance_profile_arn :: !(TF.Attr s Text)
    {- ^ (Optional) The ARN of an IAM profile that will be used for the layer's instances. -}
    , _custom_json                 :: !(TF.Attr s Text)
    {- ^ (Optional) Custom JSON attributes to apply to the layer. -}
    , _custom_security_group_ids   :: !(TF.Attr s Text)
    {- ^ (Optional) Ids for a set of security groups to apply to the layer's instances. -}
    , _drain_elb_on_shutdown       :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to enable Elastic Load Balancing connection draining. -}
    , _ebs_volume                  :: !(TF.Attr s Text)
    {- ^ (Optional) @ebs_volume@ blocks, as described below, will each create an EBS volume and connect it to the layer's instances. -}
    , _elastic_load_balancer       :: !(TF.Attr s Text)
    {- ^ (Optional) Name of an Elastic Load Balancer to attach to this layer -}
    , _install_updates_on_boot     :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to install OS and package updates on each instance when it boots. -}
    , _instance_shutdown_timeout   :: !(TF.Attr s Text)
    {- ^ (Optional) The time, in seconds, that OpsWorks will wait for Chef to complete after triggering the Shutdown event. -}
    , _name                        :: !(TF.Attr s Text)
    {- ^ (Optional) A human-readable name for the layer. -}
    , _stack_id                    :: !(TF.Attr s Text)
    {- ^ (Required) The id of the stack the layer will belong to. -}
    , _system_packages             :: !(TF.Attr s Text)
    {- ^ (Optional) Names of a set of system packages to install on the layer's instances. -}
    , _use_ebs_optimized_instances :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to use EBS-optimized instances. -}
    } deriving (Show, Eq)

instance TF.ToHCL (OpsworksPhpAppLayerResource s) where
    toHCL OpsworksPhpAppLayerResource{..} = TF.inline $ catMaybes
        [ TF.assign "auto_assign_elastic_ips" <$> TF.attribute _auto_assign_elastic_ips
        , TF.assign "auto_assign_public_ips" <$> TF.attribute _auto_assign_public_ips
        , TF.assign "auto_healing" <$> TF.attribute _auto_healing
        , TF.assign "custom_instance_profile_arn" <$> TF.attribute _custom_instance_profile_arn
        , TF.assign "custom_json" <$> TF.attribute _custom_json
        , TF.assign "custom_security_group_ids" <$> TF.attribute _custom_security_group_ids
        , TF.assign "drain_elb_on_shutdown" <$> TF.attribute _drain_elb_on_shutdown
        , TF.assign "ebs_volume" <$> TF.attribute _ebs_volume
        , TF.assign "elastic_load_balancer" <$> TF.attribute _elastic_load_balancer
        , TF.assign "install_updates_on_boot" <$> TF.attribute _install_updates_on_boot
        , TF.assign "instance_shutdown_timeout" <$> TF.attribute _instance_shutdown_timeout
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "stack_id" <$> TF.attribute _stack_id
        , TF.assign "system_packages" <$> TF.attribute _system_packages
        , TF.assign "use_ebs_optimized_instances" <$> TF.attribute _use_ebs_optimized_instances
        ]

instance P.HasAutoAssignElasticIps (OpsworksPhpAppLayerResource s) (TF.Attr s Text) where
    autoAssignElasticIps =
        lens (_auto_assign_elastic_ips :: OpsworksPhpAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _auto_assign_elastic_ips = a } :: OpsworksPhpAppLayerResource s)

instance P.HasAutoAssignPublicIps (OpsworksPhpAppLayerResource s) (TF.Attr s Text) where
    autoAssignPublicIps =
        lens (_auto_assign_public_ips :: OpsworksPhpAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _auto_assign_public_ips = a } :: OpsworksPhpAppLayerResource s)

instance P.HasAutoHealing (OpsworksPhpAppLayerResource s) (TF.Attr s Text) where
    autoHealing =
        lens (_auto_healing :: OpsworksPhpAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _auto_healing = a } :: OpsworksPhpAppLayerResource s)

instance P.HasCustomInstanceProfileArn (OpsworksPhpAppLayerResource s) (TF.Attr s Text) where
    customInstanceProfileArn =
        lens (_custom_instance_profile_arn :: OpsworksPhpAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _custom_instance_profile_arn = a } :: OpsworksPhpAppLayerResource s)

instance P.HasCustomJson (OpsworksPhpAppLayerResource s) (TF.Attr s Text) where
    customJson =
        lens (_custom_json :: OpsworksPhpAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _custom_json = a } :: OpsworksPhpAppLayerResource s)

instance P.HasCustomSecurityGroupIds (OpsworksPhpAppLayerResource s) (TF.Attr s Text) where
    customSecurityGroupIds =
        lens (_custom_security_group_ids :: OpsworksPhpAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _custom_security_group_ids = a } :: OpsworksPhpAppLayerResource s)

instance P.HasDrainElbOnShutdown (OpsworksPhpAppLayerResource s) (TF.Attr s Text) where
    drainElbOnShutdown =
        lens (_drain_elb_on_shutdown :: OpsworksPhpAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _drain_elb_on_shutdown = a } :: OpsworksPhpAppLayerResource s)

instance P.HasEbsVolume (OpsworksPhpAppLayerResource s) (TF.Attr s Text) where
    ebsVolume =
        lens (_ebs_volume :: OpsworksPhpAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _ebs_volume = a } :: OpsworksPhpAppLayerResource s)

instance P.HasElasticLoadBalancer (OpsworksPhpAppLayerResource s) (TF.Attr s Text) where
    elasticLoadBalancer =
        lens (_elastic_load_balancer :: OpsworksPhpAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _elastic_load_balancer = a } :: OpsworksPhpAppLayerResource s)

instance P.HasInstallUpdatesOnBoot (OpsworksPhpAppLayerResource s) (TF.Attr s Text) where
    installUpdatesOnBoot =
        lens (_install_updates_on_boot :: OpsworksPhpAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _install_updates_on_boot = a } :: OpsworksPhpAppLayerResource s)

instance P.HasInstanceShutdownTimeout (OpsworksPhpAppLayerResource s) (TF.Attr s Text) where
    instanceShutdownTimeout =
        lens (_instance_shutdown_timeout :: OpsworksPhpAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _instance_shutdown_timeout = a } :: OpsworksPhpAppLayerResource s)

instance P.HasName (OpsworksPhpAppLayerResource s) (TF.Attr s Text) where
    name =
        lens (_name :: OpsworksPhpAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: OpsworksPhpAppLayerResource s)

instance P.HasStackId (OpsworksPhpAppLayerResource s) (TF.Attr s Text) where
    stackId =
        lens (_stack_id :: OpsworksPhpAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _stack_id = a } :: OpsworksPhpAppLayerResource s)

instance P.HasSystemPackages (OpsworksPhpAppLayerResource s) (TF.Attr s Text) where
    systemPackages =
        lens (_system_packages :: OpsworksPhpAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _system_packages = a } :: OpsworksPhpAppLayerResource s)

instance P.HasUseEbsOptimizedInstances (OpsworksPhpAppLayerResource s) (TF.Attr s Text) where
    useEbsOptimizedInstances =
        lens (_use_ebs_optimized_instances :: OpsworksPhpAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _use_ebs_optimized_instances = a } :: OpsworksPhpAppLayerResource s)

instance P.HasComputedAutoAssignElasticIps (OpsworksPhpAppLayerResource s) s (TF.Attr s Text) where
    computedAutoAssignElasticIps =
        (_auto_assign_elastic_ips :: OpsworksPhpAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAutoAssignPublicIps (OpsworksPhpAppLayerResource s) s (TF.Attr s Text) where
    computedAutoAssignPublicIps =
        (_auto_assign_public_ips :: OpsworksPhpAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAutoHealing (OpsworksPhpAppLayerResource s) s (TF.Attr s Text) where
    computedAutoHealing =
        (_auto_healing :: OpsworksPhpAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCustomInstanceProfileArn (OpsworksPhpAppLayerResource s) s (TF.Attr s Text) where
    computedCustomInstanceProfileArn =
        (_custom_instance_profile_arn :: OpsworksPhpAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCustomJson (OpsworksPhpAppLayerResource s) s (TF.Attr s Text) where
    computedCustomJson =
        (_custom_json :: OpsworksPhpAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCustomSecurityGroupIds (OpsworksPhpAppLayerResource s) s (TF.Attr s Text) where
    computedCustomSecurityGroupIds =
        (_custom_security_group_ids :: OpsworksPhpAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDrainElbOnShutdown (OpsworksPhpAppLayerResource s) s (TF.Attr s Text) where
    computedDrainElbOnShutdown =
        (_drain_elb_on_shutdown :: OpsworksPhpAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEbsVolume (OpsworksPhpAppLayerResource s) s (TF.Attr s Text) where
    computedEbsVolume =
        (_ebs_volume :: OpsworksPhpAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedElasticLoadBalancer (OpsworksPhpAppLayerResource s) s (TF.Attr s Text) where
    computedElasticLoadBalancer =
        (_elastic_load_balancer :: OpsworksPhpAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (OpsworksPhpAppLayerResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedInstallUpdatesOnBoot (OpsworksPhpAppLayerResource s) s (TF.Attr s Text) where
    computedInstallUpdatesOnBoot =
        (_install_updates_on_boot :: OpsworksPhpAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedInstanceShutdownTimeout (OpsworksPhpAppLayerResource s) s (TF.Attr s Text) where
    computedInstanceShutdownTimeout =
        (_instance_shutdown_timeout :: OpsworksPhpAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (OpsworksPhpAppLayerResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: OpsworksPhpAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedStackId (OpsworksPhpAppLayerResource s) s (TF.Attr s Text) where
    computedStackId =
        (_stack_id :: OpsworksPhpAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSystemPackages (OpsworksPhpAppLayerResource s) s (TF.Attr s Text) where
    computedSystemPackages =
        (_system_packages :: OpsworksPhpAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedUseEbsOptimizedInstances (OpsworksPhpAppLayerResource s) s (TF.Attr s Text) where
    computedUseEbsOptimizedInstances =
        (_use_ebs_optimized_instances :: OpsworksPhpAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

opsworksPhpAppLayerResource :: TF.Schema TF.Resource P.AWS (OpsworksPhpAppLayerResource s)
opsworksPhpAppLayerResource =
    TF.newResource "aws_opsworks_php_app_layer" $
        OpsworksPhpAppLayerResource {
              _auto_assign_elastic_ips = TF.Nil
            , _auto_assign_public_ips = TF.Nil
            , _auto_healing = TF.Nil
            , _custom_instance_profile_arn = TF.Nil
            , _custom_json = TF.Nil
            , _custom_security_group_ids = TF.Nil
            , _drain_elb_on_shutdown = TF.Nil
            , _ebs_volume = TF.Nil
            , _elastic_load_balancer = TF.Nil
            , _install_updates_on_boot = TF.Nil
            , _instance_shutdown_timeout = TF.Nil
            , _name = TF.Nil
            , _stack_id = TF.Nil
            , _system_packages = TF.Nil
            , _use_ebs_optimized_instances = TF.Nil
            }

{- | The @aws_opsworks_rails_app_layer@ AWS resource.

Provides an OpsWorks Ruby on Rails application layer resource.
-}
data OpsworksRailsAppLayerResource s = OpsworksRailsAppLayerResource {
      _app_server                  :: !(TF.Attr s Text)
    {- ^ (Optional) Keyword for the app server to use. Defaults to "apache_passenger". -}
    , _auto_assign_elastic_ips     :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to automatically assign an elastic IP address to the layer's instances. -}
    , _auto_assign_public_ips      :: !(TF.Attr s Text)
    {- ^ (Optional) For stacks belonging to a VPC, whether to automatically assign a public IP address to each of the layer's instances. -}
    , _auto_healing                :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to enable auto-healing for the layer. -}
    , _bundler_version             :: !(TF.Attr s Text)
    {- ^ (Optional) When OpsWorks is managing Bundler, which version to use. Defaults to "1.5.3". -}
    , _custom_instance_profile_arn :: !(TF.Attr s Text)
    {- ^ (Optional) The ARN of an IAM profile that will be used for the layer's instances. -}
    , _custom_json                 :: !(TF.Attr s Text)
    {- ^ (Optional) Custom JSON attributes to apply to the layer. -}
    , _custom_security_group_ids   :: !(TF.Attr s Text)
    {- ^ (Optional) Ids for a set of security groups to apply to the layer's instances. -}
    , _drain_elb_on_shutdown       :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to enable Elastic Load Balancing connection draining. -}
    , _ebs_volume                  :: !(TF.Attr s Text)
    {- ^ (Optional) @ebs_volume@ blocks, as described below, will each create an EBS volume and connect it to the layer's instances. -}
    , _elastic_load_balancer       :: !(TF.Attr s Text)
    {- ^ (Optional) Name of an Elastic Load Balancer to attach to this layer -}
    , _install_updates_on_boot     :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to install OS and package updates on each instance when it boots. -}
    , _instance_shutdown_timeout   :: !(TF.Attr s Text)
    {- ^ (Optional) The time, in seconds, that OpsWorks will wait for Chef to complete after triggering the Shutdown event. -}
    , _manage_bundler              :: !(TF.Attr s Text)
    {- ^ (Optional) Whether OpsWorks should manage bundler. On by default. -}
    , _name                        :: !(TF.Attr s Text)
    {- ^ (Optional) A human-readable name for the layer. -}
    , _passenger_version           :: !(TF.Attr s Text)
    {- ^ (Optional) The version of Passenger to use. Defaults to "4.0.46". -}
    , _ruby_version                :: !(TF.Attr s Text)
    {- ^ (Optional) The version of Ruby to use. Defaults to "2.0.0". -}
    , _rubygems_version            :: !(TF.Attr s Text)
    {- ^ (Optional) The version of RubyGems to use. Defaults to "2.2.2". -}
    , _stack_id                    :: !(TF.Attr s Text)
    {- ^ (Required) The id of the stack the layer will belong to. -}
    , _system_packages             :: !(TF.Attr s Text)
    {- ^ (Optional) Names of a set of system packages to install on the layer's instances. -}
    , _use_ebs_optimized_instances :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to use EBS-optimized instances. -}
    } deriving (Show, Eq)

instance TF.ToHCL (OpsworksRailsAppLayerResource s) where
    toHCL OpsworksRailsAppLayerResource{..} = TF.inline $ catMaybes
        [ TF.assign "app_server" <$> TF.attribute _app_server
        , TF.assign "auto_assign_elastic_ips" <$> TF.attribute _auto_assign_elastic_ips
        , TF.assign "auto_assign_public_ips" <$> TF.attribute _auto_assign_public_ips
        , TF.assign "auto_healing" <$> TF.attribute _auto_healing
        , TF.assign "bundler_version" <$> TF.attribute _bundler_version
        , TF.assign "custom_instance_profile_arn" <$> TF.attribute _custom_instance_profile_arn
        , TF.assign "custom_json" <$> TF.attribute _custom_json
        , TF.assign "custom_security_group_ids" <$> TF.attribute _custom_security_group_ids
        , TF.assign "drain_elb_on_shutdown" <$> TF.attribute _drain_elb_on_shutdown
        , TF.assign "ebs_volume" <$> TF.attribute _ebs_volume
        , TF.assign "elastic_load_balancer" <$> TF.attribute _elastic_load_balancer
        , TF.assign "install_updates_on_boot" <$> TF.attribute _install_updates_on_boot
        , TF.assign "instance_shutdown_timeout" <$> TF.attribute _instance_shutdown_timeout
        , TF.assign "manage_bundler" <$> TF.attribute _manage_bundler
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "passenger_version" <$> TF.attribute _passenger_version
        , TF.assign "ruby_version" <$> TF.attribute _ruby_version
        , TF.assign "rubygems_version" <$> TF.attribute _rubygems_version
        , TF.assign "stack_id" <$> TF.attribute _stack_id
        , TF.assign "system_packages" <$> TF.attribute _system_packages
        , TF.assign "use_ebs_optimized_instances" <$> TF.attribute _use_ebs_optimized_instances
        ]

instance P.HasAppServer (OpsworksRailsAppLayerResource s) (TF.Attr s Text) where
    appServer =
        lens (_app_server :: OpsworksRailsAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _app_server = a } :: OpsworksRailsAppLayerResource s)

instance P.HasAutoAssignElasticIps (OpsworksRailsAppLayerResource s) (TF.Attr s Text) where
    autoAssignElasticIps =
        lens (_auto_assign_elastic_ips :: OpsworksRailsAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _auto_assign_elastic_ips = a } :: OpsworksRailsAppLayerResource s)

instance P.HasAutoAssignPublicIps (OpsworksRailsAppLayerResource s) (TF.Attr s Text) where
    autoAssignPublicIps =
        lens (_auto_assign_public_ips :: OpsworksRailsAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _auto_assign_public_ips = a } :: OpsworksRailsAppLayerResource s)

instance P.HasAutoHealing (OpsworksRailsAppLayerResource s) (TF.Attr s Text) where
    autoHealing =
        lens (_auto_healing :: OpsworksRailsAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _auto_healing = a } :: OpsworksRailsAppLayerResource s)

instance P.HasBundlerVersion (OpsworksRailsAppLayerResource s) (TF.Attr s Text) where
    bundlerVersion =
        lens (_bundler_version :: OpsworksRailsAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _bundler_version = a } :: OpsworksRailsAppLayerResource s)

instance P.HasCustomInstanceProfileArn (OpsworksRailsAppLayerResource s) (TF.Attr s Text) where
    customInstanceProfileArn =
        lens (_custom_instance_profile_arn :: OpsworksRailsAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _custom_instance_profile_arn = a } :: OpsworksRailsAppLayerResource s)

instance P.HasCustomJson (OpsworksRailsAppLayerResource s) (TF.Attr s Text) where
    customJson =
        lens (_custom_json :: OpsworksRailsAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _custom_json = a } :: OpsworksRailsAppLayerResource s)

instance P.HasCustomSecurityGroupIds (OpsworksRailsAppLayerResource s) (TF.Attr s Text) where
    customSecurityGroupIds =
        lens (_custom_security_group_ids :: OpsworksRailsAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _custom_security_group_ids = a } :: OpsworksRailsAppLayerResource s)

instance P.HasDrainElbOnShutdown (OpsworksRailsAppLayerResource s) (TF.Attr s Text) where
    drainElbOnShutdown =
        lens (_drain_elb_on_shutdown :: OpsworksRailsAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _drain_elb_on_shutdown = a } :: OpsworksRailsAppLayerResource s)

instance P.HasEbsVolume (OpsworksRailsAppLayerResource s) (TF.Attr s Text) where
    ebsVolume =
        lens (_ebs_volume :: OpsworksRailsAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _ebs_volume = a } :: OpsworksRailsAppLayerResource s)

instance P.HasElasticLoadBalancer (OpsworksRailsAppLayerResource s) (TF.Attr s Text) where
    elasticLoadBalancer =
        lens (_elastic_load_balancer :: OpsworksRailsAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _elastic_load_balancer = a } :: OpsworksRailsAppLayerResource s)

instance P.HasInstallUpdatesOnBoot (OpsworksRailsAppLayerResource s) (TF.Attr s Text) where
    installUpdatesOnBoot =
        lens (_install_updates_on_boot :: OpsworksRailsAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _install_updates_on_boot = a } :: OpsworksRailsAppLayerResource s)

instance P.HasInstanceShutdownTimeout (OpsworksRailsAppLayerResource s) (TF.Attr s Text) where
    instanceShutdownTimeout =
        lens (_instance_shutdown_timeout :: OpsworksRailsAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _instance_shutdown_timeout = a } :: OpsworksRailsAppLayerResource s)

instance P.HasManageBundler (OpsworksRailsAppLayerResource s) (TF.Attr s Text) where
    manageBundler =
        lens (_manage_bundler :: OpsworksRailsAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _manage_bundler = a } :: OpsworksRailsAppLayerResource s)

instance P.HasName (OpsworksRailsAppLayerResource s) (TF.Attr s Text) where
    name =
        lens (_name :: OpsworksRailsAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: OpsworksRailsAppLayerResource s)

instance P.HasPassengerVersion (OpsworksRailsAppLayerResource s) (TF.Attr s Text) where
    passengerVersion =
        lens (_passenger_version :: OpsworksRailsAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _passenger_version = a } :: OpsworksRailsAppLayerResource s)

instance P.HasRubyVersion (OpsworksRailsAppLayerResource s) (TF.Attr s Text) where
    rubyVersion =
        lens (_ruby_version :: OpsworksRailsAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _ruby_version = a } :: OpsworksRailsAppLayerResource s)

instance P.HasRubygemsVersion (OpsworksRailsAppLayerResource s) (TF.Attr s Text) where
    rubygemsVersion =
        lens (_rubygems_version :: OpsworksRailsAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _rubygems_version = a } :: OpsworksRailsAppLayerResource s)

instance P.HasStackId (OpsworksRailsAppLayerResource s) (TF.Attr s Text) where
    stackId =
        lens (_stack_id :: OpsworksRailsAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _stack_id = a } :: OpsworksRailsAppLayerResource s)

instance P.HasSystemPackages (OpsworksRailsAppLayerResource s) (TF.Attr s Text) where
    systemPackages =
        lens (_system_packages :: OpsworksRailsAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _system_packages = a } :: OpsworksRailsAppLayerResource s)

instance P.HasUseEbsOptimizedInstances (OpsworksRailsAppLayerResource s) (TF.Attr s Text) where
    useEbsOptimizedInstances =
        lens (_use_ebs_optimized_instances :: OpsworksRailsAppLayerResource s -> TF.Attr s Text)
             (\s a -> s { _use_ebs_optimized_instances = a } :: OpsworksRailsAppLayerResource s)

instance P.HasComputedAppServer (OpsworksRailsAppLayerResource s) s (TF.Attr s Text) where
    computedAppServer =
        (_app_server :: OpsworksRailsAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAutoAssignElasticIps (OpsworksRailsAppLayerResource s) s (TF.Attr s Text) where
    computedAutoAssignElasticIps =
        (_auto_assign_elastic_ips :: OpsworksRailsAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAutoAssignPublicIps (OpsworksRailsAppLayerResource s) s (TF.Attr s Text) where
    computedAutoAssignPublicIps =
        (_auto_assign_public_ips :: OpsworksRailsAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAutoHealing (OpsworksRailsAppLayerResource s) s (TF.Attr s Text) where
    computedAutoHealing =
        (_auto_healing :: OpsworksRailsAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedBundlerVersion (OpsworksRailsAppLayerResource s) s (TF.Attr s Text) where
    computedBundlerVersion =
        (_bundler_version :: OpsworksRailsAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCustomInstanceProfileArn (OpsworksRailsAppLayerResource s) s (TF.Attr s Text) where
    computedCustomInstanceProfileArn =
        (_custom_instance_profile_arn :: OpsworksRailsAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCustomJson (OpsworksRailsAppLayerResource s) s (TF.Attr s Text) where
    computedCustomJson =
        (_custom_json :: OpsworksRailsAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCustomSecurityGroupIds (OpsworksRailsAppLayerResource s) s (TF.Attr s Text) where
    computedCustomSecurityGroupIds =
        (_custom_security_group_ids :: OpsworksRailsAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDrainElbOnShutdown (OpsworksRailsAppLayerResource s) s (TF.Attr s Text) where
    computedDrainElbOnShutdown =
        (_drain_elb_on_shutdown :: OpsworksRailsAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEbsVolume (OpsworksRailsAppLayerResource s) s (TF.Attr s Text) where
    computedEbsVolume =
        (_ebs_volume :: OpsworksRailsAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedElasticLoadBalancer (OpsworksRailsAppLayerResource s) s (TF.Attr s Text) where
    computedElasticLoadBalancer =
        (_elastic_load_balancer :: OpsworksRailsAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (OpsworksRailsAppLayerResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedInstallUpdatesOnBoot (OpsworksRailsAppLayerResource s) s (TF.Attr s Text) where
    computedInstallUpdatesOnBoot =
        (_install_updates_on_boot :: OpsworksRailsAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedInstanceShutdownTimeout (OpsworksRailsAppLayerResource s) s (TF.Attr s Text) where
    computedInstanceShutdownTimeout =
        (_instance_shutdown_timeout :: OpsworksRailsAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedManageBundler (OpsworksRailsAppLayerResource s) s (TF.Attr s Text) where
    computedManageBundler =
        (_manage_bundler :: OpsworksRailsAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (OpsworksRailsAppLayerResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: OpsworksRailsAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPassengerVersion (OpsworksRailsAppLayerResource s) s (TF.Attr s Text) where
    computedPassengerVersion =
        (_passenger_version :: OpsworksRailsAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRubyVersion (OpsworksRailsAppLayerResource s) s (TF.Attr s Text) where
    computedRubyVersion =
        (_ruby_version :: OpsworksRailsAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRubygemsVersion (OpsworksRailsAppLayerResource s) s (TF.Attr s Text) where
    computedRubygemsVersion =
        (_rubygems_version :: OpsworksRailsAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedStackId (OpsworksRailsAppLayerResource s) s (TF.Attr s Text) where
    computedStackId =
        (_stack_id :: OpsworksRailsAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSystemPackages (OpsworksRailsAppLayerResource s) s (TF.Attr s Text) where
    computedSystemPackages =
        (_system_packages :: OpsworksRailsAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedUseEbsOptimizedInstances (OpsworksRailsAppLayerResource s) s (TF.Attr s Text) where
    computedUseEbsOptimizedInstances =
        (_use_ebs_optimized_instances :: OpsworksRailsAppLayerResource s -> TF.Attr s Text)
            . TF.refValue

opsworksRailsAppLayerResource :: TF.Schema TF.Resource P.AWS (OpsworksRailsAppLayerResource s)
opsworksRailsAppLayerResource =
    TF.newResource "aws_opsworks_rails_app_layer" $
        OpsworksRailsAppLayerResource {
              _app_server = TF.Nil
            , _auto_assign_elastic_ips = TF.Nil
            , _auto_assign_public_ips = TF.Nil
            , _auto_healing = TF.Nil
            , _bundler_version = TF.Nil
            , _custom_instance_profile_arn = TF.Nil
            , _custom_json = TF.Nil
            , _custom_security_group_ids = TF.Nil
            , _drain_elb_on_shutdown = TF.Nil
            , _ebs_volume = TF.Nil
            , _elastic_load_balancer = TF.Nil
            , _install_updates_on_boot = TF.Nil
            , _instance_shutdown_timeout = TF.Nil
            , _manage_bundler = TF.Nil
            , _name = TF.Nil
            , _passenger_version = TF.Nil
            , _ruby_version = TF.Nil
            , _rubygems_version = TF.Nil
            , _stack_id = TF.Nil
            , _system_packages = TF.Nil
            , _use_ebs_optimized_instances = TF.Nil
            }

{- | The @aws_opsworks_rds_db_instance@ AWS resource.

Provides an OpsWorks RDS DB Instance resource. ~> Note: All arguments
including the username and password will be stored in the raw state as
plain-text. </docs/state/sensitive-data.html> .
-}
data OpsworksRdsDbInstanceResource s = OpsworksRdsDbInstanceResource {
      _db_password         :: !(TF.Attr s Text)
    {- ^ (Required) A db password -}
    , _db_user             :: !(TF.Attr s Text)
    {- ^ (Required) A db username -}
    , _rds_db_instance_arn :: !(TF.Attr s Text)
    {- ^ (Required) The db instance to register for this stack. Changing this will force a new resource. -}
    , _stack_id            :: !(TF.Attr s Text)
    {- ^ (Required) The stack to register a db inatance for. Changing this will force a new resource. -}
    } deriving (Show, Eq)

instance TF.ToHCL (OpsworksRdsDbInstanceResource s) where
    toHCL OpsworksRdsDbInstanceResource{..} = TF.inline $ catMaybes
        [ TF.assign "db_password" <$> TF.attribute _db_password
        , TF.assign "db_user" <$> TF.attribute _db_user
        , TF.assign "rds_db_instance_arn" <$> TF.attribute _rds_db_instance_arn
        , TF.assign "stack_id" <$> TF.attribute _stack_id
        ]

instance P.HasDbPassword (OpsworksRdsDbInstanceResource s) (TF.Attr s Text) where
    dbPassword =
        lens (_db_password :: OpsworksRdsDbInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _db_password = a } :: OpsworksRdsDbInstanceResource s)

instance P.HasDbUser (OpsworksRdsDbInstanceResource s) (TF.Attr s Text) where
    dbUser =
        lens (_db_user :: OpsworksRdsDbInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _db_user = a } :: OpsworksRdsDbInstanceResource s)

instance P.HasRdsDbInstanceArn (OpsworksRdsDbInstanceResource s) (TF.Attr s Text) where
    rdsDbInstanceArn =
        lens (_rds_db_instance_arn :: OpsworksRdsDbInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _rds_db_instance_arn = a } :: OpsworksRdsDbInstanceResource s)

instance P.HasStackId (OpsworksRdsDbInstanceResource s) (TF.Attr s Text) where
    stackId =
        lens (_stack_id :: OpsworksRdsDbInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _stack_id = a } :: OpsworksRdsDbInstanceResource s)

instance P.HasComputedDbPassword (OpsworksRdsDbInstanceResource s) s (TF.Attr s Text) where
    computedDbPassword =
        (_db_password :: OpsworksRdsDbInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDbUser (OpsworksRdsDbInstanceResource s) s (TF.Attr s Text) where
    computedDbUser =
        (_db_user :: OpsworksRdsDbInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (OpsworksRdsDbInstanceResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedRdsDbInstanceArn (OpsworksRdsDbInstanceResource s) s (TF.Attr s Text) where
    computedRdsDbInstanceArn =
        (_rds_db_instance_arn :: OpsworksRdsDbInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedStackId (OpsworksRdsDbInstanceResource s) s (TF.Attr s Text) where
    computedStackId =
        (_stack_id :: OpsworksRdsDbInstanceResource s -> TF.Attr s Text)
            . TF.refValue

opsworksRdsDbInstanceResource :: TF.Schema TF.Resource P.AWS (OpsworksRdsDbInstanceResource s)
opsworksRdsDbInstanceResource =
    TF.newResource "aws_opsworks_rds_db_instance" $
        OpsworksRdsDbInstanceResource {
              _db_password = TF.Nil
            , _db_user = TF.Nil
            , _rds_db_instance_arn = TF.Nil
            , _stack_id = TF.Nil
            }

{- | The @aws_opsworks_stack@ AWS resource.

Provides an OpsWorks stack resource.
-}
data OpsworksStackResource s = OpsworksStackResource {
      _agent_version                 :: !(TF.Attr s Text)
    {- ^ (Optional) If set to @"LATEST"@ , OpsWorks will automatically install the latest version. -}
    , _berkshelf_version             :: !(TF.Attr s Text)
    {- ^ (Optional) If @manage_berkshelf@ is enabled, the version of Berkshelf to use. -}
    , _color                         :: !(TF.Attr s Text)
    {- ^ (Optional) Color to paint next to the stack's resources in the OpsWorks console. -}
    , _configuration_manager_name    :: !(TF.Attr s Text)
    {- ^ (Optional) Name of the configuration manager to use. Defaults to "Chef". -}
    , _configuration_manager_version :: !(TF.Attr s Text)
    {- ^ (Optional) Version of the configuration manager to use. Defaults to "11.4". -}
    , _custom_cookbooks_source       :: !(TF.Attr s Text)
    {- ^ (Optional) When @use_custom_cookbooks@ is set, provide this sub-object as described below. -}
    , _custom_json                   :: !(TF.Attr s Text)
    {- ^ (Optional) Custom JSON attributes to apply to the entire stack. -}
    , _default_availability_zone     :: !(TF.Attr s P.Zone)
    {- ^ (Optional) Name of the availability zone where instances will be created by default. This is required unless you set @vpc_id@ . -}
    , _default_instance_profile_arn  :: !(TF.Attr s Text)
    {- ^ (Required) The ARN of an IAM Instance Profile that created instances will have by default. -}
    , _default_os                    :: !(TF.Attr s Text)
    {- ^ (Optional) Name of OS that will be installed on instances by default. -}
    , _default_root_device_type      :: !(TF.Attr s Text)
    {- ^ (Optional) Name of the type of root device instances will have by default. -}
    , _default_ssh_key_name          :: !(TF.Attr s Text)
    {- ^ (Optional) Name of the SSH keypair that instances will have by default. -}
    , _default_subnet_id             :: !(TF.Attr s Text)
    {- ^ (Optional) Id of the subnet in which instances will be created by default. Mandatory if @vpc_id@ is set, and forbidden if it isn't. -}
    , _hostname_theme                :: !(TF.Attr s Text)
    {- ^ (Optional) Keyword representing the naming scheme that will be used for instance hostnames within this stack. -}
    , _manage_berkshelf              :: !(TF.Attr s Text)
    {- ^ (Optional) Boolean value controlling whether Opsworks will run Berkshelf for this stack. -}
    , _name                          :: !(TF.Attr s Text)
    {- ^ (Required) The name of the stack. -}
    , _region                        :: !(TF.Attr s P.Region)
    {- ^ (Required) The name of the region where the stack will exist. -}
    , _service_role_arn              :: !(TF.Attr s Text)
    {- ^ (Required) The ARN of an IAM role that the OpsWorks service will act as. -}
    , _tags                          :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    , _use_custom_cookbooks          :: !(TF.Attr s Text)
    {- ^ (Optional) Boolean value controlling whether the custom cookbook settings are enabled. -}
    , _use_opsworks_security_groups  :: !(TF.Attr s Text)
    {- ^ (Optional) Boolean value controlling whether the standard OpsWorks security groups apply to created instances. -}
    , _vpc_id                        :: !(TF.Attr s Text)
    {- ^ (Optional) The id of the VPC that this stack belongs to. -}
    } deriving (Show, Eq)

instance TF.ToHCL (OpsworksStackResource s) where
    toHCL OpsworksStackResource{..} = TF.inline $ catMaybes
        [ TF.assign "agent_version" <$> TF.attribute _agent_version
        , TF.assign "berkshelf_version" <$> TF.attribute _berkshelf_version
        , TF.assign "color" <$> TF.attribute _color
        , TF.assign "configuration_manager_name" <$> TF.attribute _configuration_manager_name
        , TF.assign "configuration_manager_version" <$> TF.attribute _configuration_manager_version
        , TF.assign "custom_cookbooks_source" <$> TF.attribute _custom_cookbooks_source
        , TF.assign "custom_json" <$> TF.attribute _custom_json
        , TF.assign "default_availability_zone" <$> TF.attribute _default_availability_zone
        , TF.assign "default_instance_profile_arn" <$> TF.attribute _default_instance_profile_arn
        , TF.assign "default_os" <$> TF.attribute _default_os
        , TF.assign "default_root_device_type" <$> TF.attribute _default_root_device_type
        , TF.assign "default_ssh_key_name" <$> TF.attribute _default_ssh_key_name
        , TF.assign "default_subnet_id" <$> TF.attribute _default_subnet_id
        , TF.assign "hostname_theme" <$> TF.attribute _hostname_theme
        , TF.assign "manage_berkshelf" <$> TF.attribute _manage_berkshelf
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "region" <$> TF.attribute _region
        , TF.assign "service_role_arn" <$> TF.attribute _service_role_arn
        , TF.assign "tags" <$> TF.attribute _tags
        , TF.assign "use_custom_cookbooks" <$> TF.attribute _use_custom_cookbooks
        , TF.assign "use_opsworks_security_groups" <$> TF.attribute _use_opsworks_security_groups
        , TF.assign "vpc_id" <$> TF.attribute _vpc_id
        ]

instance P.HasAgentVersion (OpsworksStackResource s) (TF.Attr s Text) where
    agentVersion =
        lens (_agent_version :: OpsworksStackResource s -> TF.Attr s Text)
             (\s a -> s { _agent_version = a } :: OpsworksStackResource s)

instance P.HasBerkshelfVersion (OpsworksStackResource s) (TF.Attr s Text) where
    berkshelfVersion =
        lens (_berkshelf_version :: OpsworksStackResource s -> TF.Attr s Text)
             (\s a -> s { _berkshelf_version = a } :: OpsworksStackResource s)

instance P.HasColor (OpsworksStackResource s) (TF.Attr s Text) where
    color =
        lens (_color :: OpsworksStackResource s -> TF.Attr s Text)
             (\s a -> s { _color = a } :: OpsworksStackResource s)

instance P.HasConfigurationManagerName (OpsworksStackResource s) (TF.Attr s Text) where
    configurationManagerName =
        lens (_configuration_manager_name :: OpsworksStackResource s -> TF.Attr s Text)
             (\s a -> s { _configuration_manager_name = a } :: OpsworksStackResource s)

instance P.HasConfigurationManagerVersion (OpsworksStackResource s) (TF.Attr s Text) where
    configurationManagerVersion =
        lens (_configuration_manager_version :: OpsworksStackResource s -> TF.Attr s Text)
             (\s a -> s { _configuration_manager_version = a } :: OpsworksStackResource s)

instance P.HasCustomCookbooksSource (OpsworksStackResource s) (TF.Attr s Text) where
    customCookbooksSource =
        lens (_custom_cookbooks_source :: OpsworksStackResource s -> TF.Attr s Text)
             (\s a -> s { _custom_cookbooks_source = a } :: OpsworksStackResource s)

instance P.HasCustomJson (OpsworksStackResource s) (TF.Attr s Text) where
    customJson =
        lens (_custom_json :: OpsworksStackResource s -> TF.Attr s Text)
             (\s a -> s { _custom_json = a } :: OpsworksStackResource s)

instance P.HasDefaultAvailabilityZone (OpsworksStackResource s) (TF.Attr s P.Zone) where
    defaultAvailabilityZone =
        lens (_default_availability_zone :: OpsworksStackResource s -> TF.Attr s P.Zone)
             (\s a -> s { _default_availability_zone = a } :: OpsworksStackResource s)

instance P.HasDefaultInstanceProfileArn (OpsworksStackResource s) (TF.Attr s Text) where
    defaultInstanceProfileArn =
        lens (_default_instance_profile_arn :: OpsworksStackResource s -> TF.Attr s Text)
             (\s a -> s { _default_instance_profile_arn = a } :: OpsworksStackResource s)

instance P.HasDefaultOs (OpsworksStackResource s) (TF.Attr s Text) where
    defaultOs =
        lens (_default_os :: OpsworksStackResource s -> TF.Attr s Text)
             (\s a -> s { _default_os = a } :: OpsworksStackResource s)

instance P.HasDefaultRootDeviceType (OpsworksStackResource s) (TF.Attr s Text) where
    defaultRootDeviceType =
        lens (_default_root_device_type :: OpsworksStackResource s -> TF.Attr s Text)
             (\s a -> s { _default_root_device_type = a } :: OpsworksStackResource s)

instance P.HasDefaultSshKeyName (OpsworksStackResource s) (TF.Attr s Text) where
    defaultSshKeyName =
        lens (_default_ssh_key_name :: OpsworksStackResource s -> TF.Attr s Text)
             (\s a -> s { _default_ssh_key_name = a } :: OpsworksStackResource s)

instance P.HasDefaultSubnetId (OpsworksStackResource s) (TF.Attr s Text) where
    defaultSubnetId =
        lens (_default_subnet_id :: OpsworksStackResource s -> TF.Attr s Text)
             (\s a -> s { _default_subnet_id = a } :: OpsworksStackResource s)

instance P.HasHostnameTheme (OpsworksStackResource s) (TF.Attr s Text) where
    hostnameTheme =
        lens (_hostname_theme :: OpsworksStackResource s -> TF.Attr s Text)
             (\s a -> s { _hostname_theme = a } :: OpsworksStackResource s)

instance P.HasManageBerkshelf (OpsworksStackResource s) (TF.Attr s Text) where
    manageBerkshelf =
        lens (_manage_berkshelf :: OpsworksStackResource s -> TF.Attr s Text)
             (\s a -> s { _manage_berkshelf = a } :: OpsworksStackResource s)

instance P.HasName (OpsworksStackResource s) (TF.Attr s Text) where
    name =
        lens (_name :: OpsworksStackResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: OpsworksStackResource s)

instance P.HasRegion (OpsworksStackResource s) (TF.Attr s P.Region) where
    region =
        lens (_region :: OpsworksStackResource s -> TF.Attr s P.Region)
             (\s a -> s { _region = a } :: OpsworksStackResource s)

instance P.HasServiceRoleArn (OpsworksStackResource s) (TF.Attr s Text) where
    serviceRoleArn =
        lens (_service_role_arn :: OpsworksStackResource s -> TF.Attr s Text)
             (\s a -> s { _service_role_arn = a } :: OpsworksStackResource s)

instance P.HasTags (OpsworksStackResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: OpsworksStackResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: OpsworksStackResource s)

instance P.HasUseCustomCookbooks (OpsworksStackResource s) (TF.Attr s Text) where
    useCustomCookbooks =
        lens (_use_custom_cookbooks :: OpsworksStackResource s -> TF.Attr s Text)
             (\s a -> s { _use_custom_cookbooks = a } :: OpsworksStackResource s)

instance P.HasUseOpsworksSecurityGroups (OpsworksStackResource s) (TF.Attr s Text) where
    useOpsworksSecurityGroups =
        lens (_use_opsworks_security_groups :: OpsworksStackResource s -> TF.Attr s Text)
             (\s a -> s { _use_opsworks_security_groups = a } :: OpsworksStackResource s)

instance P.HasVpcId (OpsworksStackResource s) (TF.Attr s Text) where
    vpcId =
        lens (_vpc_id :: OpsworksStackResource s -> TF.Attr s Text)
             (\s a -> s { _vpc_id = a } :: OpsworksStackResource s)

instance P.HasComputedAgentVersion (OpsworksStackResource s) s (TF.Attr s Text) where
    computedAgentVersion =
        (_agent_version :: OpsworksStackResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedBerkshelfVersion (OpsworksStackResource s) s (TF.Attr s Text) where
    computedBerkshelfVersion =
        (_berkshelf_version :: OpsworksStackResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedColor (OpsworksStackResource s) s (TF.Attr s Text) where
    computedColor =
        (_color :: OpsworksStackResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedConfigurationManagerName (OpsworksStackResource s) s (TF.Attr s Text) where
    computedConfigurationManagerName =
        (_configuration_manager_name :: OpsworksStackResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedConfigurationManagerVersion (OpsworksStackResource s) s (TF.Attr s Text) where
    computedConfigurationManagerVersion =
        (_configuration_manager_version :: OpsworksStackResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCustomCookbooksSource (OpsworksStackResource s) s (TF.Attr s Text) where
    computedCustomCookbooksSource =
        (_custom_cookbooks_source :: OpsworksStackResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCustomJson (OpsworksStackResource s) s (TF.Attr s Text) where
    computedCustomJson =
        (_custom_json :: OpsworksStackResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDefaultAvailabilityZone (OpsworksStackResource s) s (TF.Attr s P.Zone) where
    computedDefaultAvailabilityZone =
        (_default_availability_zone :: OpsworksStackResource s -> TF.Attr s P.Zone)
            . TF.refValue

instance P.HasComputedDefaultInstanceProfileArn (OpsworksStackResource s) s (TF.Attr s Text) where
    computedDefaultInstanceProfileArn =
        (_default_instance_profile_arn :: OpsworksStackResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDefaultOs (OpsworksStackResource s) s (TF.Attr s Text) where
    computedDefaultOs =
        (_default_os :: OpsworksStackResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDefaultRootDeviceType (OpsworksStackResource s) s (TF.Attr s Text) where
    computedDefaultRootDeviceType =
        (_default_root_device_type :: OpsworksStackResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDefaultSshKeyName (OpsworksStackResource s) s (TF.Attr s Text) where
    computedDefaultSshKeyName =
        (_default_ssh_key_name :: OpsworksStackResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDefaultSubnetId (OpsworksStackResource s) s (TF.Attr s Text) where
    computedDefaultSubnetId =
        (_default_subnet_id :: OpsworksStackResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedHostnameTheme (OpsworksStackResource s) s (TF.Attr s Text) where
    computedHostnameTheme =
        (_hostname_theme :: OpsworksStackResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (OpsworksStackResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedManageBerkshelf (OpsworksStackResource s) s (TF.Attr s Text) where
    computedManageBerkshelf =
        (_manage_berkshelf :: OpsworksStackResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (OpsworksStackResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: OpsworksStackResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRegion (OpsworksStackResource s) s (TF.Attr s P.Region) where
    computedRegion =
        (_region :: OpsworksStackResource s -> TF.Attr s P.Region)
            . TF.refValue

instance P.HasComputedServiceRoleArn (OpsworksStackResource s) s (TF.Attr s Text) where
    computedServiceRoleArn =
        (_service_role_arn :: OpsworksStackResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (OpsworksStackResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: OpsworksStackResource s -> TF.Attr s P.Tags)
            . TF.refValue

instance P.HasComputedUseCustomCookbooks (OpsworksStackResource s) s (TF.Attr s Text) where
    computedUseCustomCookbooks =
        (_use_custom_cookbooks :: OpsworksStackResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedUseOpsworksSecurityGroups (OpsworksStackResource s) s (TF.Attr s Text) where
    computedUseOpsworksSecurityGroups =
        (_use_opsworks_security_groups :: OpsworksStackResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedVpcId (OpsworksStackResource s) s (TF.Attr s Text) where
    computedVpcId =
        (_vpc_id :: OpsworksStackResource s -> TF.Attr s Text)
            . TF.refValue

opsworksStackResource :: TF.Schema TF.Resource P.AWS (OpsworksStackResource s)
opsworksStackResource =
    TF.newResource "aws_opsworks_stack" $
        OpsworksStackResource {
              _agent_version = TF.Nil
            , _berkshelf_version = TF.Nil
            , _color = TF.Nil
            , _configuration_manager_name = TF.Nil
            , _configuration_manager_version = TF.Nil
            , _custom_cookbooks_source = TF.Nil
            , _custom_json = TF.Nil
            , _default_availability_zone = TF.Nil
            , _default_instance_profile_arn = TF.Nil
            , _default_os = TF.Nil
            , _default_root_device_type = TF.Nil
            , _default_ssh_key_name = TF.Nil
            , _default_subnet_id = TF.Nil
            , _hostname_theme = TF.Nil
            , _manage_berkshelf = TF.Nil
            , _name = TF.Nil
            , _region = TF.Nil
            , _service_role_arn = TF.Nil
            , _tags = TF.Nil
            , _use_custom_cookbooks = TF.Nil
            , _use_opsworks_security_groups = TF.Nil
            , _vpc_id = TF.Nil
            }

{- | The @aws_opsworks_static_web_layer@ AWS resource.

Provides an OpsWorks static web server layer resource.
-}
data OpsworksStaticWebLayerResource s = OpsworksStaticWebLayerResource {
      _auto_assign_elastic_ips     :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to automatically assign an elastic IP address to the layer's instances. -}
    , _auto_assign_public_ips      :: !(TF.Attr s Text)
    {- ^ (Optional) For stacks belonging to a VPC, whether to automatically assign a public IP address to each of the layer's instances. -}
    , _auto_healing                :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to enable auto-healing for the layer. -}
    , _custom_instance_profile_arn :: !(TF.Attr s Text)
    {- ^ (Optional) The ARN of an IAM profile that will be used for the layer's instances. -}
    , _custom_security_group_ids   :: !(TF.Attr s Text)
    {- ^ (Optional) Ids for a set of security groups to apply to the layer's instances. -}
    , _drain_elb_on_shutdown       :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to enable Elastic Load Balancing connection draining. -}
    , _ebs_volume                  :: !(TF.Attr s Text)
    {- ^ (Optional) @ebs_volume@ blocks, as described below, will each create an EBS volume and connect it to the layer's instances. -}
    , _elastic_load_balancer       :: !(TF.Attr s Text)
    {- ^ (Optional) Name of an Elastic Load Balancer to attach to this layer -}
    , _install_updates_on_boot     :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to install OS and package updates on each instance when it boots. -}
    , _instance_shutdown_timeout   :: !(TF.Attr s Text)
    {- ^ (Optional) The time, in seconds, that OpsWorks will wait for Chef to complete after triggering the Shutdown event. -}
    , _name                        :: !(TF.Attr s Text)
    {- ^ (Optional) A human-readable name for the layer. -}
    , _stack_id                    :: !(TF.Attr s Text)
    {- ^ (Required) The id of the stack the layer will belong to. -}
    , _system_packages             :: !(TF.Attr s Text)
    {- ^ (Optional) Names of a set of system packages to install on the layer's instances. -}
    , _use_ebs_optimized_instances :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to use EBS-optimized instances. -}
    } deriving (Show, Eq)

instance TF.ToHCL (OpsworksStaticWebLayerResource s) where
    toHCL OpsworksStaticWebLayerResource{..} = TF.inline $ catMaybes
        [ TF.assign "auto_assign_elastic_ips" <$> TF.attribute _auto_assign_elastic_ips
        , TF.assign "auto_assign_public_ips" <$> TF.attribute _auto_assign_public_ips
        , TF.assign "auto_healing" <$> TF.attribute _auto_healing
        , TF.assign "custom_instance_profile_arn" <$> TF.attribute _custom_instance_profile_arn
        , TF.assign "custom_security_group_ids" <$> TF.attribute _custom_security_group_ids
        , TF.assign "drain_elb_on_shutdown" <$> TF.attribute _drain_elb_on_shutdown
        , TF.assign "ebs_volume" <$> TF.attribute _ebs_volume
        , TF.assign "elastic_load_balancer" <$> TF.attribute _elastic_load_balancer
        , TF.assign "install_updates_on_boot" <$> TF.attribute _install_updates_on_boot
        , TF.assign "instance_shutdown_timeout" <$> TF.attribute _instance_shutdown_timeout
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "stack_id" <$> TF.attribute _stack_id
        , TF.assign "system_packages" <$> TF.attribute _system_packages
        , TF.assign "use_ebs_optimized_instances" <$> TF.attribute _use_ebs_optimized_instances
        ]

instance P.HasAutoAssignElasticIps (OpsworksStaticWebLayerResource s) (TF.Attr s Text) where
    autoAssignElasticIps =
        lens (_auto_assign_elastic_ips :: OpsworksStaticWebLayerResource s -> TF.Attr s Text)
             (\s a -> s { _auto_assign_elastic_ips = a } :: OpsworksStaticWebLayerResource s)

instance P.HasAutoAssignPublicIps (OpsworksStaticWebLayerResource s) (TF.Attr s Text) where
    autoAssignPublicIps =
        lens (_auto_assign_public_ips :: OpsworksStaticWebLayerResource s -> TF.Attr s Text)
             (\s a -> s { _auto_assign_public_ips = a } :: OpsworksStaticWebLayerResource s)

instance P.HasAutoHealing (OpsworksStaticWebLayerResource s) (TF.Attr s Text) where
    autoHealing =
        lens (_auto_healing :: OpsworksStaticWebLayerResource s -> TF.Attr s Text)
             (\s a -> s { _auto_healing = a } :: OpsworksStaticWebLayerResource s)

instance P.HasCustomInstanceProfileArn (OpsworksStaticWebLayerResource s) (TF.Attr s Text) where
    customInstanceProfileArn =
        lens (_custom_instance_profile_arn :: OpsworksStaticWebLayerResource s -> TF.Attr s Text)
             (\s a -> s { _custom_instance_profile_arn = a } :: OpsworksStaticWebLayerResource s)

instance P.HasCustomSecurityGroupIds (OpsworksStaticWebLayerResource s) (TF.Attr s Text) where
    customSecurityGroupIds =
        lens (_custom_security_group_ids :: OpsworksStaticWebLayerResource s -> TF.Attr s Text)
             (\s a -> s { _custom_security_group_ids = a } :: OpsworksStaticWebLayerResource s)

instance P.HasDrainElbOnShutdown (OpsworksStaticWebLayerResource s) (TF.Attr s Text) where
    drainElbOnShutdown =
        lens (_drain_elb_on_shutdown :: OpsworksStaticWebLayerResource s -> TF.Attr s Text)
             (\s a -> s { _drain_elb_on_shutdown = a } :: OpsworksStaticWebLayerResource s)

instance P.HasEbsVolume (OpsworksStaticWebLayerResource s) (TF.Attr s Text) where
    ebsVolume =
        lens (_ebs_volume :: OpsworksStaticWebLayerResource s -> TF.Attr s Text)
             (\s a -> s { _ebs_volume = a } :: OpsworksStaticWebLayerResource s)

instance P.HasElasticLoadBalancer (OpsworksStaticWebLayerResource s) (TF.Attr s Text) where
    elasticLoadBalancer =
        lens (_elastic_load_balancer :: OpsworksStaticWebLayerResource s -> TF.Attr s Text)
             (\s a -> s { _elastic_load_balancer = a } :: OpsworksStaticWebLayerResource s)

instance P.HasInstallUpdatesOnBoot (OpsworksStaticWebLayerResource s) (TF.Attr s Text) where
    installUpdatesOnBoot =
        lens (_install_updates_on_boot :: OpsworksStaticWebLayerResource s -> TF.Attr s Text)
             (\s a -> s { _install_updates_on_boot = a } :: OpsworksStaticWebLayerResource s)

instance P.HasInstanceShutdownTimeout (OpsworksStaticWebLayerResource s) (TF.Attr s Text) where
    instanceShutdownTimeout =
        lens (_instance_shutdown_timeout :: OpsworksStaticWebLayerResource s -> TF.Attr s Text)
             (\s a -> s { _instance_shutdown_timeout = a } :: OpsworksStaticWebLayerResource s)

instance P.HasName (OpsworksStaticWebLayerResource s) (TF.Attr s Text) where
    name =
        lens (_name :: OpsworksStaticWebLayerResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: OpsworksStaticWebLayerResource s)

instance P.HasStackId (OpsworksStaticWebLayerResource s) (TF.Attr s Text) where
    stackId =
        lens (_stack_id :: OpsworksStaticWebLayerResource s -> TF.Attr s Text)
             (\s a -> s { _stack_id = a } :: OpsworksStaticWebLayerResource s)

instance P.HasSystemPackages (OpsworksStaticWebLayerResource s) (TF.Attr s Text) where
    systemPackages =
        lens (_system_packages :: OpsworksStaticWebLayerResource s -> TF.Attr s Text)
             (\s a -> s { _system_packages = a } :: OpsworksStaticWebLayerResource s)

instance P.HasUseEbsOptimizedInstances (OpsworksStaticWebLayerResource s) (TF.Attr s Text) where
    useEbsOptimizedInstances =
        lens (_use_ebs_optimized_instances :: OpsworksStaticWebLayerResource s -> TF.Attr s Text)
             (\s a -> s { _use_ebs_optimized_instances = a } :: OpsworksStaticWebLayerResource s)

instance P.HasComputedAutoAssignElasticIps (OpsworksStaticWebLayerResource s) s (TF.Attr s Text) where
    computedAutoAssignElasticIps =
        (_auto_assign_elastic_ips :: OpsworksStaticWebLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAutoAssignPublicIps (OpsworksStaticWebLayerResource s) s (TF.Attr s Text) where
    computedAutoAssignPublicIps =
        (_auto_assign_public_ips :: OpsworksStaticWebLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAutoHealing (OpsworksStaticWebLayerResource s) s (TF.Attr s Text) where
    computedAutoHealing =
        (_auto_healing :: OpsworksStaticWebLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCustomInstanceProfileArn (OpsworksStaticWebLayerResource s) s (TF.Attr s Text) where
    computedCustomInstanceProfileArn =
        (_custom_instance_profile_arn :: OpsworksStaticWebLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCustomSecurityGroupIds (OpsworksStaticWebLayerResource s) s (TF.Attr s Text) where
    computedCustomSecurityGroupIds =
        (_custom_security_group_ids :: OpsworksStaticWebLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDrainElbOnShutdown (OpsworksStaticWebLayerResource s) s (TF.Attr s Text) where
    computedDrainElbOnShutdown =
        (_drain_elb_on_shutdown :: OpsworksStaticWebLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEbsVolume (OpsworksStaticWebLayerResource s) s (TF.Attr s Text) where
    computedEbsVolume =
        (_ebs_volume :: OpsworksStaticWebLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedElasticLoadBalancer (OpsworksStaticWebLayerResource s) s (TF.Attr s Text) where
    computedElasticLoadBalancer =
        (_elastic_load_balancer :: OpsworksStaticWebLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (OpsworksStaticWebLayerResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedInstallUpdatesOnBoot (OpsworksStaticWebLayerResource s) s (TF.Attr s Text) where
    computedInstallUpdatesOnBoot =
        (_install_updates_on_boot :: OpsworksStaticWebLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedInstanceShutdownTimeout (OpsworksStaticWebLayerResource s) s (TF.Attr s Text) where
    computedInstanceShutdownTimeout =
        (_instance_shutdown_timeout :: OpsworksStaticWebLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (OpsworksStaticWebLayerResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: OpsworksStaticWebLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedStackId (OpsworksStaticWebLayerResource s) s (TF.Attr s Text) where
    computedStackId =
        (_stack_id :: OpsworksStaticWebLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSystemPackages (OpsworksStaticWebLayerResource s) s (TF.Attr s Text) where
    computedSystemPackages =
        (_system_packages :: OpsworksStaticWebLayerResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedUseEbsOptimizedInstances (OpsworksStaticWebLayerResource s) s (TF.Attr s Text) where
    computedUseEbsOptimizedInstances =
        (_use_ebs_optimized_instances :: OpsworksStaticWebLayerResource s -> TF.Attr s Text)
            . TF.refValue

opsworksStaticWebLayerResource :: TF.Schema TF.Resource P.AWS (OpsworksStaticWebLayerResource s)
opsworksStaticWebLayerResource =
    TF.newResource "aws_opsworks_static_web_layer" $
        OpsworksStaticWebLayerResource {
              _auto_assign_elastic_ips = TF.Nil
            , _auto_assign_public_ips = TF.Nil
            , _auto_healing = TF.Nil
            , _custom_instance_profile_arn = TF.Nil
            , _custom_security_group_ids = TF.Nil
            , _drain_elb_on_shutdown = TF.Nil
            , _ebs_volume = TF.Nil
            , _elastic_load_balancer = TF.Nil
            , _install_updates_on_boot = TF.Nil
            , _instance_shutdown_timeout = TF.Nil
            , _name = TF.Nil
            , _stack_id = TF.Nil
            , _system_packages = TF.Nil
            , _use_ebs_optimized_instances = TF.Nil
            }

{- | The @aws_opsworks_user_profile@ AWS resource.

Provides an OpsWorks User Profile resource.
-}
data OpsworksUserProfileResource s = OpsworksUserProfileResource {
      _allow_self_management :: !(TF.Attr s Text)
    {- ^ (Optional) Whether users can specify their own SSH public key through the My Settings page -}
    , _ssh_public_key        :: !(TF.Attr s Text)
    {- ^ (Optional) The users public key -}
    , _ssh_username          :: !(TF.Attr s Text)
    {- ^ (Required) The ssh username, with witch this user wants to log in -}
    , _user_arn              :: !(TF.Attr s Text)
    {- ^ (Required) The user's IAM ARN -}
    } deriving (Show, Eq)

instance TF.ToHCL (OpsworksUserProfileResource s) where
    toHCL OpsworksUserProfileResource{..} = TF.inline $ catMaybes
        [ TF.assign "allow_self_management" <$> TF.attribute _allow_self_management
        , TF.assign "ssh_public_key" <$> TF.attribute _ssh_public_key
        , TF.assign "ssh_username" <$> TF.attribute _ssh_username
        , TF.assign "user_arn" <$> TF.attribute _user_arn
        ]

instance P.HasAllowSelfManagement (OpsworksUserProfileResource s) (TF.Attr s Text) where
    allowSelfManagement =
        lens (_allow_self_management :: OpsworksUserProfileResource s -> TF.Attr s Text)
             (\s a -> s { _allow_self_management = a } :: OpsworksUserProfileResource s)

instance P.HasSshPublicKey (OpsworksUserProfileResource s) (TF.Attr s Text) where
    sshPublicKey =
        lens (_ssh_public_key :: OpsworksUserProfileResource s -> TF.Attr s Text)
             (\s a -> s { _ssh_public_key = a } :: OpsworksUserProfileResource s)

instance P.HasSshUsername (OpsworksUserProfileResource s) (TF.Attr s Text) where
    sshUsername =
        lens (_ssh_username :: OpsworksUserProfileResource s -> TF.Attr s Text)
             (\s a -> s { _ssh_username = a } :: OpsworksUserProfileResource s)

instance P.HasUserArn (OpsworksUserProfileResource s) (TF.Attr s Text) where
    userArn =
        lens (_user_arn :: OpsworksUserProfileResource s -> TF.Attr s Text)
             (\s a -> s { _user_arn = a } :: OpsworksUserProfileResource s)

instance P.HasComputedAllowSelfManagement (OpsworksUserProfileResource s) s (TF.Attr s Text) where
    computedAllowSelfManagement =
        (_allow_self_management :: OpsworksUserProfileResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (OpsworksUserProfileResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedSshPublicKey (OpsworksUserProfileResource s) s (TF.Attr s Text) where
    computedSshPublicKey =
        (_ssh_public_key :: OpsworksUserProfileResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSshUsername (OpsworksUserProfileResource s) s (TF.Attr s Text) where
    computedSshUsername =
        (_ssh_username :: OpsworksUserProfileResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedUserArn (OpsworksUserProfileResource s) s (TF.Attr s Text) where
    computedUserArn =
        (_user_arn :: OpsworksUserProfileResource s -> TF.Attr s Text)
            . TF.refValue

opsworksUserProfileResource :: TF.Schema TF.Resource P.AWS (OpsworksUserProfileResource s)
opsworksUserProfileResource =
    TF.newResource "aws_opsworks_user_profile" $
        OpsworksUserProfileResource {
              _allow_self_management = TF.Nil
            , _ssh_public_key = TF.Nil
            , _ssh_username = TF.Nil
            , _user_arn = TF.Nil
            }

{- | The @aws_placement_group@ AWS resource.

Provides an EC2 placement group. Read more about placement groups in
<https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/placement-groups.html>
.
-}
data PlacementGroupResource s = PlacementGroupResource {
      _name     :: !(TF.Attr s Text)
    {- ^ (Required) The name of the placement group. -}
    , _strategy :: !(TF.Attr s Text)
    {- ^ (Required) The placement strategy. -}
    } deriving (Show, Eq)

instance TF.ToHCL (PlacementGroupResource s) where
    toHCL PlacementGroupResource{..} = TF.inline $ catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "strategy" <$> TF.attribute _strategy
        ]

instance P.HasName (PlacementGroupResource s) (TF.Attr s Text) where
    name =
        lens (_name :: PlacementGroupResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: PlacementGroupResource s)

instance P.HasStrategy (PlacementGroupResource s) (TF.Attr s Text) where
    strategy =
        lens (_strategy :: PlacementGroupResource s -> TF.Attr s Text)
             (\s a -> s { _strategy = a } :: PlacementGroupResource s)

instance P.HasComputedId (PlacementGroupResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (PlacementGroupResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: PlacementGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedStrategy (PlacementGroupResource s) s (TF.Attr s Text) where
    computedStrategy =
        (_strategy :: PlacementGroupResource s -> TF.Attr s Text)
            . TF.refValue

placementGroupResource :: TF.Schema TF.Resource P.AWS (PlacementGroupResource s)
placementGroupResource =
    TF.newResource "aws_placement_group" $
        PlacementGroupResource {
              _name = TF.Nil
            , _strategy = TF.Nil
            }

{- | The @aws_proxy_protocol_policy@ AWS resource.

Provides a proxy protocol policy, which allows an ELB to carry a client
connection information to a backend.
-}
data ProxyProtocolPolicyResource s = ProxyProtocolPolicyResource {
      _instance_ports :: !(TF.Attr s Text)
    {- ^ (Required) List of instance ports to which the policy should be applied. This can be specified if the protocol is SSL or TCP. -}
    , _load_balancer  :: !(TF.Attr s Text)
    {- ^ (Required) The load balancer to which the policy should be attached. -}
    } deriving (Show, Eq)

instance TF.ToHCL (ProxyProtocolPolicyResource s) where
    toHCL ProxyProtocolPolicyResource{..} = TF.inline $ catMaybes
        [ TF.assign "instance_ports" <$> TF.attribute _instance_ports
        , TF.assign "load_balancer" <$> TF.attribute _load_balancer
        ]

instance P.HasInstancePorts (ProxyProtocolPolicyResource s) (TF.Attr s Text) where
    instancePorts =
        lens (_instance_ports :: ProxyProtocolPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _instance_ports = a } :: ProxyProtocolPolicyResource s)

instance P.HasLoadBalancer (ProxyProtocolPolicyResource s) (TF.Attr s Text) where
    loadBalancer =
        lens (_load_balancer :: ProxyProtocolPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _load_balancer = a } :: ProxyProtocolPolicyResource s)

instance P.HasComputedId (ProxyProtocolPolicyResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedInstancePorts (ProxyProtocolPolicyResource s) s (TF.Attr s Text) where
    computedInstancePorts =
        (_instance_ports :: ProxyProtocolPolicyResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedLoadBalancer (ProxyProtocolPolicyResource s) s (TF.Attr s Text) where
    computedLoadBalancer x = TF.compute (TF.refKey x) "load_balancer"

proxyProtocolPolicyResource :: TF.Schema TF.Resource P.AWS (ProxyProtocolPolicyResource s)
proxyProtocolPolicyResource =
    TF.newResource "aws_proxy_protocol_policy" $
        ProxyProtocolPolicyResource {
              _instance_ports = TF.Nil
            , _load_balancer = TF.Nil
            }

{- | The @aws_rds_cluster_instance@ AWS resource.

Provides an RDS Cluster Resource Instance. A Cluster Instance Resource
defines attributes that are specific to a single instance in a
</docs/providers/aws/r/rds_cluster.html> , specifically running Amazon
Aurora. Unlike other RDS resources that support replication, with Amazon
Aurora you do not designate a primary and subsequent replicas. Instead, you
simply add RDS Instances and Aurora manages the replication. You can use the
</docs/configuration/resources.html#count> meta-parameter to make multiple
instances and join them all to the same RDS Cluster, or you may specify
different Cluster Instance resources with various @instance_class@ sizes.
For more information on Amazon Aurora, see
<https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Aurora.html> in
the Amazon RDS User Guide.
-}
data RdsClusterInstanceResource s = RdsClusterInstanceResource {
      _apply_immediately               :: !(TF.Attr s Text)
    {- ^ (Optional) Specifies whether any database modifications are applied immediately, or during the next maintenance window. Default is @false@ . -}
    , _auto_minor_version_upgrade      :: !(TF.Attr s Text)
    {- ^ (Optional) Indicates that minor engine upgrades will be applied automatically to the DB instance during the maintenance window. Default @true@ . -}
    , _availability_zone               :: !(TF.Attr s P.Zone)
    {- ^ (Optional, Computed) The EC2 Availability Zone that the DB instance is created in. See <https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_CreateDBInstance.html> about the details. -}
    , _cluster_identifier              :: !(TF.Attr s Text)
    {- ^ (Required) The identifier of the </docs/providers/aws/r/rds_cluster.html> in which to launch this instance. -}
    , _db_parameter_group_name         :: !(TF.Attr s Text)
    {- ^ (Optional) The name of the DB parameter group to associate with this instance. -}
    , _db_subnet_group_name            :: !(TF.Attr s Text)
    {- ^ (Required if @publicly_accessible = false@ , Optional otherwise) A DB subnet group to associate with this DB instance. NOTE: This must match the @db_subnet_group_name@ of the attached </docs/providers/aws/r/rds_cluster.html> . -}
    , _engine                          :: !(TF.Attr s Text)
    {- ^ (Optional) The name of the database engine to be used for the RDS instance. Defaults to @aurora@ . -}
    , _engine_version                  :: !(TF.Attr s Text)
    {- ^ (Optional) The database engine version. -}
    , _identifier                      :: !(TF.Attr s Text)
    {- ^ (Optional, Forces new resource) The indentifier for the RDS instance, if omitted, Terraform will assign a random, unique identifier. -}
    , _identifier_prefix               :: !(TF.Attr s Text)
    {- ^ (Optional, Forces new resource) Creates a unique identifier beginning with the specified prefix. Conflicts with @identifer@ . -}
    , _instance_class                  :: !(TF.Attr s Text)
    {- ^ (Required) The instance class to use. For details on CPU and memory, see <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Aurora.Managing.html> . Aurora currently supports the below instance classes. -}
    , _monitoring_interval             :: !(TF.Attr s Text)
    {- ^ (Optional) The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB instance. To disable collecting Enhanced Monitoring metrics, specify 0. The default is 0. Valid Values: 0, 1, 5, 10, 15, 30, 60. -}
    , _monitoring_role_arn             :: !(TF.Attr s Text)
    {- ^ (Optional) The ARN for the IAM role that permits RDS to send enhanced monitoring metrics to CloudWatch Logs. You can find more information on the <http://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Monitoring.html> what IAM permissions are needed to allow Enhanced Monitoring for RDS Instances. -}
    , _performance_insights_enabled    :: !(TF.Attr s P.Bool)
    {- ^ (Optional) Specifies whether Performance Insights is enabled or not. -}
    , _performance_insights_kms_key_id :: !(TF.Attr s Text)
    {- ^ (Optional) The ARN for the KMS key to encrypt Performance Insights data. When specifying @performance_insights_kms_key_id@ , @performance_insights_enabled@ needs to be set to true. -}
    , _preferred_backup_window         :: !(TF.Attr s Text)
    {- ^ (Optional) The daily time range during which automated backups are created if automated backups are enabled. Eg: "04:00-09:00" -}
    , _preferred_maintenance_window    :: !(TF.Attr s Text)
    {- ^ (Optional) The window to perform maintenance in. Syntax: "ddd:hh24:mi-ddd:hh24:mi". Eg: "Mon:00:00-Mon:03:00". -}
    , _promotion_tier                  :: !(TF.Attr s Text)
    {- ^ (Optional) Default 0. Failover Priority setting on instance level. The reader who has lower tier has higher priority to get promoter to writer. -}
    , _publicly_accessible             :: !(TF.Attr s Text)
    {- ^ (Optional) Bool to control if instance is publicly accessible. Default @false@ . See the documentation on <https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_CreateDBInstance.html> for more details on controlling this property. -}
    , _tags                            :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the instance. -}
    } deriving (Show, Eq)

instance TF.ToHCL (RdsClusterInstanceResource s) where
    toHCL RdsClusterInstanceResource{..} = TF.inline $ catMaybes
        [ TF.assign "apply_immediately" <$> TF.attribute _apply_immediately
        , TF.assign "auto_minor_version_upgrade" <$> TF.attribute _auto_minor_version_upgrade
        , TF.assign "availability_zone" <$> TF.attribute _availability_zone
        , TF.assign "cluster_identifier" <$> TF.attribute _cluster_identifier
        , TF.assign "db_parameter_group_name" <$> TF.attribute _db_parameter_group_name
        , TF.assign "db_subnet_group_name" <$> TF.attribute _db_subnet_group_name
        , TF.assign "engine" <$> TF.attribute _engine
        , TF.assign "engine_version" <$> TF.attribute _engine_version
        , TF.assign "identifier" <$> TF.attribute _identifier
        , TF.assign "identifier_prefix" <$> TF.attribute _identifier_prefix
        , TF.assign "instance_class" <$> TF.attribute _instance_class
        , TF.assign "monitoring_interval" <$> TF.attribute _monitoring_interval
        , TF.assign "monitoring_role_arn" <$> TF.attribute _monitoring_role_arn
        , TF.assign "performance_insights_enabled" <$> TF.attribute _performance_insights_enabled
        , TF.assign "performance_insights_kms_key_id" <$> TF.attribute _performance_insights_kms_key_id
        , TF.assign "preferred_backup_window" <$> TF.attribute _preferred_backup_window
        , TF.assign "preferred_maintenance_window" <$> TF.attribute _preferred_maintenance_window
        , TF.assign "promotion_tier" <$> TF.attribute _promotion_tier
        , TF.assign "publicly_accessible" <$> TF.attribute _publicly_accessible
        , TF.assign "tags" <$> TF.attribute _tags
        ]

instance P.HasApplyImmediately (RdsClusterInstanceResource s) (TF.Attr s Text) where
    applyImmediately =
        lens (_apply_immediately :: RdsClusterInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _apply_immediately = a } :: RdsClusterInstanceResource s)

instance P.HasAutoMinorVersionUpgrade (RdsClusterInstanceResource s) (TF.Attr s Text) where
    autoMinorVersionUpgrade =
        lens (_auto_minor_version_upgrade :: RdsClusterInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _auto_minor_version_upgrade = a } :: RdsClusterInstanceResource s)

instance P.HasAvailabilityZone (RdsClusterInstanceResource s) (TF.Attr s P.Zone) where
    availabilityZone =
        lens (_availability_zone :: RdsClusterInstanceResource s -> TF.Attr s P.Zone)
             (\s a -> s { _availability_zone = a } :: RdsClusterInstanceResource s)

instance P.HasClusterIdentifier (RdsClusterInstanceResource s) (TF.Attr s Text) where
    clusterIdentifier =
        lens (_cluster_identifier :: RdsClusterInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _cluster_identifier = a } :: RdsClusterInstanceResource s)

instance P.HasDbParameterGroupName (RdsClusterInstanceResource s) (TF.Attr s Text) where
    dbParameterGroupName =
        lens (_db_parameter_group_name :: RdsClusterInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _db_parameter_group_name = a } :: RdsClusterInstanceResource s)

instance P.HasDbSubnetGroupName (RdsClusterInstanceResource s) (TF.Attr s Text) where
    dbSubnetGroupName =
        lens (_db_subnet_group_name :: RdsClusterInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _db_subnet_group_name = a } :: RdsClusterInstanceResource s)

instance P.HasEngine (RdsClusterInstanceResource s) (TF.Attr s Text) where
    engine =
        lens (_engine :: RdsClusterInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _engine = a } :: RdsClusterInstanceResource s)

instance P.HasEngineVersion (RdsClusterInstanceResource s) (TF.Attr s Text) where
    engineVersion =
        lens (_engine_version :: RdsClusterInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _engine_version = a } :: RdsClusterInstanceResource s)

instance P.HasIdentifier (RdsClusterInstanceResource s) (TF.Attr s Text) where
    identifier =
        lens (_identifier :: RdsClusterInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _identifier = a } :: RdsClusterInstanceResource s)

instance P.HasIdentifierPrefix (RdsClusterInstanceResource s) (TF.Attr s Text) where
    identifierPrefix =
        lens (_identifier_prefix :: RdsClusterInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _identifier_prefix = a } :: RdsClusterInstanceResource s)

instance P.HasInstanceClass (RdsClusterInstanceResource s) (TF.Attr s Text) where
    instanceClass =
        lens (_instance_class :: RdsClusterInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _instance_class = a } :: RdsClusterInstanceResource s)

instance P.HasMonitoringInterval (RdsClusterInstanceResource s) (TF.Attr s Text) where
    monitoringInterval =
        lens (_monitoring_interval :: RdsClusterInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _monitoring_interval = a } :: RdsClusterInstanceResource s)

instance P.HasMonitoringRoleArn (RdsClusterInstanceResource s) (TF.Attr s Text) where
    monitoringRoleArn =
        lens (_monitoring_role_arn :: RdsClusterInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _monitoring_role_arn = a } :: RdsClusterInstanceResource s)

instance P.HasPerformanceInsightsEnabled (RdsClusterInstanceResource s) (TF.Attr s P.Bool) where
    performanceInsightsEnabled =
        lens (_performance_insights_enabled :: RdsClusterInstanceResource s -> TF.Attr s P.Bool)
             (\s a -> s { _performance_insights_enabled = a } :: RdsClusterInstanceResource s)

instance P.HasPerformanceInsightsKmsKeyId (RdsClusterInstanceResource s) (TF.Attr s Text) where
    performanceInsightsKmsKeyId =
        lens (_performance_insights_kms_key_id :: RdsClusterInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _performance_insights_kms_key_id = a } :: RdsClusterInstanceResource s)

instance P.HasPreferredBackupWindow (RdsClusterInstanceResource s) (TF.Attr s Text) where
    preferredBackupWindow =
        lens (_preferred_backup_window :: RdsClusterInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _preferred_backup_window = a } :: RdsClusterInstanceResource s)

instance P.HasPreferredMaintenanceWindow (RdsClusterInstanceResource s) (TF.Attr s Text) where
    preferredMaintenanceWindow =
        lens (_preferred_maintenance_window :: RdsClusterInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _preferred_maintenance_window = a } :: RdsClusterInstanceResource s)

instance P.HasPromotionTier (RdsClusterInstanceResource s) (TF.Attr s Text) where
    promotionTier =
        lens (_promotion_tier :: RdsClusterInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _promotion_tier = a } :: RdsClusterInstanceResource s)

instance P.HasPubliclyAccessible (RdsClusterInstanceResource s) (TF.Attr s Text) where
    publiclyAccessible =
        lens (_publicly_accessible :: RdsClusterInstanceResource s -> TF.Attr s Text)
             (\s a -> s { _publicly_accessible = a } :: RdsClusterInstanceResource s)

instance P.HasTags (RdsClusterInstanceResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: RdsClusterInstanceResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: RdsClusterInstanceResource s)

instance P.HasComputedAllocatedStorage (RdsClusterInstanceResource s) s (TF.Attr s Text) where
    computedAllocatedStorage x = TF.compute (TF.refKey x) "allocated_storage"

instance P.HasComputedApplyImmediately (RdsClusterInstanceResource s) s (TF.Attr s Text) where
    computedApplyImmediately =
        (_apply_immediately :: RdsClusterInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAutoMinorVersionUpgrade (RdsClusterInstanceResource s) s (TF.Attr s Text) where
    computedAutoMinorVersionUpgrade =
        (_auto_minor_version_upgrade :: RdsClusterInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAvailabilityZone (RdsClusterInstanceResource s) s (TF.Attr s P.Zone) where
    computedAvailabilityZone x = TF.compute (TF.refKey x) "availability_zone"

instance P.HasComputedClusterIdentifier (RdsClusterInstanceResource s) s (TF.Attr s Text) where
    computedClusterIdentifier x = TF.compute (TF.refKey x) "cluster_identifier"

instance P.HasComputedDatabaseName (RdsClusterInstanceResource s) s (TF.Attr s Text) where
    computedDatabaseName x = TF.compute (TF.refKey x) "database_name"

instance P.HasComputedDbParameterGroupName (RdsClusterInstanceResource s) s (TF.Attr s Text) where
    computedDbParameterGroupName =
        (_db_parameter_group_name :: RdsClusterInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDbSubnetGroupName (RdsClusterInstanceResource s) s (TF.Attr s Text) where
    computedDbSubnetGroupName =
        (_db_subnet_group_name :: RdsClusterInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDbiResourceId (RdsClusterInstanceResource s) s (TF.Attr s Text) where
    computedDbiResourceId x = TF.compute (TF.refKey x) "dbi_resource_id"

instance P.HasComputedEndpoint (RdsClusterInstanceResource s) s (TF.Attr s Text) where
    computedEndpoint x = TF.compute (TF.refKey x) "endpoint"

instance P.HasComputedEngine (RdsClusterInstanceResource s) s (TF.Attr s Text) where
    computedEngine x = TF.compute (TF.refKey x) "engine"

instance P.HasComputedEngineVersion (RdsClusterInstanceResource s) s (TF.Attr s Text) where
    computedEngineVersion x = TF.compute (TF.refKey x) "engine_version"

instance P.HasComputedId (RdsClusterInstanceResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedIdentifier (RdsClusterInstanceResource s) s (TF.Attr s Text) where
    computedIdentifier x = TF.compute (TF.refKey x) "identifier"

instance P.HasComputedIdentifierPrefix (RdsClusterInstanceResource s) s (TF.Attr s Text) where
    computedIdentifierPrefix =
        (_identifier_prefix :: RdsClusterInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedInstanceClass (RdsClusterInstanceResource s) s (TF.Attr s Text) where
    computedInstanceClass =
        (_instance_class :: RdsClusterInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedKmsKeyId (RdsClusterInstanceResource s) s (TF.Attr s Text) where
    computedKmsKeyId x = TF.compute (TF.refKey x) "kms_key_id"

instance P.HasComputedMonitoringInterval (RdsClusterInstanceResource s) s (TF.Attr s Text) where
    computedMonitoringInterval =
        (_monitoring_interval :: RdsClusterInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedMonitoringRoleArn (RdsClusterInstanceResource s) s (TF.Attr s Text) where
    computedMonitoringRoleArn =
        (_monitoring_role_arn :: RdsClusterInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPerformanceInsightsEnabled (RdsClusterInstanceResource s) s (TF.Attr s P.Bool) where
    computedPerformanceInsightsEnabled x = TF.compute (TF.refKey x) "performance_insights_enabled"

instance P.HasComputedPerformanceInsightsKmsKeyId (RdsClusterInstanceResource s) s (TF.Attr s Text) where
    computedPerformanceInsightsKmsKeyId x = TF.compute (TF.refKey x) "performance_insights_kms_key_id"

instance P.HasComputedPort (RdsClusterInstanceResource s) s (TF.Attr s Text) where
    computedPort x = TF.compute (TF.refKey x) "port"

instance P.HasComputedPreferredBackupWindow (RdsClusterInstanceResource s) s (TF.Attr s Text) where
    computedPreferredBackupWindow =
        (_preferred_backup_window :: RdsClusterInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPreferredMaintenanceWindow (RdsClusterInstanceResource s) s (TF.Attr s Text) where
    computedPreferredMaintenanceWindow =
        (_preferred_maintenance_window :: RdsClusterInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPromotionTier (RdsClusterInstanceResource s) s (TF.Attr s Text) where
    computedPromotionTier =
        (_promotion_tier :: RdsClusterInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPubliclyAccessible (RdsClusterInstanceResource s) s (TF.Attr s Text) where
    computedPubliclyAccessible =
        (_publicly_accessible :: RdsClusterInstanceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedStatus (RdsClusterInstanceResource s) s (TF.Attr s Text) where
    computedStatus x = TF.compute (TF.refKey x) "status"

instance P.HasComputedStorageEncrypted (RdsClusterInstanceResource s) s (TF.Attr s Text) where
    computedStorageEncrypted x = TF.compute (TF.refKey x) "storage_encrypted"

instance P.HasComputedTags (RdsClusterInstanceResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: RdsClusterInstanceResource s -> TF.Attr s P.Tags)
            . TF.refValue

instance P.HasComputedWriter (RdsClusterInstanceResource s) s (TF.Attr s Text) where
    computedWriter x = TF.compute (TF.refKey x) "writer"

rdsClusterInstanceResource :: TF.Schema TF.Resource P.AWS (RdsClusterInstanceResource s)
rdsClusterInstanceResource =
    TF.newResource "aws_rds_cluster_instance" $
        RdsClusterInstanceResource {
              _apply_immediately = TF.Nil
            , _auto_minor_version_upgrade = TF.Nil
            , _availability_zone = TF.Nil
            , _cluster_identifier = TF.Nil
            , _db_parameter_group_name = TF.Nil
            , _db_subnet_group_name = TF.Nil
            , _engine = TF.Nil
            , _engine_version = TF.Nil
            , _identifier = TF.Nil
            , _identifier_prefix = TF.Nil
            , _instance_class = TF.Nil
            , _monitoring_interval = TF.Nil
            , _monitoring_role_arn = TF.Nil
            , _performance_insights_enabled = TF.Nil
            , _performance_insights_kms_key_id = TF.Nil
            , _preferred_backup_window = TF.Nil
            , _preferred_maintenance_window = TF.Nil
            , _promotion_tier = TF.Nil
            , _publicly_accessible = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_rds_cluster_parameter_group@ AWS resource.

Provides an RDS DB cluster parameter group resource.
-}
data RdsClusterParameterGroupResource s = RdsClusterParameterGroupResource {
      _description :: !(TF.Attr s Text)
    {- ^ (Optional) The description of the DB cluster parameter group. Defaults to "Managed by Terraform". -}
    , _family'     :: !(TF.Attr s Text)
    {- ^ (Required) The family of the DB cluster parameter group. -}
    , _name        :: !(TF.Attr s Text)
    {- ^ (Optional, Forces new resource) The name of the DB cluster parameter group. If omitted, Terraform will assign a random, unique name. -}
    , _name_prefix :: !(TF.Attr s Text)
    {- ^ (Optional, Forces new resource) Creates a unique name beginning with the specified prefix. Conflicts with @name@ . -}
    , _parameter   :: !(TF.Attr s Text)
    {- ^ (Optional) A list of DB parameters to apply. Note that parameters may differ from a family to an other. Full list of all parameters can be discovered via <https://docs.aws.amazon.com/cli/latest/reference/rds/describe-db-cluster-parameters.html> after initial creation of the group. -}
    , _tags        :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    } deriving (Show, Eq)

instance TF.ToHCL (RdsClusterParameterGroupResource s) where
    toHCL RdsClusterParameterGroupResource{..} = TF.inline $ catMaybes
        [ TF.assign "description" <$> TF.attribute _description
        , TF.assign "family" <$> TF.attribute _family'
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "name_prefix" <$> TF.attribute _name_prefix
        , TF.assign "parameter" <$> TF.attribute _parameter
        , TF.assign "tags" <$> TF.attribute _tags
        ]

instance P.HasDescription (RdsClusterParameterGroupResource s) (TF.Attr s Text) where
    description =
        lens (_description :: RdsClusterParameterGroupResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: RdsClusterParameterGroupResource s)

instance P.HasFamily' (RdsClusterParameterGroupResource s) (TF.Attr s Text) where
    family' =
        lens (_family' :: RdsClusterParameterGroupResource s -> TF.Attr s Text)
             (\s a -> s { _family' = a } :: RdsClusterParameterGroupResource s)

instance P.HasName (RdsClusterParameterGroupResource s) (TF.Attr s Text) where
    name =
        lens (_name :: RdsClusterParameterGroupResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: RdsClusterParameterGroupResource s)

instance P.HasNamePrefix (RdsClusterParameterGroupResource s) (TF.Attr s Text) where
    namePrefix =
        lens (_name_prefix :: RdsClusterParameterGroupResource s -> TF.Attr s Text)
             (\s a -> s { _name_prefix = a } :: RdsClusterParameterGroupResource s)

instance P.HasParameter (RdsClusterParameterGroupResource s) (TF.Attr s Text) where
    parameter =
        lens (_parameter :: RdsClusterParameterGroupResource s -> TF.Attr s Text)
             (\s a -> s { _parameter = a } :: RdsClusterParameterGroupResource s)

instance P.HasTags (RdsClusterParameterGroupResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: RdsClusterParameterGroupResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: RdsClusterParameterGroupResource s)

instance P.HasComputedArn (RdsClusterParameterGroupResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedDescription (RdsClusterParameterGroupResource s) s (TF.Attr s Text) where
    computedDescription =
        (_description :: RdsClusterParameterGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedFamily' (RdsClusterParameterGroupResource s) s (TF.Attr s Text) where
    computedFamily' =
        (_family' :: RdsClusterParameterGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (RdsClusterParameterGroupResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (RdsClusterParameterGroupResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: RdsClusterParameterGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedNamePrefix (RdsClusterParameterGroupResource s) s (TF.Attr s Text) where
    computedNamePrefix =
        (_name_prefix :: RdsClusterParameterGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedParameter (RdsClusterParameterGroupResource s) s (TF.Attr s Text) where
    computedParameter =
        (_parameter :: RdsClusterParameterGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (RdsClusterParameterGroupResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: RdsClusterParameterGroupResource s -> TF.Attr s P.Tags)
            . TF.refValue

rdsClusterParameterGroupResource :: TF.Schema TF.Resource P.AWS (RdsClusterParameterGroupResource s)
rdsClusterParameterGroupResource =
    TF.newResource "aws_rds_cluster_parameter_group" $
        RdsClusterParameterGroupResource {
              _description = TF.Nil
            , _family' = TF.Nil
            , _name = TF.Nil
            , _name_prefix = TF.Nil
            , _parameter = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_rds_cluster@ AWS resource.

Provides an RDS Cluster Resource. A Cluster Resource defines attributes that
are applied to the entire cluster of
</docs/providers/aws/r/rds_cluster_instance.html> . Use the RDS Cluster
resource and RDS Cluster Instances to create and use Amazon Aurora, a
MySQL-compatible database engine. For more information on Amazon Aurora, see
<https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Aurora.html> in
the Amazon RDS User Guide. Changes to a RDS Cluster can occur when you
manually change a parameter, such as @port@ , and are reflected in the next
maintenance window. Because of this, Terraform may report a difference in
its planning phase because a modification has not yet taken place. You can
use the @apply_immediately@ flag to instruct the service to apply the change
immediately (see documentation below). ~> Note: using @apply_immediately@
can result in a brief downtime as the server reboots. See the AWS Docs on
<https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_UpgradeDBInstance.Maintenance.html>
for more information. ~> Note: All arguments including the username and
password will be stored in the raw state as plain-text.
</docs/state/sensitive-data.html> .
-}
data RdsClusterResource s = RdsClusterResource {
      _apply_immediately                   :: !(TF.Attr s Text)
    {- ^ (Optional) Specifies whether any cluster modifications are applied immediately, or during the next maintenance window. Default is @false@ . See <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Overview.DBInstance.Modifying.html> -}
    , _availability_zones                  :: !(TF.Attr s Text)
    {- ^ (Optional) A list of EC2 Availability Zones that instances in the DB cluster can be created in -}
    , _backup_retention_period             :: !(TF.Attr s Text)
    {- ^ (Optional) The days to retain backups for. Default 1 -}
    , _cluster_identifier                  :: !(TF.Attr s Text)
    {- ^ (Optional, Forces new resources) The cluster identifier. If omitted, Terraform will assign a random, unique identifier. -}
    , _cluster_identifier_prefix           :: !(TF.Attr s Text)
    {- ^ (Optional, Forces new resource) Creates a unique cluster identifier beginning with the specified prefix. Conflicts with @cluster_identifer@ . -}
    , _database_name                       :: !(TF.Attr s Text)
    {- ^ (Optional) Name for an automatically created database on cluster creation. There are different naming restrictions per database engine: <http://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Limits.html#RDS_Limits.Constraints> -}
    , _db_cluster_parameter_group_name     :: !(TF.Attr s Text)
    {- ^ (Optional) A cluster parameter group to associate with the cluster. -}
    , _db_subnet_group_name                :: !(TF.Attr s Text)
    {- ^ (Optional) A DB subnet group to associate with this DB instance. NOTE: This must match the @db_subnet_group_name@ specified on every </docs/providers/aws/r/rds_cluster_instance.html> in the cluster. -}
    , _engine                              :: !(TF.Attr s Text)
    {- ^ (Optional) The name of the database engine to be used for this DB cluster. Defaults to @aurora@ . -}
    , _engine_version                      :: !(TF.Attr s Text)
    {- ^ (Optional) The database engine version. -}
    , _final_snapshot_identifier           :: !(TF.Attr s Text)
    {- ^ (Optional) The name of your final DB snapshot when this DB cluster is deleted. If omitted, no final snapshot will be made. -}
    , _iam_database_authentication_enabled :: !(TF.Attr s P.Bool)
    {- ^ (Optional) Specifies whether or mappings of AWS Identity and Access Management (IAM) accounts to database accounts is enabled. -}
    , _iam_roles                           :: !(TF.Attr s Text)
    {- ^ (Optional) A List of ARNs for the IAM roles to associate to the RDS Cluster. -}
    , _kms_key_id                          :: !(TF.Attr s Text)
    {- ^ (Optional) The ARN for the KMS encryption key. When specifying @kms_key_id@ , @storage_encrypted@ needs to be set to true. -}
    , _master_password                     :: !(TF.Attr s Text)
    {- ^ (Required unless a @snapshot_identifier@ is provided) Password for the master DB user. Note that this may show up in logs, and it will be stored in the state file. Please refer to the <http://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Limits.html#RDS_Limits.Constraints> -}
    , _master_username                     :: !(TF.Attr s Text)
    {- ^ (Required unless a @snapshot_identifier@ is provided) Username for the master DB user. Please refer to the <http://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Limits.html#RDS_Limits.Constraints> -}
    , _port                                :: !(TF.Attr s Text)
    {- ^ (Optional) The port on which the DB accepts connections -}
    , _preferred_backup_window             :: !(TF.Attr s Text)
    {- ^ (Optional) The daily time range during which automated backups are created if automated backups are enabled using the BackupRetentionPeriod parameter.Time in UTC Default: A 30-minute window selected at random from an 8-hour block of time per region. e.g. 04:00-09:00 -}
    , _preferred_maintenance_window        :: !(TF.Attr s Text)
    {- ^ (Optional) The weekly time range during which system maintenance can occur, in (UTC) e.g. wed:04:00-wed:04:30 -}
    , _skip_final_snapshot                 :: !(TF.Attr s Text)
    {- ^ (Optional) Determines whether a final DB snapshot is created before the DB cluster is deleted. If true is specified, no DB snapshot is created. If false is specified, a DB snapshot is created before the DB cluster is deleted, using the value from @final_snapshot_identifier@ . Default is @false@ . -}
    , _snapshot_identifier                 :: !(TF.Attr s Text)
    {- ^ (Optional) Specifies whether or not to create this cluster from a snapshot. This correlates to the snapshot ID you'd find in the RDS console, e.g: rds:production-2015-06-26-06-05. -}
    , _storage_encrypted                   :: !(TF.Attr s Text)
    {- ^ (Optional) Specifies whether the DB cluster is encrypted. The default is @false@ if not specified. -}
    , _vpc_security_group_ids              :: !(TF.Attr s Text)
    {- ^ (Optional) List of VPC security groups to associate with the Cluster -}
    } deriving (Show, Eq)

instance TF.ToHCL (RdsClusterResource s) where
    toHCL RdsClusterResource{..} = TF.inline $ catMaybes
        [ TF.assign "apply_immediately" <$> TF.attribute _apply_immediately
        , TF.assign "availability_zones" <$> TF.attribute _availability_zones
        , TF.assign "backup_retention_period" <$> TF.attribute _backup_retention_period
        , TF.assign "cluster_identifier" <$> TF.attribute _cluster_identifier
        , TF.assign "cluster_identifier_prefix" <$> TF.attribute _cluster_identifier_prefix
        , TF.assign "database_name" <$> TF.attribute _database_name
        , TF.assign "db_cluster_parameter_group_name" <$> TF.attribute _db_cluster_parameter_group_name
        , TF.assign "db_subnet_group_name" <$> TF.attribute _db_subnet_group_name
        , TF.assign "engine" <$> TF.attribute _engine
        , TF.assign "engine_version" <$> TF.attribute _engine_version
        , TF.assign "final_snapshot_identifier" <$> TF.attribute _final_snapshot_identifier
        , TF.assign "iam_database_authentication_enabled" <$> TF.attribute _iam_database_authentication_enabled
        , TF.assign "iam_roles" <$> TF.attribute _iam_roles
        , TF.assign "kms_key_id" <$> TF.attribute _kms_key_id
        , TF.assign "master_password" <$> TF.attribute _master_password
        , TF.assign "master_username" <$> TF.attribute _master_username
        , TF.assign "port" <$> TF.attribute _port
        , TF.assign "preferred_backup_window" <$> TF.attribute _preferred_backup_window
        , TF.assign "preferred_maintenance_window" <$> TF.attribute _preferred_maintenance_window
        , TF.assign "skip_final_snapshot" <$> TF.attribute _skip_final_snapshot
        , TF.assign "snapshot_identifier" <$> TF.attribute _snapshot_identifier
        , TF.assign "storage_encrypted" <$> TF.attribute _storage_encrypted
        , TF.assign "vpc_security_group_ids" <$> TF.attribute _vpc_security_group_ids
        ]

instance P.HasApplyImmediately (RdsClusterResource s) (TF.Attr s Text) where
    applyImmediately =
        lens (_apply_immediately :: RdsClusterResource s -> TF.Attr s Text)
             (\s a -> s { _apply_immediately = a } :: RdsClusterResource s)

instance P.HasAvailabilityZones (RdsClusterResource s) (TF.Attr s Text) where
    availabilityZones =
        lens (_availability_zones :: RdsClusterResource s -> TF.Attr s Text)
             (\s a -> s { _availability_zones = a } :: RdsClusterResource s)

instance P.HasBackupRetentionPeriod (RdsClusterResource s) (TF.Attr s Text) where
    backupRetentionPeriod =
        lens (_backup_retention_period :: RdsClusterResource s -> TF.Attr s Text)
             (\s a -> s { _backup_retention_period = a } :: RdsClusterResource s)

instance P.HasClusterIdentifier (RdsClusterResource s) (TF.Attr s Text) where
    clusterIdentifier =
        lens (_cluster_identifier :: RdsClusterResource s -> TF.Attr s Text)
             (\s a -> s { _cluster_identifier = a } :: RdsClusterResource s)

instance P.HasClusterIdentifierPrefix (RdsClusterResource s) (TF.Attr s Text) where
    clusterIdentifierPrefix =
        lens (_cluster_identifier_prefix :: RdsClusterResource s -> TF.Attr s Text)
             (\s a -> s { _cluster_identifier_prefix = a } :: RdsClusterResource s)

instance P.HasDatabaseName (RdsClusterResource s) (TF.Attr s Text) where
    databaseName =
        lens (_database_name :: RdsClusterResource s -> TF.Attr s Text)
             (\s a -> s { _database_name = a } :: RdsClusterResource s)

instance P.HasDbClusterParameterGroupName (RdsClusterResource s) (TF.Attr s Text) where
    dbClusterParameterGroupName =
        lens (_db_cluster_parameter_group_name :: RdsClusterResource s -> TF.Attr s Text)
             (\s a -> s { _db_cluster_parameter_group_name = a } :: RdsClusterResource s)

instance P.HasDbSubnetGroupName (RdsClusterResource s) (TF.Attr s Text) where
    dbSubnetGroupName =
        lens (_db_subnet_group_name :: RdsClusterResource s -> TF.Attr s Text)
             (\s a -> s { _db_subnet_group_name = a } :: RdsClusterResource s)

instance P.HasEngine (RdsClusterResource s) (TF.Attr s Text) where
    engine =
        lens (_engine :: RdsClusterResource s -> TF.Attr s Text)
             (\s a -> s { _engine = a } :: RdsClusterResource s)

instance P.HasEngineVersion (RdsClusterResource s) (TF.Attr s Text) where
    engineVersion =
        lens (_engine_version :: RdsClusterResource s -> TF.Attr s Text)
             (\s a -> s { _engine_version = a } :: RdsClusterResource s)

instance P.HasFinalSnapshotIdentifier (RdsClusterResource s) (TF.Attr s Text) where
    finalSnapshotIdentifier =
        lens (_final_snapshot_identifier :: RdsClusterResource s -> TF.Attr s Text)
             (\s a -> s { _final_snapshot_identifier = a } :: RdsClusterResource s)

instance P.HasIamDatabaseAuthenticationEnabled (RdsClusterResource s) (TF.Attr s P.Bool) where
    iamDatabaseAuthenticationEnabled =
        lens (_iam_database_authentication_enabled :: RdsClusterResource s -> TF.Attr s P.Bool)
             (\s a -> s { _iam_database_authentication_enabled = a } :: RdsClusterResource s)

instance P.HasIamRoles (RdsClusterResource s) (TF.Attr s Text) where
    iamRoles =
        lens (_iam_roles :: RdsClusterResource s -> TF.Attr s Text)
             (\s a -> s { _iam_roles = a } :: RdsClusterResource s)

instance P.HasKmsKeyId (RdsClusterResource s) (TF.Attr s Text) where
    kmsKeyId =
        lens (_kms_key_id :: RdsClusterResource s -> TF.Attr s Text)
             (\s a -> s { _kms_key_id = a } :: RdsClusterResource s)

instance P.HasMasterPassword (RdsClusterResource s) (TF.Attr s Text) where
    masterPassword =
        lens (_master_password :: RdsClusterResource s -> TF.Attr s Text)
             (\s a -> s { _master_password = a } :: RdsClusterResource s)

instance P.HasMasterUsername (RdsClusterResource s) (TF.Attr s Text) where
    masterUsername =
        lens (_master_username :: RdsClusterResource s -> TF.Attr s Text)
             (\s a -> s { _master_username = a } :: RdsClusterResource s)

instance P.HasPort (RdsClusterResource s) (TF.Attr s Text) where
    port =
        lens (_port :: RdsClusterResource s -> TF.Attr s Text)
             (\s a -> s { _port = a } :: RdsClusterResource s)

instance P.HasPreferredBackupWindow (RdsClusterResource s) (TF.Attr s Text) where
    preferredBackupWindow =
        lens (_preferred_backup_window :: RdsClusterResource s -> TF.Attr s Text)
             (\s a -> s { _preferred_backup_window = a } :: RdsClusterResource s)

instance P.HasPreferredMaintenanceWindow (RdsClusterResource s) (TF.Attr s Text) where
    preferredMaintenanceWindow =
        lens (_preferred_maintenance_window :: RdsClusterResource s -> TF.Attr s Text)
             (\s a -> s { _preferred_maintenance_window = a } :: RdsClusterResource s)

instance P.HasSkipFinalSnapshot (RdsClusterResource s) (TF.Attr s Text) where
    skipFinalSnapshot =
        lens (_skip_final_snapshot :: RdsClusterResource s -> TF.Attr s Text)
             (\s a -> s { _skip_final_snapshot = a } :: RdsClusterResource s)

instance P.HasSnapshotIdentifier (RdsClusterResource s) (TF.Attr s Text) where
    snapshotIdentifier =
        lens (_snapshot_identifier :: RdsClusterResource s -> TF.Attr s Text)
             (\s a -> s { _snapshot_identifier = a } :: RdsClusterResource s)

instance P.HasStorageEncrypted (RdsClusterResource s) (TF.Attr s Text) where
    storageEncrypted =
        lens (_storage_encrypted :: RdsClusterResource s -> TF.Attr s Text)
             (\s a -> s { _storage_encrypted = a } :: RdsClusterResource s)

instance P.HasVpcSecurityGroupIds (RdsClusterResource s) (TF.Attr s Text) where
    vpcSecurityGroupIds =
        lens (_vpc_security_group_ids :: RdsClusterResource s -> TF.Attr s Text)
             (\s a -> s { _vpc_security_group_ids = a } :: RdsClusterResource s)

instance P.HasComputedAllocatedStorage (RdsClusterResource s) s (TF.Attr s Text) where
    computedAllocatedStorage x = TF.compute (TF.refKey x) "allocated_storage"

instance P.HasComputedApplyImmediately (RdsClusterResource s) s (TF.Attr s Text) where
    computedApplyImmediately =
        (_apply_immediately :: RdsClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAvailabilityZones (RdsClusterResource s) s (TF.Attr s Text) where
    computedAvailabilityZones x = TF.compute (TF.refKey x) "availability_zones"

instance P.HasComputedBackupRetentionPeriod (RdsClusterResource s) s (TF.Attr s Text) where
    computedBackupRetentionPeriod x = TF.compute (TF.refKey x) "backup_retention_period"

instance P.HasComputedClusterIdentifier (RdsClusterResource s) s (TF.Attr s Text) where
    computedClusterIdentifier x = TF.compute (TF.refKey x) "cluster_identifier"

instance P.HasComputedClusterIdentifierPrefix (RdsClusterResource s) s (TF.Attr s Text) where
    computedClusterIdentifierPrefix =
        (_cluster_identifier_prefix :: RdsClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedClusterMembers (RdsClusterResource s) s (TF.Attr s Text) where
    computedClusterMembers x = TF.compute (TF.refKey x) "cluster_members"

instance P.HasComputedClusterResourceId (RdsClusterResource s) s (TF.Attr s Text) where
    computedClusterResourceId x = TF.compute (TF.refKey x) "cluster_resource_id"

instance P.HasComputedDatabaseName (RdsClusterResource s) s (TF.Attr s Text) where
    computedDatabaseName x = TF.compute (TF.refKey x) "database_name"

instance P.HasComputedDbClusterParameterGroupName (RdsClusterResource s) s (TF.Attr s Text) where
    computedDbClusterParameterGroupName =
        (_db_cluster_parameter_group_name :: RdsClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDbSubnetGroupName (RdsClusterResource s) s (TF.Attr s Text) where
    computedDbSubnetGroupName =
        (_db_subnet_group_name :: RdsClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEndpoint (RdsClusterResource s) s (TF.Attr s Text) where
    computedEndpoint x = TF.compute (TF.refKey x) "endpoint"

instance P.HasComputedEngine (RdsClusterResource s) s (TF.Attr s Text) where
    computedEngine x = TF.compute (TF.refKey x) "engine"

instance P.HasComputedEngineVersion (RdsClusterResource s) s (TF.Attr s Text) where
    computedEngineVersion x = TF.compute (TF.refKey x) "engine_version"

instance P.HasComputedFinalSnapshotIdentifier (RdsClusterResource s) s (TF.Attr s Text) where
    computedFinalSnapshotIdentifier =
        (_final_snapshot_identifier :: RdsClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedHostedZoneId (RdsClusterResource s) s (TF.Attr s Text) where
    computedHostedZoneId x = TF.compute (TF.refKey x) "hosted_zone_id"

instance P.HasComputedIamDatabaseAuthenticationEnabled (RdsClusterResource s) s (TF.Attr s P.Bool) where
    computedIamDatabaseAuthenticationEnabled =
        (_iam_database_authentication_enabled :: RdsClusterResource s -> TF.Attr s P.Bool)
            . TF.refValue

instance P.HasComputedIamRoles (RdsClusterResource s) s (TF.Attr s Text) where
    computedIamRoles =
        (_iam_roles :: RdsClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (RdsClusterResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedKmsKeyId (RdsClusterResource s) s (TF.Attr s Text) where
    computedKmsKeyId =
        (_kms_key_id :: RdsClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedMaintenanceWindow (RdsClusterResource s) s (TF.Attr s Text) where
    computedMaintenanceWindow x = TF.compute (TF.refKey x) "maintenance_window"

instance P.HasComputedMasterPassword (RdsClusterResource s) s (TF.Attr s Text) where
    computedMasterPassword =
        (_master_password :: RdsClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedMasterUsername (RdsClusterResource s) s (TF.Attr s Text) where
    computedMasterUsername x = TF.compute (TF.refKey x) "master_username"

instance P.HasComputedPort (RdsClusterResource s) s (TF.Attr s Text) where
    computedPort x = TF.compute (TF.refKey x) "port"

instance P.HasComputedPreferredBackupWindow (RdsClusterResource s) s (TF.Attr s Text) where
    computedPreferredBackupWindow x = TF.compute (TF.refKey x) "preferred_backup_window"

instance P.HasComputedPreferredMaintenanceWindow (RdsClusterResource s) s (TF.Attr s Text) where
    computedPreferredMaintenanceWindow x = TF.compute (TF.refKey x) "preferred_maintenance_window"

instance P.HasComputedReaderEndpoint (RdsClusterResource s) s (TF.Attr s Text) where
    computedReaderEndpoint x = TF.compute (TF.refKey x) "reader_endpoint"

instance P.HasComputedReplicationSourceIdentifier (RdsClusterResource s) s (TF.Attr s Text) where
    computedReplicationSourceIdentifier x = TF.compute (TF.refKey x) "replication_source_identifier"

instance P.HasComputedSkipFinalSnapshot (RdsClusterResource s) s (TF.Attr s Text) where
    computedSkipFinalSnapshot =
        (_skip_final_snapshot :: RdsClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSnapshotIdentifier (RdsClusterResource s) s (TF.Attr s Text) where
    computedSnapshotIdentifier =
        (_snapshot_identifier :: RdsClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedStatus (RdsClusterResource s) s (TF.Attr s Text) where
    computedStatus x = TF.compute (TF.refKey x) "status"

instance P.HasComputedStorageEncrypted (RdsClusterResource s) s (TF.Attr s Text) where
    computedStorageEncrypted x = TF.compute (TF.refKey x) "storage_encrypted"

instance P.HasComputedVpcSecurityGroupIds (RdsClusterResource s) s (TF.Attr s Text) where
    computedVpcSecurityGroupIds =
        (_vpc_security_group_ids :: RdsClusterResource s -> TF.Attr s Text)
            . TF.refValue

rdsClusterResource :: TF.Schema TF.Resource P.AWS (RdsClusterResource s)
rdsClusterResource =
    TF.newResource "aws_rds_cluster" $
        RdsClusterResource {
              _apply_immediately = TF.Nil
            , _availability_zones = TF.Nil
            , _backup_retention_period = TF.Nil
            , _cluster_identifier = TF.Nil
            , _cluster_identifier_prefix = TF.Nil
            , _database_name = TF.Nil
            , _db_cluster_parameter_group_name = TF.Nil
            , _db_subnet_group_name = TF.Nil
            , _engine = TF.Nil
            , _engine_version = TF.Nil
            , _final_snapshot_identifier = TF.Nil
            , _iam_database_authentication_enabled = TF.Nil
            , _iam_roles = TF.Nil
            , _kms_key_id = TF.Nil
            , _master_password = TF.Nil
            , _master_username = TF.Nil
            , _port = TF.Nil
            , _preferred_backup_window = TF.Nil
            , _preferred_maintenance_window = TF.Nil
            , _skip_final_snapshot = TF.Nil
            , _snapshot_identifier = TF.Nil
            , _storage_encrypted = TF.Nil
            , _vpc_security_group_ids = TF.Nil
            }

{- | The @aws_redshift_cluster@ AWS resource.

Provides a Redshift Cluster Resource. ~> Note: All arguments including the
username and password will be stored in the raw state as plain-text.
</docs/state/sensitive-data.html> .
-}
data RedshiftClusterResource s = RedshiftClusterResource {
      _allow_version_upgrade               :: !(TF.Attr s Text)
    {- ^ (Optional) If true , major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. Default is true -}
    , _automated_snapshot_retention_period :: !(TF.Attr s Text)
    {- ^ (Optional) The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with create-cluster-snapshot. Default is 1. -}
    , _availability_zone                   :: !(TF.Attr s P.Zone)
    {- ^ (Optional) The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency. -}
    , _cluster_identifier                  :: !(TF.Attr s Text)
    {- ^ (Required) The Cluster Identifier. Must be a lower case string. -}
    , _cluster_parameter_group_name        :: !(TF.Attr s Text)
    {- ^ (Optional) The name of the parameter group to be associated with this cluster. -}
    , _cluster_security_groups             :: !(TF.Attr s Text)
    {- ^ (Optional) A list of security groups to be associated with this cluster. -}
    , _cluster_subnet_group_name           :: !(TF.Attr s Text)
    {- ^ (Optional) The name of a cluster subnet group to be associated with this cluster. If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC). -}
    , _cluster_type                        :: !(TF.Attr s Text)
    {- ^ (Optional) The cluster type to use. Either @single-node@ or @multi-node@ . -}
    , _cluster_version                     :: !(TF.Attr s Text)
    {- ^ (Optional) The version of the Amazon Redshift engine software that you want to deploy on the cluster. The version selected runs on all the nodes in the cluster. -}
    , _database_name                       :: !(TF.Attr s Text)
    {- ^ (Optional) The name of the first database to be created when the cluster is created. If you do not provide a name, Amazon Redshift will create a default database called @dev@ . -}
    , _elastic_ip                          :: !(TF.Attr s Text)
    {- ^ (Optional) The Elastic IP (EIP) address for the cluster. -}
    , _encrypted                           :: !(TF.Attr s Text)
    {- ^ (Optional) If true , the data in the cluster is encrypted at rest. -}
    , _enhanced_vpc_routing                :: !(TF.Attr s Text)
    {- ^ (Optional) If true , enhanced VPC routing is enabled. -}
    , _final_snapshot_identifier           :: !(TF.Attr s Text)
    {- ^ (Optional) The identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, @skip_final_snapshot@ must be false. -}
    , _iam_roles                           :: !(TF.Attr s Text)
    {- ^ (Optional) A list of IAM Role ARNs to associate with the cluster. A Maximum of 10 can be associated to the cluster at any time. -}
    , _kms_key_id                          :: !(TF.Attr s Text)
    {- ^ (Optional) The ARN for the KMS encryption key. When specifying @kms_key_id@ , @encrypted@ needs to be set to true. -}
    , _logging                             :: !(TF.Attr s Text)
    {- ^ (Optional) Logging, documented below. -}
    , _master_password                     :: !(TF.Attr s Text)
    {- ^ (Required unless a @snapshot_identifier@ is provided) Password for the master DB user. Note that this may show up in logs, and it will be stored in the state file. Password must contain at least 8 chars and contain at least one uppercase letter, one lowercase letter, and one number. -}
    , _master_username                     :: !(TF.Attr s Text)
    {- ^ (Required unless a @snapshot_identifier@ is provided) Username for the master DB user. -}
    , _node_type                           :: !(TF.Attr s Text)
    {- ^ (Required) The node type to be provisioned for the cluster. -}
    , _number_of_nodes                     :: !(TF.Attr s Text)
    {- ^ (Optional) The number of compute nodes in the cluster. This parameter is required when the ClusterType parameter is specified as multi-node. Default is 1. -}
    , _owner_account                       :: !(TF.Attr s Text)
    {- ^ (Optional) The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot. -}
    , _port                                :: !(TF.Attr s Text)
    {- ^ (Optional) The port number on which the cluster accepts incoming connections. The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections. Default port is 5439. -}
    , _preferred_maintenance_window        :: !(TF.Attr s Text)
    {- ^ (Optional) The weekly time range (in UTC) during which automated cluster maintenance can occur. Format: ddd:hh24:mi-ddd:hh24:mi -}
    , _publicly_accessible                 :: !(TF.Attr s Text)
    {- ^ (Optional) If true, the cluster can be accessed from a public network. Default is @true@ . -}
    , _skip_final_snapshot                 :: !(TF.Attr s Text)
    {- ^ (Optional) Determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If true , a final cluster snapshot is not created. If false , a final cluster snapshot is created before the cluster is deleted. Default is false. -}
    , _snapshot_cluster_identifier         :: !(TF.Attr s Text)
    {- ^ (Optional) The name of the cluster the source snapshot was created from. -}
    , _snapshot_copy                       :: !(TF.Attr s Text)
    {- ^ (Optional) Configuration of automatic copy of snapshots from one region to another. Documented below. -}
    , _snapshot_identifier                 :: !(TF.Attr s Text)
    {- ^ (Optional) The name of the snapshot from which to create the new cluster. -}
    , _tags                                :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    , _vpc_security_group_ids              :: !(TF.Attr s Text)
    {- ^ (Optional) A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster. -}
    } deriving (Show, Eq)

instance TF.ToHCL (RedshiftClusterResource s) where
    toHCL RedshiftClusterResource{..} = TF.inline $ catMaybes
        [ TF.assign "allow_version_upgrade" <$> TF.attribute _allow_version_upgrade
        , TF.assign "automated_snapshot_retention_period" <$> TF.attribute _automated_snapshot_retention_period
        , TF.assign "availability_zone" <$> TF.attribute _availability_zone
        , TF.assign "cluster_identifier" <$> TF.attribute _cluster_identifier
        , TF.assign "cluster_parameter_group_name" <$> TF.attribute _cluster_parameter_group_name
        , TF.assign "cluster_security_groups" <$> TF.attribute _cluster_security_groups
        , TF.assign "cluster_subnet_group_name" <$> TF.attribute _cluster_subnet_group_name
        , TF.assign "cluster_type" <$> TF.attribute _cluster_type
        , TF.assign "cluster_version" <$> TF.attribute _cluster_version
        , TF.assign "database_name" <$> TF.attribute _database_name
        , TF.assign "elastic_ip" <$> TF.attribute _elastic_ip
        , TF.assign "encrypted" <$> TF.attribute _encrypted
        , TF.assign "enhanced_vpc_routing" <$> TF.attribute _enhanced_vpc_routing
        , TF.assign "final_snapshot_identifier" <$> TF.attribute _final_snapshot_identifier
        , TF.assign "iam_roles" <$> TF.attribute _iam_roles
        , TF.assign "kms_key_id" <$> TF.attribute _kms_key_id
        , TF.assign "logging" <$> TF.attribute _logging
        , TF.assign "master_password" <$> TF.attribute _master_password
        , TF.assign "master_username" <$> TF.attribute _master_username
        , TF.assign "node_type" <$> TF.attribute _node_type
        , TF.assign "number_of_nodes" <$> TF.attribute _number_of_nodes
        , TF.assign "owner_account" <$> TF.attribute _owner_account
        , TF.assign "port" <$> TF.attribute _port
        , TF.assign "preferred_maintenance_window" <$> TF.attribute _preferred_maintenance_window
        , TF.assign "publicly_accessible" <$> TF.attribute _publicly_accessible
        , TF.assign "skip_final_snapshot" <$> TF.attribute _skip_final_snapshot
        , TF.assign "snapshot_cluster_identifier" <$> TF.attribute _snapshot_cluster_identifier
        , TF.assign "snapshot_copy" <$> TF.attribute _snapshot_copy
        , TF.assign "snapshot_identifier" <$> TF.attribute _snapshot_identifier
        , TF.assign "tags" <$> TF.attribute _tags
        , TF.assign "vpc_security_group_ids" <$> TF.attribute _vpc_security_group_ids
        ]

instance P.HasAllowVersionUpgrade (RedshiftClusterResource s) (TF.Attr s Text) where
    allowVersionUpgrade =
        lens (_allow_version_upgrade :: RedshiftClusterResource s -> TF.Attr s Text)
             (\s a -> s { _allow_version_upgrade = a } :: RedshiftClusterResource s)

instance P.HasAutomatedSnapshotRetentionPeriod (RedshiftClusterResource s) (TF.Attr s Text) where
    automatedSnapshotRetentionPeriod =
        lens (_automated_snapshot_retention_period :: RedshiftClusterResource s -> TF.Attr s Text)
             (\s a -> s { _automated_snapshot_retention_period = a } :: RedshiftClusterResource s)

instance P.HasAvailabilityZone (RedshiftClusterResource s) (TF.Attr s P.Zone) where
    availabilityZone =
        lens (_availability_zone :: RedshiftClusterResource s -> TF.Attr s P.Zone)
             (\s a -> s { _availability_zone = a } :: RedshiftClusterResource s)

instance P.HasClusterIdentifier (RedshiftClusterResource s) (TF.Attr s Text) where
    clusterIdentifier =
        lens (_cluster_identifier :: RedshiftClusterResource s -> TF.Attr s Text)
             (\s a -> s { _cluster_identifier = a } :: RedshiftClusterResource s)

instance P.HasClusterParameterGroupName (RedshiftClusterResource s) (TF.Attr s Text) where
    clusterParameterGroupName =
        lens (_cluster_parameter_group_name :: RedshiftClusterResource s -> TF.Attr s Text)
             (\s a -> s { _cluster_parameter_group_name = a } :: RedshiftClusterResource s)

instance P.HasClusterSecurityGroups (RedshiftClusterResource s) (TF.Attr s Text) where
    clusterSecurityGroups =
        lens (_cluster_security_groups :: RedshiftClusterResource s -> TF.Attr s Text)
             (\s a -> s { _cluster_security_groups = a } :: RedshiftClusterResource s)

instance P.HasClusterSubnetGroupName (RedshiftClusterResource s) (TF.Attr s Text) where
    clusterSubnetGroupName =
        lens (_cluster_subnet_group_name :: RedshiftClusterResource s -> TF.Attr s Text)
             (\s a -> s { _cluster_subnet_group_name = a } :: RedshiftClusterResource s)

instance P.HasClusterType (RedshiftClusterResource s) (TF.Attr s Text) where
    clusterType =
        lens (_cluster_type :: RedshiftClusterResource s -> TF.Attr s Text)
             (\s a -> s { _cluster_type = a } :: RedshiftClusterResource s)

instance P.HasClusterVersion (RedshiftClusterResource s) (TF.Attr s Text) where
    clusterVersion =
        lens (_cluster_version :: RedshiftClusterResource s -> TF.Attr s Text)
             (\s a -> s { _cluster_version = a } :: RedshiftClusterResource s)

instance P.HasDatabaseName (RedshiftClusterResource s) (TF.Attr s Text) where
    databaseName =
        lens (_database_name :: RedshiftClusterResource s -> TF.Attr s Text)
             (\s a -> s { _database_name = a } :: RedshiftClusterResource s)

instance P.HasElasticIp (RedshiftClusterResource s) (TF.Attr s Text) where
    elasticIp =
        lens (_elastic_ip :: RedshiftClusterResource s -> TF.Attr s Text)
             (\s a -> s { _elastic_ip = a } :: RedshiftClusterResource s)

instance P.HasEncrypted (RedshiftClusterResource s) (TF.Attr s Text) where
    encrypted =
        lens (_encrypted :: RedshiftClusterResource s -> TF.Attr s Text)
             (\s a -> s { _encrypted = a } :: RedshiftClusterResource s)

instance P.HasEnhancedVpcRouting (RedshiftClusterResource s) (TF.Attr s Text) where
    enhancedVpcRouting =
        lens (_enhanced_vpc_routing :: RedshiftClusterResource s -> TF.Attr s Text)
             (\s a -> s { _enhanced_vpc_routing = a } :: RedshiftClusterResource s)

instance P.HasFinalSnapshotIdentifier (RedshiftClusterResource s) (TF.Attr s Text) where
    finalSnapshotIdentifier =
        lens (_final_snapshot_identifier :: RedshiftClusterResource s -> TF.Attr s Text)
             (\s a -> s { _final_snapshot_identifier = a } :: RedshiftClusterResource s)

instance P.HasIamRoles (RedshiftClusterResource s) (TF.Attr s Text) where
    iamRoles =
        lens (_iam_roles :: RedshiftClusterResource s -> TF.Attr s Text)
             (\s a -> s { _iam_roles = a } :: RedshiftClusterResource s)

instance P.HasKmsKeyId (RedshiftClusterResource s) (TF.Attr s Text) where
    kmsKeyId =
        lens (_kms_key_id :: RedshiftClusterResource s -> TF.Attr s Text)
             (\s a -> s { _kms_key_id = a } :: RedshiftClusterResource s)

instance P.HasLogging (RedshiftClusterResource s) (TF.Attr s Text) where
    logging =
        lens (_logging :: RedshiftClusterResource s -> TF.Attr s Text)
             (\s a -> s { _logging = a } :: RedshiftClusterResource s)

instance P.HasMasterPassword (RedshiftClusterResource s) (TF.Attr s Text) where
    masterPassword =
        lens (_master_password :: RedshiftClusterResource s -> TF.Attr s Text)
             (\s a -> s { _master_password = a } :: RedshiftClusterResource s)

instance P.HasMasterUsername (RedshiftClusterResource s) (TF.Attr s Text) where
    masterUsername =
        lens (_master_username :: RedshiftClusterResource s -> TF.Attr s Text)
             (\s a -> s { _master_username = a } :: RedshiftClusterResource s)

instance P.HasNodeType (RedshiftClusterResource s) (TF.Attr s Text) where
    nodeType =
        lens (_node_type :: RedshiftClusterResource s -> TF.Attr s Text)
             (\s a -> s { _node_type = a } :: RedshiftClusterResource s)

instance P.HasNumberOfNodes (RedshiftClusterResource s) (TF.Attr s Text) where
    numberOfNodes =
        lens (_number_of_nodes :: RedshiftClusterResource s -> TF.Attr s Text)
             (\s a -> s { _number_of_nodes = a } :: RedshiftClusterResource s)

instance P.HasOwnerAccount (RedshiftClusterResource s) (TF.Attr s Text) where
    ownerAccount =
        lens (_owner_account :: RedshiftClusterResource s -> TF.Attr s Text)
             (\s a -> s { _owner_account = a } :: RedshiftClusterResource s)

instance P.HasPort (RedshiftClusterResource s) (TF.Attr s Text) where
    port =
        lens (_port :: RedshiftClusterResource s -> TF.Attr s Text)
             (\s a -> s { _port = a } :: RedshiftClusterResource s)

instance P.HasPreferredMaintenanceWindow (RedshiftClusterResource s) (TF.Attr s Text) where
    preferredMaintenanceWindow =
        lens (_preferred_maintenance_window :: RedshiftClusterResource s -> TF.Attr s Text)
             (\s a -> s { _preferred_maintenance_window = a } :: RedshiftClusterResource s)

instance P.HasPubliclyAccessible (RedshiftClusterResource s) (TF.Attr s Text) where
    publiclyAccessible =
        lens (_publicly_accessible :: RedshiftClusterResource s -> TF.Attr s Text)
             (\s a -> s { _publicly_accessible = a } :: RedshiftClusterResource s)

instance P.HasSkipFinalSnapshot (RedshiftClusterResource s) (TF.Attr s Text) where
    skipFinalSnapshot =
        lens (_skip_final_snapshot :: RedshiftClusterResource s -> TF.Attr s Text)
             (\s a -> s { _skip_final_snapshot = a } :: RedshiftClusterResource s)

instance P.HasSnapshotClusterIdentifier (RedshiftClusterResource s) (TF.Attr s Text) where
    snapshotClusterIdentifier =
        lens (_snapshot_cluster_identifier :: RedshiftClusterResource s -> TF.Attr s Text)
             (\s a -> s { _snapshot_cluster_identifier = a } :: RedshiftClusterResource s)

instance P.HasSnapshotCopy (RedshiftClusterResource s) (TF.Attr s Text) where
    snapshotCopy =
        lens (_snapshot_copy :: RedshiftClusterResource s -> TF.Attr s Text)
             (\s a -> s { _snapshot_copy = a } :: RedshiftClusterResource s)

instance P.HasSnapshotIdentifier (RedshiftClusterResource s) (TF.Attr s Text) where
    snapshotIdentifier =
        lens (_snapshot_identifier :: RedshiftClusterResource s -> TF.Attr s Text)
             (\s a -> s { _snapshot_identifier = a } :: RedshiftClusterResource s)

instance P.HasTags (RedshiftClusterResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: RedshiftClusterResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: RedshiftClusterResource s)

instance P.HasVpcSecurityGroupIds (RedshiftClusterResource s) (TF.Attr s Text) where
    vpcSecurityGroupIds =
        lens (_vpc_security_group_ids :: RedshiftClusterResource s -> TF.Attr s Text)
             (\s a -> s { _vpc_security_group_ids = a } :: RedshiftClusterResource s)

instance P.HasComputedAllowVersionUpgrade (RedshiftClusterResource s) s (TF.Attr s Text) where
    computedAllowVersionUpgrade =
        (_allow_version_upgrade :: RedshiftClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAutomatedSnapshotRetentionPeriod (RedshiftClusterResource s) s (TF.Attr s Text) where
    computedAutomatedSnapshotRetentionPeriod x = TF.compute (TF.refKey x) "automated_snapshot_retention_period"

instance P.HasComputedAvailabilityZone (RedshiftClusterResource s) s (TF.Attr s P.Zone) where
    computedAvailabilityZone x = TF.compute (TF.refKey x) "availability_zone"

instance P.HasComputedClusterIdentifier (RedshiftClusterResource s) s (TF.Attr s Text) where
    computedClusterIdentifier x = TF.compute (TF.refKey x) "cluster_identifier"

instance P.HasComputedClusterParameterGroupName (RedshiftClusterResource s) s (TF.Attr s Text) where
    computedClusterParameterGroupName x = TF.compute (TF.refKey x) "cluster_parameter_group_name"

instance P.HasComputedClusterPublicKey (RedshiftClusterResource s) s (TF.Attr s Text) where
    computedClusterPublicKey x = TF.compute (TF.refKey x) "cluster_public_key"

instance P.HasComputedClusterRevisionNumber (RedshiftClusterResource s) s (TF.Attr s Text) where
    computedClusterRevisionNumber x = TF.compute (TF.refKey x) "cluster_revision_number"

instance P.HasComputedClusterSecurityGroups (RedshiftClusterResource s) s (TF.Attr s Text) where
    computedClusterSecurityGroups x = TF.compute (TF.refKey x) "cluster_security_groups"

instance P.HasComputedClusterSubnetGroupName (RedshiftClusterResource s) s (TF.Attr s Text) where
    computedClusterSubnetGroupName x = TF.compute (TF.refKey x) "cluster_subnet_group_name"

instance P.HasComputedClusterType (RedshiftClusterResource s) s (TF.Attr s Text) where
    computedClusterType x = TF.compute (TF.refKey x) "cluster_type"

instance P.HasComputedClusterVersion (RedshiftClusterResource s) s (TF.Attr s Text) where
    computedClusterVersion x = TF.compute (TF.refKey x) "cluster_version"

instance P.HasComputedDatabaseName (RedshiftClusterResource s) s (TF.Attr s Text) where
    computedDatabaseName x = TF.compute (TF.refKey x) "database_name"

instance P.HasComputedElasticIp (RedshiftClusterResource s) s (TF.Attr s Text) where
    computedElasticIp =
        (_elastic_ip :: RedshiftClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEncrypted (RedshiftClusterResource s) s (TF.Attr s Text) where
    computedEncrypted x = TF.compute (TF.refKey x) "encrypted"

instance P.HasComputedEndpoint (RedshiftClusterResource s) s (TF.Attr s Text) where
    computedEndpoint x = TF.compute (TF.refKey x) "endpoint"

instance P.HasComputedEnhancedVpcRouting (RedshiftClusterResource s) s (TF.Attr s Text) where
    computedEnhancedVpcRouting =
        (_enhanced_vpc_routing :: RedshiftClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedFinalSnapshotIdentifier (RedshiftClusterResource s) s (TF.Attr s Text) where
    computedFinalSnapshotIdentifier =
        (_final_snapshot_identifier :: RedshiftClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedIamRoles (RedshiftClusterResource s) s (TF.Attr s Text) where
    computedIamRoles =
        (_iam_roles :: RedshiftClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (RedshiftClusterResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedKmsKeyId (RedshiftClusterResource s) s (TF.Attr s Text) where
    computedKmsKeyId =
        (_kms_key_id :: RedshiftClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedLogging (RedshiftClusterResource s) s (TF.Attr s Text) where
    computedLogging =
        (_logging :: RedshiftClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedMasterPassword (RedshiftClusterResource s) s (TF.Attr s Text) where
    computedMasterPassword =
        (_master_password :: RedshiftClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedMasterUsername (RedshiftClusterResource s) s (TF.Attr s Text) where
    computedMasterUsername =
        (_master_username :: RedshiftClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedNodeType (RedshiftClusterResource s) s (TF.Attr s Text) where
    computedNodeType x = TF.compute (TF.refKey x) "node_type"

instance P.HasComputedNumberOfNodes (RedshiftClusterResource s) s (TF.Attr s Text) where
    computedNumberOfNodes =
        (_number_of_nodes :: RedshiftClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedOwnerAccount (RedshiftClusterResource s) s (TF.Attr s Text) where
    computedOwnerAccount =
        (_owner_account :: RedshiftClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPort (RedshiftClusterResource s) s (TF.Attr s Text) where
    computedPort x = TF.compute (TF.refKey x) "port"

instance P.HasComputedPreferredMaintenanceWindow (RedshiftClusterResource s) s (TF.Attr s Text) where
    computedPreferredMaintenanceWindow x = TF.compute (TF.refKey x) "preferred_maintenance_window"

instance P.HasComputedPubliclyAccessible (RedshiftClusterResource s) s (TF.Attr s Text) where
    computedPubliclyAccessible =
        (_publicly_accessible :: RedshiftClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSkipFinalSnapshot (RedshiftClusterResource s) s (TF.Attr s Text) where
    computedSkipFinalSnapshot =
        (_skip_final_snapshot :: RedshiftClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSnapshotClusterIdentifier (RedshiftClusterResource s) s (TF.Attr s Text) where
    computedSnapshotClusterIdentifier =
        (_snapshot_cluster_identifier :: RedshiftClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSnapshotCopy (RedshiftClusterResource s) s (TF.Attr s Text) where
    computedSnapshotCopy =
        (_snapshot_copy :: RedshiftClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSnapshotIdentifier (RedshiftClusterResource s) s (TF.Attr s Text) where
    computedSnapshotIdentifier =
        (_snapshot_identifier :: RedshiftClusterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (RedshiftClusterResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: RedshiftClusterResource s -> TF.Attr s P.Tags)
            . TF.refValue

instance P.HasComputedVpcSecurityGroupIds (RedshiftClusterResource s) s (TF.Attr s Text) where
    computedVpcSecurityGroupIds x = TF.compute (TF.refKey x) "vpc_security_group_ids"

redshiftClusterResource :: TF.Schema TF.Resource P.AWS (RedshiftClusterResource s)
redshiftClusterResource =
    TF.newResource "aws_redshift_cluster" $
        RedshiftClusterResource {
              _allow_version_upgrade = TF.Nil
            , _automated_snapshot_retention_period = TF.Nil
            , _availability_zone = TF.Nil
            , _cluster_identifier = TF.Nil
            , _cluster_parameter_group_name = TF.Nil
            , _cluster_security_groups = TF.Nil
            , _cluster_subnet_group_name = TF.Nil
            , _cluster_type = TF.Nil
            , _cluster_version = TF.Nil
            , _database_name = TF.Nil
            , _elastic_ip = TF.Nil
            , _encrypted = TF.Nil
            , _enhanced_vpc_routing = TF.Nil
            , _final_snapshot_identifier = TF.Nil
            , _iam_roles = TF.Nil
            , _kms_key_id = TF.Nil
            , _logging = TF.Nil
            , _master_password = TF.Nil
            , _master_username = TF.Nil
            , _node_type = TF.Nil
            , _number_of_nodes = TF.Nil
            , _owner_account = TF.Nil
            , _port = TF.Nil
            , _preferred_maintenance_window = TF.Nil
            , _publicly_accessible = TF.Nil
            , _skip_final_snapshot = TF.Nil
            , _snapshot_cluster_identifier = TF.Nil
            , _snapshot_copy = TF.Nil
            , _snapshot_identifier = TF.Nil
            , _tags = TF.Nil
            , _vpc_security_group_ids = TF.Nil
            }

{- | The @aws_redshift_parameter_group@ AWS resource.

Provides a Redshift Cluster parameter group resource.
-}
data RedshiftParameterGroupResource s = RedshiftParameterGroupResource {
      _description :: !(TF.Attr s Text)
    {- ^ (Optional) The description of the Redshift parameter group. Defaults to "Managed by Terraform". -}
    , _family'     :: !(TF.Attr s Text)
    {- ^ (Required) The family of the Redshift parameter group. -}
    , _name        :: !(TF.Attr s Text)
    {- ^ (Required) The name of the Redshift parameter group. -}
    , _parameter   :: !(TF.Attr s Text)
    {- ^ (Optional) A list of Redshift parameters to apply. -}
    } deriving (Show, Eq)

instance TF.ToHCL (RedshiftParameterGroupResource s) where
    toHCL RedshiftParameterGroupResource{..} = TF.inline $ catMaybes
        [ TF.assign "description" <$> TF.attribute _description
        , TF.assign "family" <$> TF.attribute _family'
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "parameter" <$> TF.attribute _parameter
        ]

instance P.HasDescription (RedshiftParameterGroupResource s) (TF.Attr s Text) where
    description =
        lens (_description :: RedshiftParameterGroupResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: RedshiftParameterGroupResource s)

instance P.HasFamily' (RedshiftParameterGroupResource s) (TF.Attr s Text) where
    family' =
        lens (_family' :: RedshiftParameterGroupResource s -> TF.Attr s Text)
             (\s a -> s { _family' = a } :: RedshiftParameterGroupResource s)

instance P.HasName (RedshiftParameterGroupResource s) (TF.Attr s Text) where
    name =
        lens (_name :: RedshiftParameterGroupResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: RedshiftParameterGroupResource s)

instance P.HasParameter (RedshiftParameterGroupResource s) (TF.Attr s Text) where
    parameter =
        lens (_parameter :: RedshiftParameterGroupResource s -> TF.Attr s Text)
             (\s a -> s { _parameter = a } :: RedshiftParameterGroupResource s)

instance P.HasComputedDescription (RedshiftParameterGroupResource s) s (TF.Attr s Text) where
    computedDescription =
        (_description :: RedshiftParameterGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedFamily' (RedshiftParameterGroupResource s) s (TF.Attr s Text) where
    computedFamily' =
        (_family' :: RedshiftParameterGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (RedshiftParameterGroupResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (RedshiftParameterGroupResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: RedshiftParameterGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedParameter (RedshiftParameterGroupResource s) s (TF.Attr s Text) where
    computedParameter =
        (_parameter :: RedshiftParameterGroupResource s -> TF.Attr s Text)
            . TF.refValue

redshiftParameterGroupResource :: TF.Schema TF.Resource P.AWS (RedshiftParameterGroupResource s)
redshiftParameterGroupResource =
    TF.newResource "aws_redshift_parameter_group" $
        RedshiftParameterGroupResource {
              _description = TF.Nil
            , _family' = TF.Nil
            , _name = TF.Nil
            , _parameter = TF.Nil
            }

{- | The @aws_redshift_security_group@ AWS resource.

Creates a new Amazon Redshift security group. You use security groups to
control access to non-VPC clusters
-}
data RedshiftSecurityGroupResource s = RedshiftSecurityGroupResource {
      _description :: !(TF.Attr s Text)
    {- ^ (Optional) The description of the Redshift security group. Defaults to "Managed by Terraform". -}
    , _ingress     :: !(TF.Attr s Text)
    {- ^ (Optional) A list of ingress rules. -}
    , _name        :: !(TF.Attr s Text)
    {- ^ (Required) The name of the Redshift security group. -}
    } deriving (Show, Eq)

instance TF.ToHCL (RedshiftSecurityGroupResource s) where
    toHCL RedshiftSecurityGroupResource{..} = TF.inline $ catMaybes
        [ TF.assign "description" <$> TF.attribute _description
        , TF.assign "ingress" <$> TF.attribute _ingress
        , TF.assign "name" <$> TF.attribute _name
        ]

instance P.HasDescription (RedshiftSecurityGroupResource s) (TF.Attr s Text) where
    description =
        lens (_description :: RedshiftSecurityGroupResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: RedshiftSecurityGroupResource s)

instance P.HasIngress (RedshiftSecurityGroupResource s) (TF.Attr s Text) where
    ingress =
        lens (_ingress :: RedshiftSecurityGroupResource s -> TF.Attr s Text)
             (\s a -> s { _ingress = a } :: RedshiftSecurityGroupResource s)

instance P.HasName (RedshiftSecurityGroupResource s) (TF.Attr s Text) where
    name =
        lens (_name :: RedshiftSecurityGroupResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: RedshiftSecurityGroupResource s)

instance P.HasComputedDescription (RedshiftSecurityGroupResource s) s (TF.Attr s Text) where
    computedDescription =
        (_description :: RedshiftSecurityGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (RedshiftSecurityGroupResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedIngress (RedshiftSecurityGroupResource s) s (TF.Attr s Text) where
    computedIngress =
        (_ingress :: RedshiftSecurityGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (RedshiftSecurityGroupResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: RedshiftSecurityGroupResource s -> TF.Attr s Text)
            . TF.refValue

redshiftSecurityGroupResource :: TF.Schema TF.Resource P.AWS (RedshiftSecurityGroupResource s)
redshiftSecurityGroupResource =
    TF.newResource "aws_redshift_security_group" $
        RedshiftSecurityGroupResource {
              _description = TF.Nil
            , _ingress = TF.Nil
            , _name = TF.Nil
            }

{- | The @aws_redshift_subnet_group@ AWS resource.

Creates a new Amazon Redshift subnet group. You must provide a list of one
or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC)
when creating Amazon Redshift subnet group.
-}
data RedshiftSubnetGroupResource s = RedshiftSubnetGroupResource {
      _description :: !(TF.Attr s Text)
    {- ^ (Optional) The description of the Redshift Subnet group. Defaults to "Managed by Terraform". -}
    , _name        :: !(TF.Attr s Text)
    {- ^ (Required) The name of the Redshift Subnet group. -}
    , _subnet_ids  :: !(TF.Attr s Text)
    {- ^ (Required) An array of VPC subnet IDs. -}
    , _tags        :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    } deriving (Show, Eq)

instance TF.ToHCL (RedshiftSubnetGroupResource s) where
    toHCL RedshiftSubnetGroupResource{..} = TF.inline $ catMaybes
        [ TF.assign "description" <$> TF.attribute _description
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "subnet_ids" <$> TF.attribute _subnet_ids
        , TF.assign "tags" <$> TF.attribute _tags
        ]

instance P.HasDescription (RedshiftSubnetGroupResource s) (TF.Attr s Text) where
    description =
        lens (_description :: RedshiftSubnetGroupResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: RedshiftSubnetGroupResource s)

instance P.HasName (RedshiftSubnetGroupResource s) (TF.Attr s Text) where
    name =
        lens (_name :: RedshiftSubnetGroupResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: RedshiftSubnetGroupResource s)

instance P.HasSubnetIds (RedshiftSubnetGroupResource s) (TF.Attr s Text) where
    subnetIds =
        lens (_subnet_ids :: RedshiftSubnetGroupResource s -> TF.Attr s Text)
             (\s a -> s { _subnet_ids = a } :: RedshiftSubnetGroupResource s)

instance P.HasTags (RedshiftSubnetGroupResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: RedshiftSubnetGroupResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: RedshiftSubnetGroupResource s)

instance P.HasComputedDescription (RedshiftSubnetGroupResource s) s (TF.Attr s Text) where
    computedDescription =
        (_description :: RedshiftSubnetGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (RedshiftSubnetGroupResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (RedshiftSubnetGroupResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: RedshiftSubnetGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSubnetIds (RedshiftSubnetGroupResource s) s (TF.Attr s Text) where
    computedSubnetIds =
        (_subnet_ids :: RedshiftSubnetGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (RedshiftSubnetGroupResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: RedshiftSubnetGroupResource s -> TF.Attr s P.Tags)
            . TF.refValue

redshiftSubnetGroupResource :: TF.Schema TF.Resource P.AWS (RedshiftSubnetGroupResource s)
redshiftSubnetGroupResource =
    TF.newResource "aws_redshift_subnet_group" $
        RedshiftSubnetGroupResource {
              _description = TF.Nil
            , _name = TF.Nil
            , _subnet_ids = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_route53_delegation_set@ AWS resource.

Provides a
<https://docs.aws.amazon.com/Route53/latest/APIReference/actions-on-reusable-delegation-sets.html>
resource.
-}
data Route53DelegationSetResource s = Route53DelegationSetResource {
      _reference_name :: !(TF.Attr s Text)
    {- ^ (Optional) This is a reference name used in Caller Reference (helpful for identifying single delegation set amongst others) -}
    } deriving (Show, Eq)

instance TF.ToHCL (Route53DelegationSetResource s) where
    toHCL Route53DelegationSetResource{..} = TF.inline $ catMaybes
        [ TF.assign "reference_name" <$> TF.attribute _reference_name
        ]

instance P.HasReferenceName (Route53DelegationSetResource s) (TF.Attr s Text) where
    referenceName =
        lens (_reference_name :: Route53DelegationSetResource s -> TF.Attr s Text)
             (\s a -> s { _reference_name = a } :: Route53DelegationSetResource s)

instance P.HasComputedId (Route53DelegationSetResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedNameServers (Route53DelegationSetResource s) s (TF.Attr s Text) where
    computedNameServers x = TF.compute (TF.refKey x) "name_servers"

instance P.HasComputedReferenceName (Route53DelegationSetResource s) s (TF.Attr s Text) where
    computedReferenceName =
        (_reference_name :: Route53DelegationSetResource s -> TF.Attr s Text)
            . TF.refValue

route53DelegationSetResource :: TF.Schema TF.Resource P.AWS (Route53DelegationSetResource s)
route53DelegationSetResource =
    TF.newResource "aws_route53_delegation_set" $
        Route53DelegationSetResource {
              _reference_name = TF.Nil
            }

{- | The @aws_route53_health_check@ AWS resource.

Provides a Route53 health check.
-}
data Route53HealthCheckResource s = Route53HealthCheckResource {
      _child_health_threshold          :: !(TF.Attr s Text)
    {- ^ (Optional) The minimum number of child health checks that must be healthy for Route 53 to consider the parent health check to be healthy. Valid values are integers between 0 and 256, inclusive -}
    , _child_healthchecks              :: !(TF.Attr s Text)
    {- ^ (Optional) For a specified parent health check, a list of HealthCheckId values for the associated child health checks. -}
    , _cloudwatch_alarm_name           :: !(TF.Attr s Text)
    {- ^ (Optional) The name of the CloudWatch alarm. -}
    , _cloudwatch_alarm_region         :: !(TF.Attr s P.Region)
    {- ^ (Optional) The CloudWatchRegion that the CloudWatch alarm was created in. -}
    , _enable_sni                      :: !(TF.Attr s P.Bool)
    {- ^ (Optional) A boolean value that indicates whether Route53 should send the @fqdn@ to the endpoint when performing the health check. This defaults to AWS' defaults: when the @type@ is "HTTPS" @enable_sni@ defaults to @true@ , when @type@ is anything else @enable_sni@ defaults to @false@ . -}
    , _failure_threshold               :: !(TF.Attr s Text)
    {- ^ (Required) The number of consecutive health checks that an endpoint must pass or fail. -}
    , _fqdn                            :: !(TF.Attr s Text)
    {- ^ (Optional) The fully qualified domain name of the endpoint to be checked. -}
    , _insufficient_data_health_status :: !(TF.Attr s Text)
    {- ^ (Optional) The status of the health check when CloudWatch has insufficient data about the state of associated alarm. Valid values are @Healthy@ , @Unhealthy@ and @LastKnownStatus@ . -}
    , _invert_healthcheck              :: !(TF.Attr s Text)
    {- ^ (Optional) A boolean value that indicates whether the status of health check should be inverted. For example, if a health check is healthy but Inverted is True , then Route 53 considers the health check to be unhealthy. -}
    , _ip_address                      :: !(TF.Attr s Text)
    {- ^ (Optional) The IP address of the endpoint to be checked. -}
    , _measure_latency                 :: !(TF.Attr s Text)
    {- ^ (Optional) A Boolean value that indicates whether you want Route 53 to measure the latency between health checkers in multiple AWS regions and your endpoint and to display CloudWatch latency graphs in the Route 53 console. -}
    , _port                            :: !(TF.Attr s Text)
    {- ^ (Optional) The port of the endpoint to be checked. -}
    , _reference_name                  :: !(TF.Attr s Text)
    {- ^ (Optional) This is a reference name used in Caller Reference (helpful for identifying single health_check set amongst others) -}
    , _regions                         :: !(TF.Attr s Text)
    {- ^ (Optional) A list of AWS regions that you want Amazon Route 53 health checkers to check the specified endpoint from. -}
    , _request_interval                :: !(TF.Attr s Text)
    {- ^ (Required) The number of seconds between the time that Amazon Route 53 gets a response from your endpoint and the time that it sends the next health-check request. -}
    , _resource_path                   :: !(TF.Attr s Text)
    {- ^ (Optional) The path that you want Amazon Route 53 to request when performing health checks. -}
    , _search_string                   :: !(TF.Attr s Text)
    {- ^ (Optional) String searched in the first 5120 bytes of the response body for check to be considered healthy. -}
    , _tags                            :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the health check. -}
    , _type'                           :: !(TF.Attr s Text)
    {- ^ (Required) The protocol to use when performing health checks. Valid values are @HTTP@ , @HTTPS@ , @HTTP_STR_MATCH@ , @HTTPS_STR_MATCH@ , @TCP@ , @CALCULATED@ and @CLOUDWATCH_METRIC@ . -}
    } deriving (Show, Eq)

instance TF.ToHCL (Route53HealthCheckResource s) where
    toHCL Route53HealthCheckResource{..} = TF.inline $ catMaybes
        [ TF.assign "child_health_threshold" <$> TF.attribute _child_health_threshold
        , TF.assign "child_healthchecks" <$> TF.attribute _child_healthchecks
        , TF.assign "cloudwatch_alarm_name" <$> TF.attribute _cloudwatch_alarm_name
        , TF.assign "cloudwatch_alarm_region" <$> TF.attribute _cloudwatch_alarm_region
        , TF.assign "enable_sni" <$> TF.attribute _enable_sni
        , TF.assign "failure_threshold" <$> TF.attribute _failure_threshold
        , TF.assign "fqdn" <$> TF.attribute _fqdn
        , TF.assign "insufficient_data_health_status" <$> TF.attribute _insufficient_data_health_status
        , TF.assign "invert_healthcheck" <$> TF.attribute _invert_healthcheck
        , TF.assign "ip_address" <$> TF.attribute _ip_address
        , TF.assign "measure_latency" <$> TF.attribute _measure_latency
        , TF.assign "port" <$> TF.attribute _port
        , TF.assign "reference_name" <$> TF.attribute _reference_name
        , TF.assign "regions" <$> TF.attribute _regions
        , TF.assign "request_interval" <$> TF.attribute _request_interval
        , TF.assign "resource_path" <$> TF.attribute _resource_path
        , TF.assign "search_string" <$> TF.attribute _search_string
        , TF.assign "tags" <$> TF.attribute _tags
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance P.HasChildHealthThreshold (Route53HealthCheckResource s) (TF.Attr s Text) where
    childHealthThreshold =
        lens (_child_health_threshold :: Route53HealthCheckResource s -> TF.Attr s Text)
             (\s a -> s { _child_health_threshold = a } :: Route53HealthCheckResource s)

instance P.HasChildHealthchecks (Route53HealthCheckResource s) (TF.Attr s Text) where
    childHealthchecks =
        lens (_child_healthchecks :: Route53HealthCheckResource s -> TF.Attr s Text)
             (\s a -> s { _child_healthchecks = a } :: Route53HealthCheckResource s)

instance P.HasCloudwatchAlarmName (Route53HealthCheckResource s) (TF.Attr s Text) where
    cloudwatchAlarmName =
        lens (_cloudwatch_alarm_name :: Route53HealthCheckResource s -> TF.Attr s Text)
             (\s a -> s { _cloudwatch_alarm_name = a } :: Route53HealthCheckResource s)

instance P.HasCloudwatchAlarmRegion (Route53HealthCheckResource s) (TF.Attr s P.Region) where
    cloudwatchAlarmRegion =
        lens (_cloudwatch_alarm_region :: Route53HealthCheckResource s -> TF.Attr s P.Region)
             (\s a -> s { _cloudwatch_alarm_region = a } :: Route53HealthCheckResource s)

instance P.HasEnableSni (Route53HealthCheckResource s) (TF.Attr s P.Bool) where
    enableSni =
        lens (_enable_sni :: Route53HealthCheckResource s -> TF.Attr s P.Bool)
             (\s a -> s { _enable_sni = a } :: Route53HealthCheckResource s)

instance P.HasFailureThreshold (Route53HealthCheckResource s) (TF.Attr s Text) where
    failureThreshold =
        lens (_failure_threshold :: Route53HealthCheckResource s -> TF.Attr s Text)
             (\s a -> s { _failure_threshold = a } :: Route53HealthCheckResource s)

instance P.HasFqdn (Route53HealthCheckResource s) (TF.Attr s Text) where
    fqdn =
        lens (_fqdn :: Route53HealthCheckResource s -> TF.Attr s Text)
             (\s a -> s { _fqdn = a } :: Route53HealthCheckResource s)

instance P.HasInsufficientDataHealthStatus (Route53HealthCheckResource s) (TF.Attr s Text) where
    insufficientDataHealthStatus =
        lens (_insufficient_data_health_status :: Route53HealthCheckResource s -> TF.Attr s Text)
             (\s a -> s { _insufficient_data_health_status = a } :: Route53HealthCheckResource s)

instance P.HasInvertHealthcheck (Route53HealthCheckResource s) (TF.Attr s Text) where
    invertHealthcheck =
        lens (_invert_healthcheck :: Route53HealthCheckResource s -> TF.Attr s Text)
             (\s a -> s { _invert_healthcheck = a } :: Route53HealthCheckResource s)

instance P.HasIpAddress (Route53HealthCheckResource s) (TF.Attr s Text) where
    ipAddress =
        lens (_ip_address :: Route53HealthCheckResource s -> TF.Attr s Text)
             (\s a -> s { _ip_address = a } :: Route53HealthCheckResource s)

instance P.HasMeasureLatency (Route53HealthCheckResource s) (TF.Attr s Text) where
    measureLatency =
        lens (_measure_latency :: Route53HealthCheckResource s -> TF.Attr s Text)
             (\s a -> s { _measure_latency = a } :: Route53HealthCheckResource s)

instance P.HasPort (Route53HealthCheckResource s) (TF.Attr s Text) where
    port =
        lens (_port :: Route53HealthCheckResource s -> TF.Attr s Text)
             (\s a -> s { _port = a } :: Route53HealthCheckResource s)

instance P.HasReferenceName (Route53HealthCheckResource s) (TF.Attr s Text) where
    referenceName =
        lens (_reference_name :: Route53HealthCheckResource s -> TF.Attr s Text)
             (\s a -> s { _reference_name = a } :: Route53HealthCheckResource s)

instance P.HasRegions (Route53HealthCheckResource s) (TF.Attr s Text) where
    regions =
        lens (_regions :: Route53HealthCheckResource s -> TF.Attr s Text)
             (\s a -> s { _regions = a } :: Route53HealthCheckResource s)

instance P.HasRequestInterval (Route53HealthCheckResource s) (TF.Attr s Text) where
    requestInterval =
        lens (_request_interval :: Route53HealthCheckResource s -> TF.Attr s Text)
             (\s a -> s { _request_interval = a } :: Route53HealthCheckResource s)

instance P.HasResourcePath (Route53HealthCheckResource s) (TF.Attr s Text) where
    resourcePath =
        lens (_resource_path :: Route53HealthCheckResource s -> TF.Attr s Text)
             (\s a -> s { _resource_path = a } :: Route53HealthCheckResource s)

instance P.HasSearchString (Route53HealthCheckResource s) (TF.Attr s Text) where
    searchString =
        lens (_search_string :: Route53HealthCheckResource s -> TF.Attr s Text)
             (\s a -> s { _search_string = a } :: Route53HealthCheckResource s)

instance P.HasTags (Route53HealthCheckResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: Route53HealthCheckResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: Route53HealthCheckResource s)

instance P.HasType' (Route53HealthCheckResource s) (TF.Attr s Text) where
    type' =
        lens (_type' :: Route53HealthCheckResource s -> TF.Attr s Text)
             (\s a -> s { _type' = a } :: Route53HealthCheckResource s)

instance P.HasComputedChildHealthThreshold (Route53HealthCheckResource s) s (TF.Attr s Text) where
    computedChildHealthThreshold =
        (_child_health_threshold :: Route53HealthCheckResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedChildHealthchecks (Route53HealthCheckResource s) s (TF.Attr s Text) where
    computedChildHealthchecks =
        (_child_healthchecks :: Route53HealthCheckResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCloudwatchAlarmName (Route53HealthCheckResource s) s (TF.Attr s Text) where
    computedCloudwatchAlarmName =
        (_cloudwatch_alarm_name :: Route53HealthCheckResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCloudwatchAlarmRegion (Route53HealthCheckResource s) s (TF.Attr s P.Region) where
    computedCloudwatchAlarmRegion =
        (_cloudwatch_alarm_region :: Route53HealthCheckResource s -> TF.Attr s P.Region)
            . TF.refValue

instance P.HasComputedEnableSni (Route53HealthCheckResource s) s (TF.Attr s P.Bool) where
    computedEnableSni =
        (_enable_sni :: Route53HealthCheckResource s -> TF.Attr s P.Bool)
            . TF.refValue

instance P.HasComputedFailureThreshold (Route53HealthCheckResource s) s (TF.Attr s Text) where
    computedFailureThreshold =
        (_failure_threshold :: Route53HealthCheckResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedFqdn (Route53HealthCheckResource s) s (TF.Attr s Text) where
    computedFqdn =
        (_fqdn :: Route53HealthCheckResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedInsufficientDataHealthStatus (Route53HealthCheckResource s) s (TF.Attr s Text) where
    computedInsufficientDataHealthStatus =
        (_insufficient_data_health_status :: Route53HealthCheckResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedInvertHealthcheck (Route53HealthCheckResource s) s (TF.Attr s Text) where
    computedInvertHealthcheck =
        (_invert_healthcheck :: Route53HealthCheckResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedIpAddress (Route53HealthCheckResource s) s (TF.Attr s Text) where
    computedIpAddress =
        (_ip_address :: Route53HealthCheckResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedMeasureLatency (Route53HealthCheckResource s) s (TF.Attr s Text) where
    computedMeasureLatency =
        (_measure_latency :: Route53HealthCheckResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPort (Route53HealthCheckResource s) s (TF.Attr s Text) where
    computedPort =
        (_port :: Route53HealthCheckResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedReferenceName (Route53HealthCheckResource s) s (TF.Attr s Text) where
    computedReferenceName =
        (_reference_name :: Route53HealthCheckResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRegions (Route53HealthCheckResource s) s (TF.Attr s Text) where
    computedRegions =
        (_regions :: Route53HealthCheckResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRequestInterval (Route53HealthCheckResource s) s (TF.Attr s Text) where
    computedRequestInterval =
        (_request_interval :: Route53HealthCheckResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedResourcePath (Route53HealthCheckResource s) s (TF.Attr s Text) where
    computedResourcePath =
        (_resource_path :: Route53HealthCheckResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSearchString (Route53HealthCheckResource s) s (TF.Attr s Text) where
    computedSearchString =
        (_search_string :: Route53HealthCheckResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (Route53HealthCheckResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: Route53HealthCheckResource s -> TF.Attr s P.Tags)
            . TF.refValue

instance P.HasComputedType' (Route53HealthCheckResource s) s (TF.Attr s Text) where
    computedType' =
        (_type' :: Route53HealthCheckResource s -> TF.Attr s Text)
            . TF.refValue

route53HealthCheckResource :: TF.Schema TF.Resource P.AWS (Route53HealthCheckResource s)
route53HealthCheckResource =
    TF.newResource "aws_route53_health_check" $
        Route53HealthCheckResource {
              _child_health_threshold = TF.Nil
            , _child_healthchecks = TF.Nil
            , _cloudwatch_alarm_name = TF.Nil
            , _cloudwatch_alarm_region = TF.Nil
            , _enable_sni = TF.Nil
            , _failure_threshold = TF.Nil
            , _fqdn = TF.Nil
            , _insufficient_data_health_status = TF.Nil
            , _invert_healthcheck = TF.Nil
            , _ip_address = TF.Nil
            , _measure_latency = TF.Nil
            , _port = TF.Nil
            , _reference_name = TF.Nil
            , _regions = TF.Nil
            , _request_interval = TF.Nil
            , _resource_path = TF.Nil
            , _search_string = TF.Nil
            , _tags = TF.Nil
            , _type' = TF.Nil
            }

{- | The @aws_route53_query_log@ AWS resource.

Provides a Route53 query logging configuration resource. ~> NOTE: There are
restrictions on the configuration of query logging. Notably, the CloudWatch
log group must be in the @us-east-1@ region, a permissive CloudWatch log
resource policy must be in place, and the Route53 hosted zone must be
public. See
<https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/query-logs.html?console_help=true#query-logs-configuring>
for additional details.
-}
data Route53QueryLogResource s = Route53QueryLogResource {
      _cloudwatch_log_group_arn :: !(TF.Attr s Text)
    {- ^ (Required) CloudWatch log group ARN to send query logs. -}
    , _zone_id                  :: !(TF.Attr s Text)
    {- ^ (Required) Route53 hosted zone ID to enable query logs. -}
    } deriving (Show, Eq)

instance TF.ToHCL (Route53QueryLogResource s) where
    toHCL Route53QueryLogResource{..} = TF.inline $ catMaybes
        [ TF.assign "cloudwatch_log_group_arn" <$> TF.attribute _cloudwatch_log_group_arn
        , TF.assign "zone_id" <$> TF.attribute _zone_id
        ]

instance P.HasCloudwatchLogGroupArn (Route53QueryLogResource s) (TF.Attr s Text) where
    cloudwatchLogGroupArn =
        lens (_cloudwatch_log_group_arn :: Route53QueryLogResource s -> TF.Attr s Text)
             (\s a -> s { _cloudwatch_log_group_arn = a } :: Route53QueryLogResource s)

instance P.HasZoneId (Route53QueryLogResource s) (TF.Attr s Text) where
    zoneId =
        lens (_zone_id :: Route53QueryLogResource s -> TF.Attr s Text)
             (\s a -> s { _zone_id = a } :: Route53QueryLogResource s)

instance P.HasComputedCloudwatchLogGroupArn (Route53QueryLogResource s) s (TF.Attr s Text) where
    computedCloudwatchLogGroupArn =
        (_cloudwatch_log_group_arn :: Route53QueryLogResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (Route53QueryLogResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedZoneId (Route53QueryLogResource s) s (TF.Attr s Text) where
    computedZoneId =
        (_zone_id :: Route53QueryLogResource s -> TF.Attr s Text)
            . TF.refValue

route53QueryLogResource :: TF.Schema TF.Resource P.AWS (Route53QueryLogResource s)
route53QueryLogResource =
    TF.newResource "aws_route53_query_log" $
        Route53QueryLogResource {
              _cloudwatch_log_group_arn = TF.Nil
            , _zone_id = TF.Nil
            }

{- | The @aws_route53_record@ AWS resource.

Provides a Route53 record resource.
-}
data Route53RecordResource s = Route53RecordResource {
      _alias                            :: !(TF.Attr s Text)
    {- ^ (Optional) An alias block. Conflicts with @ttl@ & @records@ . Alias record documented below. -}
    , _allow_overwrite                  :: !(TF.Attr s Text)
    {- ^ (Optional) Allow creation of this record in Terraform to overwrite an existing record, if any. This does not prevent other resources within Terraform or manual Route53 changes from overwriting this record. @true@ by default. -}
    , _failover_routing_policy          :: !(TF.Attr s Text)
    {- ^ (Optional) A block indicating the routing behavior when associated health check fails. Conflicts with any other routing policy. Documented below. -}
    , _geolocation_routing_policy       :: !(TF.Attr s Text)
    {- ^ (Optional) A block indicating a routing policy based on the geolocation of the requestor. Conflicts with any other routing policy. Documented below. -}
    , _health_check_id                  :: !(TF.Attr s Text)
    {- ^ (Optional) The health check the record should be associated with. -}
    , _latency_routing_policy           :: !(TF.Attr s Text)
    {- ^ (Optional) A block indicating a routing policy based on the latency between the requestor and an AWS region. Conflicts with any other routing policy. Documented below. -}
    , _multivalue_answer_routing_policy :: !(TF.Attr s Text)
    {- ^ (Optional) A block indicating a multivalue answer routing policy. Conflicts with any other routing policy. -}
    , _name                             :: !(TF.Attr s Text)
    {- ^ (Required) The name of the record. -}
    , _records                          :: !(P.Maybe [TF.Attr s Text])
    {- ^ (Required for non-alias records) A string list of records. To specify a single record value longer than 255 characters such as a TXT record for DKIM, add @\"\"@ inside the Terraform configuration string (e.g. @"first255characters\"\"morecharacters"@ ). -}
    , _set_identifier                   :: !(TF.Attr s Text)
    {- ^ (Optional) Unique identifier to differentiate records with routing policies from one another. Required if using @failover@ , @geolocation@ , @latency@ , or @weighted@ routing policies documented below. -}
    , _ttl                              :: !(TF.Attr s Text)
    {- ^ (Required for non-alias records) The TTL of the record. -}
    , _type'                            :: !(TF.Attr s Text)
    {- ^ (Required) The record type. Valid values are @A@ , @AAAA@ , @CAA@ , @CNAME@ , @MX@ , @NAPTR@ , @NS@ , @PTR@ , @SOA@ , @SPF@ , @SRV@ and @TXT@ . -}
    , _weighted_routing_policy          :: !(TF.Attr s Text)
    {- ^ (Optional) A block indicating a weighted routing policy. Conflicts with any other routing policy. Documented below. -}
    , _zone_id                          :: !(TF.Attr s Text)
    {- ^ (Required) The ID of the hosted zone to contain this record. -}
    } deriving (Show, Eq)

instance TF.ToHCL (Route53RecordResource s) where
    toHCL Route53RecordResource{..} = TF.inline $ catMaybes
        [ TF.assign "alias" <$> TF.attribute _alias
        , TF.assign "allow_overwrite" <$> TF.attribute _allow_overwrite
        , TF.assign "failover_routing_policy" <$> TF.attribute _failover_routing_policy
        , TF.assign "geolocation_routing_policy" <$> TF.attribute _geolocation_routing_policy
        , TF.assign "health_check_id" <$> TF.attribute _health_check_id
        , TF.assign "latency_routing_policy" <$> TF.attribute _latency_routing_policy
        , TF.assign "multivalue_answer_routing_policy" <$> TF.attribute _multivalue_answer_routing_policy
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "records" <$> TF.repeated _records
        , TF.assign "set_identifier" <$> TF.attribute _set_identifier
        , TF.assign "ttl" <$> TF.attribute _ttl
        , TF.assign "type" <$> TF.attribute _type'
        , TF.assign "weighted_routing_policy" <$> TF.attribute _weighted_routing_policy
        , TF.assign "zone_id" <$> TF.attribute _zone_id
        ]

instance P.HasAlias (Route53RecordResource s) (TF.Attr s Text) where
    alias =
        lens (_alias :: Route53RecordResource s -> TF.Attr s Text)
             (\s a -> s { _alias = a } :: Route53RecordResource s)

instance P.HasAllowOverwrite (Route53RecordResource s) (TF.Attr s Text) where
    allowOverwrite =
        lens (_allow_overwrite :: Route53RecordResource s -> TF.Attr s Text)
             (\s a -> s { _allow_overwrite = a } :: Route53RecordResource s)

instance P.HasFailoverRoutingPolicy (Route53RecordResource s) (TF.Attr s Text) where
    failoverRoutingPolicy =
        lens (_failover_routing_policy :: Route53RecordResource s -> TF.Attr s Text)
             (\s a -> s { _failover_routing_policy = a } :: Route53RecordResource s)

instance P.HasGeolocationRoutingPolicy (Route53RecordResource s) (TF.Attr s Text) where
    geolocationRoutingPolicy =
        lens (_geolocation_routing_policy :: Route53RecordResource s -> TF.Attr s Text)
             (\s a -> s { _geolocation_routing_policy = a } :: Route53RecordResource s)

instance P.HasHealthCheckId (Route53RecordResource s) (TF.Attr s Text) where
    healthCheckId =
        lens (_health_check_id :: Route53RecordResource s -> TF.Attr s Text)
             (\s a -> s { _health_check_id = a } :: Route53RecordResource s)

instance P.HasLatencyRoutingPolicy (Route53RecordResource s) (TF.Attr s Text) where
    latencyRoutingPolicy =
        lens (_latency_routing_policy :: Route53RecordResource s -> TF.Attr s Text)
             (\s a -> s { _latency_routing_policy = a } :: Route53RecordResource s)

instance P.HasMultivalueAnswerRoutingPolicy (Route53RecordResource s) (TF.Attr s Text) where
    multivalueAnswerRoutingPolicy =
        lens (_multivalue_answer_routing_policy :: Route53RecordResource s -> TF.Attr s Text)
             (\s a -> s { _multivalue_answer_routing_policy = a } :: Route53RecordResource s)

instance P.HasName (Route53RecordResource s) (TF.Attr s Text) where
    name =
        lens (_name :: Route53RecordResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: Route53RecordResource s)

instance P.HasRecords (Route53RecordResource s) (P.Maybe [TF.Attr s Text]) where
    records =
        lens (_records :: Route53RecordResource s -> P.Maybe [TF.Attr s Text])
             (\s a -> s { _records = a } :: Route53RecordResource s)

instance P.HasSetIdentifier (Route53RecordResource s) (TF.Attr s Text) where
    setIdentifier =
        lens (_set_identifier :: Route53RecordResource s -> TF.Attr s Text)
             (\s a -> s { _set_identifier = a } :: Route53RecordResource s)

instance P.HasTtl (Route53RecordResource s) (TF.Attr s Text) where
    ttl =
        lens (_ttl :: Route53RecordResource s -> TF.Attr s Text)
             (\s a -> s { _ttl = a } :: Route53RecordResource s)

instance P.HasType' (Route53RecordResource s) (TF.Attr s Text) where
    type' =
        lens (_type' :: Route53RecordResource s -> TF.Attr s Text)
             (\s a -> s { _type' = a } :: Route53RecordResource s)

instance P.HasWeightedRoutingPolicy (Route53RecordResource s) (TF.Attr s Text) where
    weightedRoutingPolicy =
        lens (_weighted_routing_policy :: Route53RecordResource s -> TF.Attr s Text)
             (\s a -> s { _weighted_routing_policy = a } :: Route53RecordResource s)

instance P.HasZoneId (Route53RecordResource s) (TF.Attr s Text) where
    zoneId =
        lens (_zone_id :: Route53RecordResource s -> TF.Attr s Text)
             (\s a -> s { _zone_id = a } :: Route53RecordResource s)

instance P.HasComputedAlias (Route53RecordResource s) s (TF.Attr s Text) where
    computedAlias =
        (_alias :: Route53RecordResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAllowOverwrite (Route53RecordResource s) s (TF.Attr s Text) where
    computedAllowOverwrite =
        (_allow_overwrite :: Route53RecordResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedFailoverRoutingPolicy (Route53RecordResource s) s (TF.Attr s Text) where
    computedFailoverRoutingPolicy =
        (_failover_routing_policy :: Route53RecordResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedFqdn (Route53RecordResource s) s (TF.Attr s Text) where
    computedFqdn x = TF.compute (TF.refKey x) "fqdn"

instance P.HasComputedGeolocationRoutingPolicy (Route53RecordResource s) s (TF.Attr s Text) where
    computedGeolocationRoutingPolicy =
        (_geolocation_routing_policy :: Route53RecordResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedHealthCheckId (Route53RecordResource s) s (TF.Attr s Text) where
    computedHealthCheckId =
        (_health_check_id :: Route53RecordResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedLatencyRoutingPolicy (Route53RecordResource s) s (TF.Attr s Text) where
    computedLatencyRoutingPolicy =
        (_latency_routing_policy :: Route53RecordResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedMultivalueAnswerRoutingPolicy (Route53RecordResource s) s (TF.Attr s Text) where
    computedMultivalueAnswerRoutingPolicy =
        (_multivalue_answer_routing_policy :: Route53RecordResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (Route53RecordResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: Route53RecordResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRecords (Route53RecordResource s) s (P.Maybe [TF.Attr s Text]) where
    computedRecords =
        (_records :: Route53RecordResource s -> P.Maybe [TF.Attr s Text])
            . TF.refValue

instance P.HasComputedSetIdentifier (Route53RecordResource s) s (TF.Attr s Text) where
    computedSetIdentifier =
        (_set_identifier :: Route53RecordResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTtl (Route53RecordResource s) s (TF.Attr s Text) where
    computedTtl =
        (_ttl :: Route53RecordResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedType' (Route53RecordResource s) s (TF.Attr s Text) where
    computedType' =
        (_type' :: Route53RecordResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedWeightedRoutingPolicy (Route53RecordResource s) s (TF.Attr s Text) where
    computedWeightedRoutingPolicy =
        (_weighted_routing_policy :: Route53RecordResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedZoneId (Route53RecordResource s) s (TF.Attr s Text) where
    computedZoneId =
        (_zone_id :: Route53RecordResource s -> TF.Attr s Text)
            . TF.refValue

route53RecordResource :: TF.Schema TF.Resource P.AWS (Route53RecordResource s)
route53RecordResource =
    TF.newResource "aws_route53_record" $
        Route53RecordResource {
              _alias = TF.Nil
            , _allow_overwrite = TF.Nil
            , _failover_routing_policy = TF.Nil
            , _geolocation_routing_policy = TF.Nil
            , _health_check_id = TF.Nil
            , _latency_routing_policy = TF.Nil
            , _multivalue_answer_routing_policy = TF.Nil
            , _name = TF.Nil
            , _records = P.Nothing
            , _set_identifier = TF.Nil
            , _ttl = TF.Nil
            , _type' = TF.Nil
            , _weighted_routing_policy = TF.Nil
            , _zone_id = TF.Nil
            }

{- | The @aws_route53_zone_association@ AWS resource.

Provides a Route53 private Hosted Zone to VPC association resource.
-}
data Route53ZoneAssociationResource s = Route53ZoneAssociationResource {
      _vpc_id     :: !(TF.Attr s Text)
    {- ^ (Required) The VPC to associate with the private hosted zone. -}
    , _vpc_region :: !(TF.Attr s P.Region)
    {- ^ (Optional) The VPC's region. Defaults to the region of the AWS provider. -}
    , _zone_id    :: !(TF.Attr s Text)
    {- ^ (Required) The private hosted zone to associate. -}
    } deriving (Show, Eq)

instance TF.ToHCL (Route53ZoneAssociationResource s) where
    toHCL Route53ZoneAssociationResource{..} = TF.inline $ catMaybes
        [ TF.assign "vpc_id" <$> TF.attribute _vpc_id
        , TF.assign "vpc_region" <$> TF.attribute _vpc_region
        , TF.assign "zone_id" <$> TF.attribute _zone_id
        ]

instance P.HasVpcId (Route53ZoneAssociationResource s) (TF.Attr s Text) where
    vpcId =
        lens (_vpc_id :: Route53ZoneAssociationResource s -> TF.Attr s Text)
             (\s a -> s { _vpc_id = a } :: Route53ZoneAssociationResource s)

instance P.HasVpcRegion (Route53ZoneAssociationResource s) (TF.Attr s P.Region) where
    vpcRegion =
        lens (_vpc_region :: Route53ZoneAssociationResource s -> TF.Attr s P.Region)
             (\s a -> s { _vpc_region = a } :: Route53ZoneAssociationResource s)

instance P.HasZoneId (Route53ZoneAssociationResource s) (TF.Attr s Text) where
    zoneId =
        lens (_zone_id :: Route53ZoneAssociationResource s -> TF.Attr s Text)
             (\s a -> s { _zone_id = a } :: Route53ZoneAssociationResource s)

instance P.HasComputedId (Route53ZoneAssociationResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedVpcId (Route53ZoneAssociationResource s) s (TF.Attr s Text) where
    computedVpcId x = TF.compute (TF.refKey x) "vpc_id"

instance P.HasComputedVpcRegion (Route53ZoneAssociationResource s) s (TF.Attr s P.Region) where
    computedVpcRegion x = TF.compute (TF.refKey x) "vpc_region"

instance P.HasComputedZoneId (Route53ZoneAssociationResource s) s (TF.Attr s Text) where
    computedZoneId x = TF.compute (TF.refKey x) "zone_id"

route53ZoneAssociationResource :: TF.Schema TF.Resource P.AWS (Route53ZoneAssociationResource s)
route53ZoneAssociationResource =
    TF.newResource "aws_route53_zone_association" $
        Route53ZoneAssociationResource {
              _vpc_id = TF.Nil
            , _vpc_region = TF.Nil
            , _zone_id = TF.Nil
            }

{- | The @aws_route53_zone@ AWS resource.

Provides a Route53 Hosted Zone resource.
-}
data Route53ZoneResource s = Route53ZoneResource {
      _comment           :: !(TF.Attr s Text)
    {- ^ (Optional) A comment for the hosted zone. Defaults to 'Managed by Terraform'. -}
    , _delegation_set_id :: !(TF.Attr s Text)
    {- ^ (Optional) The ID of the reusable delegation set whose NS records you want to assign to the hosted zone. Conflicts w/ @vpc_id@ as delegation sets can only be used for public zones. -}
    , _force_destroy     :: !(TF.Attr s Text)
    {- ^ (Optional) Whether to destroy all records (possibly managed outside of Terraform) in the zone when destroying the zone. -}
    , _name              :: !(TF.Attr s Text)
    {- ^ (Required) This is the name of the hosted zone. -}
    , _tags              :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the zone. -}
    , _vpc_id            :: !(TF.Attr s Text)
    {- ^ (Optional) The VPC to associate with a private hosted zone. Specifying @vpc_id@ will create a private hosted zone. Conflicts w/ @delegation_set_id@ as delegation sets can only be used for public zones. -}
    , _vpc_region        :: !(TF.Attr s P.Region)
    {- ^ (Optional) The VPC's region. Defaults to the region of the AWS provider. -}
    } deriving (Show, Eq)

instance TF.ToHCL (Route53ZoneResource s) where
    toHCL Route53ZoneResource{..} = TF.inline $ catMaybes
        [ TF.assign "comment" <$> TF.attribute _comment
        , TF.assign "delegation_set_id" <$> TF.attribute _delegation_set_id
        , TF.assign "force_destroy" <$> TF.attribute _force_destroy
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "tags" <$> TF.attribute _tags
        , TF.assign "vpc_id" <$> TF.attribute _vpc_id
        , TF.assign "vpc_region" <$> TF.attribute _vpc_region
        ]

instance P.HasComment (Route53ZoneResource s) (TF.Attr s Text) where
    comment =
        lens (_comment :: Route53ZoneResource s -> TF.Attr s Text)
             (\s a -> s { _comment = a } :: Route53ZoneResource s)

instance P.HasDelegationSetId (Route53ZoneResource s) (TF.Attr s Text) where
    delegationSetId =
        lens (_delegation_set_id :: Route53ZoneResource s -> TF.Attr s Text)
             (\s a -> s { _delegation_set_id = a } :: Route53ZoneResource s)

instance P.HasForceDestroy (Route53ZoneResource s) (TF.Attr s Text) where
    forceDestroy =
        lens (_force_destroy :: Route53ZoneResource s -> TF.Attr s Text)
             (\s a -> s { _force_destroy = a } :: Route53ZoneResource s)

instance P.HasName (Route53ZoneResource s) (TF.Attr s Text) where
    name =
        lens (_name :: Route53ZoneResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: Route53ZoneResource s)

instance P.HasTags (Route53ZoneResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: Route53ZoneResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: Route53ZoneResource s)

instance P.HasVpcId (Route53ZoneResource s) (TF.Attr s Text) where
    vpcId =
        lens (_vpc_id :: Route53ZoneResource s -> TF.Attr s Text)
             (\s a -> s { _vpc_id = a } :: Route53ZoneResource s)

instance P.HasVpcRegion (Route53ZoneResource s) (TF.Attr s P.Region) where
    vpcRegion =
        lens (_vpc_region :: Route53ZoneResource s -> TF.Attr s P.Region)
             (\s a -> s { _vpc_region = a } :: Route53ZoneResource s)

instance P.HasComputedComment (Route53ZoneResource s) s (TF.Attr s Text) where
    computedComment =
        (_comment :: Route53ZoneResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDelegationSetId (Route53ZoneResource s) s (TF.Attr s Text) where
    computedDelegationSetId =
        (_delegation_set_id :: Route53ZoneResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedForceDestroy (Route53ZoneResource s) s (TF.Attr s Text) where
    computedForceDestroy =
        (_force_destroy :: Route53ZoneResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (Route53ZoneResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: Route53ZoneResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedNameServers (Route53ZoneResource s) s (TF.Attr s Text) where
    computedNameServers x = TF.compute (TF.refKey x) "name_servers"

instance P.HasComputedTags (Route53ZoneResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: Route53ZoneResource s -> TF.Attr s P.Tags)
            . TF.refValue

instance P.HasComputedVpcId (Route53ZoneResource s) s (TF.Attr s Text) where
    computedVpcId =
        (_vpc_id :: Route53ZoneResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedVpcRegion (Route53ZoneResource s) s (TF.Attr s P.Region) where
    computedVpcRegion =
        (_vpc_region :: Route53ZoneResource s -> TF.Attr s P.Region)
            . TF.refValue

instance P.HasComputedZoneId (Route53ZoneResource s) s (TF.Attr s Text) where
    computedZoneId x = TF.compute (TF.refKey x) "zone_id"

route53ZoneResource :: TF.Schema TF.Resource P.AWS (Route53ZoneResource s)
route53ZoneResource =
    TF.newResource "aws_route53_zone" $
        Route53ZoneResource {
              _comment = TF.Nil
            , _delegation_set_id = TF.Nil
            , _force_destroy = TF.Nil
            , _name = TF.Nil
            , _tags = TF.Nil
            , _vpc_id = TF.Nil
            , _vpc_region = TF.Nil
            }

{- | The @aws_route@ AWS resource.

Provides a resource to create a routing table entry (a route) in a VPC
routing table. ~> NOTE on Route Tables and Routes: Terraform currently
provides both a standalone Route resource and a <route_table.html> resource
with routes defined in-line. At this time you cannot use a Route Table with
in-line routes in conjunction with any Route resources. Doing so will cause
a conflict of rule settings and will overwrite rules.
-}
data RouteResource s = RouteResource {
      _destination_cidr_block      :: !(TF.Attr s P.CIDR)
    {- ^ (Optional) The destination CIDR block. -}
    , _destination_ipv6_cidr_block :: !(TF.Attr s P.CIDR)
    {- ^ (Optional) The destination IPv6 CIDR block. -}
    , _egress_only_gateway_id      :: !(TF.Attr s Text)
    {- ^ (Optional) An ID of a VPC Egress Only Internet Gateway. -}
    , _gateway_id                  :: !(TF.Attr s Text)
    {- ^ (Optional) An ID of a VPC internet gateway or a virtual private gateway. -}
    , _instance_id                 :: !(TF.Attr s Text)
    {- ^ (Optional) An ID of an EC2 instance. -}
    , _nat_gateway_id              :: !(TF.Attr s Text)
    {- ^ (Optional) An ID of a VPC NAT gateway. -}
    , _network_interface_id        :: !(TF.Attr s Text)
    {- ^ (Optional) An ID of a network interface. -}
    , _route_table_id              :: !(TF.Attr s Text)
    {- ^ (Required) The ID of the routing table. -}
    , _vpc_peering_connection_id   :: !(TF.Attr s Text)
    {- ^ (Optional) An ID of a VPC peering connection. -}
    } deriving (Show, Eq)

instance TF.ToHCL (RouteResource s) where
    toHCL RouteResource{..} = TF.inline $ catMaybes
        [ TF.assign "destination_cidr_block" <$> TF.attribute _destination_cidr_block
        , TF.assign "destination_ipv6_cidr_block" <$> TF.attribute _destination_ipv6_cidr_block
        , TF.assign "egress_only_gateway_id" <$> TF.attribute _egress_only_gateway_id
        , TF.assign "gateway_id" <$> TF.attribute _gateway_id
        , TF.assign "instance_id" <$> TF.attribute _instance_id
        , TF.assign "nat_gateway_id" <$> TF.attribute _nat_gateway_id
        , TF.assign "network_interface_id" <$> TF.attribute _network_interface_id
        , TF.assign "route_table_id" <$> TF.attribute _route_table_id
        , TF.assign "vpc_peering_connection_id" <$> TF.attribute _vpc_peering_connection_id
        ]

instance P.HasDestinationCidrBlock (RouteResource s) (TF.Attr s P.CIDR) where
    destinationCidrBlock =
        lens (_destination_cidr_block :: RouteResource s -> TF.Attr s P.CIDR)
             (\s a -> s { _destination_cidr_block = a } :: RouteResource s)

instance P.HasDestinationIpv6CidrBlock (RouteResource s) (TF.Attr s P.CIDR) where
    destinationIpv6CidrBlock =
        lens (_destination_ipv6_cidr_block :: RouteResource s -> TF.Attr s P.CIDR)
             (\s a -> s { _destination_ipv6_cidr_block = a } :: RouteResource s)

instance P.HasEgressOnlyGatewayId (RouteResource s) (TF.Attr s Text) where
    egressOnlyGatewayId =
        lens (_egress_only_gateway_id :: RouteResource s -> TF.Attr s Text)
             (\s a -> s { _egress_only_gateway_id = a } :: RouteResource s)

instance P.HasGatewayId (RouteResource s) (TF.Attr s Text) where
    gatewayId =
        lens (_gateway_id :: RouteResource s -> TF.Attr s Text)
             (\s a -> s { _gateway_id = a } :: RouteResource s)

instance P.HasInstanceId (RouteResource s) (TF.Attr s Text) where
    instanceId =
        lens (_instance_id :: RouteResource s -> TF.Attr s Text)
             (\s a -> s { _instance_id = a } :: RouteResource s)

instance P.HasNatGatewayId (RouteResource s) (TF.Attr s Text) where
    natGatewayId =
        lens (_nat_gateway_id :: RouteResource s -> TF.Attr s Text)
             (\s a -> s { _nat_gateway_id = a } :: RouteResource s)

instance P.HasNetworkInterfaceId (RouteResource s) (TF.Attr s Text) where
    networkInterfaceId =
        lens (_network_interface_id :: RouteResource s -> TF.Attr s Text)
             (\s a -> s { _network_interface_id = a } :: RouteResource s)

instance P.HasRouteTableId (RouteResource s) (TF.Attr s Text) where
    routeTableId =
        lens (_route_table_id :: RouteResource s -> TF.Attr s Text)
             (\s a -> s { _route_table_id = a } :: RouteResource s)

instance P.HasVpcPeeringConnectionId (RouteResource s) (TF.Attr s Text) where
    vpcPeeringConnectionId =
        lens (_vpc_peering_connection_id :: RouteResource s -> TF.Attr s Text)
             (\s a -> s { _vpc_peering_connection_id = a } :: RouteResource s)

instance P.HasComputedDestinationCidrBlock (RouteResource s) s (TF.Attr s P.CIDR) where
    computedDestinationCidrBlock x = TF.compute (TF.refKey x) "destination_cidr_block"

instance P.HasComputedDestinationIpv6CidrBlock (RouteResource s) s (TF.Attr s P.CIDR) where
    computedDestinationIpv6CidrBlock x = TF.compute (TF.refKey x) "destination_ipv6_cidr_block"

instance P.HasComputedEgressOnlyGatewayId (RouteResource s) s (TF.Attr s Text) where
    computedEgressOnlyGatewayId x = TF.compute (TF.refKey x) "egress_only_gateway_id"

instance P.HasComputedGatewayId (RouteResource s) s (TF.Attr s Text) where
    computedGatewayId x = TF.compute (TF.refKey x) "gateway_id"

instance P.HasComputedInstanceId (RouteResource s) s (TF.Attr s Text) where
    computedInstanceId x = TF.compute (TF.refKey x) "instance_id"

instance P.HasComputedNatGatewayId (RouteResource s) s (TF.Attr s Text) where
    computedNatGatewayId x = TF.compute (TF.refKey x) "nat_gateway_id"

instance P.HasComputedNetworkInterfaceId (RouteResource s) s (TF.Attr s Text) where
    computedNetworkInterfaceId x = TF.compute (TF.refKey x) "network_interface_id"

instance P.HasComputedRouteTableId (RouteResource s) s (TF.Attr s Text) where
    computedRouteTableId x = TF.compute (TF.refKey x) "route_table_id"

instance P.HasComputedVpcPeeringConnectionId (RouteResource s) s (TF.Attr s Text) where
    computedVpcPeeringConnectionId x = TF.compute (TF.refKey x) "vpc_peering_connection_id"

routeResource :: TF.Schema TF.Resource P.AWS (RouteResource s)
routeResource =
    TF.newResource "aws_route" $
        RouteResource {
              _destination_cidr_block = TF.Nil
            , _destination_ipv6_cidr_block = TF.Nil
            , _egress_only_gateway_id = TF.Nil
            , _gateway_id = TF.Nil
            , _instance_id = TF.Nil
            , _nat_gateway_id = TF.Nil
            , _network_interface_id = TF.Nil
            , _route_table_id = TF.Nil
            , _vpc_peering_connection_id = TF.Nil
            }

{- | The @aws_route_table_association@ AWS resource.

Provides a resource to create an association between a subnet and routing
table.
-}
data RouteTableAssociationResource s = RouteTableAssociationResource {
      _route_table_id :: !(TF.Attr s Text)
    {- ^ (Required) The ID of the routing table to associate with. -}
    , _subnet_id      :: !(TF.Attr s Text)
    {- ^ (Required) The subnet ID to create an association. -}
    } deriving (Show, Eq)

instance TF.ToHCL (RouteTableAssociationResource s) where
    toHCL RouteTableAssociationResource{..} = TF.inline $ catMaybes
        [ TF.assign "route_table_id" <$> TF.attribute _route_table_id
        , TF.assign "subnet_id" <$> TF.attribute _subnet_id
        ]

instance P.HasRouteTableId (RouteTableAssociationResource s) (TF.Attr s Text) where
    routeTableId =
        lens (_route_table_id :: RouteTableAssociationResource s -> TF.Attr s Text)
             (\s a -> s { _route_table_id = a } :: RouteTableAssociationResource s)

instance P.HasSubnetId (RouteTableAssociationResource s) (TF.Attr s Text) where
    subnetId =
        lens (_subnet_id :: RouteTableAssociationResource s -> TF.Attr s Text)
             (\s a -> s { _subnet_id = a } :: RouteTableAssociationResource s)

instance P.HasComputedId (RouteTableAssociationResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedRouteTableId (RouteTableAssociationResource s) s (TF.Attr s Text) where
    computedRouteTableId =
        (_route_table_id :: RouteTableAssociationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSubnetId (RouteTableAssociationResource s) s (TF.Attr s Text) where
    computedSubnetId =
        (_subnet_id :: RouteTableAssociationResource s -> TF.Attr s Text)
            . TF.refValue

routeTableAssociationResource :: TF.Schema TF.Resource P.AWS (RouteTableAssociationResource s)
routeTableAssociationResource =
    TF.newResource "aws_route_table_association" $
        RouteTableAssociationResource {
              _route_table_id = TF.Nil
            , _subnet_id = TF.Nil
            }

{- | The @aws_route_table@ AWS resource.

Provides a resource to create a VPC routing table. ~> NOTE on Route Tables
and Routes: Terraform currently provides both a standalone <route.html> and
a Route Table resource with routes defined in-line. At this time you cannot
use a Route Table with in-line routes in conjunction with any Route
resources. Doing so will cause a conflict of rule settings and will
overwrite rules. ~> NOTE on @gateway_id@ and @nat_gateway_id@ : The AWS API
is very forgiving with these two attributes and the @aws_route_table@
resource can be created with a NAT ID specified as a Gateway ID attribute.
This will lead to a permanent diff between your configuration and statefile,
as the API returns the correct parameters in the returned route table. If
you're experiencing constant diffs in your @aws_route_table@ resources, the
first thing to check is whether or not you're specifying a NAT ID instead of
a Gateway ID, or vice-versa. ~> NOTE on @propagating_vgws@ and the
@aws_vpn_gateway_route_propagation@ resource: If the @propagating_vgws@
argument is present, it's not supported to also define route propagations
using @aws_vpn_gateway_route_propagation@ , since this resource will delete
any propagating gateways not explicitly listed in @propagating_vgws@ . Omit
this argument when defining route propagation using the separate resource.
-}
data RouteTableResource s = RouteTableResource {
      _propagating_vgws :: !(TF.Attr s Text)
    {- ^ (Optional) A list of virtual gateways for propagation. -}
    , _route            :: !(TF.Attr s Text)
    {- ^ (Optional) A list of route objects. Their keys are documented below. -}
    , _tags             :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    , _vpc_id           :: !(TF.Attr s Text)
    {- ^ (Required) The VPC ID. -}
    } deriving (Show, Eq)

instance TF.ToHCL (RouteTableResource s) where
    toHCL RouteTableResource{..} = TF.inline $ catMaybes
        [ TF.assign "propagating_vgws" <$> TF.attribute _propagating_vgws
        , TF.assign "route" <$> TF.attribute _route
        , TF.assign "tags" <$> TF.attribute _tags
        , TF.assign "vpc_id" <$> TF.attribute _vpc_id
        ]

instance P.HasPropagatingVgws (RouteTableResource s) (TF.Attr s Text) where
    propagatingVgws =
        lens (_propagating_vgws :: RouteTableResource s -> TF.Attr s Text)
             (\s a -> s { _propagating_vgws = a } :: RouteTableResource s)

instance P.HasRoute (RouteTableResource s) (TF.Attr s Text) where
    route =
        lens (_route :: RouteTableResource s -> TF.Attr s Text)
             (\s a -> s { _route = a } :: RouteTableResource s)

instance P.HasTags (RouteTableResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: RouteTableResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: RouteTableResource s)

instance P.HasVpcId (RouteTableResource s) (TF.Attr s Text) where
    vpcId =
        lens (_vpc_id :: RouteTableResource s -> TF.Attr s Text)
             (\s a -> s { _vpc_id = a } :: RouteTableResource s)

instance P.HasComputedId (RouteTableResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedPropagatingVgws (RouteTableResource s) s (TF.Attr s Text) where
    computedPropagatingVgws =
        (_propagating_vgws :: RouteTableResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRoute (RouteTableResource s) s (TF.Attr s Text) where
    computedRoute =
        (_route :: RouteTableResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (RouteTableResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: RouteTableResource s -> TF.Attr s P.Tags)
            . TF.refValue

instance P.HasComputedVpcId (RouteTableResource s) s (TF.Attr s Text) where
    computedVpcId =
        (_vpc_id :: RouteTableResource s -> TF.Attr s Text)
            . TF.refValue

routeTableResource :: TF.Schema TF.Resource P.AWS (RouteTableResource s)
routeTableResource =
    TF.newResource "aws_route_table" $
        RouteTableResource {
              _propagating_vgws = TF.Nil
            , _route = TF.Nil
            , _tags = TF.Nil
            , _vpc_id = TF.Nil
            }

{- | The @aws_s3_bucket_metric@ AWS resource.

Provides a S3 bucket
<http://docs.aws.amazon.com/AmazonS3/latest/dev/metrics-configurations.html>
resource.
-}
data S3BucketMetricResource s = S3BucketMetricResource {
      _bucket :: !(TF.Attr s Text)
    {- ^ (Required) The name of the bucket to put metric configuration. -}
    , _filter :: !(TF.Attr s Text)
    {- ^ (Optional) <http://docs.aws.amazon.com/AmazonS3/latest/dev/metrics-configurations.html#metrics-configurations-filter> that accepts a prefix, tags, or a logical AND of prefix and tags (documented below). -}
    , _name   :: !(TF.Attr s Text)
    {- ^ (Required) Unique identifier of the metrics configuration for the bucket. -}
    } deriving (Show, Eq)

instance TF.ToHCL (S3BucketMetricResource s) where
    toHCL S3BucketMetricResource{..} = TF.inline $ catMaybes
        [ TF.assign "bucket" <$> TF.attribute _bucket
        , TF.assign "filter" <$> TF.attribute _filter
        , TF.assign "name" <$> TF.attribute _name
        ]

instance P.HasBucket (S3BucketMetricResource s) (TF.Attr s Text) where
    bucket =
        lens (_bucket :: S3BucketMetricResource s -> TF.Attr s Text)
             (\s a -> s { _bucket = a } :: S3BucketMetricResource s)

instance P.HasFilter (S3BucketMetricResource s) (TF.Attr s Text) where
    filter =
        lens (_filter :: S3BucketMetricResource s -> TF.Attr s Text)
             (\s a -> s { _filter = a } :: S3BucketMetricResource s)

instance P.HasName (S3BucketMetricResource s) (TF.Attr s Text) where
    name =
        lens (_name :: S3BucketMetricResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: S3BucketMetricResource s)

instance P.HasComputedBucket (S3BucketMetricResource s) s (TF.Attr s Text) where
    computedBucket =
        (_bucket :: S3BucketMetricResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedFilter (S3BucketMetricResource s) s (TF.Attr s Text) where
    computedFilter =
        (_filter :: S3BucketMetricResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (S3BucketMetricResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: S3BucketMetricResource s -> TF.Attr s Text)
            . TF.refValue

s3BucketMetricResource :: TF.Schema TF.Resource P.AWS (S3BucketMetricResource s)
s3BucketMetricResource =
    TF.newResource "aws_s3_bucket_metric" $
        S3BucketMetricResource {
              _bucket = TF.Nil
            , _filter = TF.Nil
            , _name = TF.Nil
            }

{- | The @aws_s3_bucket_notification@ AWS resource.

Provides a S3 bucket notification resource.
-}
data S3BucketNotificationResource s = S3BucketNotificationResource {
      _bucket          :: !(TF.Attr s Text)
    {- ^ (Required) The name of the bucket to put notification configuration. -}
    , _lambda_function :: !(TF.Attr s Text)
    {- ^ (Optional, Multiple) Used to configure notifications to a Lambda Function (documented below). -}
    , _queue           :: !(TF.Attr s Text)
    {- ^ (Optional) The notification configuration to SQS Queue (documented below). -}
    , _topic           :: !(TF.Attr s Text)
    {- ^ (Optional) The notification configuration to SNS Topic (documented below). -}
    } deriving (Show, Eq)

instance TF.ToHCL (S3BucketNotificationResource s) where
    toHCL S3BucketNotificationResource{..} = TF.inline $ catMaybes
        [ TF.assign "bucket" <$> TF.attribute _bucket
        , TF.assign "lambda_function" <$> TF.attribute _lambda_function
        , TF.assign "queue" <$> TF.attribute _queue
        , TF.assign "topic" <$> TF.attribute _topic
        ]

instance P.HasBucket (S3BucketNotificationResource s) (TF.Attr s Text) where
    bucket =
        lens (_bucket :: S3BucketNotificationResource s -> TF.Attr s Text)
             (\s a -> s { _bucket = a } :: S3BucketNotificationResource s)

instance P.HasLambdaFunction (S3BucketNotificationResource s) (TF.Attr s Text) where
    lambdaFunction =
        lens (_lambda_function :: S3BucketNotificationResource s -> TF.Attr s Text)
             (\s a -> s { _lambda_function = a } :: S3BucketNotificationResource s)

instance P.HasQueue (S3BucketNotificationResource s) (TF.Attr s Text) where
    queue =
        lens (_queue :: S3BucketNotificationResource s -> TF.Attr s Text)
             (\s a -> s { _queue = a } :: S3BucketNotificationResource s)

instance P.HasTopic (S3BucketNotificationResource s) (TF.Attr s Text) where
    topic =
        lens (_topic :: S3BucketNotificationResource s -> TF.Attr s Text)
             (\s a -> s { _topic = a } :: S3BucketNotificationResource s)

instance P.HasComputedBucket (S3BucketNotificationResource s) s (TF.Attr s Text) where
    computedBucket =
        (_bucket :: S3BucketNotificationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedLambdaFunction (S3BucketNotificationResource s) s (TF.Attr s Text) where
    computedLambdaFunction =
        (_lambda_function :: S3BucketNotificationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedQueue (S3BucketNotificationResource s) s (TF.Attr s Text) where
    computedQueue =
        (_queue :: S3BucketNotificationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTopic (S3BucketNotificationResource s) s (TF.Attr s Text) where
    computedTopic =
        (_topic :: S3BucketNotificationResource s -> TF.Attr s Text)
            . TF.refValue

s3BucketNotificationResource :: TF.Schema TF.Resource P.AWS (S3BucketNotificationResource s)
s3BucketNotificationResource =
    TF.newResource "aws_s3_bucket_notification" $
        S3BucketNotificationResource {
              _bucket = TF.Nil
            , _lambda_function = TF.Nil
            , _queue = TF.Nil
            , _topic = TF.Nil
            }

{- | The @aws_s3_bucket_object@ AWS resource.

Provides a S3 bucket object resource.
-}
data S3BucketObjectResource s = S3BucketObjectResource {
      _acl                    :: !(TF.Attr s Text)
    {- ^ (Optional) The <https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl> to apply. Defaults to "private". -}
    , _bucket                 :: !(TF.Attr s Text)
    {- ^ (Required) The name of the bucket to put the file in. -}
    , _cache_control          :: !(TF.Attr s Text)
    {- ^ (Optional) Specifies caching behavior along the request/reply chain Read <http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9> for further details. -}
    , _content                :: !(TF.Attr s Text)
    {- ^ (Required unless @source@ given) The literal content being uploaded to the bucket. -}
    , _content_disposition    :: !(TF.Attr s Text)
    {- ^ (Optional) Specifies presentational information for the object. Read <http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html#sec19.5.1> for further information. -}
    , _content_encoding       :: !(TF.Attr s Text)
    {- ^ (Optional) Specifies what content encodings have been applied to the object and thus what decoding mechanisms must be applied to obtain the media-type referenced by the Content-Type header field. Read <http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11> for further information. -}
    , _content_language       :: !(TF.Attr s Text)
    {- ^ (Optional) The language the content is in e.g. en-US or en-GB. -}
    , _content_type           :: !(TF.Attr s Text)
    {- ^ (Optional) A standard MIME type describing the format of the object data, e.g. application/octet-stream. All Valid MIME Types are valid for this input. -}
    , _etag                   :: !(TF.Attr s Text)
    {- ^ (Optional) Used to trigger updates. The only meaningful value is @${md5(file("path/to/file"))}@ . This attribute is not compatible with @kms_key_id@ . -}
    , _key                    :: !(TF.Attr s Text)
    {- ^ (Required) The name of the object once it is in the bucket. -}
    , _kms_key_id             :: !(TF.Attr s Text)
    {- ^ (Optional) Specifies the AWS KMS Key ARN to use for object encryption. This value is a fully qualified ARN of the KMS Key. If using @aws_kms_key@ , use the exported @arn@ attribute: @kms_key_id = "${aws_kms_key.foo.arn}"@ -}
    , _server_side_encryption :: !(TF.Attr s Text)
    {- ^ (Optional) Specifies server-side encryption of the object in S3. Valid values are " @AES256@ " and " @aws:kms@ ". -}
    , _source                 :: !(TF.Attr s Text)
    {- ^ (Required) The path to the source file being uploaded to the bucket. -}
    , _storage_class          :: !(TF.Attr s Text)
    {- ^ (Optional) Specifies the desired <http://docs.aws.amazon.com/AmazonS3/latest/dev/storage-class-intro.html> for the object. Can be either " @STANDARD@ ", " @REDUCED_REDUNDANCY@ ", or " @STANDARD_IA@ ". Defaults to " @STANDARD@ ". -}
    , _tags                   :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the object. -}
    , _website_redirect       :: !(TF.Attr s Text)
    {- ^ (Optional) Specifies a target URL for <http://docs.aws.amazon.com/AmazonS3/latest/dev/how-to-page-redirect.html> . -}
    } deriving (Show, Eq)

instance TF.ToHCL (S3BucketObjectResource s) where
    toHCL S3BucketObjectResource{..} = TF.inline $ catMaybes
        [ TF.assign "acl" <$> TF.attribute _acl
        , TF.assign "bucket" <$> TF.attribute _bucket
        , TF.assign "cache_control" <$> TF.attribute _cache_control
        , TF.assign "content" <$> TF.attribute _content
        , TF.assign "content_disposition" <$> TF.attribute _content_disposition
        , TF.assign "content_encoding" <$> TF.attribute _content_encoding
        , TF.assign "content_language" <$> TF.attribute _content_language
        , TF.assign "content_type" <$> TF.attribute _content_type
        , TF.assign "etag" <$> TF.attribute _etag
        , TF.assign "key" <$> TF.attribute _key
        , TF.assign "kms_key_id" <$> TF.attribute _kms_key_id
        , TF.assign "server_side_encryption" <$> TF.attribute _server_side_encryption
        , TF.assign "source" <$> TF.attribute _source
        , TF.assign "storage_class" <$> TF.attribute _storage_class
        , TF.assign "tags" <$> TF.attribute _tags
        , TF.assign "website_redirect" <$> TF.attribute _website_redirect
        ]

instance P.HasAcl (S3BucketObjectResource s) (TF.Attr s Text) where
    acl =
        lens (_acl :: S3BucketObjectResource s -> TF.Attr s Text)
             (\s a -> s { _acl = a } :: S3BucketObjectResource s)

instance P.HasBucket (S3BucketObjectResource s) (TF.Attr s Text) where
    bucket =
        lens (_bucket :: S3BucketObjectResource s -> TF.Attr s Text)
             (\s a -> s { _bucket = a } :: S3BucketObjectResource s)

instance P.HasCacheControl (S3BucketObjectResource s) (TF.Attr s Text) where
    cacheControl =
        lens (_cache_control :: S3BucketObjectResource s -> TF.Attr s Text)
             (\s a -> s { _cache_control = a } :: S3BucketObjectResource s)

instance P.HasContent (S3BucketObjectResource s) (TF.Attr s Text) where
    content =
        lens (_content :: S3BucketObjectResource s -> TF.Attr s Text)
             (\s a -> s { _content = a } :: S3BucketObjectResource s)

instance P.HasContentDisposition (S3BucketObjectResource s) (TF.Attr s Text) where
    contentDisposition =
        lens (_content_disposition :: S3BucketObjectResource s -> TF.Attr s Text)
             (\s a -> s { _content_disposition = a } :: S3BucketObjectResource s)

instance P.HasContentEncoding (S3BucketObjectResource s) (TF.Attr s Text) where
    contentEncoding =
        lens (_content_encoding :: S3BucketObjectResource s -> TF.Attr s Text)
             (\s a -> s { _content_encoding = a } :: S3BucketObjectResource s)

instance P.HasContentLanguage (S3BucketObjectResource s) (TF.Attr s Text) where
    contentLanguage =
        lens (_content_language :: S3BucketObjectResource s -> TF.Attr s Text)
             (\s a -> s { _content_language = a } :: S3BucketObjectResource s)

instance P.HasContentType (S3BucketObjectResource s) (TF.Attr s Text) where
    contentType =
        lens (_content_type :: S3BucketObjectResource s -> TF.Attr s Text)
             (\s a -> s { _content_type = a } :: S3BucketObjectResource s)

instance P.HasEtag (S3BucketObjectResource s) (TF.Attr s Text) where
    etag =
        lens (_etag :: S3BucketObjectResource s -> TF.Attr s Text)
             (\s a -> s { _etag = a } :: S3BucketObjectResource s)

instance P.HasKey (S3BucketObjectResource s) (TF.Attr s Text) where
    key =
        lens (_key :: S3BucketObjectResource s -> TF.Attr s Text)
             (\s a -> s { _key = a } :: S3BucketObjectResource s)

instance P.HasKmsKeyId (S3BucketObjectResource s) (TF.Attr s Text) where
    kmsKeyId =
        lens (_kms_key_id :: S3BucketObjectResource s -> TF.Attr s Text)
             (\s a -> s { _kms_key_id = a } :: S3BucketObjectResource s)

instance P.HasServerSideEncryption (S3BucketObjectResource s) (TF.Attr s Text) where
    serverSideEncryption =
        lens (_server_side_encryption :: S3BucketObjectResource s -> TF.Attr s Text)
             (\s a -> s { _server_side_encryption = a } :: S3BucketObjectResource s)

instance P.HasSource (S3BucketObjectResource s) (TF.Attr s Text) where
    source =
        lens (_source :: S3BucketObjectResource s -> TF.Attr s Text)
             (\s a -> s { _source = a } :: S3BucketObjectResource s)

instance P.HasStorageClass (S3BucketObjectResource s) (TF.Attr s Text) where
    storageClass =
        lens (_storage_class :: S3BucketObjectResource s -> TF.Attr s Text)
             (\s a -> s { _storage_class = a } :: S3BucketObjectResource s)

instance P.HasTags (S3BucketObjectResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: S3BucketObjectResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: S3BucketObjectResource s)

instance P.HasWebsiteRedirect (S3BucketObjectResource s) (TF.Attr s Text) where
    websiteRedirect =
        lens (_website_redirect :: S3BucketObjectResource s -> TF.Attr s Text)
             (\s a -> s { _website_redirect = a } :: S3BucketObjectResource s)

instance P.HasComputedAcl (S3BucketObjectResource s) s (TF.Attr s Text) where
    computedAcl =
        (_acl :: S3BucketObjectResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedBucket (S3BucketObjectResource s) s (TF.Attr s Text) where
    computedBucket =
        (_bucket :: S3BucketObjectResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCacheControl (S3BucketObjectResource s) s (TF.Attr s Text) where
    computedCacheControl =
        (_cache_control :: S3BucketObjectResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedContent (S3BucketObjectResource s) s (TF.Attr s Text) where
    computedContent =
        (_content :: S3BucketObjectResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedContentDisposition (S3BucketObjectResource s) s (TF.Attr s Text) where
    computedContentDisposition =
        (_content_disposition :: S3BucketObjectResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedContentEncoding (S3BucketObjectResource s) s (TF.Attr s Text) where
    computedContentEncoding =
        (_content_encoding :: S3BucketObjectResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedContentLanguage (S3BucketObjectResource s) s (TF.Attr s Text) where
    computedContentLanguage =
        (_content_language :: S3BucketObjectResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedContentType (S3BucketObjectResource s) s (TF.Attr s Text) where
    computedContentType =
        (_content_type :: S3BucketObjectResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEtag (S3BucketObjectResource s) s (TF.Attr s Text) where
    computedEtag x = TF.compute (TF.refKey x) "etag"

instance P.HasComputedId (S3BucketObjectResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedKey (S3BucketObjectResource s) s (TF.Attr s Text) where
    computedKey =
        (_key :: S3BucketObjectResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedKmsKeyId (S3BucketObjectResource s) s (TF.Attr s Text) where
    computedKmsKeyId =
        (_kms_key_id :: S3BucketObjectResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedServerSideEncryption (S3BucketObjectResource s) s (TF.Attr s Text) where
    computedServerSideEncryption =
        (_server_side_encryption :: S3BucketObjectResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSource (S3BucketObjectResource s) s (TF.Attr s Text) where
    computedSource =
        (_source :: S3BucketObjectResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedStorageClass (S3BucketObjectResource s) s (TF.Attr s Text) where
    computedStorageClass =
        (_storage_class :: S3BucketObjectResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (S3BucketObjectResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: S3BucketObjectResource s -> TF.Attr s P.Tags)
            . TF.refValue

instance P.HasComputedVersionId (S3BucketObjectResource s) s (TF.Attr s Text) where
    computedVersionId x = TF.compute (TF.refKey x) "version_id"

instance P.HasComputedWebsiteRedirect (S3BucketObjectResource s) s (TF.Attr s Text) where
    computedWebsiteRedirect =
        (_website_redirect :: S3BucketObjectResource s -> TF.Attr s Text)
            . TF.refValue

s3BucketObjectResource :: TF.Schema TF.Resource P.AWS (S3BucketObjectResource s)
s3BucketObjectResource =
    TF.newResource "aws_s3_bucket_object" $
        S3BucketObjectResource {
              _acl = TF.Nil
            , _bucket = TF.Nil
            , _cache_control = TF.Nil
            , _content = TF.Nil
            , _content_disposition = TF.Nil
            , _content_encoding = TF.Nil
            , _content_language = TF.Nil
            , _content_type = TF.Nil
            , _etag = TF.Nil
            , _key = TF.Nil
            , _kms_key_id = TF.Nil
            , _server_side_encryption = TF.Nil
            , _source = TF.Nil
            , _storage_class = TF.Nil
            , _tags = TF.Nil
            , _website_redirect = TF.Nil
            }

{- | The @aws_s3_bucket_policy@ AWS resource.

Attaches a policy to an S3 bucket resource.
-}
data S3BucketPolicyResource s = S3BucketPolicyResource {
      _bucket :: !(TF.Attr s Text)
    {- ^ (Required) The name of the bucket to which to apply the policy. -}
    , _policy :: !(TF.Attr s Text)
    {- ^ (Required) The text of the policy. -}
    } deriving (Show, Eq)

instance TF.ToHCL (S3BucketPolicyResource s) where
    toHCL S3BucketPolicyResource{..} = TF.inline $ catMaybes
        [ TF.assign "bucket" <$> TF.attribute _bucket
        , TF.assign "policy" <$> TF.attribute _policy
        ]

instance P.HasBucket (S3BucketPolicyResource s) (TF.Attr s Text) where
    bucket =
        lens (_bucket :: S3BucketPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _bucket = a } :: S3BucketPolicyResource s)

instance P.HasPolicy (S3BucketPolicyResource s) (TF.Attr s Text) where
    policy =
        lens (_policy :: S3BucketPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _policy = a } :: S3BucketPolicyResource s)

instance P.HasComputedBucket (S3BucketPolicyResource s) s (TF.Attr s Text) where
    computedBucket =
        (_bucket :: S3BucketPolicyResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPolicy (S3BucketPolicyResource s) s (TF.Attr s Text) where
    computedPolicy =
        (_policy :: S3BucketPolicyResource s -> TF.Attr s Text)
            . TF.refValue

s3BucketPolicyResource :: TF.Schema TF.Resource P.AWS (S3BucketPolicyResource s)
s3BucketPolicyResource =
    TF.newResource "aws_s3_bucket_policy" $
        S3BucketPolicyResource {
              _bucket = TF.Nil
            , _policy = TF.Nil
            }

{- | The @aws_s3_bucket@ AWS resource.

Provides a S3 bucket resource.
-}
data S3BucketResource s = S3BucketResource {
      _acceleration_status :: !(TF.Attr s Text)
    {- ^ (Optional) Sets the accelerate configuration of an existing bucket. Can be @Enabled@ or @Suspended@ . -}
    , _acl :: !(TF.Attr s Text)
    {- ^ (Optional) The <https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl> to apply. Defaults to "private". -}
    , _bucket :: !(TF.Attr s Text)
    {- ^ (Optional, Forces new resource) The name of the bucket. If omitted, Terraform will assign a random, unique name. -}
    , _bucket_prefix :: !(TF.Attr s Text)
    {- ^ (Optional, Forces new resource) Creates a unique bucket name beginning with the specified prefix. Conflicts with @bucket@ . -}
    , _cors_rule :: !(TF.Attr s Text)
    {- ^ (Optional) A rule of <https://docs.aws.amazon.com/AmazonS3/latest/dev/cors.html> (documented below). -}
    , _force_destroy :: !(TF.Attr s Text)
    {- ^ (Optional, Default:false ) A boolean that indicates all objects should be deleted from the bucket so that the bucket can be destroyed without error. These objects are not recoverable. -}
    , _lifecycle_rule :: !(TF.Attr s Text)
    {- ^ (Optional) A configuration of <http://docs.aws.amazon.com/AmazonS3/latest/dev/object-lifecycle-mgmt.html> (documented below). -}
    , _logging :: !(TF.Attr s Text)
    {- ^ (Optional) A settings of <https://docs.aws.amazon.com/AmazonS3/latest/UG/ManagingBucketLogging.html> (documented below). -}
    , _policy :: !(TF.Attr s Text)
    {- ^ (Optional) A valid <https://docs.aws.amazon.com/AmazonS3/latest/dev/example-bucket-policies.html> JSON document. Note that if the policy document is not specific enough (but still valid), Terraform may view the policy as constantly changing in a @terraform plan@ . In this case, please make sure you use the verbose/specific version of the policy. -}
    , _region :: !(TF.Attr s P.Region)
    {- ^ (Optional) If specified, the AWS region this bucket should reside in. Otherwise, the region used by the callee. -}
    , _replication_configuration :: !(TF.Attr s Text)
    {- ^ (Optional) A configuration of <http://docs.aws.amazon.com/AmazonS3/latest/dev/crr.html> (documented below). -}
    , _request_payer :: !(TF.Attr s Text)
    {- ^ (Optional) Specifies who should bear the cost of Amazon S3 data transfer. Can be either @BucketOwner@ or @Requester@ . By default, the owner of the S3 bucket would incur the costs of any data transfer. See <http://docs.aws.amazon.com/AmazonS3/latest/dev/RequesterPaysBuckets.html> developer guide for more information. -}
    , _server_side_encryption_configuration :: !(TF.Attr s Text)
    {- ^ (Optional) A configuration of <http://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-encryption.html> (documented below) -}
    , _tags :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the bucket. -}
    , _versioning :: !(TF.Attr s (P.S3BucketVersioning s))
    {- ^ (Optional) A state of <https://docs.aws.amazon.com/AmazonS3/latest/dev/Versioning.html> (documented below) -}
    , _website :: !(TF.Attr s Text)
    {- ^ (Optional) A website object (documented below). -}
    } deriving (Show, Eq)

instance TF.ToHCL (S3BucketResource s) where
    toHCL S3BucketResource{..} = TF.inline $ catMaybes
        [ TF.assign "acceleration_status" <$> TF.attribute _acceleration_status
        , TF.assign "acl" <$> TF.attribute _acl
        , TF.assign "bucket" <$> TF.attribute _bucket
        , TF.assign "bucket_prefix" <$> TF.attribute _bucket_prefix
        , TF.assign "cors_rule" <$> TF.attribute _cors_rule
        , TF.assign "force_destroy" <$> TF.attribute _force_destroy
        , TF.assign "lifecycle_rule" <$> TF.attribute _lifecycle_rule
        , TF.assign "logging" <$> TF.attribute _logging
        , TF.assign "policy" <$> TF.attribute _policy
        , TF.assign "region" <$> TF.attribute _region
        , TF.assign "replication_configuration" <$> TF.attribute _replication_configuration
        , TF.assign "request_payer" <$> TF.attribute _request_payer
        , TF.assign "server_side_encryption_configuration" <$> TF.attribute _server_side_encryption_configuration
        , TF.assign "tags" <$> TF.attribute _tags
        , TF.assign "versioning" <$> TF.attribute _versioning
        , TF.assign "website" <$> TF.attribute _website
        ]

instance P.HasAccelerationStatus (S3BucketResource s) (TF.Attr s Text) where
    accelerationStatus =
        lens (_acceleration_status :: S3BucketResource s -> TF.Attr s Text)
             (\s a -> s { _acceleration_status = a } :: S3BucketResource s)

instance P.HasAcl (S3BucketResource s) (TF.Attr s Text) where
    acl =
        lens (_acl :: S3BucketResource s -> TF.Attr s Text)
             (\s a -> s { _acl = a } :: S3BucketResource s)

instance P.HasBucket (S3BucketResource s) (TF.Attr s Text) where
    bucket =
        lens (_bucket :: S3BucketResource s -> TF.Attr s Text)
             (\s a -> s { _bucket = a } :: S3BucketResource s)

instance P.HasBucketPrefix (S3BucketResource s) (TF.Attr s Text) where
    bucketPrefix =
        lens (_bucket_prefix :: S3BucketResource s -> TF.Attr s Text)
             (\s a -> s { _bucket_prefix = a } :: S3BucketResource s)

instance P.HasCorsRule (S3BucketResource s) (TF.Attr s Text) where
    corsRule =
        lens (_cors_rule :: S3BucketResource s -> TF.Attr s Text)
             (\s a -> s { _cors_rule = a } :: S3BucketResource s)

instance P.HasForceDestroy (S3BucketResource s) (TF.Attr s Text) where
    forceDestroy =
        lens (_force_destroy :: S3BucketResource s -> TF.Attr s Text)
             (\s a -> s { _force_destroy = a } :: S3BucketResource s)

instance P.HasLifecycleRule (S3BucketResource s) (TF.Attr s Text) where
    lifecycleRule =
        lens (_lifecycle_rule :: S3BucketResource s -> TF.Attr s Text)
             (\s a -> s { _lifecycle_rule = a } :: S3BucketResource s)

instance P.HasLogging (S3BucketResource s) (TF.Attr s Text) where
    logging =
        lens (_logging :: S3BucketResource s -> TF.Attr s Text)
             (\s a -> s { _logging = a } :: S3BucketResource s)

instance P.HasPolicy (S3BucketResource s) (TF.Attr s Text) where
    policy =
        lens (_policy :: S3BucketResource s -> TF.Attr s Text)
             (\s a -> s { _policy = a } :: S3BucketResource s)

instance P.HasRegion (S3BucketResource s) (TF.Attr s P.Region) where
    region =
        lens (_region :: S3BucketResource s -> TF.Attr s P.Region)
             (\s a -> s { _region = a } :: S3BucketResource s)

instance P.HasReplicationConfiguration (S3BucketResource s) (TF.Attr s Text) where
    replicationConfiguration =
        lens (_replication_configuration :: S3BucketResource s -> TF.Attr s Text)
             (\s a -> s { _replication_configuration = a } :: S3BucketResource s)

instance P.HasRequestPayer (S3BucketResource s) (TF.Attr s Text) where
    requestPayer =
        lens (_request_payer :: S3BucketResource s -> TF.Attr s Text)
             (\s a -> s { _request_payer = a } :: S3BucketResource s)

instance P.HasServerSideEncryptionConfiguration (S3BucketResource s) (TF.Attr s Text) where
    serverSideEncryptionConfiguration =
        lens (_server_side_encryption_configuration :: S3BucketResource s -> TF.Attr s Text)
             (\s a -> s { _server_side_encryption_configuration = a } :: S3BucketResource s)

instance P.HasTags (S3BucketResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: S3BucketResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: S3BucketResource s)

instance P.HasVersioning (S3BucketResource s) (TF.Attr s (P.S3BucketVersioning s)) where
    versioning =
        lens (_versioning :: S3BucketResource s -> TF.Attr s (P.S3BucketVersioning s))
             (\s a -> s { _versioning = a } :: S3BucketResource s)

instance P.HasWebsite (S3BucketResource s) (TF.Attr s Text) where
    website =
        lens (_website :: S3BucketResource s -> TF.Attr s Text)
             (\s a -> s { _website = a } :: S3BucketResource s)

instance P.HasComputedAccelerationStatus (S3BucketResource s) s (TF.Attr s Text) where
    computedAccelerationStatus =
        (_acceleration_status :: S3BucketResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAcl (S3BucketResource s) s (TF.Attr s Text) where
    computedAcl =
        (_acl :: S3BucketResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedArn (S3BucketResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedBucket (S3BucketResource s) s (TF.Attr s Text) where
    computedBucket =
        (_bucket :: S3BucketResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedBucketDomainName (S3BucketResource s) s (TF.Attr s Text) where
    computedBucketDomainName x = TF.compute (TF.refKey x) "bucket_domain_name"

instance P.HasComputedBucketPrefix (S3BucketResource s) s (TF.Attr s Text) where
    computedBucketPrefix =
        (_bucket_prefix :: S3BucketResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCorsRule (S3BucketResource s) s (TF.Attr s Text) where
    computedCorsRule =
        (_cors_rule :: S3BucketResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedForceDestroy (S3BucketResource s) s (TF.Attr s Text) where
    computedForceDestroy =
        (_force_destroy :: S3BucketResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedHostedZoneId (S3BucketResource s) s (TF.Attr s Text) where
    computedHostedZoneId x = TF.compute (TF.refKey x) "hosted_zone_id"

instance P.HasComputedId (S3BucketResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedLifecycleRule (S3BucketResource s) s (TF.Attr s Text) where
    computedLifecycleRule =
        (_lifecycle_rule :: S3BucketResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedLogging (S3BucketResource s) s (TF.Attr s Text) where
    computedLogging =
        (_logging :: S3BucketResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPolicy (S3BucketResource s) s (TF.Attr s Text) where
    computedPolicy =
        (_policy :: S3BucketResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRegion (S3BucketResource s) s (TF.Attr s P.Region) where
    computedRegion x = TF.compute (TF.refKey x) "region"

instance P.HasComputedReplicationConfiguration (S3BucketResource s) s (TF.Attr s Text) where
    computedReplicationConfiguration =
        (_replication_configuration :: S3BucketResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRequestPayer (S3BucketResource s) s (TF.Attr s Text) where
    computedRequestPayer =
        (_request_payer :: S3BucketResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedServerSideEncryptionConfiguration (S3BucketResource s) s (TF.Attr s Text) where
    computedServerSideEncryptionConfiguration =
        (_server_side_encryption_configuration :: S3BucketResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (S3BucketResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: S3BucketResource s -> TF.Attr s P.Tags)
            . TF.refValue

instance P.HasComputedVersioning (S3BucketResource s) s (TF.Attr s (P.S3BucketVersioning s)) where
    computedVersioning =
        (_versioning :: S3BucketResource s -> TF.Attr s (P.S3BucketVersioning s))
            . TF.refValue

instance P.HasComputedWebsite (S3BucketResource s) s (TF.Attr s Text) where
    computedWebsite =
        (_website :: S3BucketResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedWebsiteDomain (S3BucketResource s) s (TF.Attr s Text) where
    computedWebsiteDomain x = TF.compute (TF.refKey x) "website_domain"

instance P.HasComputedWebsiteEndpoint (S3BucketResource s) s (TF.Attr s Text) where
    computedWebsiteEndpoint x = TF.compute (TF.refKey x) "website_endpoint"

s3BucketResource :: TF.Schema TF.Resource P.AWS (S3BucketResource s)
s3BucketResource =
    TF.newResource "aws_s3_bucket" $
        S3BucketResource {
              _acceleration_status = TF.Nil
            , _acl = TF.Nil
            , _bucket = TF.Nil
            , _bucket_prefix = TF.Nil
            , _cors_rule = TF.Nil
            , _force_destroy = TF.Nil
            , _lifecycle_rule = TF.Nil
            , _logging = TF.Nil
            , _policy = TF.Nil
            , _region = TF.Nil
            , _replication_configuration = TF.Nil
            , _request_payer = TF.Nil
            , _server_side_encryption_configuration = TF.Nil
            , _tags = TF.Nil
            , _versioning = TF.Nil
            , _website = TF.Nil
            }

{- | The @aws_security_group@ AWS resource.

Provides a security group resource. ~> NOTE on Security Groups and Security
Group Rules: Terraform currently provides both a standalone
<security_group_rule.html> (a single @ingress@ or @egress@ rule), and a
Security Group resource with @ingress@ and @egress@ rules defined in-line.
At this time you cannot use a Security Group with in-line rules in
conjunction with any Security Group Rule resources. Doing so will cause a
conflict of rule settings and will overwrite rules.
-}
data SecurityGroupResource s = SecurityGroupResource {
      _description            :: !(TF.Attr s Text)
    {- ^ (Optional, Forces new resource) The security group description. Defaults to "Managed by Terraform". Cannot be "". NOTE : This field maps to the AWS @GroupDescription@ attribute, for which there is no Update API. If you'd like to classify your security groups in a way that can be updated, use @tags@ . -}
    , _egress                 :: !(TF.Attr s Text)
    {- ^ (Optional, VPC only) Can be specified multiple times for each egress rule. Each egress block supports fields documented below. -}
    , _ingress                :: !(TF.Attr s Text)
    {- ^ (Optional) Can be specified multiple times for each ingress rule. Each ingress block supports fields documented below. -}
    , _name                   :: !(TF.Attr s Text)
    {- ^ (Optional, Forces new resource) The name of the security group. If omitted, Terraform will assign a random, unique name -}
    , _name_prefix            :: !(TF.Attr s Text)
    {- ^ (Optional, Forces new resource) Creates a unique name beginning with the specified prefix. Conflicts with @name@ . -}
    , _revoke_rules_on_delete :: !(TF.Attr s Text)
    {- ^ (Optional) Instruct Terraform to revoke all of the Security Groups attached ingress and egress rules before deleting the rule itself. This is normally not needed, however certain AWS services such as Elastic Map Reduce may automatically add required rules to security groups used with the service, and those rules may contain a cyclic dependency that prevent the security groups from being destroyed without removing the dependency first. Default @false@ -}
    , _tags                   :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    , _vpc_id                 :: !(TF.Attr s Text)
    {- ^ (Optional, Forces new resource) The VPC ID. -}
    } deriving (Show, Eq)

instance TF.ToHCL (SecurityGroupResource s) where
    toHCL SecurityGroupResource{..} = TF.inline $ catMaybes
        [ TF.assign "description" <$> TF.attribute _description
        , TF.assign "egress" <$> TF.attribute _egress
        , TF.assign "ingress" <$> TF.attribute _ingress
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "name_prefix" <$> TF.attribute _name_prefix
        , TF.assign "revoke_rules_on_delete" <$> TF.attribute _revoke_rules_on_delete
        , TF.assign "tags" <$> TF.attribute _tags
        , TF.assign "vpc_id" <$> TF.attribute _vpc_id
        ]

instance P.HasDescription (SecurityGroupResource s) (TF.Attr s Text) where
    description =
        lens (_description :: SecurityGroupResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: SecurityGroupResource s)

instance P.HasEgress (SecurityGroupResource s) (TF.Attr s Text) where
    egress =
        lens (_egress :: SecurityGroupResource s -> TF.Attr s Text)
             (\s a -> s { _egress = a } :: SecurityGroupResource s)

instance P.HasIngress (SecurityGroupResource s) (TF.Attr s Text) where
    ingress =
        lens (_ingress :: SecurityGroupResource s -> TF.Attr s Text)
             (\s a -> s { _ingress = a } :: SecurityGroupResource s)

instance P.HasName (SecurityGroupResource s) (TF.Attr s Text) where
    name =
        lens (_name :: SecurityGroupResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: SecurityGroupResource s)

instance P.HasNamePrefix (SecurityGroupResource s) (TF.Attr s Text) where
    namePrefix =
        lens (_name_prefix :: SecurityGroupResource s -> TF.Attr s Text)
             (\s a -> s { _name_prefix = a } :: SecurityGroupResource s)

instance P.HasRevokeRulesOnDelete (SecurityGroupResource s) (TF.Attr s Text) where
    revokeRulesOnDelete =
        lens (_revoke_rules_on_delete :: SecurityGroupResource s -> TF.Attr s Text)
             (\s a -> s { _revoke_rules_on_delete = a } :: SecurityGroupResource s)

instance P.HasTags (SecurityGroupResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: SecurityGroupResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: SecurityGroupResource s)

instance P.HasVpcId (SecurityGroupResource s) (TF.Attr s Text) where
    vpcId =
        lens (_vpc_id :: SecurityGroupResource s -> TF.Attr s Text)
             (\s a -> s { _vpc_id = a } :: SecurityGroupResource s)

instance P.HasComputedDescription (SecurityGroupResource s) s (TF.Attr s Text) where
    computedDescription x = TF.compute (TF.refKey x) "description"

instance P.HasComputedEgress (SecurityGroupResource s) s (TF.Attr s Text) where
    computedEgress x = TF.compute (TF.refKey x) "egress"

instance P.HasComputedId (SecurityGroupResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedIngress (SecurityGroupResource s) s (TF.Attr s Text) where
    computedIngress x = TF.compute (TF.refKey x) "ingress"

instance P.HasComputedName (SecurityGroupResource s) s (TF.Attr s Text) where
    computedName x = TF.compute (TF.refKey x) "name"

instance P.HasComputedNamePrefix (SecurityGroupResource s) s (TF.Attr s Text) where
    computedNamePrefix =
        (_name_prefix :: SecurityGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedOwnerId (SecurityGroupResource s) s (TF.Attr s Text) where
    computedOwnerId x = TF.compute (TF.refKey x) "owner_id"

instance P.HasComputedRevokeRulesOnDelete (SecurityGroupResource s) s (TF.Attr s Text) where
    computedRevokeRulesOnDelete =
        (_revoke_rules_on_delete :: SecurityGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (SecurityGroupResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: SecurityGroupResource s -> TF.Attr s P.Tags)
            . TF.refValue

instance P.HasComputedVpcId (SecurityGroupResource s) s (TF.Attr s Text) where
    computedVpcId x = TF.compute (TF.refKey x) "vpc_id"

securityGroupResource :: TF.Schema TF.Resource P.AWS (SecurityGroupResource s)
securityGroupResource =
    TF.newResource "aws_security_group" $
        SecurityGroupResource {
              _description = TF.Nil
            , _egress = TF.Nil
            , _ingress = TF.Nil
            , _name = TF.Nil
            , _name_prefix = TF.Nil
            , _revoke_rules_on_delete = TF.Nil
            , _tags = TF.Nil
            , _vpc_id = TF.Nil
            }

{- | The @aws_security_group_rule@ AWS resource.

Provides a security group rule resource. Represents a single @ingress@ or
@egress@ group rule, which can be added to external Security Groups. ~> NOTE
on Security Groups and Security Group Rules: Terraform currently provides
both a standalone Security Group Rule resource (a single @ingress@ or
@egress@ rule), and a <security_group.html> with @ingress@ and @egress@
rules defined in-line. At this time you cannot use a Security Group with
in-line rules in conjunction with any Security Group Rule resources. Doing
so will cause a conflict of rule settings and will overwrite rules.
-}
data SecurityGroupRuleResource s = SecurityGroupRuleResource {
      _cidr_blocks              :: !(P.Maybe [TF.Attr s P.CIDR])
    {- ^ (Optional) List of CIDR blocks. Cannot be specified with @source_security_group_id@ . -}
    , _description              :: !(TF.Attr s Text)
    {- ^ (Optional) Description of the rule. -}
    , _from_port                :: !(TF.Attr s P.Word16)
    {- ^ (Required) The start port (or ICMP type number if protocol is "icmp"). -}
    , _ipv6_cidr_blocks         :: !(TF.Attr s Text)
    {- ^ (Optional) List of IPv6 CIDR blocks. -}
    , _prefix_list_ids          :: !(TF.Attr s Text)
    {- ^ (Optional) List of prefix list IDs (for allowing access to VPC endpoints). Only valid with @egress@ . -}
    , _protocol                 :: !(TF.Attr s P.Protocol)
    {- ^ (Required) The protocol. If not icmp, tcp, udp, or all use the <https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml> -}
    , _security_group_id        :: !(TF.Attr s Text)
    {- ^ (Required) The security group to apply this rule to. -}
    , _self                     :: !(TF.Attr s Text)
    {- ^ (Optional) If true, the security group itself will be added as a source to this ingress rule. -}
    , _source_security_group_id :: !(TF.Attr s Text)
    {- ^ (Optional) The security group id to allow access to/from, depending on the @type@ . Cannot be specified with @cidr_blocks@ . -}
    , _to_port                  :: !(TF.Attr s P.Word16)
    {- ^ (Required) The end port (or ICMP code if protocol is "icmp"). -}
    , _type'                    :: !(TF.Attr s P.SecurityGroupType)
    {- ^ (Required) The type of rule being created. Valid options are @ingress@ (inbound) or @egress@ (outbound). -}
    } deriving (Show, Eq)

instance TF.ToHCL (SecurityGroupRuleResource s) where
    toHCL SecurityGroupRuleResource{..} = TF.inline $ catMaybes
        [ TF.assign "cidr_blocks" <$> TF.repeated _cidr_blocks
        , TF.assign "description" <$> TF.attribute _description
        , TF.assign "from_port" <$> TF.attribute _from_port
        , TF.assign "ipv6_cidr_blocks" <$> TF.attribute _ipv6_cidr_blocks
        , TF.assign "prefix_list_ids" <$> TF.attribute _prefix_list_ids
        , TF.assign "protocol" <$> TF.attribute _protocol
        , TF.assign "security_group_id" <$> TF.attribute _security_group_id
        , TF.assign "self" <$> TF.attribute _self
        , TF.assign "source_security_group_id" <$> TF.attribute _source_security_group_id
        , TF.assign "to_port" <$> TF.attribute _to_port
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance P.HasCidrBlocks (SecurityGroupRuleResource s) (P.Maybe [TF.Attr s P.CIDR]) where
    cidrBlocks =
        lens (_cidr_blocks :: SecurityGroupRuleResource s -> P.Maybe [TF.Attr s P.CIDR])
             (\s a -> s { _cidr_blocks = a } :: SecurityGroupRuleResource s)

instance P.HasDescription (SecurityGroupRuleResource s) (TF.Attr s Text) where
    description =
        lens (_description :: SecurityGroupRuleResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: SecurityGroupRuleResource s)

instance P.HasFromPort (SecurityGroupRuleResource s) (TF.Attr s P.Word16) where
    fromPort =
        lens (_from_port :: SecurityGroupRuleResource s -> TF.Attr s P.Word16)
             (\s a -> s { _from_port = a } :: SecurityGroupRuleResource s)

instance P.HasIpv6CidrBlocks (SecurityGroupRuleResource s) (TF.Attr s Text) where
    ipv6CidrBlocks =
        lens (_ipv6_cidr_blocks :: SecurityGroupRuleResource s -> TF.Attr s Text)
             (\s a -> s { _ipv6_cidr_blocks = a } :: SecurityGroupRuleResource s)

instance P.HasPrefixListIds (SecurityGroupRuleResource s) (TF.Attr s Text) where
    prefixListIds =
        lens (_prefix_list_ids :: SecurityGroupRuleResource s -> TF.Attr s Text)
             (\s a -> s { _prefix_list_ids = a } :: SecurityGroupRuleResource s)

instance P.HasProtocol (SecurityGroupRuleResource s) (TF.Attr s P.Protocol) where
    protocol =
        lens (_protocol :: SecurityGroupRuleResource s -> TF.Attr s P.Protocol)
             (\s a -> s { _protocol = a } :: SecurityGroupRuleResource s)

instance P.HasSecurityGroupId (SecurityGroupRuleResource s) (TF.Attr s Text) where
    securityGroupId =
        lens (_security_group_id :: SecurityGroupRuleResource s -> TF.Attr s Text)
             (\s a -> s { _security_group_id = a } :: SecurityGroupRuleResource s)

instance P.HasSelf (SecurityGroupRuleResource s) (TF.Attr s Text) where
    self =
        lens (_self :: SecurityGroupRuleResource s -> TF.Attr s Text)
             (\s a -> s { _self = a } :: SecurityGroupRuleResource s)

instance P.HasSourceSecurityGroupId (SecurityGroupRuleResource s) (TF.Attr s Text) where
    sourceSecurityGroupId =
        lens (_source_security_group_id :: SecurityGroupRuleResource s -> TF.Attr s Text)
             (\s a -> s { _source_security_group_id = a } :: SecurityGroupRuleResource s)

instance P.HasToPort (SecurityGroupRuleResource s) (TF.Attr s P.Word16) where
    toPort =
        lens (_to_port :: SecurityGroupRuleResource s -> TF.Attr s P.Word16)
             (\s a -> s { _to_port = a } :: SecurityGroupRuleResource s)

instance P.HasType' (SecurityGroupRuleResource s) (TF.Attr s P.SecurityGroupType) where
    type' =
        lens (_type' :: SecurityGroupRuleResource s -> TF.Attr s P.SecurityGroupType)
             (\s a -> s { _type' = a } :: SecurityGroupRuleResource s)

instance P.HasComputedCidrBlocks (SecurityGroupRuleResource s) s (P.Maybe [TF.Attr s P.CIDR]) where
    computedCidrBlocks =
        (_cidr_blocks :: SecurityGroupRuleResource s -> P.Maybe [TF.Attr s P.CIDR])
            . TF.refValue

instance P.HasComputedDescription (SecurityGroupRuleResource s) s (TF.Attr s Text) where
    computedDescription x = TF.compute (TF.refKey x) "description"

instance P.HasComputedFromPort (SecurityGroupRuleResource s) s (TF.Attr s P.Word16) where
    computedFromPort x = TF.compute (TF.refKey x) "from_port"

instance P.HasComputedId (SecurityGroupRuleResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedIpv6CidrBlocks (SecurityGroupRuleResource s) s (TF.Attr s Text) where
    computedIpv6CidrBlocks =
        (_ipv6_cidr_blocks :: SecurityGroupRuleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPrefixListIds (SecurityGroupRuleResource s) s (TF.Attr s Text) where
    computedPrefixListIds =
        (_prefix_list_ids :: SecurityGroupRuleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedProtocol (SecurityGroupRuleResource s) s (TF.Attr s Text) where
    computedProtocol x = TF.compute (TF.refKey x) "protocol"

instance P.HasComputedSecurityGroupId (SecurityGroupRuleResource s) s (TF.Attr s Text) where
    computedSecurityGroupId =
        (_security_group_id :: SecurityGroupRuleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSelf (SecurityGroupRuleResource s) s (TF.Attr s Text) where
    computedSelf =
        (_self :: SecurityGroupRuleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSourceSecurityGroupId (SecurityGroupRuleResource s) s (TF.Attr s Text) where
    computedSourceSecurityGroupId =
        (_source_security_group_id :: SecurityGroupRuleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedToPort (SecurityGroupRuleResource s) s (TF.Attr s P.Word16) where
    computedToPort x = TF.compute (TF.refKey x) "to_port"

instance P.HasComputedType' (SecurityGroupRuleResource s) s (TF.Attr s Text) where
    computedType' x = TF.compute (TF.refKey x) "type"

securityGroupRuleResource :: TF.Schema TF.Resource P.AWS (SecurityGroupRuleResource s)
securityGroupRuleResource =
    TF.newResource "aws_security_group_rule" $
        SecurityGroupRuleResource {
              _cidr_blocks = P.Nothing
            , _description = TF.Nil
            , _from_port = TF.Nil
            , _ipv6_cidr_blocks = TF.Nil
            , _prefix_list_ids = TF.Nil
            , _protocol = TF.Nil
            , _security_group_id = TF.Nil
            , _self = TF.Nil
            , _source_security_group_id = TF.Nil
            , _to_port = TF.Nil
            , _type' = TF.Nil
            }

{- | The @aws_service_discovery_private_dns_namespace@ AWS resource.

Provides a Service Discovery Private DNS Namespace resource.
-}
data ServiceDiscoveryPrivateDnsNamespaceResource s = ServiceDiscoveryPrivateDnsNamespaceResource {
      _description :: !(TF.Attr s Text)
    {- ^ (Optional) The description that you specify for the namespace when you create it. -}
    , _name        :: !(TF.Attr s Text)
    {- ^ (Required) The name of the namespace. -}
    , _vpc         :: !(TF.Attr s Text)
    {- ^ (Required) The ID of VPC that you want to associate the namespace with. -}
    } deriving (Show, Eq)

instance TF.ToHCL (ServiceDiscoveryPrivateDnsNamespaceResource s) where
    toHCL ServiceDiscoveryPrivateDnsNamespaceResource{..} = TF.inline $ catMaybes
        [ TF.assign "description" <$> TF.attribute _description
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "vpc" <$> TF.attribute _vpc
        ]

instance P.HasDescription (ServiceDiscoveryPrivateDnsNamespaceResource s) (TF.Attr s Text) where
    description =
        lens (_description :: ServiceDiscoveryPrivateDnsNamespaceResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: ServiceDiscoveryPrivateDnsNamespaceResource s)

instance P.HasName (ServiceDiscoveryPrivateDnsNamespaceResource s) (TF.Attr s Text) where
    name =
        lens (_name :: ServiceDiscoveryPrivateDnsNamespaceResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: ServiceDiscoveryPrivateDnsNamespaceResource s)

instance P.HasVpc (ServiceDiscoveryPrivateDnsNamespaceResource s) (TF.Attr s Text) where
    vpc =
        lens (_vpc :: ServiceDiscoveryPrivateDnsNamespaceResource s -> TF.Attr s Text)
             (\s a -> s { _vpc = a } :: ServiceDiscoveryPrivateDnsNamespaceResource s)

instance P.HasComputedArn (ServiceDiscoveryPrivateDnsNamespaceResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedDescription (ServiceDiscoveryPrivateDnsNamespaceResource s) s (TF.Attr s Text) where
    computedDescription =
        (_description :: ServiceDiscoveryPrivateDnsNamespaceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedHostedZone (ServiceDiscoveryPrivateDnsNamespaceResource s) s (TF.Attr s Text) where
    computedHostedZone x = TF.compute (TF.refKey x) "hosted_zone"

instance P.HasComputedId (ServiceDiscoveryPrivateDnsNamespaceResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (ServiceDiscoveryPrivateDnsNamespaceResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: ServiceDiscoveryPrivateDnsNamespaceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedVpc (ServiceDiscoveryPrivateDnsNamespaceResource s) s (TF.Attr s Text) where
    computedVpc =
        (_vpc :: ServiceDiscoveryPrivateDnsNamespaceResource s -> TF.Attr s Text)
            . TF.refValue

serviceDiscoveryPrivateDnsNamespaceResource :: TF.Schema TF.Resource P.AWS (ServiceDiscoveryPrivateDnsNamespaceResource s)
serviceDiscoveryPrivateDnsNamespaceResource =
    TF.newResource "aws_service_discovery_private_dns_namespace" $
        ServiceDiscoveryPrivateDnsNamespaceResource {
              _description = TF.Nil
            , _name = TF.Nil
            , _vpc = TF.Nil
            }

{- | The @aws_service_discovery_public_dns_namespace@ AWS resource.

Provides a Service Discovery Public DNS Namespace resource.
-}
data ServiceDiscoveryPublicDnsNamespaceResource s = ServiceDiscoveryPublicDnsNamespaceResource {
      _description :: !(TF.Attr s Text)
    {- ^ (Optional) The description that you specify for the namespace when you create it. -}
    , _name        :: !(TF.Attr s Text)
    {- ^ (Required) The name of the namespace. -}
    } deriving (Show, Eq)

instance TF.ToHCL (ServiceDiscoveryPublicDnsNamespaceResource s) where
    toHCL ServiceDiscoveryPublicDnsNamespaceResource{..} = TF.inline $ catMaybes
        [ TF.assign "description" <$> TF.attribute _description
        , TF.assign "name" <$> TF.attribute _name
        ]

instance P.HasDescription (ServiceDiscoveryPublicDnsNamespaceResource s) (TF.Attr s Text) where
    description =
        lens (_description :: ServiceDiscoveryPublicDnsNamespaceResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: ServiceDiscoveryPublicDnsNamespaceResource s)

instance P.HasName (ServiceDiscoveryPublicDnsNamespaceResource s) (TF.Attr s Text) where
    name =
        lens (_name :: ServiceDiscoveryPublicDnsNamespaceResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: ServiceDiscoveryPublicDnsNamespaceResource s)

instance P.HasComputedArn (ServiceDiscoveryPublicDnsNamespaceResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedDescription (ServiceDiscoveryPublicDnsNamespaceResource s) s (TF.Attr s Text) where
    computedDescription =
        (_description :: ServiceDiscoveryPublicDnsNamespaceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedHostedZone (ServiceDiscoveryPublicDnsNamespaceResource s) s (TF.Attr s Text) where
    computedHostedZone x = TF.compute (TF.refKey x) "hosted_zone"

instance P.HasComputedId (ServiceDiscoveryPublicDnsNamespaceResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (ServiceDiscoveryPublicDnsNamespaceResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: ServiceDiscoveryPublicDnsNamespaceResource s -> TF.Attr s Text)
            . TF.refValue

serviceDiscoveryPublicDnsNamespaceResource :: TF.Schema TF.Resource P.AWS (ServiceDiscoveryPublicDnsNamespaceResource s)
serviceDiscoveryPublicDnsNamespaceResource =
    TF.newResource "aws_service_discovery_public_dns_namespace" $
        ServiceDiscoveryPublicDnsNamespaceResource {
              _description = TF.Nil
            , _name = TF.Nil
            }

{- | The @aws_service_discovery_service@ AWS resource.

Provides a Service Discovery Service resource.
-}
data ServiceDiscoveryServiceResource s = ServiceDiscoveryServiceResource {
      _description         :: !(TF.Attr s Text)
    {- ^ (Optional) The description of the service. -}
    , _dns_config          :: !(TF.Attr s Text)
    {- ^ (Required) A complex type that contains information about the resource record sets that you want Amazon Route 53 to create when you register an instance. -}
    , _health_check_config :: !(TF.Attr s Text)
    {- ^ (Optional) A complex type that contains settings for an optional health check. Only for Public DNS namespaces. -}
    , _name                :: !(TF.Attr s Text)
    {- ^ (Required, ForceNew) The name of the service. -}
    } deriving (Show, Eq)

instance TF.ToHCL (ServiceDiscoveryServiceResource s) where
    toHCL ServiceDiscoveryServiceResource{..} = TF.inline $ catMaybes
        [ TF.assign "description" <$> TF.attribute _description
        , TF.assign "dns_config" <$> TF.attribute _dns_config
        , TF.assign "health_check_config" <$> TF.attribute _health_check_config
        , TF.assign "name" <$> TF.attribute _name
        ]

instance P.HasDescription (ServiceDiscoveryServiceResource s) (TF.Attr s Text) where
    description =
        lens (_description :: ServiceDiscoveryServiceResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: ServiceDiscoveryServiceResource s)

instance P.HasDnsConfig (ServiceDiscoveryServiceResource s) (TF.Attr s Text) where
    dnsConfig =
        lens (_dns_config :: ServiceDiscoveryServiceResource s -> TF.Attr s Text)
             (\s a -> s { _dns_config = a } :: ServiceDiscoveryServiceResource s)

instance P.HasHealthCheckConfig (ServiceDiscoveryServiceResource s) (TF.Attr s Text) where
    healthCheckConfig =
        lens (_health_check_config :: ServiceDiscoveryServiceResource s -> TF.Attr s Text)
             (\s a -> s { _health_check_config = a } :: ServiceDiscoveryServiceResource s)

instance P.HasName (ServiceDiscoveryServiceResource s) (TF.Attr s Text) where
    name =
        lens (_name :: ServiceDiscoveryServiceResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: ServiceDiscoveryServiceResource s)

instance P.HasComputedArn (ServiceDiscoveryServiceResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedDescription (ServiceDiscoveryServiceResource s) s (TF.Attr s Text) where
    computedDescription =
        (_description :: ServiceDiscoveryServiceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDnsConfig (ServiceDiscoveryServiceResource s) s (TF.Attr s Text) where
    computedDnsConfig =
        (_dns_config :: ServiceDiscoveryServiceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedHealthCheckConfig (ServiceDiscoveryServiceResource s) s (TF.Attr s Text) where
    computedHealthCheckConfig =
        (_health_check_config :: ServiceDiscoveryServiceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (ServiceDiscoveryServiceResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (ServiceDiscoveryServiceResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: ServiceDiscoveryServiceResource s -> TF.Attr s Text)
            . TF.refValue

serviceDiscoveryServiceResource :: TF.Schema TF.Resource P.AWS (ServiceDiscoveryServiceResource s)
serviceDiscoveryServiceResource =
    TF.newResource "aws_service_discovery_service" $
        ServiceDiscoveryServiceResource {
              _description = TF.Nil
            , _dns_config = TF.Nil
            , _health_check_config = TF.Nil
            , _name = TF.Nil
            }

{- | The @aws_servicecatalog_portfolio@ AWS resource.

Provides a resource to create a Service Catalog Portfolio.
-}
data ServicecatalogPortfolioResource s = ServicecatalogPortfolioResource {
      _description   :: !(TF.Attr s Text)
    {- ^ (Required) Description of the portfolio -}
    , _name          :: !(TF.Attr s Text)
    {- ^ (Required) The name of the portfolio. -}
    , _provider_name :: !(TF.Attr s Text)
    {- ^ (Required) Name of the person or organization who owns the portfolio. -}
    , _tags          :: !(TF.Attr s P.Tags)
    {- ^ (Optional) Tags to apply to the connection. -}
    } deriving (Show, Eq)

instance TF.ToHCL (ServicecatalogPortfolioResource s) where
    toHCL ServicecatalogPortfolioResource{..} = TF.inline $ catMaybes
        [ TF.assign "description" <$> TF.attribute _description
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "provider_name" <$> TF.attribute _provider_name
        , TF.assign "tags" <$> TF.attribute _tags
        ]

instance P.HasDescription (ServicecatalogPortfolioResource s) (TF.Attr s Text) where
    description =
        lens (_description :: ServicecatalogPortfolioResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: ServicecatalogPortfolioResource s)

instance P.HasName (ServicecatalogPortfolioResource s) (TF.Attr s Text) where
    name =
        lens (_name :: ServicecatalogPortfolioResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: ServicecatalogPortfolioResource s)

instance P.HasProviderName (ServicecatalogPortfolioResource s) (TF.Attr s Text) where
    providerName =
        lens (_provider_name :: ServicecatalogPortfolioResource s -> TF.Attr s Text)
             (\s a -> s { _provider_name = a } :: ServicecatalogPortfolioResource s)

instance P.HasTags (ServicecatalogPortfolioResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: ServicecatalogPortfolioResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: ServicecatalogPortfolioResource s)

instance P.HasComputedDescription (ServicecatalogPortfolioResource s) s (TF.Attr s Text) where
    computedDescription =
        (_description :: ServicecatalogPortfolioResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (ServicecatalogPortfolioResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (ServicecatalogPortfolioResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: ServicecatalogPortfolioResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedProviderName (ServicecatalogPortfolioResource s) s (TF.Attr s Text) where
    computedProviderName =
        (_provider_name :: ServicecatalogPortfolioResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (ServicecatalogPortfolioResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: ServicecatalogPortfolioResource s -> TF.Attr s P.Tags)
            . TF.refValue

servicecatalogPortfolioResource :: TF.Schema TF.Resource P.AWS (ServicecatalogPortfolioResource s)
servicecatalogPortfolioResource =
    TF.newResource "aws_servicecatalog_portfolio" $
        ServicecatalogPortfolioResource {
              _description = TF.Nil
            , _name = TF.Nil
            , _provider_name = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_ses_active_receipt_rule_set@ AWS resource.

Provides a resource to designate the active SES receipt rule set
-}
data SesActiveReceiptRuleSetResource s = SesActiveReceiptRuleSetResource {
      _rule_set_name :: !(TF.Attr s Text)
    {- ^ (Required) The name of the rule set -}
    } deriving (Show, Eq)

instance TF.ToHCL (SesActiveReceiptRuleSetResource s) where
    toHCL SesActiveReceiptRuleSetResource{..} = TF.inline $ catMaybes
        [ TF.assign "rule_set_name" <$> TF.attribute _rule_set_name
        ]

instance P.HasRuleSetName (SesActiveReceiptRuleSetResource s) (TF.Attr s Text) where
    ruleSetName =
        lens (_rule_set_name :: SesActiveReceiptRuleSetResource s -> TF.Attr s Text)
             (\s a -> s { _rule_set_name = a } :: SesActiveReceiptRuleSetResource s)

instance P.HasComputedRuleSetName (SesActiveReceiptRuleSetResource s) s (TF.Attr s Text) where
    computedRuleSetName =
        (_rule_set_name :: SesActiveReceiptRuleSetResource s -> TF.Attr s Text)
            . TF.refValue

sesActiveReceiptRuleSetResource :: TF.Schema TF.Resource P.AWS (SesActiveReceiptRuleSetResource s)
sesActiveReceiptRuleSetResource =
    TF.newResource "aws_ses_active_receipt_rule_set" $
        SesActiveReceiptRuleSetResource {
              _rule_set_name = TF.Nil
            }

{- | The @aws_ses_configuration_set@ AWS resource.

Provides an SES configuration set resource
-}
data SesConfigurationSetResource s = SesConfigurationSetResource {
      _name :: !(TF.Attr s Text)
    {- ^ (Required) The name of the configuration set -}
    } deriving (Show, Eq)

instance TF.ToHCL (SesConfigurationSetResource s) where
    toHCL SesConfigurationSetResource{..} = TF.inline $ catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        ]

instance P.HasName (SesConfigurationSetResource s) (TF.Attr s Text) where
    name =
        lens (_name :: SesConfigurationSetResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: SesConfigurationSetResource s)

instance P.HasComputedName (SesConfigurationSetResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: SesConfigurationSetResource s -> TF.Attr s Text)
            . TF.refValue

sesConfigurationSetResource :: TF.Schema TF.Resource P.AWS (SesConfigurationSetResource s)
sesConfigurationSetResource =
    TF.newResource "aws_ses_configuration_set" $
        SesConfigurationSetResource {
              _name = TF.Nil
            }

{- | The @aws_ses_domain_dkim@ AWS resource.

Provides an SES domain DKIM generation resource. Domain ownership needs to
be confirmed first using </docs/providers/aws/r/ses_domain_identity.html>
-}
data SesDomainDkimResource s = SesDomainDkimResource {
      _domain :: !(TF.Attr s Text)
    {- ^ (Required) Verified domain name to generate DKIM tokens for. -}
    } deriving (Show, Eq)

instance TF.ToHCL (SesDomainDkimResource s) where
    toHCL SesDomainDkimResource{..} = TF.inline $ catMaybes
        [ TF.assign "domain" <$> TF.attribute _domain
        ]

instance P.HasDomain (SesDomainDkimResource s) (TF.Attr s Text) where
    domain =
        lens (_domain :: SesDomainDkimResource s -> TF.Attr s Text)
             (\s a -> s { _domain = a } :: SesDomainDkimResource s)

instance P.HasComputedDkimTokens (SesDomainDkimResource s) s (TF.Attr s Text) where
    computedDkimTokens x = TF.compute (TF.refKey x) "dkim_tokens"

instance P.HasComputedDomain (SesDomainDkimResource s) s (TF.Attr s Text) where
    computedDomain =
        (_domain :: SesDomainDkimResource s -> TF.Attr s Text)
            . TF.refValue

sesDomainDkimResource :: TF.Schema TF.Resource P.AWS (SesDomainDkimResource s)
sesDomainDkimResource =
    TF.newResource "aws_ses_domain_dkim" $
        SesDomainDkimResource {
              _domain = TF.Nil
            }

{- | The @aws_ses_domain_identity@ AWS resource.

Provides an SES domain identity resource
-}
data SesDomainIdentityResource s = SesDomainIdentityResource {
      _domain :: !(TF.Attr s Text)
    {- ^ (Required) The domain name to assign to SES -}
    } deriving (Show, Eq)

instance TF.ToHCL (SesDomainIdentityResource s) where
    toHCL SesDomainIdentityResource{..} = TF.inline $ catMaybes
        [ TF.assign "domain" <$> TF.attribute _domain
        ]

instance P.HasDomain (SesDomainIdentityResource s) (TF.Attr s Text) where
    domain =
        lens (_domain :: SesDomainIdentityResource s -> TF.Attr s Text)
             (\s a -> s { _domain = a } :: SesDomainIdentityResource s)

instance P.HasComputedArn (SesDomainIdentityResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedDomain (SesDomainIdentityResource s) s (TF.Attr s Text) where
    computedDomain =
        (_domain :: SesDomainIdentityResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedVerificationToken (SesDomainIdentityResource s) s (TF.Attr s Text) where
    computedVerificationToken x = TF.compute (TF.refKey x) "verification_token"

sesDomainIdentityResource :: TF.Schema TF.Resource P.AWS (SesDomainIdentityResource s)
sesDomainIdentityResource =
    TF.newResource "aws_ses_domain_identity" $
        SesDomainIdentityResource {
              _domain = TF.Nil
            }

{- | The @aws_ses_domain_mail_from@ AWS resource.

Provides an SES domain MAIL FROM resource. ~> NOTE: For the MAIL FROM domain
to be fully usable, this resource should be paired with the
</docs/providers/aws/r/ses_domain_identity.html> . To validate the MAIL FROM
domain, a DNS MX record is required. To pass SPF checks, a DNS TXT record
may also be required. See the
<https://docs.aws.amazon.com/ses/latest/DeveloperGuide/mail-from-set.html>
for more information.
-}
data SesDomainMailFromResource s = SesDomainMailFromResource {
      _domain           :: !(TF.Attr s Text)
    {- ^ (Required) Verified domain name to generate DKIM tokens for. -}
    , _mail_from_domain :: !(TF.Attr s Text)
    {- ^ (Required) Subdomain (of above domain) which is to be used as MAIL FROM address (Required for DMARC validation) -}
    } deriving (Show, Eq)

instance TF.ToHCL (SesDomainMailFromResource s) where
    toHCL SesDomainMailFromResource{..} = TF.inline $ catMaybes
        [ TF.assign "domain" <$> TF.attribute _domain
        , TF.assign "mail_from_domain" <$> TF.attribute _mail_from_domain
        ]

instance P.HasDomain (SesDomainMailFromResource s) (TF.Attr s Text) where
    domain =
        lens (_domain :: SesDomainMailFromResource s -> TF.Attr s Text)
             (\s a -> s { _domain = a } :: SesDomainMailFromResource s)

instance P.HasMailFromDomain (SesDomainMailFromResource s) (TF.Attr s Text) where
    mailFromDomain =
        lens (_mail_from_domain :: SesDomainMailFromResource s -> TF.Attr s Text)
             (\s a -> s { _mail_from_domain = a } :: SesDomainMailFromResource s)

instance P.HasComputedDomain (SesDomainMailFromResource s) s (TF.Attr s Text) where
    computedDomain =
        (_domain :: SesDomainMailFromResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (SesDomainMailFromResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedMailFromDomain (SesDomainMailFromResource s) s (TF.Attr s Text) where
    computedMailFromDomain =
        (_mail_from_domain :: SesDomainMailFromResource s -> TF.Attr s Text)
            . TF.refValue

sesDomainMailFromResource :: TF.Schema TF.Resource P.AWS (SesDomainMailFromResource s)
sesDomainMailFromResource =
    TF.newResource "aws_ses_domain_mail_from" $
        SesDomainMailFromResource {
              _domain = TF.Nil
            , _mail_from_domain = TF.Nil
            }

{- | The @aws_ses_event_destination@ AWS resource.

Provides an SES event destination
-}
data SesEventDestinationResource s = SesEventDestinationResource {
      _cloudwatch_destination :: !(TF.Attr s Text)
    {- ^ (Optional) CloudWatch destination for the events -}
    , _configuration_set_name :: !(TF.Attr s Text)
    {- ^ (Required) The name of the configuration set -}
    , _enabled                :: !(TF.Attr s P.Bool)
    {- ^ (Optional) If true, the event destination will be enabled -}
    , _kinesis_destination    :: !(TF.Attr s Text)
    {- ^ (Optional) Send the events to a kinesis firehose destination -}
    , _matching_types         :: !(TF.Attr s Text)
    {- ^ (Required) A list of matching types. May be any of @"send"@ , @"reject"@ , @"bounce"@ , @"complaint"@ , @"delivery"@ , @"open"@ , or @"click"@ . -}
    , _name                   :: !(TF.Attr s Text)
    {- ^ (Required) The name of the event destination -}
    , _sns_destination        :: !(TF.Attr s Text)
    {- ^ (Optional) Send the events to an SNS Topic destination -}
    } deriving (Show, Eq)

instance TF.ToHCL (SesEventDestinationResource s) where
    toHCL SesEventDestinationResource{..} = TF.inline $ catMaybes
        [ TF.assign "cloudwatch_destination" <$> TF.attribute _cloudwatch_destination
        , TF.assign "configuration_set_name" <$> TF.attribute _configuration_set_name
        , TF.assign "enabled" <$> TF.attribute _enabled
        , TF.assign "kinesis_destination" <$> TF.attribute _kinesis_destination
        , TF.assign "matching_types" <$> TF.attribute _matching_types
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "sns_destination" <$> TF.attribute _sns_destination
        ]

instance P.HasCloudwatchDestination (SesEventDestinationResource s) (TF.Attr s Text) where
    cloudwatchDestination =
        lens (_cloudwatch_destination :: SesEventDestinationResource s -> TF.Attr s Text)
             (\s a -> s { _cloudwatch_destination = a } :: SesEventDestinationResource s)

instance P.HasConfigurationSetName (SesEventDestinationResource s) (TF.Attr s Text) where
    configurationSetName =
        lens (_configuration_set_name :: SesEventDestinationResource s -> TF.Attr s Text)
             (\s a -> s { _configuration_set_name = a } :: SesEventDestinationResource s)

instance P.HasEnabled (SesEventDestinationResource s) (TF.Attr s P.Bool) where
    enabled =
        lens (_enabled :: SesEventDestinationResource s -> TF.Attr s P.Bool)
             (\s a -> s { _enabled = a } :: SesEventDestinationResource s)

instance P.HasKinesisDestination (SesEventDestinationResource s) (TF.Attr s Text) where
    kinesisDestination =
        lens (_kinesis_destination :: SesEventDestinationResource s -> TF.Attr s Text)
             (\s a -> s { _kinesis_destination = a } :: SesEventDestinationResource s)

instance P.HasMatchingTypes (SesEventDestinationResource s) (TF.Attr s Text) where
    matchingTypes =
        lens (_matching_types :: SesEventDestinationResource s -> TF.Attr s Text)
             (\s a -> s { _matching_types = a } :: SesEventDestinationResource s)

instance P.HasName (SesEventDestinationResource s) (TF.Attr s Text) where
    name =
        lens (_name :: SesEventDestinationResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: SesEventDestinationResource s)

instance P.HasSnsDestination (SesEventDestinationResource s) (TF.Attr s Text) where
    snsDestination =
        lens (_sns_destination :: SesEventDestinationResource s -> TF.Attr s Text)
             (\s a -> s { _sns_destination = a } :: SesEventDestinationResource s)

instance P.HasComputedCloudwatchDestination (SesEventDestinationResource s) s (TF.Attr s Text) where
    computedCloudwatchDestination =
        (_cloudwatch_destination :: SesEventDestinationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedConfigurationSetName (SesEventDestinationResource s) s (TF.Attr s Text) where
    computedConfigurationSetName =
        (_configuration_set_name :: SesEventDestinationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEnabled (SesEventDestinationResource s) s (TF.Attr s P.Bool) where
    computedEnabled =
        (_enabled :: SesEventDestinationResource s -> TF.Attr s P.Bool)
            . TF.refValue

instance P.HasComputedKinesisDestination (SesEventDestinationResource s) s (TF.Attr s Text) where
    computedKinesisDestination =
        (_kinesis_destination :: SesEventDestinationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedMatchingTypes (SesEventDestinationResource s) s (TF.Attr s Text) where
    computedMatchingTypes =
        (_matching_types :: SesEventDestinationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (SesEventDestinationResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: SesEventDestinationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSnsDestination (SesEventDestinationResource s) s (TF.Attr s Text) where
    computedSnsDestination =
        (_sns_destination :: SesEventDestinationResource s -> TF.Attr s Text)
            . TF.refValue

sesEventDestinationResource :: TF.Schema TF.Resource P.AWS (SesEventDestinationResource s)
sesEventDestinationResource =
    TF.newResource "aws_ses_event_destination" $
        SesEventDestinationResource {
              _cloudwatch_destination = TF.Nil
            , _configuration_set_name = TF.Nil
            , _enabled = TF.Nil
            , _kinesis_destination = TF.Nil
            , _matching_types = TF.Nil
            , _name = TF.Nil
            , _sns_destination = TF.Nil
            }

{- | The @aws_ses_receipt_filter@ AWS resource.

Provides an SES receipt filter resource
-}
data SesReceiptFilterResource s = SesReceiptFilterResource {
      _cidr   :: !(TF.Attr s Text)
    {- ^ (Required) The IP address or address range to filter, in CIDR notation -}
    , _name   :: !(TF.Attr s Text)
    {- ^ (Required) The name of the filter -}
    , _policy :: !(TF.Attr s Text)
    {- ^ (Required) Block or Allow -}
    } deriving (Show, Eq)

instance TF.ToHCL (SesReceiptFilterResource s) where
    toHCL SesReceiptFilterResource{..} = TF.inline $ catMaybes
        [ TF.assign "cidr" <$> TF.attribute _cidr
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "policy" <$> TF.attribute _policy
        ]

instance P.HasCidr (SesReceiptFilterResource s) (TF.Attr s Text) where
    cidr =
        lens (_cidr :: SesReceiptFilterResource s -> TF.Attr s Text)
             (\s a -> s { _cidr = a } :: SesReceiptFilterResource s)

instance P.HasName (SesReceiptFilterResource s) (TF.Attr s Text) where
    name =
        lens (_name :: SesReceiptFilterResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: SesReceiptFilterResource s)

instance P.HasPolicy (SesReceiptFilterResource s) (TF.Attr s Text) where
    policy =
        lens (_policy :: SesReceiptFilterResource s -> TF.Attr s Text)
             (\s a -> s { _policy = a } :: SesReceiptFilterResource s)

instance P.HasComputedCidr (SesReceiptFilterResource s) s (TF.Attr s Text) where
    computedCidr =
        (_cidr :: SesReceiptFilterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (SesReceiptFilterResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: SesReceiptFilterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPolicy (SesReceiptFilterResource s) s (TF.Attr s Text) where
    computedPolicy =
        (_policy :: SesReceiptFilterResource s -> TF.Attr s Text)
            . TF.refValue

sesReceiptFilterResource :: TF.Schema TF.Resource P.AWS (SesReceiptFilterResource s)
sesReceiptFilterResource =
    TF.newResource "aws_ses_receipt_filter" $
        SesReceiptFilterResource {
              _cidr = TF.Nil
            , _name = TF.Nil
            , _policy = TF.Nil
            }

{- | The @aws_ses_receipt_rule@ AWS resource.

Provides an SES receipt rule resource
-}
data SesReceiptRuleResource s = SesReceiptRuleResource {
      _add_header_action :: !(TF.Attr s Text)
    {- ^ (Optional) A list of Add Header Action blocks. Documented below. -}
    , _after             :: !(TF.Attr s Text)
    {- ^ (Optional) The name of the rule to place this rule after -}
    , _bounce_action     :: !(TF.Attr s Text)
    {- ^ (Optional) A list of Bounce Action blocks. Documented below. -}
    , _enabled           :: !(TF.Attr s P.Bool)
    {- ^ (Optional) If true, the rule will be enabled -}
    , _lambda_action     :: !(TF.Attr s Text)
    {- ^ (Optional) A list of Lambda Action blocks. Documented below. -}
    , _name              :: !(TF.Attr s Text)
    {- ^ (Required) The name of the rule -}
    , _recipients        :: !(TF.Attr s Text)
    {- ^ (Optional) A list of email addresses -}
    , _rule_set_name     :: !(TF.Attr s Text)
    {- ^ (Required) The name of the rule set -}
    , _s3_action         :: !(TF.Attr s Text)
    {- ^ (Optional) A list of S3 Action blocks. Documented below. -}
    , _scan_enabled      :: !(TF.Attr s P.Bool)
    {- ^ (Optional) If true, incoming emails will be scanned for spam and viruses -}
    , _sns_action        :: !(TF.Attr s Text)
    {- ^ (Optional) A list of SNS Action blocks. Documented below. -}
    , _stop_action       :: !(TF.Attr s Text)
    {- ^ (Optional) A list of Stop Action blocks. Documented below. -}
    , _tls_policy        :: !(TF.Attr s Text)
    {- ^ (Optional) Require or Optional -}
    , _workmail_action   :: !(TF.Attr s Text)
    {- ^ (Optional) A list of WorkMail Action blocks. Documented below. -}
    } deriving (Show, Eq)

instance TF.ToHCL (SesReceiptRuleResource s) where
    toHCL SesReceiptRuleResource{..} = TF.inline $ catMaybes
        [ TF.assign "add_header_action" <$> TF.attribute _add_header_action
        , TF.assign "after" <$> TF.attribute _after
        , TF.assign "bounce_action" <$> TF.attribute _bounce_action
        , TF.assign "enabled" <$> TF.attribute _enabled
        , TF.assign "lambda_action" <$> TF.attribute _lambda_action
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "recipients" <$> TF.attribute _recipients
        , TF.assign "rule_set_name" <$> TF.attribute _rule_set_name
        , TF.assign "s3_action" <$> TF.attribute _s3_action
        , TF.assign "scan_enabled" <$> TF.attribute _scan_enabled
        , TF.assign "sns_action" <$> TF.attribute _sns_action
        , TF.assign "stop_action" <$> TF.attribute _stop_action
        , TF.assign "tls_policy" <$> TF.attribute _tls_policy
        , TF.assign "workmail_action" <$> TF.attribute _workmail_action
        ]

instance P.HasAddHeaderAction (SesReceiptRuleResource s) (TF.Attr s Text) where
    addHeaderAction =
        lens (_add_header_action :: SesReceiptRuleResource s -> TF.Attr s Text)
             (\s a -> s { _add_header_action = a } :: SesReceiptRuleResource s)

instance P.HasAfter (SesReceiptRuleResource s) (TF.Attr s Text) where
    after =
        lens (_after :: SesReceiptRuleResource s -> TF.Attr s Text)
             (\s a -> s { _after = a } :: SesReceiptRuleResource s)

instance P.HasBounceAction (SesReceiptRuleResource s) (TF.Attr s Text) where
    bounceAction =
        lens (_bounce_action :: SesReceiptRuleResource s -> TF.Attr s Text)
             (\s a -> s { _bounce_action = a } :: SesReceiptRuleResource s)

instance P.HasEnabled (SesReceiptRuleResource s) (TF.Attr s P.Bool) where
    enabled =
        lens (_enabled :: SesReceiptRuleResource s -> TF.Attr s P.Bool)
             (\s a -> s { _enabled = a } :: SesReceiptRuleResource s)

instance P.HasLambdaAction (SesReceiptRuleResource s) (TF.Attr s Text) where
    lambdaAction =
        lens (_lambda_action :: SesReceiptRuleResource s -> TF.Attr s Text)
             (\s a -> s { _lambda_action = a } :: SesReceiptRuleResource s)

instance P.HasName (SesReceiptRuleResource s) (TF.Attr s Text) where
    name =
        lens (_name :: SesReceiptRuleResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: SesReceiptRuleResource s)

instance P.HasRecipients (SesReceiptRuleResource s) (TF.Attr s Text) where
    recipients =
        lens (_recipients :: SesReceiptRuleResource s -> TF.Attr s Text)
             (\s a -> s { _recipients = a } :: SesReceiptRuleResource s)

instance P.HasRuleSetName (SesReceiptRuleResource s) (TF.Attr s Text) where
    ruleSetName =
        lens (_rule_set_name :: SesReceiptRuleResource s -> TF.Attr s Text)
             (\s a -> s { _rule_set_name = a } :: SesReceiptRuleResource s)

instance P.HasS3Action (SesReceiptRuleResource s) (TF.Attr s Text) where
    s3Action =
        lens (_s3_action :: SesReceiptRuleResource s -> TF.Attr s Text)
             (\s a -> s { _s3_action = a } :: SesReceiptRuleResource s)

instance P.HasScanEnabled (SesReceiptRuleResource s) (TF.Attr s P.Bool) where
    scanEnabled =
        lens (_scan_enabled :: SesReceiptRuleResource s -> TF.Attr s P.Bool)
             (\s a -> s { _scan_enabled = a } :: SesReceiptRuleResource s)

instance P.HasSnsAction (SesReceiptRuleResource s) (TF.Attr s Text) where
    snsAction =
        lens (_sns_action :: SesReceiptRuleResource s -> TF.Attr s Text)
             (\s a -> s { _sns_action = a } :: SesReceiptRuleResource s)

instance P.HasStopAction (SesReceiptRuleResource s) (TF.Attr s Text) where
    stopAction =
        lens (_stop_action :: SesReceiptRuleResource s -> TF.Attr s Text)
             (\s a -> s { _stop_action = a } :: SesReceiptRuleResource s)

instance P.HasTlsPolicy (SesReceiptRuleResource s) (TF.Attr s Text) where
    tlsPolicy =
        lens (_tls_policy :: SesReceiptRuleResource s -> TF.Attr s Text)
             (\s a -> s { _tls_policy = a } :: SesReceiptRuleResource s)

instance P.HasWorkmailAction (SesReceiptRuleResource s) (TF.Attr s Text) where
    workmailAction =
        lens (_workmail_action :: SesReceiptRuleResource s -> TF.Attr s Text)
             (\s a -> s { _workmail_action = a } :: SesReceiptRuleResource s)

instance P.HasComputedAddHeaderAction (SesReceiptRuleResource s) s (TF.Attr s Text) where
    computedAddHeaderAction =
        (_add_header_action :: SesReceiptRuleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAfter (SesReceiptRuleResource s) s (TF.Attr s Text) where
    computedAfter =
        (_after :: SesReceiptRuleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedBounceAction (SesReceiptRuleResource s) s (TF.Attr s Text) where
    computedBounceAction =
        (_bounce_action :: SesReceiptRuleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEnabled (SesReceiptRuleResource s) s (TF.Attr s P.Bool) where
    computedEnabled =
        (_enabled :: SesReceiptRuleResource s -> TF.Attr s P.Bool)
            . TF.refValue

instance P.HasComputedLambdaAction (SesReceiptRuleResource s) s (TF.Attr s Text) where
    computedLambdaAction =
        (_lambda_action :: SesReceiptRuleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (SesReceiptRuleResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: SesReceiptRuleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRecipients (SesReceiptRuleResource s) s (TF.Attr s Text) where
    computedRecipients =
        (_recipients :: SesReceiptRuleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRuleSetName (SesReceiptRuleResource s) s (TF.Attr s Text) where
    computedRuleSetName =
        (_rule_set_name :: SesReceiptRuleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedS3Action (SesReceiptRuleResource s) s (TF.Attr s Text) where
    computedS3Action =
        (_s3_action :: SesReceiptRuleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedScanEnabled (SesReceiptRuleResource s) s (TF.Attr s P.Bool) where
    computedScanEnabled =
        (_scan_enabled :: SesReceiptRuleResource s -> TF.Attr s P.Bool)
            . TF.refValue

instance P.HasComputedSnsAction (SesReceiptRuleResource s) s (TF.Attr s Text) where
    computedSnsAction =
        (_sns_action :: SesReceiptRuleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedStopAction (SesReceiptRuleResource s) s (TF.Attr s Text) where
    computedStopAction =
        (_stop_action :: SesReceiptRuleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTlsPolicy (SesReceiptRuleResource s) s (TF.Attr s Text) where
    computedTlsPolicy =
        (_tls_policy :: SesReceiptRuleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedWorkmailAction (SesReceiptRuleResource s) s (TF.Attr s Text) where
    computedWorkmailAction =
        (_workmail_action :: SesReceiptRuleResource s -> TF.Attr s Text)
            . TF.refValue

sesReceiptRuleResource :: TF.Schema TF.Resource P.AWS (SesReceiptRuleResource s)
sesReceiptRuleResource =
    TF.newResource "aws_ses_receipt_rule" $
        SesReceiptRuleResource {
              _add_header_action = TF.Nil
            , _after = TF.Nil
            , _bounce_action = TF.Nil
            , _enabled = TF.Nil
            , _lambda_action = TF.Nil
            , _name = TF.Nil
            , _recipients = TF.Nil
            , _rule_set_name = TF.Nil
            , _s3_action = TF.Nil
            , _scan_enabled = TF.Nil
            , _sns_action = TF.Nil
            , _stop_action = TF.Nil
            , _tls_policy = TF.Nil
            , _workmail_action = TF.Nil
            }

{- | The @aws_ses_receipt_rule_set@ AWS resource.

Provides an SES receipt rule set resource
-}
data SesReceiptRuleSetResource s = SesReceiptRuleSetResource {
      _rule_set_name :: !(TF.Attr s Text)
    {- ^ (Required) The name of the rule set -}
    } deriving (Show, Eq)

instance TF.ToHCL (SesReceiptRuleSetResource s) where
    toHCL SesReceiptRuleSetResource{..} = TF.inline $ catMaybes
        [ TF.assign "rule_set_name" <$> TF.attribute _rule_set_name
        ]

instance P.HasRuleSetName (SesReceiptRuleSetResource s) (TF.Attr s Text) where
    ruleSetName =
        lens (_rule_set_name :: SesReceiptRuleSetResource s -> TF.Attr s Text)
             (\s a -> s { _rule_set_name = a } :: SesReceiptRuleSetResource s)

instance P.HasComputedRuleSetName (SesReceiptRuleSetResource s) s (TF.Attr s Text) where
    computedRuleSetName =
        (_rule_set_name :: SesReceiptRuleSetResource s -> TF.Attr s Text)
            . TF.refValue

sesReceiptRuleSetResource :: TF.Schema TF.Resource P.AWS (SesReceiptRuleSetResource s)
sesReceiptRuleSetResource =
    TF.newResource "aws_ses_receipt_rule_set" $
        SesReceiptRuleSetResource {
              _rule_set_name = TF.Nil
            }

{- | The @aws_ses_template@ AWS resource.

Provides a resource to create a SES template.
-}
data SesTemplateResource s = SesTemplateResource {
      _html    :: !(TF.Attr s Text)
    {- ^ (Optional) The HTML body of the email. Must be less than 500KB in size, including both the text and HTML parts. -}
    , _name    :: !(TF.Attr s Text)
    {- ^ (Required) The name of the template. Cannot exceed 64 characters. You will refer to this name when you send email. -}
    , _subject :: !(TF.Attr s Text)
    {- ^ (Optional) The subject line of the email. -}
    , _text    :: !(TF.Attr s Text)
    {- ^ (Optional) The email body that will be visible to recipients whose email clients do not display HTML. Must be less than 500KB in size, including both the text and HTML parts. -}
    } deriving (Show, Eq)

instance TF.ToHCL (SesTemplateResource s) where
    toHCL SesTemplateResource{..} = TF.inline $ catMaybes
        [ TF.assign "html" <$> TF.attribute _html
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "subject" <$> TF.attribute _subject
        , TF.assign "text" <$> TF.attribute _text
        ]

instance P.HasHtml (SesTemplateResource s) (TF.Attr s Text) where
    html =
        lens (_html :: SesTemplateResource s -> TF.Attr s Text)
             (\s a -> s { _html = a } :: SesTemplateResource s)

instance P.HasName (SesTemplateResource s) (TF.Attr s Text) where
    name =
        lens (_name :: SesTemplateResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: SesTemplateResource s)

instance P.HasSubject (SesTemplateResource s) (TF.Attr s Text) where
    subject =
        lens (_subject :: SesTemplateResource s -> TF.Attr s Text)
             (\s a -> s { _subject = a } :: SesTemplateResource s)

instance P.HasText (SesTemplateResource s) (TF.Attr s Text) where
    text =
        lens (_text :: SesTemplateResource s -> TF.Attr s Text)
             (\s a -> s { _text = a } :: SesTemplateResource s)

instance P.HasComputedHtml (SesTemplateResource s) s (TF.Attr s Text) where
    computedHtml =
        (_html :: SesTemplateResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (SesTemplateResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (SesTemplateResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: SesTemplateResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSubject (SesTemplateResource s) s (TF.Attr s Text) where
    computedSubject =
        (_subject :: SesTemplateResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedText (SesTemplateResource s) s (TF.Attr s Text) where
    computedText =
        (_text :: SesTemplateResource s -> TF.Attr s Text)
            . TF.refValue

sesTemplateResource :: TF.Schema TF.Resource P.AWS (SesTemplateResource s)
sesTemplateResource =
    TF.newResource "aws_ses_template" $
        SesTemplateResource {
              _html = TF.Nil
            , _name = TF.Nil
            , _subject = TF.Nil
            , _text = TF.Nil
            }

{- | The @aws_simpledb_domain@ AWS resource.

Provides a SimpleDB domain resource
-}
data SimpledbDomainResource s = SimpledbDomainResource {
      _name :: !(TF.Attr s Text)
    {- ^ (Required) The name of the SimpleDB domain -}
    } deriving (Show, Eq)

instance TF.ToHCL (SimpledbDomainResource s) where
    toHCL SimpledbDomainResource{..} = TF.inline $ catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        ]

instance P.HasName (SimpledbDomainResource s) (TF.Attr s Text) where
    name =
        lens (_name :: SimpledbDomainResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: SimpledbDomainResource s)

instance P.HasComputedId (SimpledbDomainResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (SimpledbDomainResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: SimpledbDomainResource s -> TF.Attr s Text)
            . TF.refValue

simpledbDomainResource :: TF.Schema TF.Resource P.AWS (SimpledbDomainResource s)
simpledbDomainResource =
    TF.newResource "aws_simpledb_domain" $
        SimpledbDomainResource {
              _name = TF.Nil
            }

{- | The @aws_snapshot_create_volume_permission@ AWS resource.

Adds permission to create volumes off of a given EBS Snapshot.
-}
data SnapshotCreateVolumePermissionResource s = SnapshotCreateVolumePermissionResource {
      _account_id  :: !(TF.Attr s Text)
    {- ^ - (required) An AWS Account ID to add create volume permissions -}
    , _snapshot_id :: !(TF.Attr s Text)
    {- ^ - (required) A snapshot ID -}
    } deriving (Show, Eq)

instance TF.ToHCL (SnapshotCreateVolumePermissionResource s) where
    toHCL SnapshotCreateVolumePermissionResource{..} = TF.inline $ catMaybes
        [ TF.assign "account_id" <$> TF.attribute _account_id
        , TF.assign "snapshot_id" <$> TF.attribute _snapshot_id
        ]

instance P.HasAccountId (SnapshotCreateVolumePermissionResource s) (TF.Attr s Text) where
    accountId =
        lens (_account_id :: SnapshotCreateVolumePermissionResource s -> TF.Attr s Text)
             (\s a -> s { _account_id = a } :: SnapshotCreateVolumePermissionResource s)

instance P.HasSnapshotId (SnapshotCreateVolumePermissionResource s) (TF.Attr s Text) where
    snapshotId =
        lens (_snapshot_id :: SnapshotCreateVolumePermissionResource s -> TF.Attr s Text)
             (\s a -> s { _snapshot_id = a } :: SnapshotCreateVolumePermissionResource s)

instance P.HasComputedAccountId (SnapshotCreateVolumePermissionResource s) s (TF.Attr s Text) where
    computedAccountId =
        (_account_id :: SnapshotCreateVolumePermissionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (SnapshotCreateVolumePermissionResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedSnapshotId (SnapshotCreateVolumePermissionResource s) s (TF.Attr s Text) where
    computedSnapshotId =
        (_snapshot_id :: SnapshotCreateVolumePermissionResource s -> TF.Attr s Text)
            . TF.refValue

snapshotCreateVolumePermissionResource :: TF.Schema TF.Resource P.AWS (SnapshotCreateVolumePermissionResource s)
snapshotCreateVolumePermissionResource =
    TF.newResource "aws_snapshot_create_volume_permission" $
        SnapshotCreateVolumePermissionResource {
              _account_id = TF.Nil
            , _snapshot_id = TF.Nil
            }

{- | The @aws_sns_platform_application@ AWS resource.

Provides an SNS platform application resource
-}
data SnsPlatformApplicationResource s = SnsPlatformApplicationResource {
      _event_delivery_failure_topic_arn :: !(TF.Attr s Text)
    {- ^ (Optional) SNS Topic triggered when a delivery to any of the platform endpoints associated with your platform application encounters a permanent failure. -}
    , _event_endpoint_created_topic_arn :: !(TF.Attr s Text)
    {- ^ (Optional) SNS Topic triggered when a new platform endpoint is added to your platform application. -}
    , _event_endpoint_deleted_topic_arn :: !(TF.Attr s Text)
    {- ^ (Optional) SNS Topic triggered when an existing platform endpoint is deleted from your platform application. -}
    , _event_endpoint_updated_topic     :: !(TF.Attr s Text)
    {- ^ (Optional) SNS Topic triggered when an existing platform endpoint is changed from your platform application. -}
    , _failure_feedback_role_arn        :: !(TF.Attr s Text)
    {- ^ (Optional) The IAM role permitted to receive failure feedback for this application. -}
    , _name                             :: !(TF.Attr s Text)
    {- ^ (Required) The friendly name for the SNS platform application -}
    , _platform                         :: !(TF.Attr s Text)
    {- ^ (Required) The platform that the app is registered with. See <http://docs.aws.amazon.com/sns/latest/dg/mobile-push-send-register.html> for supported platforms. -}
    , _platform_credential              :: !(TF.Attr s Text)
    {- ^ (Required) Application Platform credential. See <http://docs.aws.amazon.com/sns/latest/dg/mobile-push-send-register.html> for type of credential required for platform. The value of this attribute when stored into the Terraform state is only a hash of the real value, so therefore it is not practical to use this as an attribute for other resources. -}
    , _platform_principal               :: !(TF.Attr s Text)
    {- ^ (Optional) Application Platform principal. See <http://docs.aws.amazon.com/sns/latest/api/API_CreatePlatformApplication.html> for type of principal required for platform. The value of this attribute when stored into the Terraform state is only a hash of the real value, so therefore it is not practical to use this as an attribute for other resources. -}
    , _success_feedback_role_arn        :: !(TF.Attr s Text)
    {- ^ (Optional) The IAM role permitted to receive success feedback for this application. -}
    , _success_feedback_sample_rate     :: !(TF.Attr s Text)
    {- ^ (Optional) The percentage of success to sample (0-100) -}
    } deriving (Show, Eq)

instance TF.ToHCL (SnsPlatformApplicationResource s) where
    toHCL SnsPlatformApplicationResource{..} = TF.inline $ catMaybes
        [ TF.assign "event_delivery_failure_topic_arn" <$> TF.attribute _event_delivery_failure_topic_arn
        , TF.assign "event_endpoint_created_topic_arn" <$> TF.attribute _event_endpoint_created_topic_arn
        , TF.assign "event_endpoint_deleted_topic_arn" <$> TF.attribute _event_endpoint_deleted_topic_arn
        , TF.assign "event_endpoint_updated_topic" <$> TF.attribute _event_endpoint_updated_topic
        , TF.assign "failure_feedback_role_arn" <$> TF.attribute _failure_feedback_role_arn
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "platform" <$> TF.attribute _platform
        , TF.assign "platform_credential" <$> TF.attribute _platform_credential
        , TF.assign "platform_principal" <$> TF.attribute _platform_principal
        , TF.assign "success_feedback_role_arn" <$> TF.attribute _success_feedback_role_arn
        , TF.assign "success_feedback_sample_rate" <$> TF.attribute _success_feedback_sample_rate
        ]

instance P.HasEventDeliveryFailureTopicArn (SnsPlatformApplicationResource s) (TF.Attr s Text) where
    eventDeliveryFailureTopicArn =
        lens (_event_delivery_failure_topic_arn :: SnsPlatformApplicationResource s -> TF.Attr s Text)
             (\s a -> s { _event_delivery_failure_topic_arn = a } :: SnsPlatformApplicationResource s)

instance P.HasEventEndpointCreatedTopicArn (SnsPlatformApplicationResource s) (TF.Attr s Text) where
    eventEndpointCreatedTopicArn =
        lens (_event_endpoint_created_topic_arn :: SnsPlatformApplicationResource s -> TF.Attr s Text)
             (\s a -> s { _event_endpoint_created_topic_arn = a } :: SnsPlatformApplicationResource s)

instance P.HasEventEndpointDeletedTopicArn (SnsPlatformApplicationResource s) (TF.Attr s Text) where
    eventEndpointDeletedTopicArn =
        lens (_event_endpoint_deleted_topic_arn :: SnsPlatformApplicationResource s -> TF.Attr s Text)
             (\s a -> s { _event_endpoint_deleted_topic_arn = a } :: SnsPlatformApplicationResource s)

instance P.HasEventEndpointUpdatedTopic (SnsPlatformApplicationResource s) (TF.Attr s Text) where
    eventEndpointUpdatedTopic =
        lens (_event_endpoint_updated_topic :: SnsPlatformApplicationResource s -> TF.Attr s Text)
             (\s a -> s { _event_endpoint_updated_topic = a } :: SnsPlatformApplicationResource s)

instance P.HasFailureFeedbackRoleArn (SnsPlatformApplicationResource s) (TF.Attr s Text) where
    failureFeedbackRoleArn =
        lens (_failure_feedback_role_arn :: SnsPlatformApplicationResource s -> TF.Attr s Text)
             (\s a -> s { _failure_feedback_role_arn = a } :: SnsPlatformApplicationResource s)

instance P.HasName (SnsPlatformApplicationResource s) (TF.Attr s Text) where
    name =
        lens (_name :: SnsPlatformApplicationResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: SnsPlatformApplicationResource s)

instance P.HasPlatform (SnsPlatformApplicationResource s) (TF.Attr s Text) where
    platform =
        lens (_platform :: SnsPlatformApplicationResource s -> TF.Attr s Text)
             (\s a -> s { _platform = a } :: SnsPlatformApplicationResource s)

instance P.HasPlatformCredential (SnsPlatformApplicationResource s) (TF.Attr s Text) where
    platformCredential =
        lens (_platform_credential :: SnsPlatformApplicationResource s -> TF.Attr s Text)
             (\s a -> s { _platform_credential = a } :: SnsPlatformApplicationResource s)

instance P.HasPlatformPrincipal (SnsPlatformApplicationResource s) (TF.Attr s Text) where
    platformPrincipal =
        lens (_platform_principal :: SnsPlatformApplicationResource s -> TF.Attr s Text)
             (\s a -> s { _platform_principal = a } :: SnsPlatformApplicationResource s)

instance P.HasSuccessFeedbackRoleArn (SnsPlatformApplicationResource s) (TF.Attr s Text) where
    successFeedbackRoleArn =
        lens (_success_feedback_role_arn :: SnsPlatformApplicationResource s -> TF.Attr s Text)
             (\s a -> s { _success_feedback_role_arn = a } :: SnsPlatformApplicationResource s)

instance P.HasSuccessFeedbackSampleRate (SnsPlatformApplicationResource s) (TF.Attr s Text) where
    successFeedbackSampleRate =
        lens (_success_feedback_sample_rate :: SnsPlatformApplicationResource s -> TF.Attr s Text)
             (\s a -> s { _success_feedback_sample_rate = a } :: SnsPlatformApplicationResource s)

instance P.HasComputedArn (SnsPlatformApplicationResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedEventDeliveryFailureTopicArn (SnsPlatformApplicationResource s) s (TF.Attr s Text) where
    computedEventDeliveryFailureTopicArn =
        (_event_delivery_failure_topic_arn :: SnsPlatformApplicationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEventEndpointCreatedTopicArn (SnsPlatformApplicationResource s) s (TF.Attr s Text) where
    computedEventEndpointCreatedTopicArn =
        (_event_endpoint_created_topic_arn :: SnsPlatformApplicationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEventEndpointDeletedTopicArn (SnsPlatformApplicationResource s) s (TF.Attr s Text) where
    computedEventEndpointDeletedTopicArn =
        (_event_endpoint_deleted_topic_arn :: SnsPlatformApplicationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEventEndpointUpdatedTopic (SnsPlatformApplicationResource s) s (TF.Attr s Text) where
    computedEventEndpointUpdatedTopic =
        (_event_endpoint_updated_topic :: SnsPlatformApplicationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedFailureFeedbackRoleArn (SnsPlatformApplicationResource s) s (TF.Attr s Text) where
    computedFailureFeedbackRoleArn =
        (_failure_feedback_role_arn :: SnsPlatformApplicationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (SnsPlatformApplicationResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (SnsPlatformApplicationResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: SnsPlatformApplicationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPlatform (SnsPlatformApplicationResource s) s (TF.Attr s Text) where
    computedPlatform =
        (_platform :: SnsPlatformApplicationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPlatformCredential (SnsPlatformApplicationResource s) s (TF.Attr s Text) where
    computedPlatformCredential =
        (_platform_credential :: SnsPlatformApplicationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPlatformPrincipal (SnsPlatformApplicationResource s) s (TF.Attr s Text) where
    computedPlatformPrincipal =
        (_platform_principal :: SnsPlatformApplicationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSuccessFeedbackRoleArn (SnsPlatformApplicationResource s) s (TF.Attr s Text) where
    computedSuccessFeedbackRoleArn =
        (_success_feedback_role_arn :: SnsPlatformApplicationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSuccessFeedbackSampleRate (SnsPlatformApplicationResource s) s (TF.Attr s Text) where
    computedSuccessFeedbackSampleRate =
        (_success_feedback_sample_rate :: SnsPlatformApplicationResource s -> TF.Attr s Text)
            . TF.refValue

snsPlatformApplicationResource :: TF.Schema TF.Resource P.AWS (SnsPlatformApplicationResource s)
snsPlatformApplicationResource =
    TF.newResource "aws_sns_platform_application" $
        SnsPlatformApplicationResource {
              _event_delivery_failure_topic_arn = TF.Nil
            , _event_endpoint_created_topic_arn = TF.Nil
            , _event_endpoint_deleted_topic_arn = TF.Nil
            , _event_endpoint_updated_topic = TF.Nil
            , _failure_feedback_role_arn = TF.Nil
            , _name = TF.Nil
            , _platform = TF.Nil
            , _platform_credential = TF.Nil
            , _platform_principal = TF.Nil
            , _success_feedback_role_arn = TF.Nil
            , _success_feedback_sample_rate = TF.Nil
            }

{- | The @aws_sns_topic_policy@ AWS resource.

Provides an SNS topic policy resource ~> NOTE: If a Principal is specified
as just an AWS account ID rather than an ARN, AWS silently converts it to
the ARN for the root user, causing future terraform plans to differ. To
avoid this problem, just specify the full ARN, e.g.
@arn:aws:iam::123456789012:root@
-}
data SnsTopicPolicyResource s = SnsTopicPolicyResource {
      _arn    :: !(TF.Attr s Text)
    {- ^ (Required) The ARN of the SNS topic -}
    , _policy :: !(TF.Attr s Text)
    {- ^ (Required) The fully-formed AWS policy as JSON -}
    } deriving (Show, Eq)

instance TF.ToHCL (SnsTopicPolicyResource s) where
    toHCL SnsTopicPolicyResource{..} = TF.inline $ catMaybes
        [ TF.assign "arn" <$> TF.attribute _arn
        , TF.assign "policy" <$> TF.attribute _policy
        ]

instance P.HasArn (SnsTopicPolicyResource s) (TF.Attr s Text) where
    arn =
        lens (_arn :: SnsTopicPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _arn = a } :: SnsTopicPolicyResource s)

instance P.HasPolicy (SnsTopicPolicyResource s) (TF.Attr s Text) where
    policy =
        lens (_policy :: SnsTopicPolicyResource s -> TF.Attr s Text)
             (\s a -> s { _policy = a } :: SnsTopicPolicyResource s)

instance P.HasComputedArn (SnsTopicPolicyResource s) s (TF.Attr s Text) where
    computedArn =
        (_arn :: SnsTopicPolicyResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPolicy (SnsTopicPolicyResource s) s (TF.Attr s Text) where
    computedPolicy =
        (_policy :: SnsTopicPolicyResource s -> TF.Attr s Text)
            . TF.refValue

snsTopicPolicyResource :: TF.Schema TF.Resource P.AWS (SnsTopicPolicyResource s)
snsTopicPolicyResource =
    TF.newResource "aws_sns_topic_policy" $
        SnsTopicPolicyResource {
              _arn = TF.Nil
            , _policy = TF.Nil
            }

{- | The @aws_sns_topic@ AWS resource.

Provides an SNS topic resource
-}
data SnsTopicResource s = SnsTopicResource {
      _application_failure_feedback_role_arn    :: !(TF.Attr s Text)
    {- ^ (Optional) IAM role for failure feedback -}
    , _application_success_feedback_role_arn    :: !(TF.Attr s Text)
    {- ^ (Optional) The IAM role permitted to receive success feedback for this topic -}
    , _application_success_feedback_sample_rate :: !(TF.Attr s Text)
    {- ^ (Optional) Percentage of success to sample -}
    , _delivery_policy                          :: !(TF.Attr s Text)
    {- ^ (Optional) The SNS delivery policy -}
    , _display_name                             :: !(TF.Attr s Text)
    {- ^ (Optional) The display name for the SNS topic -}
    , _http_failure_feedback_role_arn           :: !(TF.Attr s Text)
    {- ^ (Optional) IAM role for failure feedback -}
    , _http_success_feedback_role_arn           :: !(TF.Attr s Text)
    {- ^ (Optional) The IAM role permitted to receive success feedback for this topic -}
    , _http_success_feedback_sample_rate        :: !(TF.Attr s Text)
    {- ^ (Optional) Percentage of success to sample -}
    , _lambda_failure_feedback_role_arn         :: !(TF.Attr s Text)
    {- ^ (Optional) IAM role for failure feedback -}
    , _lambda_success_feedback_role_arn         :: !(TF.Attr s Text)
    {- ^ (Optional) The IAM role permitted to receive success feedback for this topic -}
    , _lambda_success_feedback_sample_rate      :: !(TF.Attr s Text)
    {- ^ (Optional) Percentage of success to sample -}
    , _name                                     :: !(TF.Attr s Text)
    {- ^ (Optional) The friendly name for the SNS topic. By default generated by Terraform. -}
    , _name_prefix                              :: !(TF.Attr s Text)
    {- ^ (Optional) The friendly name for the SNS topic. Conflicts with @name@ . -}
    , _policy                                   :: !(TF.Attr s Text)
    {- ^ (Optional) The fully-formed AWS policy as JSON -}
    , _sqs_failure_feedback_role_arn            :: !(TF.Attr s Text)
    {- ^ (Optional) IAM role for failure feedback -}
    , _sqs_success_feedback_role_arn            :: !(TF.Attr s Text)
    {- ^ (Optional) The IAM role permitted to receive success feedback for this topic -}
    , _sqs_success_feedback_sample_rate         :: !(TF.Attr s Text)
    {- ^ (Optional) Percentage of success to sample -}
    } deriving (Show, Eq)

instance TF.ToHCL (SnsTopicResource s) where
    toHCL SnsTopicResource{..} = TF.inline $ catMaybes
        [ TF.assign "application_failure_feedback_role_arn" <$> TF.attribute _application_failure_feedback_role_arn
        , TF.assign "application_success_feedback_role_arn" <$> TF.attribute _application_success_feedback_role_arn
        , TF.assign "application_success_feedback_sample_rate" <$> TF.attribute _application_success_feedback_sample_rate
        , TF.assign "delivery_policy" <$> TF.attribute _delivery_policy
        , TF.assign "display_name" <$> TF.attribute _display_name
        , TF.assign "http_failure_feedback_role_arn" <$> TF.attribute _http_failure_feedback_role_arn
        , TF.assign "http_success_feedback_role_arn" <$> TF.attribute _http_success_feedback_role_arn
        , TF.assign "http_success_feedback_sample_rate" <$> TF.attribute _http_success_feedback_sample_rate
        , TF.assign "lambda_failure_feedback_role_arn" <$> TF.attribute _lambda_failure_feedback_role_arn
        , TF.assign "lambda_success_feedback_role_arn" <$> TF.attribute _lambda_success_feedback_role_arn
        , TF.assign "lambda_success_feedback_sample_rate" <$> TF.attribute _lambda_success_feedback_sample_rate
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "name_prefix" <$> TF.attribute _name_prefix
        , TF.assign "policy" <$> TF.attribute _policy
        , TF.assign "sqs_failure_feedback_role_arn" <$> TF.attribute _sqs_failure_feedback_role_arn
        , TF.assign "sqs_success_feedback_role_arn" <$> TF.attribute _sqs_success_feedback_role_arn
        , TF.assign "sqs_success_feedback_sample_rate" <$> TF.attribute _sqs_success_feedback_sample_rate
        ]

instance P.HasApplicationFailureFeedbackRoleArn (SnsTopicResource s) (TF.Attr s Text) where
    applicationFailureFeedbackRoleArn =
        lens (_application_failure_feedback_role_arn :: SnsTopicResource s -> TF.Attr s Text)
             (\s a -> s { _application_failure_feedback_role_arn = a } :: SnsTopicResource s)

instance P.HasApplicationSuccessFeedbackRoleArn (SnsTopicResource s) (TF.Attr s Text) where
    applicationSuccessFeedbackRoleArn =
        lens (_application_success_feedback_role_arn :: SnsTopicResource s -> TF.Attr s Text)
             (\s a -> s { _application_success_feedback_role_arn = a } :: SnsTopicResource s)

instance P.HasApplicationSuccessFeedbackSampleRate (SnsTopicResource s) (TF.Attr s Text) where
    applicationSuccessFeedbackSampleRate =
        lens (_application_success_feedback_sample_rate :: SnsTopicResource s -> TF.Attr s Text)
             (\s a -> s { _application_success_feedback_sample_rate = a } :: SnsTopicResource s)

instance P.HasDeliveryPolicy (SnsTopicResource s) (TF.Attr s Text) where
    deliveryPolicy =
        lens (_delivery_policy :: SnsTopicResource s -> TF.Attr s Text)
             (\s a -> s { _delivery_policy = a } :: SnsTopicResource s)

instance P.HasDisplayName (SnsTopicResource s) (TF.Attr s Text) where
    displayName =
        lens (_display_name :: SnsTopicResource s -> TF.Attr s Text)
             (\s a -> s { _display_name = a } :: SnsTopicResource s)

instance P.HasHttpFailureFeedbackRoleArn (SnsTopicResource s) (TF.Attr s Text) where
    httpFailureFeedbackRoleArn =
        lens (_http_failure_feedback_role_arn :: SnsTopicResource s -> TF.Attr s Text)
             (\s a -> s { _http_failure_feedback_role_arn = a } :: SnsTopicResource s)

instance P.HasHttpSuccessFeedbackRoleArn (SnsTopicResource s) (TF.Attr s Text) where
    httpSuccessFeedbackRoleArn =
        lens (_http_success_feedback_role_arn :: SnsTopicResource s -> TF.Attr s Text)
             (\s a -> s { _http_success_feedback_role_arn = a } :: SnsTopicResource s)

instance P.HasHttpSuccessFeedbackSampleRate (SnsTopicResource s) (TF.Attr s Text) where
    httpSuccessFeedbackSampleRate =
        lens (_http_success_feedback_sample_rate :: SnsTopicResource s -> TF.Attr s Text)
             (\s a -> s { _http_success_feedback_sample_rate = a } :: SnsTopicResource s)

instance P.HasLambdaFailureFeedbackRoleArn (SnsTopicResource s) (TF.Attr s Text) where
    lambdaFailureFeedbackRoleArn =
        lens (_lambda_failure_feedback_role_arn :: SnsTopicResource s -> TF.Attr s Text)
             (\s a -> s { _lambda_failure_feedback_role_arn = a } :: SnsTopicResource s)

instance P.HasLambdaSuccessFeedbackRoleArn (SnsTopicResource s) (TF.Attr s Text) where
    lambdaSuccessFeedbackRoleArn =
        lens (_lambda_success_feedback_role_arn :: SnsTopicResource s -> TF.Attr s Text)
             (\s a -> s { _lambda_success_feedback_role_arn = a } :: SnsTopicResource s)

instance P.HasLambdaSuccessFeedbackSampleRate (SnsTopicResource s) (TF.Attr s Text) where
    lambdaSuccessFeedbackSampleRate =
        lens (_lambda_success_feedback_sample_rate :: SnsTopicResource s -> TF.Attr s Text)
             (\s a -> s { _lambda_success_feedback_sample_rate = a } :: SnsTopicResource s)

instance P.HasName (SnsTopicResource s) (TF.Attr s Text) where
    name =
        lens (_name :: SnsTopicResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: SnsTopicResource s)

instance P.HasNamePrefix (SnsTopicResource s) (TF.Attr s Text) where
    namePrefix =
        lens (_name_prefix :: SnsTopicResource s -> TF.Attr s Text)
             (\s a -> s { _name_prefix = a } :: SnsTopicResource s)

instance P.HasPolicy (SnsTopicResource s) (TF.Attr s Text) where
    policy =
        lens (_policy :: SnsTopicResource s -> TF.Attr s Text)
             (\s a -> s { _policy = a } :: SnsTopicResource s)

instance P.HasSqsFailureFeedbackRoleArn (SnsTopicResource s) (TF.Attr s Text) where
    sqsFailureFeedbackRoleArn =
        lens (_sqs_failure_feedback_role_arn :: SnsTopicResource s -> TF.Attr s Text)
             (\s a -> s { _sqs_failure_feedback_role_arn = a } :: SnsTopicResource s)

instance P.HasSqsSuccessFeedbackRoleArn (SnsTopicResource s) (TF.Attr s Text) where
    sqsSuccessFeedbackRoleArn =
        lens (_sqs_success_feedback_role_arn :: SnsTopicResource s -> TF.Attr s Text)
             (\s a -> s { _sqs_success_feedback_role_arn = a } :: SnsTopicResource s)

instance P.HasSqsSuccessFeedbackSampleRate (SnsTopicResource s) (TF.Attr s Text) where
    sqsSuccessFeedbackSampleRate =
        lens (_sqs_success_feedback_sample_rate :: SnsTopicResource s -> TF.Attr s Text)
             (\s a -> s { _sqs_success_feedback_sample_rate = a } :: SnsTopicResource s)

instance P.HasComputedApplicationFailureFeedbackRoleArn (SnsTopicResource s) s (TF.Attr s Text) where
    computedApplicationFailureFeedbackRoleArn =
        (_application_failure_feedback_role_arn :: SnsTopicResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedApplicationSuccessFeedbackRoleArn (SnsTopicResource s) s (TF.Attr s Text) where
    computedApplicationSuccessFeedbackRoleArn =
        (_application_success_feedback_role_arn :: SnsTopicResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedApplicationSuccessFeedbackSampleRate (SnsTopicResource s) s (TF.Attr s Text) where
    computedApplicationSuccessFeedbackSampleRate =
        (_application_success_feedback_sample_rate :: SnsTopicResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedArn (SnsTopicResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedDeliveryPolicy (SnsTopicResource s) s (TF.Attr s Text) where
    computedDeliveryPolicy =
        (_delivery_policy :: SnsTopicResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDisplayName (SnsTopicResource s) s (TF.Attr s Text) where
    computedDisplayName =
        (_display_name :: SnsTopicResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedHttpFailureFeedbackRoleArn (SnsTopicResource s) s (TF.Attr s Text) where
    computedHttpFailureFeedbackRoleArn =
        (_http_failure_feedback_role_arn :: SnsTopicResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedHttpSuccessFeedbackRoleArn (SnsTopicResource s) s (TF.Attr s Text) where
    computedHttpSuccessFeedbackRoleArn =
        (_http_success_feedback_role_arn :: SnsTopicResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedHttpSuccessFeedbackSampleRate (SnsTopicResource s) s (TF.Attr s Text) where
    computedHttpSuccessFeedbackSampleRate =
        (_http_success_feedback_sample_rate :: SnsTopicResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (SnsTopicResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedLambdaFailureFeedbackRoleArn (SnsTopicResource s) s (TF.Attr s Text) where
    computedLambdaFailureFeedbackRoleArn =
        (_lambda_failure_feedback_role_arn :: SnsTopicResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedLambdaSuccessFeedbackRoleArn (SnsTopicResource s) s (TF.Attr s Text) where
    computedLambdaSuccessFeedbackRoleArn =
        (_lambda_success_feedback_role_arn :: SnsTopicResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedLambdaSuccessFeedbackSampleRate (SnsTopicResource s) s (TF.Attr s Text) where
    computedLambdaSuccessFeedbackSampleRate =
        (_lambda_success_feedback_sample_rate :: SnsTopicResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (SnsTopicResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: SnsTopicResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedNamePrefix (SnsTopicResource s) s (TF.Attr s Text) where
    computedNamePrefix =
        (_name_prefix :: SnsTopicResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPolicy (SnsTopicResource s) s (TF.Attr s Text) where
    computedPolicy =
        (_policy :: SnsTopicResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSqsFailureFeedbackRoleArn (SnsTopicResource s) s (TF.Attr s Text) where
    computedSqsFailureFeedbackRoleArn =
        (_sqs_failure_feedback_role_arn :: SnsTopicResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSqsSuccessFeedbackRoleArn (SnsTopicResource s) s (TF.Attr s Text) where
    computedSqsSuccessFeedbackRoleArn =
        (_sqs_success_feedback_role_arn :: SnsTopicResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSqsSuccessFeedbackSampleRate (SnsTopicResource s) s (TF.Attr s Text) where
    computedSqsSuccessFeedbackSampleRate =
        (_sqs_success_feedback_sample_rate :: SnsTopicResource s -> TF.Attr s Text)
            . TF.refValue

snsTopicResource :: TF.Schema TF.Resource P.AWS (SnsTopicResource s)
snsTopicResource =
    TF.newResource "aws_sns_topic" $
        SnsTopicResource {
              _application_failure_feedback_role_arn = TF.Nil
            , _application_success_feedback_role_arn = TF.Nil
            , _application_success_feedback_sample_rate = TF.Nil
            , _delivery_policy = TF.Nil
            , _display_name = TF.Nil
            , _http_failure_feedback_role_arn = TF.Nil
            , _http_success_feedback_role_arn = TF.Nil
            , _http_success_feedback_sample_rate = TF.Nil
            , _lambda_failure_feedback_role_arn = TF.Nil
            , _lambda_success_feedback_role_arn = TF.Nil
            , _lambda_success_feedback_sample_rate = TF.Nil
            , _name = TF.Nil
            , _name_prefix = TF.Nil
            , _policy = TF.Nil
            , _sqs_failure_feedback_role_arn = TF.Nil
            , _sqs_success_feedback_role_arn = TF.Nil
            , _sqs_success_feedback_sample_rate = TF.Nil
            }

{- | The @aws_sns_topic_subscription@ AWS resource.

Provides a resource for subscribing to SNS topics. Requires that an SNS
topic exist for the subscription to attach to. This resource allows you to
automatically place messages sent to SNS topics in SQS queues, send them as
HTTP(S) POST requests to a given endpoint, send SMS messages, or notify
devices / applications. The most likely use case for Terraform users will
probably be SQS queues. ~> NOTE: If SNS topic and SQS queue are in different
AWS regions it is important to place the "aws_sns_topic_subscription" into
the terraform configuration of the region with the SQS queue. If
"aws_sns_topic_subscription" is placed in the terraform configuration of the
region with the SNS topic terraform will fail to create the subscription. ~>
NOTE: Setup of cross-account subscriptions from SNS topics to SQS queues
requires Terraform to have access to BOTH accounts. ~> NOTE: If SNS topic
and SQS queue are in different AWS accounts but the same region it is
important to place the "aws_sns_topic_subscription" into the terraform
configuration of the account with the SQS queue. If
"aws_sns_topic_subscription" is placed in the terraform configuration of the
account with the SNS topic terraform creates the subscriptions but does not
keep state and tries to re-create the subscription at every apply. ~> NOTE:
If SNS topic and SQS queue are in different AWS accounts and different AWS
regions it is important to recognize that the subscription needs to be
initiated from the account with the SQS queue but in the region of the SNS
topic.
-}
data SnsTopicSubscriptionResource s = SnsTopicSubscriptionResource {
      _confirmation_timeout_in_minutes :: !(TF.Attr s Text)
    {- ^ (Optional) Integer indicating number of minutes to wait in retying mode for fetching subscription arn before marking it as failure. Only applicable for http and https protocols (default is 1 minute). -}
    , _endpoint                        :: !(TF.Attr s Text)
    {- ^ (Required) The endpoint to send data to, the contents will vary with the protocol. (see below for more information) -}
    , _endpoint_auto_confirms          :: !(TF.Attr s Text)
    {- ^ (Optional) Boolean indicating whether the end point is capable of <http://docs.aws.amazon.com/sns/latest/dg/SendMessageToHttp.html#SendMessageToHttp.prepare> e.g., PagerDuty (default is false) -}
    , _filter_policy                   :: !(TF.Attr s Text)
    {- ^ (Optional) The text of a filter policy to the topic subscription. -}
    , _protocol                        :: !(TF.Attr s Text)
    {- ^ (Required) The protocol to use. The possible values for this are: @sqs@ , @sms@ , @lambda@ , @application@ . ( @http@ or @https@ are partially supported, see below) ( @email@ is option but unsupported, see below). -}
    , _raw_message_delivery            :: !(TF.Attr s Text)
    {- ^ (Optional) Boolean indicating whether or not to enable raw message delivery (the original message is directly passed, not wrapped in JSON with the original message in the message property) (default is false). -}
    , _topic_arn                       :: !(TF.Attr s Text)
    {- ^ (Required) The ARN of the SNS topic to subscribe to -}
    } deriving (Show, Eq)

instance TF.ToHCL (SnsTopicSubscriptionResource s) where
    toHCL SnsTopicSubscriptionResource{..} = TF.inline $ catMaybes
        [ TF.assign "confirmation_timeout_in_minutes" <$> TF.attribute _confirmation_timeout_in_minutes
        , TF.assign "endpoint" <$> TF.attribute _endpoint
        , TF.assign "endpoint_auto_confirms" <$> TF.attribute _endpoint_auto_confirms
        , TF.assign "filter_policy" <$> TF.attribute _filter_policy
        , TF.assign "protocol" <$> TF.attribute _protocol
        , TF.assign "raw_message_delivery" <$> TF.attribute _raw_message_delivery
        , TF.assign "topic_arn" <$> TF.attribute _topic_arn
        ]

instance P.HasConfirmationTimeoutInMinutes (SnsTopicSubscriptionResource s) (TF.Attr s Text) where
    confirmationTimeoutInMinutes =
        lens (_confirmation_timeout_in_minutes :: SnsTopicSubscriptionResource s -> TF.Attr s Text)
             (\s a -> s { _confirmation_timeout_in_minutes = a } :: SnsTopicSubscriptionResource s)

instance P.HasEndpoint (SnsTopicSubscriptionResource s) (TF.Attr s Text) where
    endpoint =
        lens (_endpoint :: SnsTopicSubscriptionResource s -> TF.Attr s Text)
             (\s a -> s { _endpoint = a } :: SnsTopicSubscriptionResource s)

instance P.HasEndpointAutoConfirms (SnsTopicSubscriptionResource s) (TF.Attr s Text) where
    endpointAutoConfirms =
        lens (_endpoint_auto_confirms :: SnsTopicSubscriptionResource s -> TF.Attr s Text)
             (\s a -> s { _endpoint_auto_confirms = a } :: SnsTopicSubscriptionResource s)

instance P.HasFilterPolicy (SnsTopicSubscriptionResource s) (TF.Attr s Text) where
    filterPolicy =
        lens (_filter_policy :: SnsTopicSubscriptionResource s -> TF.Attr s Text)
             (\s a -> s { _filter_policy = a } :: SnsTopicSubscriptionResource s)

instance P.HasProtocol (SnsTopicSubscriptionResource s) (TF.Attr s Text) where
    protocol =
        lens (_protocol :: SnsTopicSubscriptionResource s -> TF.Attr s Text)
             (\s a -> s { _protocol = a } :: SnsTopicSubscriptionResource s)

instance P.HasRawMessageDelivery (SnsTopicSubscriptionResource s) (TF.Attr s Text) where
    rawMessageDelivery =
        lens (_raw_message_delivery :: SnsTopicSubscriptionResource s -> TF.Attr s Text)
             (\s a -> s { _raw_message_delivery = a } :: SnsTopicSubscriptionResource s)

instance P.HasTopicArn (SnsTopicSubscriptionResource s) (TF.Attr s Text) where
    topicArn =
        lens (_topic_arn :: SnsTopicSubscriptionResource s -> TF.Attr s Text)
             (\s a -> s { _topic_arn = a } :: SnsTopicSubscriptionResource s)

instance P.HasComputedArn (SnsTopicSubscriptionResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedConfirmationTimeoutInMinutes (SnsTopicSubscriptionResource s) s (TF.Attr s Text) where
    computedConfirmationTimeoutInMinutes =
        (_confirmation_timeout_in_minutes :: SnsTopicSubscriptionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedEndpoint (SnsTopicSubscriptionResource s) s (TF.Attr s Text) where
    computedEndpoint x = TF.compute (TF.refKey x) "endpoint"

instance P.HasComputedEndpointAutoConfirms (SnsTopicSubscriptionResource s) s (TF.Attr s Text) where
    computedEndpointAutoConfirms =
        (_endpoint_auto_confirms :: SnsTopicSubscriptionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedFilterPolicy (SnsTopicSubscriptionResource s) s (TF.Attr s Text) where
    computedFilterPolicy =
        (_filter_policy :: SnsTopicSubscriptionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (SnsTopicSubscriptionResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedProtocol (SnsTopicSubscriptionResource s) s (TF.Attr s Text) where
    computedProtocol x = TF.compute (TF.refKey x) "protocol"

instance P.HasComputedRawMessageDelivery (SnsTopicSubscriptionResource s) s (TF.Attr s Text) where
    computedRawMessageDelivery =
        (_raw_message_delivery :: SnsTopicSubscriptionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTopicArn (SnsTopicSubscriptionResource s) s (TF.Attr s Text) where
    computedTopicArn x = TF.compute (TF.refKey x) "topic_arn"

snsTopicSubscriptionResource :: TF.Schema TF.Resource P.AWS (SnsTopicSubscriptionResource s)
snsTopicSubscriptionResource =
    TF.newResource "aws_sns_topic_subscription" $
        SnsTopicSubscriptionResource {
              _confirmation_timeout_in_minutes = TF.Nil
            , _endpoint = TF.Nil
            , _endpoint_auto_confirms = TF.Nil
            , _filter_policy = TF.Nil
            , _protocol = TF.Nil
            , _raw_message_delivery = TF.Nil
            , _topic_arn = TF.Nil
            }

{- | The @aws_spot_datafeed_subscription@ AWS resource.

-> Note: There is only a single subscription allowed per account. To help
you understand the charges for your Spot instances, Amazon EC2 provides a
data feed that describes your Spot instance usage and pricing. This data
feed is sent to an Amazon S3 bucket that you specify when you subscribe to
the data feed.
-}
data SpotDatafeedSubscriptionResource s = SpotDatafeedSubscriptionResource {
      _bucket :: !(TF.Attr s Text)
    {- ^ (Required) The Amazon S3 bucket in which to store the Spot instance data feed. -}
    , _prefix :: !(TF.Attr s Text)
    {- ^ (Optional) Path of folder inside bucket to place spot pricing data. -}
    } deriving (Show, Eq)

instance TF.ToHCL (SpotDatafeedSubscriptionResource s) where
    toHCL SpotDatafeedSubscriptionResource{..} = TF.inline $ catMaybes
        [ TF.assign "bucket" <$> TF.attribute _bucket
        , TF.assign "prefix" <$> TF.attribute _prefix
        ]

instance P.HasBucket (SpotDatafeedSubscriptionResource s) (TF.Attr s Text) where
    bucket =
        lens (_bucket :: SpotDatafeedSubscriptionResource s -> TF.Attr s Text)
             (\s a -> s { _bucket = a } :: SpotDatafeedSubscriptionResource s)

instance P.HasPrefix (SpotDatafeedSubscriptionResource s) (TF.Attr s Text) where
    prefix =
        lens (_prefix :: SpotDatafeedSubscriptionResource s -> TF.Attr s Text)
             (\s a -> s { _prefix = a } :: SpotDatafeedSubscriptionResource s)

instance P.HasComputedBucket (SpotDatafeedSubscriptionResource s) s (TF.Attr s Text) where
    computedBucket =
        (_bucket :: SpotDatafeedSubscriptionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPrefix (SpotDatafeedSubscriptionResource s) s (TF.Attr s Text) where
    computedPrefix =
        (_prefix :: SpotDatafeedSubscriptionResource s -> TF.Attr s Text)
            . TF.refValue

spotDatafeedSubscriptionResource :: TF.Schema TF.Resource P.AWS (SpotDatafeedSubscriptionResource s)
spotDatafeedSubscriptionResource =
    TF.newResource "aws_spot_datafeed_subscription" $
        SpotDatafeedSubscriptionResource {
              _bucket = TF.Nil
            , _prefix = TF.Nil
            }

{- | The @aws_spot_fleet_request@ AWS resource.

Provides an EC2 Spot Fleet Request resource. This allows a fleet of Spot
instances to be requested on the Spot market.
-}
data SpotFleetRequestResource s = SpotFleetRequestResource {
      _allocation_strategy                 :: !(TF.Attr s Text)
    {- ^ - Indicates how to allocate the target capacity across the Spot pools specified by the Spot fleet request. The default is lowestPrice. -}
    , _excess_capacity_termination_policy  :: !(TF.Attr s Text)
    {- ^ - Indicates whether running Spot instances should be terminated if the target capacity of the Spot fleet request is decreased below the current size of the Spot fleet. -}
    , _iam_fleet_role                      :: !(TF.Attr s Text)
    {- ^ (Required) Grants the Spot fleet permission to terminate Spot instances on your behalf when you cancel its Spot fleet request using CancelSpotFleetRequests or when the Spot fleet request expires, if you set terminateInstancesWithExpiration. -}
    , _instance_interruption_behavior      :: !(TF.Attr s Text)
    {- ^ (Optional) Indicates whether a Spot instance stops or terminates when it is interrupted. Default is @terminate@ . -}
    , _launch_specification                :: !(TF.Attr s Text)
    {- ^ - Used to define the launch configuration of the spot-fleet request. Can be specified multiple times to define different bids across different markets and instance types. -}
    , _replace_unhealthy_instances         :: !(TF.Attr s Text)
    {- ^ (Optional) Indicates whether Spot fleet should replace unhealthy instances. Default @false@ . -}
    , _spot_price                          :: !(TF.Attr s Text)
    {- ^ (Required) The bid price per unit hour. -}
    , _target_capacity                     :: !(TF.Attr s Text)
    {- ^ - The number of units to request. You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O. -}
    , _terminate_instances_with_expiration :: !(TF.Attr s Text)
    {- ^ - Indicates whether running Spot instances should be terminated when the Spot fleet request expires. -}
    , _valid_until                         :: !(TF.Attr s Text)
    {- ^ - The end date and time of the request, in UTC ISO8601 format (for example, YYYY-MM-DDTHH:MM:SSZ). At this point, no new Spot instance requests are placed or enabled to fulfill the request. Defaults to 24 hours. -}
    , _wait_for_fulfillment                :: !(TF.Attr s Text)
    {- ^ (Optional; Default: false) If set, Terraform will wait for the Spot Request to be fulfilled, and will throw an error if the timeout of 10m is reached. -}
    } deriving (Show, Eq)

instance TF.ToHCL (SpotFleetRequestResource s) where
    toHCL SpotFleetRequestResource{..} = TF.inline $ catMaybes
        [ TF.assign "allocation_strategy" <$> TF.attribute _allocation_strategy
        , TF.assign "excess_capacity_termination_policy" <$> TF.attribute _excess_capacity_termination_policy
        , TF.assign "iam_fleet_role" <$> TF.attribute _iam_fleet_role
        , TF.assign "instance_interruption_behavior" <$> TF.attribute _instance_interruption_behavior
        , TF.assign "launch_specification" <$> TF.attribute _launch_specification
        , TF.assign "replace_unhealthy_instances" <$> TF.attribute _replace_unhealthy_instances
        , TF.assign "spot_price" <$> TF.attribute _spot_price
        , TF.assign "target_capacity" <$> TF.attribute _target_capacity
        , TF.assign "terminate_instances_with_expiration" <$> TF.attribute _terminate_instances_with_expiration
        , TF.assign "valid_until" <$> TF.attribute _valid_until
        , TF.assign "wait_for_fulfillment" <$> TF.attribute _wait_for_fulfillment
        ]

instance P.HasAllocationStrategy (SpotFleetRequestResource s) (TF.Attr s Text) where
    allocationStrategy =
        lens (_allocation_strategy :: SpotFleetRequestResource s -> TF.Attr s Text)
             (\s a -> s { _allocation_strategy = a } :: SpotFleetRequestResource s)

instance P.HasExcessCapacityTerminationPolicy (SpotFleetRequestResource s) (TF.Attr s Text) where
    excessCapacityTerminationPolicy =
        lens (_excess_capacity_termination_policy :: SpotFleetRequestResource s -> TF.Attr s Text)
             (\s a -> s { _excess_capacity_termination_policy = a } :: SpotFleetRequestResource s)

instance P.HasIamFleetRole (SpotFleetRequestResource s) (TF.Attr s Text) where
    iamFleetRole =
        lens (_iam_fleet_role :: SpotFleetRequestResource s -> TF.Attr s Text)
             (\s a -> s { _iam_fleet_role = a } :: SpotFleetRequestResource s)

instance P.HasInstanceInterruptionBehavior (SpotFleetRequestResource s) (TF.Attr s Text) where
    instanceInterruptionBehavior =
        lens (_instance_interruption_behavior :: SpotFleetRequestResource s -> TF.Attr s Text)
             (\s a -> s { _instance_interruption_behavior = a } :: SpotFleetRequestResource s)

instance P.HasLaunchSpecification (SpotFleetRequestResource s) (TF.Attr s Text) where
    launchSpecification =
        lens (_launch_specification :: SpotFleetRequestResource s -> TF.Attr s Text)
             (\s a -> s { _launch_specification = a } :: SpotFleetRequestResource s)

instance P.HasReplaceUnhealthyInstances (SpotFleetRequestResource s) (TF.Attr s Text) where
    replaceUnhealthyInstances =
        lens (_replace_unhealthy_instances :: SpotFleetRequestResource s -> TF.Attr s Text)
             (\s a -> s { _replace_unhealthy_instances = a } :: SpotFleetRequestResource s)

instance P.HasSpotPrice (SpotFleetRequestResource s) (TF.Attr s Text) where
    spotPrice =
        lens (_spot_price :: SpotFleetRequestResource s -> TF.Attr s Text)
             (\s a -> s { _spot_price = a } :: SpotFleetRequestResource s)

instance P.HasTargetCapacity (SpotFleetRequestResource s) (TF.Attr s Text) where
    targetCapacity =
        lens (_target_capacity :: SpotFleetRequestResource s -> TF.Attr s Text)
             (\s a -> s { _target_capacity = a } :: SpotFleetRequestResource s)

instance P.HasTerminateInstancesWithExpiration (SpotFleetRequestResource s) (TF.Attr s Text) where
    terminateInstancesWithExpiration =
        lens (_terminate_instances_with_expiration :: SpotFleetRequestResource s -> TF.Attr s Text)
             (\s a -> s { _terminate_instances_with_expiration = a } :: SpotFleetRequestResource s)

instance P.HasValidUntil (SpotFleetRequestResource s) (TF.Attr s Text) where
    validUntil =
        lens (_valid_until :: SpotFleetRequestResource s -> TF.Attr s Text)
             (\s a -> s { _valid_until = a } :: SpotFleetRequestResource s)

instance P.HasWaitForFulfillment (SpotFleetRequestResource s) (TF.Attr s Text) where
    waitForFulfillment =
        lens (_wait_for_fulfillment :: SpotFleetRequestResource s -> TF.Attr s Text)
             (\s a -> s { _wait_for_fulfillment = a } :: SpotFleetRequestResource s)

instance P.HasComputedAllocationStrategy (SpotFleetRequestResource s) s (TF.Attr s Text) where
    computedAllocationStrategy =
        (_allocation_strategy :: SpotFleetRequestResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedExcessCapacityTerminationPolicy (SpotFleetRequestResource s) s (TF.Attr s Text) where
    computedExcessCapacityTerminationPolicy =
        (_excess_capacity_termination_policy :: SpotFleetRequestResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedIamFleetRole (SpotFleetRequestResource s) s (TF.Attr s Text) where
    computedIamFleetRole =
        (_iam_fleet_role :: SpotFleetRequestResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (SpotFleetRequestResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedInstanceInterruptionBehavior (SpotFleetRequestResource s) s (TF.Attr s Text) where
    computedInstanceInterruptionBehavior =
        (_instance_interruption_behavior :: SpotFleetRequestResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedLaunchSpecification (SpotFleetRequestResource s) s (TF.Attr s Text) where
    computedLaunchSpecification =
        (_launch_specification :: SpotFleetRequestResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedReplaceUnhealthyInstances (SpotFleetRequestResource s) s (TF.Attr s Text) where
    computedReplaceUnhealthyInstances =
        (_replace_unhealthy_instances :: SpotFleetRequestResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSpotPrice (SpotFleetRequestResource s) s (TF.Attr s Text) where
    computedSpotPrice =
        (_spot_price :: SpotFleetRequestResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSpotRequestState (SpotFleetRequestResource s) s (TF.Attr s Text) where
    computedSpotRequestState x = TF.compute (TF.refKey x) "spot_request_state"

instance P.HasComputedTargetCapacity (SpotFleetRequestResource s) s (TF.Attr s Text) where
    computedTargetCapacity =
        (_target_capacity :: SpotFleetRequestResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTerminateInstancesWithExpiration (SpotFleetRequestResource s) s (TF.Attr s Text) where
    computedTerminateInstancesWithExpiration =
        (_terminate_instances_with_expiration :: SpotFleetRequestResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedValidUntil (SpotFleetRequestResource s) s (TF.Attr s Text) where
    computedValidUntil =
        (_valid_until :: SpotFleetRequestResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedWaitForFulfillment (SpotFleetRequestResource s) s (TF.Attr s Text) where
    computedWaitForFulfillment =
        (_wait_for_fulfillment :: SpotFleetRequestResource s -> TF.Attr s Text)
            . TF.refValue

spotFleetRequestResource :: TF.Schema TF.Resource P.AWS (SpotFleetRequestResource s)
spotFleetRequestResource =
    TF.newResource "aws_spot_fleet_request" $
        SpotFleetRequestResource {
              _allocation_strategy = TF.Nil
            , _excess_capacity_termination_policy = TF.Nil
            , _iam_fleet_role = TF.Nil
            , _instance_interruption_behavior = TF.Nil
            , _launch_specification = TF.Nil
            , _replace_unhealthy_instances = TF.Nil
            , _spot_price = TF.Nil
            , _target_capacity = TF.Nil
            , _terminate_instances_with_expiration = TF.Nil
            , _valid_until = TF.Nil
            , _wait_for_fulfillment = TF.Nil
            }

{- | The @aws_spot_instance_request@ AWS resource.

Provides an EC2 Spot Instance Request resource. This allows instances to be
requested on the spot market. Terraform always creates Spot Instance
Requests with a @persistent@ type, which means that for the duration of
their lifetime, AWS will launch an instance with the configured details if
and when the spot market will accept the requested price. On destruction,
Terraform will make an attempt to terminate the associated Spot Instance if
there is one present. ~> NOTE: Because their behavior depends on the live
status of the spot market, Spot Instance Requests have a unique lifecycle
that makes them behave differently than other Terraform resources. Most
importantly: there is no guarantee that a Spot Instance exists to fulfill
the request at any given point in time. See the
<https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-spot-instances.html>
for more information.
-}
data SpotInstanceRequestResource s = SpotInstanceRequestResource {
      _block_duration_minutes         :: !(TF.Attr s Text)
    {- ^ (Optional) The required duration for the Spot instances, in minutes. This value must be a multiple of 60 (60, 120, 180, 240, 300, or 360). The duration period starts as soon as your Spot instance receives its instance ID. At the end of the duration period, Amazon EC2 marks the Spot instance for termination and provides a Spot instance termination notice, which gives the instance a two-minute warning before it terminates. Note that you can't specify an Availability Zone group or a launch group if you specify a duration. -}
    , _instance_interruption_behavior :: !(TF.Attr s Text)
    {- ^ (Optional) Indicates whether a Spot instance stops or terminates when it is interrupted. Default is @terminate@ as this is the current AWS behaviour. -}
    , _launch_group                   :: !(TF.Attr s Text)
    {- ^ (Optional) A launch group is a group of spot instances that launch together and terminate together. If left empty instances are launched and terminated individually. -}
    , _spot_price                     :: !(TF.Attr s Text)
    {- ^ (Required) The price to request on the spot market. -}
    , _spot_type                      :: !(TF.Attr s Text)
    {- ^ (Optional; Default: "persistent") If set to "one-time", after the instance is terminated, the spot request will be closed. Also, Terraform can't manage one-time spot requests, just launch them. -}
    , _wait_for_fulfillment           :: !(TF.Attr s Text)
    {- ^ (Optional; Default: false) If set, Terraform will wait for the Spot Request to be fulfilled, and will throw an error if the timeout of 10m is reached. -}
    } deriving (Show, Eq)

instance TF.ToHCL (SpotInstanceRequestResource s) where
    toHCL SpotInstanceRequestResource{..} = TF.inline $ catMaybes
        [ TF.assign "block_duration_minutes" <$> TF.attribute _block_duration_minutes
        , TF.assign "instance_interruption_behavior" <$> TF.attribute _instance_interruption_behavior
        , TF.assign "launch_group" <$> TF.attribute _launch_group
        , TF.assign "spot_price" <$> TF.attribute _spot_price
        , TF.assign "spot_type" <$> TF.attribute _spot_type
        , TF.assign "wait_for_fulfillment" <$> TF.attribute _wait_for_fulfillment
        ]

instance P.HasBlockDurationMinutes (SpotInstanceRequestResource s) (TF.Attr s Text) where
    blockDurationMinutes =
        lens (_block_duration_minutes :: SpotInstanceRequestResource s -> TF.Attr s Text)
             (\s a -> s { _block_duration_minutes = a } :: SpotInstanceRequestResource s)

instance P.HasInstanceInterruptionBehavior (SpotInstanceRequestResource s) (TF.Attr s Text) where
    instanceInterruptionBehavior =
        lens (_instance_interruption_behavior :: SpotInstanceRequestResource s -> TF.Attr s Text)
             (\s a -> s { _instance_interruption_behavior = a } :: SpotInstanceRequestResource s)

instance P.HasLaunchGroup (SpotInstanceRequestResource s) (TF.Attr s Text) where
    launchGroup =
        lens (_launch_group :: SpotInstanceRequestResource s -> TF.Attr s Text)
             (\s a -> s { _launch_group = a } :: SpotInstanceRequestResource s)

instance P.HasSpotPrice (SpotInstanceRequestResource s) (TF.Attr s Text) where
    spotPrice =
        lens (_spot_price :: SpotInstanceRequestResource s -> TF.Attr s Text)
             (\s a -> s { _spot_price = a } :: SpotInstanceRequestResource s)

instance P.HasSpotType (SpotInstanceRequestResource s) (TF.Attr s Text) where
    spotType =
        lens (_spot_type :: SpotInstanceRequestResource s -> TF.Attr s Text)
             (\s a -> s { _spot_type = a } :: SpotInstanceRequestResource s)

instance P.HasWaitForFulfillment (SpotInstanceRequestResource s) (TF.Attr s Text) where
    waitForFulfillment =
        lens (_wait_for_fulfillment :: SpotInstanceRequestResource s -> TF.Attr s Text)
             (\s a -> s { _wait_for_fulfillment = a } :: SpotInstanceRequestResource s)

instance P.HasComputedBlockDurationMinutes (SpotInstanceRequestResource s) s (TF.Attr s Text) where
    computedBlockDurationMinutes =
        (_block_duration_minutes :: SpotInstanceRequestResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (SpotInstanceRequestResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedInstanceInterruptionBehavior (SpotInstanceRequestResource s) s (TF.Attr s Text) where
    computedInstanceInterruptionBehavior =
        (_instance_interruption_behavior :: SpotInstanceRequestResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedLaunchGroup (SpotInstanceRequestResource s) s (TF.Attr s Text) where
    computedLaunchGroup =
        (_launch_group :: SpotInstanceRequestResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSpotPrice (SpotInstanceRequestResource s) s (TF.Attr s Text) where
    computedSpotPrice =
        (_spot_price :: SpotInstanceRequestResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSpotType (SpotInstanceRequestResource s) s (TF.Attr s Text) where
    computedSpotType =
        (_spot_type :: SpotInstanceRequestResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedWaitForFulfillment (SpotInstanceRequestResource s) s (TF.Attr s Text) where
    computedWaitForFulfillment =
        (_wait_for_fulfillment :: SpotInstanceRequestResource s -> TF.Attr s Text)
            . TF.refValue

spotInstanceRequestResource :: TF.Schema TF.Resource P.AWS (SpotInstanceRequestResource s)
spotInstanceRequestResource =
    TF.newResource "aws_spot_instance_request" $
        SpotInstanceRequestResource {
              _block_duration_minutes = TF.Nil
            , _instance_interruption_behavior = TF.Nil
            , _launch_group = TF.Nil
            , _spot_price = TF.Nil
            , _spot_type = TF.Nil
            , _wait_for_fulfillment = TF.Nil
            }

{- | The @aws_sqs_queue_policy@ AWS resource.

Allows you to set a policy of an SQS Queue while referencing ARN of the
queue within the policy.
-}
data SqsQueuePolicyResource s = SqsQueuePolicyResource {
      _policy    :: !(TF.Attr s Text)
    {- ^ (Required) The JSON policy for the SQS queue -}
    , _queue_url :: !(TF.Attr s Text)
    {- ^ (Required) The URL of the SQS Queue to which to attach the policy -}
    } deriving (Show, Eq)

instance TF.ToHCL (SqsQueuePolicyResource s) where
    toHCL SqsQueuePolicyResource{..} = TF.inline $ catMaybes
        [ TF.assign "policy" <$> TF.attribute _policy
        , TF.assign "queue_url" <$> TF.attribute _queue_url
        ]

instance P.HasPolicy (SqsQueuePolicyResource s) (TF.Attr s Text) where
    policy =
        lens (_policy :: SqsQueuePolicyResource s -> TF.Attr s Text)
             (\s a -> s { _policy = a } :: SqsQueuePolicyResource s)

instance P.HasQueueUrl (SqsQueuePolicyResource s) (TF.Attr s Text) where
    queueUrl =
        lens (_queue_url :: SqsQueuePolicyResource s -> TF.Attr s Text)
             (\s a -> s { _queue_url = a } :: SqsQueuePolicyResource s)

instance P.HasComputedPolicy (SqsQueuePolicyResource s) s (TF.Attr s Text) where
    computedPolicy =
        (_policy :: SqsQueuePolicyResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedQueueUrl (SqsQueuePolicyResource s) s (TF.Attr s Text) where
    computedQueueUrl =
        (_queue_url :: SqsQueuePolicyResource s -> TF.Attr s Text)
            . TF.refValue

sqsQueuePolicyResource :: TF.Schema TF.Resource P.AWS (SqsQueuePolicyResource s)
sqsQueuePolicyResource =
    TF.newResource "aws_sqs_queue_policy" $
        SqsQueuePolicyResource {
              _policy = TF.Nil
            , _queue_url = TF.Nil
            }

{- | The @aws_sqs_queue@ AWS resource.


-}
data SqsQueueResource s = SqsQueueResource {
      _content_based_deduplication       :: !(TF.Attr s Text)
    {- ^ (Optional) Enables content-based deduplication for FIFO queues. For more information, see the <http://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/FIFO-queues.html#FIFO-queues-exactly-once-processing> -}
    , _delay_seconds                     :: !(TF.Attr s Text)
    {- ^ (Optional) The time in seconds that the delivery of all messages in the queue will be delayed. An integer from 0 to 900 (15 minutes). The default for this attribute is 0 seconds. -}
    , _fifo_queue                        :: !(TF.Attr s Text)
    {- ^ (Optional) Boolean designating a FIFO queue. If not set, it defaults to @false@ making it standard. -}
    , _kms_data_key_reuse_period_seconds :: !(TF.Attr s Text)
    {- ^ (Optional) The length of time, in seconds, for which Amazon SQS can reuse a data key to encrypt or decrypt messages before calling AWS KMS again. An integer representing seconds, between 60 seconds (1 minute) and 86,400 seconds (24 hours). The default is 300 (5 minutes). -}
    , _kms_master_key_id                 :: !(TF.Attr s Text)
    {- ^ (Optional) The ID of an AWS-managed customer master key (CMK) for Amazon SQS or a custom CMK. For more information, see <http://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-server-side-encryption.html#sqs-sse-key-terms> . -}
    , _max_message_size                  :: !(TF.Attr s Text)
    {- ^ (Optional) The limit of how many bytes a message can contain before Amazon SQS rejects it. An integer from 1024 bytes (1 KiB) up to 262144 bytes (256 KiB). The default for this attribute is 262144 (256 KiB). -}
    , _message_retention_seconds         :: !(TF.Attr s Text)
    {- ^ (Optional) The number of seconds Amazon SQS retains a message. Integer representing seconds, from 60 (1 minute) to 1209600 (14 days). The default for this attribute is 345600 (4 days). -}
    , _name                              :: !(TF.Attr s Text)
    {- ^ (Optional) This is the human-readable name of the queue. If omitted, Terraform will assign a random name. -}
    , _name_prefix                       :: !(TF.Attr s Text)
    {- ^ (Optional) Creates a unique name beginning with the specified prefix. Conflicts with @name@ . -}
    , _policy                            :: !(TF.Attr s Text)
    {- ^ (Optional) The JSON policy for the SQS queue -}
    , _receive_wait_time_seconds         :: !(TF.Attr s Text)
    {- ^ (Optional) The time for which a ReceiveMessage call will wait for a message to arrive (long polling) before returning. An integer from 0 to 20 (seconds). The default for this attribute is 0, meaning that the call will return immediately. -}
    , _redrive_policy                    :: !(TF.Attr s Text)
    {- ^ (Optional) The JSON policy to set up the Dead Letter Queue, see <https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/SQSDeadLetterQueue.html> . Note: when specifying @maxReceiveCount@ , you must specify it as an integer ( @5@ ), and not a string ( @"5"@ ). -}
    , _tags                              :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the queue. -}
    , _visibility_timeout_seconds        :: !(TF.Attr s Text)
    {- ^ (Optional) The visibility timeout for the queue. An integer from 0 to 43200 (12 hours). The default for this attribute is 30. For more information about visibility timeout, see <https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/AboutVT.html> . -}
    } deriving (Show, Eq)

instance TF.ToHCL (SqsQueueResource s) where
    toHCL SqsQueueResource{..} = TF.inline $ catMaybes
        [ TF.assign "content_based_deduplication" <$> TF.attribute _content_based_deduplication
        , TF.assign "delay_seconds" <$> TF.attribute _delay_seconds
        , TF.assign "fifo_queue" <$> TF.attribute _fifo_queue
        , TF.assign "kms_data_key_reuse_period_seconds" <$> TF.attribute _kms_data_key_reuse_period_seconds
        , TF.assign "kms_master_key_id" <$> TF.attribute _kms_master_key_id
        , TF.assign "max_message_size" <$> TF.attribute _max_message_size
        , TF.assign "message_retention_seconds" <$> TF.attribute _message_retention_seconds
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "name_prefix" <$> TF.attribute _name_prefix
        , TF.assign "policy" <$> TF.attribute _policy
        , TF.assign "receive_wait_time_seconds" <$> TF.attribute _receive_wait_time_seconds
        , TF.assign "redrive_policy" <$> TF.attribute _redrive_policy
        , TF.assign "tags" <$> TF.attribute _tags
        , TF.assign "visibility_timeout_seconds" <$> TF.attribute _visibility_timeout_seconds
        ]

instance P.HasContentBasedDeduplication (SqsQueueResource s) (TF.Attr s Text) where
    contentBasedDeduplication =
        lens (_content_based_deduplication :: SqsQueueResource s -> TF.Attr s Text)
             (\s a -> s { _content_based_deduplication = a } :: SqsQueueResource s)

instance P.HasDelaySeconds (SqsQueueResource s) (TF.Attr s Text) where
    delaySeconds =
        lens (_delay_seconds :: SqsQueueResource s -> TF.Attr s Text)
             (\s a -> s { _delay_seconds = a } :: SqsQueueResource s)

instance P.HasFifoQueue (SqsQueueResource s) (TF.Attr s Text) where
    fifoQueue =
        lens (_fifo_queue :: SqsQueueResource s -> TF.Attr s Text)
             (\s a -> s { _fifo_queue = a } :: SqsQueueResource s)

instance P.HasKmsDataKeyReusePeriodSeconds (SqsQueueResource s) (TF.Attr s Text) where
    kmsDataKeyReusePeriodSeconds =
        lens (_kms_data_key_reuse_period_seconds :: SqsQueueResource s -> TF.Attr s Text)
             (\s a -> s { _kms_data_key_reuse_period_seconds = a } :: SqsQueueResource s)

instance P.HasKmsMasterKeyId (SqsQueueResource s) (TF.Attr s Text) where
    kmsMasterKeyId =
        lens (_kms_master_key_id :: SqsQueueResource s -> TF.Attr s Text)
             (\s a -> s { _kms_master_key_id = a } :: SqsQueueResource s)

instance P.HasMaxMessageSize (SqsQueueResource s) (TF.Attr s Text) where
    maxMessageSize =
        lens (_max_message_size :: SqsQueueResource s -> TF.Attr s Text)
             (\s a -> s { _max_message_size = a } :: SqsQueueResource s)

instance P.HasMessageRetentionSeconds (SqsQueueResource s) (TF.Attr s Text) where
    messageRetentionSeconds =
        lens (_message_retention_seconds :: SqsQueueResource s -> TF.Attr s Text)
             (\s a -> s { _message_retention_seconds = a } :: SqsQueueResource s)

instance P.HasName (SqsQueueResource s) (TF.Attr s Text) where
    name =
        lens (_name :: SqsQueueResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: SqsQueueResource s)

instance P.HasNamePrefix (SqsQueueResource s) (TF.Attr s Text) where
    namePrefix =
        lens (_name_prefix :: SqsQueueResource s -> TF.Attr s Text)
             (\s a -> s { _name_prefix = a } :: SqsQueueResource s)

instance P.HasPolicy (SqsQueueResource s) (TF.Attr s Text) where
    policy =
        lens (_policy :: SqsQueueResource s -> TF.Attr s Text)
             (\s a -> s { _policy = a } :: SqsQueueResource s)

instance P.HasReceiveWaitTimeSeconds (SqsQueueResource s) (TF.Attr s Text) where
    receiveWaitTimeSeconds =
        lens (_receive_wait_time_seconds :: SqsQueueResource s -> TF.Attr s Text)
             (\s a -> s { _receive_wait_time_seconds = a } :: SqsQueueResource s)

instance P.HasRedrivePolicy (SqsQueueResource s) (TF.Attr s Text) where
    redrivePolicy =
        lens (_redrive_policy :: SqsQueueResource s -> TF.Attr s Text)
             (\s a -> s { _redrive_policy = a } :: SqsQueueResource s)

instance P.HasTags (SqsQueueResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: SqsQueueResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: SqsQueueResource s)

instance P.HasVisibilityTimeoutSeconds (SqsQueueResource s) (TF.Attr s Text) where
    visibilityTimeoutSeconds =
        lens (_visibility_timeout_seconds :: SqsQueueResource s -> TF.Attr s Text)
             (\s a -> s { _visibility_timeout_seconds = a } :: SqsQueueResource s)

instance P.HasComputedArn (SqsQueueResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedContentBasedDeduplication (SqsQueueResource s) s (TF.Attr s Text) where
    computedContentBasedDeduplication =
        (_content_based_deduplication :: SqsQueueResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDelaySeconds (SqsQueueResource s) s (TF.Attr s Text) where
    computedDelaySeconds =
        (_delay_seconds :: SqsQueueResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedFifoQueue (SqsQueueResource s) s (TF.Attr s Text) where
    computedFifoQueue =
        (_fifo_queue :: SqsQueueResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (SqsQueueResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedKmsDataKeyReusePeriodSeconds (SqsQueueResource s) s (TF.Attr s Text) where
    computedKmsDataKeyReusePeriodSeconds =
        (_kms_data_key_reuse_period_seconds :: SqsQueueResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedKmsMasterKeyId (SqsQueueResource s) s (TF.Attr s Text) where
    computedKmsMasterKeyId =
        (_kms_master_key_id :: SqsQueueResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedMaxMessageSize (SqsQueueResource s) s (TF.Attr s Text) where
    computedMaxMessageSize =
        (_max_message_size :: SqsQueueResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedMessageRetentionSeconds (SqsQueueResource s) s (TF.Attr s Text) where
    computedMessageRetentionSeconds =
        (_message_retention_seconds :: SqsQueueResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (SqsQueueResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: SqsQueueResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedNamePrefix (SqsQueueResource s) s (TF.Attr s Text) where
    computedNamePrefix =
        (_name_prefix :: SqsQueueResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPolicy (SqsQueueResource s) s (TF.Attr s Text) where
    computedPolicy =
        (_policy :: SqsQueueResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedReceiveWaitTimeSeconds (SqsQueueResource s) s (TF.Attr s Text) where
    computedReceiveWaitTimeSeconds =
        (_receive_wait_time_seconds :: SqsQueueResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRedrivePolicy (SqsQueueResource s) s (TF.Attr s Text) where
    computedRedrivePolicy =
        (_redrive_policy :: SqsQueueResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (SqsQueueResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: SqsQueueResource s -> TF.Attr s P.Tags)
            . TF.refValue

instance P.HasComputedVisibilityTimeoutSeconds (SqsQueueResource s) s (TF.Attr s Text) where
    computedVisibilityTimeoutSeconds =
        (_visibility_timeout_seconds :: SqsQueueResource s -> TF.Attr s Text)
            . TF.refValue

sqsQueueResource :: TF.Schema TF.Resource P.AWS (SqsQueueResource s)
sqsQueueResource =
    TF.newResource "aws_sqs_queue" $
        SqsQueueResource {
              _content_based_deduplication = TF.Nil
            , _delay_seconds = TF.Nil
            , _fifo_queue = TF.Nil
            , _kms_data_key_reuse_period_seconds = TF.Nil
            , _kms_master_key_id = TF.Nil
            , _max_message_size = TF.Nil
            , _message_retention_seconds = TF.Nil
            , _name = TF.Nil
            , _name_prefix = TF.Nil
            , _policy = TF.Nil
            , _receive_wait_time_seconds = TF.Nil
            , _redrive_policy = TF.Nil
            , _tags = TF.Nil
            , _visibility_timeout_seconds = TF.Nil
            }

{- | The @aws_ssm_activation@ AWS resource.

Registers an on-premises server or virtual machine with Amazon EC2 so that
it can be managed using Run Command.
-}
data SsmActivationResource s = SsmActivationResource {
      _description        :: !(TF.Attr s Text)
    {- ^ (Optional) The description of the resource that you want to register. -}
    , _expiration_date    :: !(TF.Attr s Text)
    {- ^ (Optional) The date by which this activation request should expire. The default value is 24 hours. -}
    , _iam_role           :: !(TF.Attr s Text)
    {- ^ (Required) The IAM Role to attach to the managed instance. -}
    , _name               :: !(TF.Attr s Text)
    {- ^ (Optional) The default name of the registerd managed instance. -}
    , _registration_limit :: !(TF.Attr s Text)
    {- ^ (Optional) The maximum number of managed instances you want to register. The default value is 1 instance. -}
    } deriving (Show, Eq)

instance TF.ToHCL (SsmActivationResource s) where
    toHCL SsmActivationResource{..} = TF.inline $ catMaybes
        [ TF.assign "description" <$> TF.attribute _description
        , TF.assign "expiration_date" <$> TF.attribute _expiration_date
        , TF.assign "iam_role" <$> TF.attribute _iam_role
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "registration_limit" <$> TF.attribute _registration_limit
        ]

instance P.HasDescription (SsmActivationResource s) (TF.Attr s Text) where
    description =
        lens (_description :: SsmActivationResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: SsmActivationResource s)

instance P.HasExpirationDate (SsmActivationResource s) (TF.Attr s Text) where
    expirationDate =
        lens (_expiration_date :: SsmActivationResource s -> TF.Attr s Text)
             (\s a -> s { _expiration_date = a } :: SsmActivationResource s)

instance P.HasIamRole (SsmActivationResource s) (TF.Attr s Text) where
    iamRole =
        lens (_iam_role :: SsmActivationResource s -> TF.Attr s Text)
             (\s a -> s { _iam_role = a } :: SsmActivationResource s)

instance P.HasName (SsmActivationResource s) (TF.Attr s Text) where
    name =
        lens (_name :: SsmActivationResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: SsmActivationResource s)

instance P.HasRegistrationLimit (SsmActivationResource s) (TF.Attr s Text) where
    registrationLimit =
        lens (_registration_limit :: SsmActivationResource s -> TF.Attr s Text)
             (\s a -> s { _registration_limit = a } :: SsmActivationResource s)

instance P.HasComputedActivationCode (SsmActivationResource s) s (TF.Attr s Text) where
    computedActivationCode x = TF.compute (TF.refKey x) "activation_code"

instance P.HasComputedDescription (SsmActivationResource s) s (TF.Attr s Text) where
    computedDescription x = TF.compute (TF.refKey x) "description"

instance P.HasComputedExpirationDate (SsmActivationResource s) s (TF.Attr s Text) where
    computedExpirationDate x = TF.compute (TF.refKey x) "expiration_date"

instance P.HasComputedExpired (SsmActivationResource s) s (TF.Attr s Text) where
    computedExpired x = TF.compute (TF.refKey x) "expired"

instance P.HasComputedIamRole (SsmActivationResource s) s (TF.Attr s Text) where
    computedIamRole x = TF.compute (TF.refKey x) "iam_role"

instance P.HasComputedName (SsmActivationResource s) s (TF.Attr s Text) where
    computedName x = TF.compute (TF.refKey x) "name"

instance P.HasComputedRegistrationCount (SsmActivationResource s) s (TF.Attr s Text) where
    computedRegistrationCount x = TF.compute (TF.refKey x) "registration_count"

instance P.HasComputedRegistrationLimit (SsmActivationResource s) s (TF.Attr s Text) where
    computedRegistrationLimit x = TF.compute (TF.refKey x) "registration_limit"

ssmActivationResource :: TF.Schema TF.Resource P.AWS (SsmActivationResource s)
ssmActivationResource =
    TF.newResource "aws_ssm_activation" $
        SsmActivationResource {
              _description = TF.Nil
            , _expiration_date = TF.Nil
            , _iam_role = TF.Nil
            , _name = TF.Nil
            , _registration_limit = TF.Nil
            }

{- | The @aws_ssm_association@ AWS resource.

Associates an SSM Document to an instance or EC2 tag.
-}
data SsmAssociationResource s = SsmAssociationResource {
      _association_name    :: !(TF.Attr s Text)
    {- ^ (Optional) The descriptive name for the association. -}
    , _document_version    :: !(TF.Attr s Text)
    {- ^ (Optional) The document version you want to associate with the target(s). Can be a specific version or the default version. -}
    , _instance_id         :: !(TF.Attr s Text)
    {- ^ (Optional) The instance ID to apply an SSM document to. -}
    , _name                :: !(TF.Attr s Text)
    {- ^ (Required) The name of the SSM document to apply. -}
    , _output_location     :: !(TF.Attr s Text)
    {- ^ (Optional) An output location block. Output Location is documented below. -}
    , _parameters          :: !(TF.Attr s Text)
    {- ^ (Optional) A block of arbitrary string parameters to pass to the SSM document. -}
    , _schedule_expression :: !(TF.Attr s Text)
    {- ^ (Optional) A cron expression when the association will be applied to the target(s). -}
    , _targets             :: !(TF.Attr s Text)
    {- ^ (Optional) A block containing the targets of the SSM association. Targets are documented below. AWS currently supports a maximum of 5 targets. -}
    } deriving (Show, Eq)

instance TF.ToHCL (SsmAssociationResource s) where
    toHCL SsmAssociationResource{..} = TF.inline $ catMaybes
        [ TF.assign "association_name" <$> TF.attribute _association_name
        , TF.assign "document_version" <$> TF.attribute _document_version
        , TF.assign "instance_id" <$> TF.attribute _instance_id
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "output_location" <$> TF.attribute _output_location
        , TF.assign "parameters" <$> TF.attribute _parameters
        , TF.assign "schedule_expression" <$> TF.attribute _schedule_expression
        , TF.assign "targets" <$> TF.attribute _targets
        ]

instance P.HasAssociationName (SsmAssociationResource s) (TF.Attr s Text) where
    associationName =
        lens (_association_name :: SsmAssociationResource s -> TF.Attr s Text)
             (\s a -> s { _association_name = a } :: SsmAssociationResource s)

instance P.HasDocumentVersion (SsmAssociationResource s) (TF.Attr s Text) where
    documentVersion =
        lens (_document_version :: SsmAssociationResource s -> TF.Attr s Text)
             (\s a -> s { _document_version = a } :: SsmAssociationResource s)

instance P.HasInstanceId (SsmAssociationResource s) (TF.Attr s Text) where
    instanceId =
        lens (_instance_id :: SsmAssociationResource s -> TF.Attr s Text)
             (\s a -> s { _instance_id = a } :: SsmAssociationResource s)

instance P.HasName (SsmAssociationResource s) (TF.Attr s Text) where
    name =
        lens (_name :: SsmAssociationResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: SsmAssociationResource s)

instance P.HasOutputLocation (SsmAssociationResource s) (TF.Attr s Text) where
    outputLocation =
        lens (_output_location :: SsmAssociationResource s -> TF.Attr s Text)
             (\s a -> s { _output_location = a } :: SsmAssociationResource s)

instance P.HasParameters (SsmAssociationResource s) (TF.Attr s Text) where
    parameters =
        lens (_parameters :: SsmAssociationResource s -> TF.Attr s Text)
             (\s a -> s { _parameters = a } :: SsmAssociationResource s)

instance P.HasScheduleExpression (SsmAssociationResource s) (TF.Attr s Text) where
    scheduleExpression =
        lens (_schedule_expression :: SsmAssociationResource s -> TF.Attr s Text)
             (\s a -> s { _schedule_expression = a } :: SsmAssociationResource s)

instance P.HasTargets (SsmAssociationResource s) (TF.Attr s Text) where
    targets =
        lens (_targets :: SsmAssociationResource s -> TF.Attr s Text)
             (\s a -> s { _targets = a } :: SsmAssociationResource s)

instance P.HasComputedAssociationName (SsmAssociationResource s) s (TF.Attr s Text) where
    computedAssociationName =
        (_association_name :: SsmAssociationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDocumentVersion (SsmAssociationResource s) s (TF.Attr s Text) where
    computedDocumentVersion =
        (_document_version :: SsmAssociationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedInstanceId (SsmAssociationResource s) s (TF.Attr s Text) where
    computedInstanceId =
        (_instance_id :: SsmAssociationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedInstanceIds (SsmAssociationResource s) s (TF.Attr s Text) where
    computedInstanceIds x = TF.compute (TF.refKey x) "instance_ids"

instance P.HasComputedName (SsmAssociationResource s) s (TF.Attr s Text) where
    computedName x = TF.compute (TF.refKey x) "name"

instance P.HasComputedOutputLocation (SsmAssociationResource s) s (TF.Attr s Text) where
    computedOutputLocation =
        (_output_location :: SsmAssociationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedParameters (SsmAssociationResource s) s (TF.Attr s Text) where
    computedParameters x = TF.compute (TF.refKey x) "parameters"

instance P.HasComputedScheduleExpression (SsmAssociationResource s) s (TF.Attr s Text) where
    computedScheduleExpression =
        (_schedule_expression :: SsmAssociationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTargets (SsmAssociationResource s) s (TF.Attr s Text) where
    computedTargets =
        (_targets :: SsmAssociationResource s -> TF.Attr s Text)
            . TF.refValue

ssmAssociationResource :: TF.Schema TF.Resource P.AWS (SsmAssociationResource s)
ssmAssociationResource =
    TF.newResource "aws_ssm_association" $
        SsmAssociationResource {
              _association_name = TF.Nil
            , _document_version = TF.Nil
            , _instance_id = TF.Nil
            , _name = TF.Nil
            , _output_location = TF.Nil
            , _parameters = TF.Nil
            , _schedule_expression = TF.Nil
            , _targets = TF.Nil
            }

{- | The @aws_ssm_document@ AWS resource.

Provides an SSM Document resource ~> NOTE on updating SSM documents: Only
documents with a schema version of 2.0 or greater can update their content
once created, see
<http://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-ssm-docs.html#document-schemas-features>
. To update a document with an older schema version you must recreate the
resource.
-}
data SsmDocumentResource s = SsmDocumentResource {
      _content       :: !(TF.Attr s Text)
    {- ^ (Required) The json content of the document. -}
    , _document_type :: !(TF.Attr s Text)
    {- ^ (Required) The type of the document. Valid document types include: @Command@ , @Policy@ and @Automation@ -}
    , _name          :: !(TF.Attr s Text)
    {- ^ (Required) The name of the document. -}
    , _permissions   :: !(TF.Attr s Text)
    {- ^ (Optional) Additional Permissions to attach to the document. See <#permissions> below for details. -}
    } deriving (Show, Eq)

instance TF.ToHCL (SsmDocumentResource s) where
    toHCL SsmDocumentResource{..} = TF.inline $ catMaybes
        [ TF.assign "content" <$> TF.attribute _content
        , TF.assign "document_type" <$> TF.attribute _document_type
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "permissions" <$> TF.attribute _permissions
        ]

instance P.HasContent (SsmDocumentResource s) (TF.Attr s Text) where
    content =
        lens (_content :: SsmDocumentResource s -> TF.Attr s Text)
             (\s a -> s { _content = a } :: SsmDocumentResource s)

instance P.HasDocumentType (SsmDocumentResource s) (TF.Attr s Text) where
    documentType =
        lens (_document_type :: SsmDocumentResource s -> TF.Attr s Text)
             (\s a -> s { _document_type = a } :: SsmDocumentResource s)

instance P.HasName (SsmDocumentResource s) (TF.Attr s Text) where
    name =
        lens (_name :: SsmDocumentResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: SsmDocumentResource s)

instance P.HasPermissions (SsmDocumentResource s) (TF.Attr s Text) where
    permissions =
        lens (_permissions :: SsmDocumentResource s -> TF.Attr s Text)
             (\s a -> s { _permissions = a } :: SsmDocumentResource s)

instance P.HasComputedContent (SsmDocumentResource s) s (TF.Attr s Text) where
    computedContent x = TF.compute (TF.refKey x) "content"

instance P.HasComputedCreatedDate (SsmDocumentResource s) s (TF.Attr s Text) where
    computedCreatedDate x = TF.compute (TF.refKey x) "created_date"

instance P.HasComputedDefaultVersion (SsmDocumentResource s) s (TF.Attr s Text) where
    computedDefaultVersion x = TF.compute (TF.refKey x) "default_version"

instance P.HasComputedDescription (SsmDocumentResource s) s (TF.Attr s Text) where
    computedDescription x = TF.compute (TF.refKey x) "description"

instance P.HasComputedDocumentType (SsmDocumentResource s) s (TF.Attr s Text) where
    computedDocumentType x = TF.compute (TF.refKey x) "document_type"

instance P.HasComputedHash (SsmDocumentResource s) s (TF.Attr s Text) where
    computedHash x = TF.compute (TF.refKey x) "hash"

instance P.HasComputedHashType (SsmDocumentResource s) s (TF.Attr s Text) where
    computedHashType x = TF.compute (TF.refKey x) "hash_type"

instance P.HasComputedLatestVersion (SsmDocumentResource s) s (TF.Attr s Text) where
    computedLatestVersion x = TF.compute (TF.refKey x) "latest_version"

instance P.HasComputedName (SsmDocumentResource s) s (TF.Attr s Text) where
    computedName x = TF.compute (TF.refKey x) "name"

instance P.HasComputedOwner (SsmDocumentResource s) s (TF.Attr s Text) where
    computedOwner x = TF.compute (TF.refKey x) "owner"

instance P.HasComputedParameter (SsmDocumentResource s) s (TF.Attr s Text) where
    computedParameter x = TF.compute (TF.refKey x) "parameter"

instance P.HasComputedPermissions (SsmDocumentResource s) s (TF.Attr s Text) where
    computedPermissions x = TF.compute (TF.refKey x) "permissions"

instance P.HasComputedPlatformTypes (SsmDocumentResource s) s (TF.Attr s Text) where
    computedPlatformTypes x = TF.compute (TF.refKey x) "platform_types"

instance P.HasComputedSchemaVersion (SsmDocumentResource s) s (TF.Attr s Text) where
    computedSchemaVersion x = TF.compute (TF.refKey x) "schema_version"

instance P.HasComputedStatus (SsmDocumentResource s) s (TF.Attr s Text) where
    computedStatus x = TF.compute (TF.refKey x) "status"

ssmDocumentResource :: TF.Schema TF.Resource P.AWS (SsmDocumentResource s)
ssmDocumentResource =
    TF.newResource "aws_ssm_document" $
        SsmDocumentResource {
              _content = TF.Nil
            , _document_type = TF.Nil
            , _name = TF.Nil
            , _permissions = TF.Nil
            }

{- | The @aws_ssm_maintenance_window@ AWS resource.

Provides an SSM Maintenance Window resource
-}
data SsmMaintenanceWindowResource s = SsmMaintenanceWindowResource {
      _allow_unassociated_targets :: !(TF.Attr s Text)
    {- ^ (Optional) Whether targets must be registered with the Maintenance Window before tasks can be defined for those targets. -}
    , _cutoff                     :: !(TF.Attr s Text)
    {- ^ (Required) The number of hours before the end of the Maintenance Window that Systems Manager stops scheduling new tasks for execution. -}
    , _duration                   :: !(TF.Attr s Text)
    {- ^ (Required) The duration of the Maintenance Window in hours. -}
    , _name                       :: !(TF.Attr s Text)
    {- ^ (Required) The name of the maintenance window. -}
    , _schedule                   :: !(TF.Attr s Text)
    {- ^ (Required) The schedule of the Maintenance Window in the form of a <https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-maintenance-cron.html> or rate expression. -}
    } deriving (Show, Eq)

instance TF.ToHCL (SsmMaintenanceWindowResource s) where
    toHCL SsmMaintenanceWindowResource{..} = TF.inline $ catMaybes
        [ TF.assign "allow_unassociated_targets" <$> TF.attribute _allow_unassociated_targets
        , TF.assign "cutoff" <$> TF.attribute _cutoff
        , TF.assign "duration" <$> TF.attribute _duration
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "schedule" <$> TF.attribute _schedule
        ]

instance P.HasAllowUnassociatedTargets (SsmMaintenanceWindowResource s) (TF.Attr s Text) where
    allowUnassociatedTargets =
        lens (_allow_unassociated_targets :: SsmMaintenanceWindowResource s -> TF.Attr s Text)
             (\s a -> s { _allow_unassociated_targets = a } :: SsmMaintenanceWindowResource s)

instance P.HasCutoff (SsmMaintenanceWindowResource s) (TF.Attr s Text) where
    cutoff =
        lens (_cutoff :: SsmMaintenanceWindowResource s -> TF.Attr s Text)
             (\s a -> s { _cutoff = a } :: SsmMaintenanceWindowResource s)

instance P.HasDuration (SsmMaintenanceWindowResource s) (TF.Attr s Text) where
    duration =
        lens (_duration :: SsmMaintenanceWindowResource s -> TF.Attr s Text)
             (\s a -> s { _duration = a } :: SsmMaintenanceWindowResource s)

instance P.HasName (SsmMaintenanceWindowResource s) (TF.Attr s Text) where
    name =
        lens (_name :: SsmMaintenanceWindowResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: SsmMaintenanceWindowResource s)

instance P.HasSchedule (SsmMaintenanceWindowResource s) (TF.Attr s Text) where
    schedule =
        lens (_schedule :: SsmMaintenanceWindowResource s -> TF.Attr s Text)
             (\s a -> s { _schedule = a } :: SsmMaintenanceWindowResource s)

instance P.HasComputedAllowUnassociatedTargets (SsmMaintenanceWindowResource s) s (TF.Attr s Text) where
    computedAllowUnassociatedTargets =
        (_allow_unassociated_targets :: SsmMaintenanceWindowResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCutoff (SsmMaintenanceWindowResource s) s (TF.Attr s Text) where
    computedCutoff =
        (_cutoff :: SsmMaintenanceWindowResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDuration (SsmMaintenanceWindowResource s) s (TF.Attr s Text) where
    computedDuration =
        (_duration :: SsmMaintenanceWindowResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (SsmMaintenanceWindowResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (SsmMaintenanceWindowResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: SsmMaintenanceWindowResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSchedule (SsmMaintenanceWindowResource s) s (TF.Attr s Text) where
    computedSchedule =
        (_schedule :: SsmMaintenanceWindowResource s -> TF.Attr s Text)
            . TF.refValue

ssmMaintenanceWindowResource :: TF.Schema TF.Resource P.AWS (SsmMaintenanceWindowResource s)
ssmMaintenanceWindowResource =
    TF.newResource "aws_ssm_maintenance_window" $
        SsmMaintenanceWindowResource {
              _allow_unassociated_targets = TF.Nil
            , _cutoff = TF.Nil
            , _duration = TF.Nil
            , _name = TF.Nil
            , _schedule = TF.Nil
            }

{- | The @aws_ssm_maintenance_window_target@ AWS resource.

Provides an SSM Maintenance Window Target resource
-}
data SsmMaintenanceWindowTargetResource s = SsmMaintenanceWindowTargetResource {
      _owner_information :: !(TF.Attr s Text)
    {- ^ (Optional) User-provided value that will be included in any CloudWatch events raised while running tasks for these targets in this Maintenance Window. -}
    , _resource_type     :: !(TF.Attr s Text)
    {- ^ (Required) The type of target being registered with the Maintenance Window. Possible values @INSTANCE@ . -}
    , _targets           :: !(TF.Attr s Text)
    {- ^ (Required) The targets (either instances or tags). Instances are specified using Key=instanceids,Values=instanceid1,instanceid2. Tags are specified using Key=tag name,Values=tag value. -}
    , _window_id         :: !(TF.Attr s Text)
    {- ^ (Required) The Id of the maintenance window to register the target with. -}
    } deriving (Show, Eq)

instance TF.ToHCL (SsmMaintenanceWindowTargetResource s) where
    toHCL SsmMaintenanceWindowTargetResource{..} = TF.inline $ catMaybes
        [ TF.assign "owner_information" <$> TF.attribute _owner_information
        , TF.assign "resource_type" <$> TF.attribute _resource_type
        , TF.assign "targets" <$> TF.attribute _targets
        , TF.assign "window_id" <$> TF.attribute _window_id
        ]

instance P.HasOwnerInformation (SsmMaintenanceWindowTargetResource s) (TF.Attr s Text) where
    ownerInformation =
        lens (_owner_information :: SsmMaintenanceWindowTargetResource s -> TF.Attr s Text)
             (\s a -> s { _owner_information = a } :: SsmMaintenanceWindowTargetResource s)

instance P.HasResourceType (SsmMaintenanceWindowTargetResource s) (TF.Attr s Text) where
    resourceType =
        lens (_resource_type :: SsmMaintenanceWindowTargetResource s -> TF.Attr s Text)
             (\s a -> s { _resource_type = a } :: SsmMaintenanceWindowTargetResource s)

instance P.HasTargets (SsmMaintenanceWindowTargetResource s) (TF.Attr s Text) where
    targets =
        lens (_targets :: SsmMaintenanceWindowTargetResource s -> TF.Attr s Text)
             (\s a -> s { _targets = a } :: SsmMaintenanceWindowTargetResource s)

instance P.HasWindowId (SsmMaintenanceWindowTargetResource s) (TF.Attr s Text) where
    windowId =
        lens (_window_id :: SsmMaintenanceWindowTargetResource s -> TF.Attr s Text)
             (\s a -> s { _window_id = a } :: SsmMaintenanceWindowTargetResource s)

instance P.HasComputedId (SsmMaintenanceWindowTargetResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedOwnerInformation (SsmMaintenanceWindowTargetResource s) s (TF.Attr s Text) where
    computedOwnerInformation =
        (_owner_information :: SsmMaintenanceWindowTargetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedResourceType (SsmMaintenanceWindowTargetResource s) s (TF.Attr s Text) where
    computedResourceType =
        (_resource_type :: SsmMaintenanceWindowTargetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTargets (SsmMaintenanceWindowTargetResource s) s (TF.Attr s Text) where
    computedTargets =
        (_targets :: SsmMaintenanceWindowTargetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedWindowId (SsmMaintenanceWindowTargetResource s) s (TF.Attr s Text) where
    computedWindowId =
        (_window_id :: SsmMaintenanceWindowTargetResource s -> TF.Attr s Text)
            . TF.refValue

ssmMaintenanceWindowTargetResource :: TF.Schema TF.Resource P.AWS (SsmMaintenanceWindowTargetResource s)
ssmMaintenanceWindowTargetResource =
    TF.newResource "aws_ssm_maintenance_window_target" $
        SsmMaintenanceWindowTargetResource {
              _owner_information = TF.Nil
            , _resource_type = TF.Nil
            , _targets = TF.Nil
            , _window_id = TF.Nil
            }

{- | The @aws_ssm_maintenance_window_task@ AWS resource.

Provides an SSM Maintenance Window Task resource
-}
data SsmMaintenanceWindowTaskResource s = SsmMaintenanceWindowTaskResource {
      _logging_info     :: !(TF.Attr s Text)
    {- ^ (Optional) A structure containing information about an Amazon S3 bucket to write instance-level logs to. Documented below. -}
    , _max_concurrency  :: !(TF.Attr s Text)
    {- ^ (Required) The maximum number of targets this task can be run for in parallel. -}
    , _max_errors       :: !(TF.Attr s Text)
    {- ^ (Required) The maximum number of errors allowed before this task stops being scheduled. -}
    , _priority         :: !(TF.Attr s Text)
    {- ^ (Optional) The priority of the task in the Maintenance Window, the lower the number the higher the priority. Tasks in a Maintenance Window are scheduled in priority order with tasks that have the same priority scheduled in parallel. -}
    , _service_role_arn :: !(TF.Attr s Text)
    {- ^ (Required) The role that should be assumed when executing the task. -}
    , _targets          :: !(TF.Attr s Text)
    {- ^ (Required) The targets (either instances or window target ids). Instances are specified using Key=InstanceIds,Values=instanceid1,instanceid2. Window target ids are specified using Key=WindowTargetIds,Values=window target id1, window target id2. -}
    , _task_arn         :: !(TF.Attr s Text)
    {- ^ (Required) The ARN of the task to execute. -}
    , _task_parameters  :: !(TF.Attr s Text)
    {- ^ (Optional) A structure containing information about parameters required by the particular @task_arn@ . Documented below. -}
    , _task_type        :: !(TF.Attr s Text)
    {- ^ (Required) The type of task being registered. The only allowed value is @RUN_COMMAND@ . -}
    , _window_id        :: !(TF.Attr s Text)
    {- ^ (Required) The Id of the maintenance window to register the task with. -}
    } deriving (Show, Eq)

instance TF.ToHCL (SsmMaintenanceWindowTaskResource s) where
    toHCL SsmMaintenanceWindowTaskResource{..} = TF.inline $ catMaybes
        [ TF.assign "logging_info" <$> TF.attribute _logging_info
        , TF.assign "max_concurrency" <$> TF.attribute _max_concurrency
        , TF.assign "max_errors" <$> TF.attribute _max_errors
        , TF.assign "priority" <$> TF.attribute _priority
        , TF.assign "service_role_arn" <$> TF.attribute _service_role_arn
        , TF.assign "targets" <$> TF.attribute _targets
        , TF.assign "task_arn" <$> TF.attribute _task_arn
        , TF.assign "task_parameters" <$> TF.attribute _task_parameters
        , TF.assign "task_type" <$> TF.attribute _task_type
        , TF.assign "window_id" <$> TF.attribute _window_id
        ]

instance P.HasLoggingInfo (SsmMaintenanceWindowTaskResource s) (TF.Attr s Text) where
    loggingInfo =
        lens (_logging_info :: SsmMaintenanceWindowTaskResource s -> TF.Attr s Text)
             (\s a -> s { _logging_info = a } :: SsmMaintenanceWindowTaskResource s)

instance P.HasMaxConcurrency (SsmMaintenanceWindowTaskResource s) (TF.Attr s Text) where
    maxConcurrency =
        lens (_max_concurrency :: SsmMaintenanceWindowTaskResource s -> TF.Attr s Text)
             (\s a -> s { _max_concurrency = a } :: SsmMaintenanceWindowTaskResource s)

instance P.HasMaxErrors (SsmMaintenanceWindowTaskResource s) (TF.Attr s Text) where
    maxErrors =
        lens (_max_errors :: SsmMaintenanceWindowTaskResource s -> TF.Attr s Text)
             (\s a -> s { _max_errors = a } :: SsmMaintenanceWindowTaskResource s)

instance P.HasPriority (SsmMaintenanceWindowTaskResource s) (TF.Attr s Text) where
    priority =
        lens (_priority :: SsmMaintenanceWindowTaskResource s -> TF.Attr s Text)
             (\s a -> s { _priority = a } :: SsmMaintenanceWindowTaskResource s)

instance P.HasServiceRoleArn (SsmMaintenanceWindowTaskResource s) (TF.Attr s Text) where
    serviceRoleArn =
        lens (_service_role_arn :: SsmMaintenanceWindowTaskResource s -> TF.Attr s Text)
             (\s a -> s { _service_role_arn = a } :: SsmMaintenanceWindowTaskResource s)

instance P.HasTargets (SsmMaintenanceWindowTaskResource s) (TF.Attr s Text) where
    targets =
        lens (_targets :: SsmMaintenanceWindowTaskResource s -> TF.Attr s Text)
             (\s a -> s { _targets = a } :: SsmMaintenanceWindowTaskResource s)

instance P.HasTaskArn (SsmMaintenanceWindowTaskResource s) (TF.Attr s Text) where
    taskArn =
        lens (_task_arn :: SsmMaintenanceWindowTaskResource s -> TF.Attr s Text)
             (\s a -> s { _task_arn = a } :: SsmMaintenanceWindowTaskResource s)

instance P.HasTaskParameters (SsmMaintenanceWindowTaskResource s) (TF.Attr s Text) where
    taskParameters =
        lens (_task_parameters :: SsmMaintenanceWindowTaskResource s -> TF.Attr s Text)
             (\s a -> s { _task_parameters = a } :: SsmMaintenanceWindowTaskResource s)

instance P.HasTaskType (SsmMaintenanceWindowTaskResource s) (TF.Attr s Text) where
    taskType =
        lens (_task_type :: SsmMaintenanceWindowTaskResource s -> TF.Attr s Text)
             (\s a -> s { _task_type = a } :: SsmMaintenanceWindowTaskResource s)

instance P.HasWindowId (SsmMaintenanceWindowTaskResource s) (TF.Attr s Text) where
    windowId =
        lens (_window_id :: SsmMaintenanceWindowTaskResource s -> TF.Attr s Text)
             (\s a -> s { _window_id = a } :: SsmMaintenanceWindowTaskResource s)

instance P.HasComputedId (SsmMaintenanceWindowTaskResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedLoggingInfo (SsmMaintenanceWindowTaskResource s) s (TF.Attr s Text) where
    computedLoggingInfo =
        (_logging_info :: SsmMaintenanceWindowTaskResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedMaxConcurrency (SsmMaintenanceWindowTaskResource s) s (TF.Attr s Text) where
    computedMaxConcurrency =
        (_max_concurrency :: SsmMaintenanceWindowTaskResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedMaxErrors (SsmMaintenanceWindowTaskResource s) s (TF.Attr s Text) where
    computedMaxErrors =
        (_max_errors :: SsmMaintenanceWindowTaskResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPriority (SsmMaintenanceWindowTaskResource s) s (TF.Attr s Text) where
    computedPriority =
        (_priority :: SsmMaintenanceWindowTaskResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedServiceRoleArn (SsmMaintenanceWindowTaskResource s) s (TF.Attr s Text) where
    computedServiceRoleArn =
        (_service_role_arn :: SsmMaintenanceWindowTaskResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTargets (SsmMaintenanceWindowTaskResource s) s (TF.Attr s Text) where
    computedTargets =
        (_targets :: SsmMaintenanceWindowTaskResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTaskArn (SsmMaintenanceWindowTaskResource s) s (TF.Attr s Text) where
    computedTaskArn =
        (_task_arn :: SsmMaintenanceWindowTaskResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTaskParameters (SsmMaintenanceWindowTaskResource s) s (TF.Attr s Text) where
    computedTaskParameters =
        (_task_parameters :: SsmMaintenanceWindowTaskResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTaskType (SsmMaintenanceWindowTaskResource s) s (TF.Attr s Text) where
    computedTaskType =
        (_task_type :: SsmMaintenanceWindowTaskResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedWindowId (SsmMaintenanceWindowTaskResource s) s (TF.Attr s Text) where
    computedWindowId =
        (_window_id :: SsmMaintenanceWindowTaskResource s -> TF.Attr s Text)
            . TF.refValue

ssmMaintenanceWindowTaskResource :: TF.Schema TF.Resource P.AWS (SsmMaintenanceWindowTaskResource s)
ssmMaintenanceWindowTaskResource =
    TF.newResource "aws_ssm_maintenance_window_task" $
        SsmMaintenanceWindowTaskResource {
              _logging_info = TF.Nil
            , _max_concurrency = TF.Nil
            , _max_errors = TF.Nil
            , _priority = TF.Nil
            , _service_role_arn = TF.Nil
            , _targets = TF.Nil
            , _task_arn = TF.Nil
            , _task_parameters = TF.Nil
            , _task_type = TF.Nil
            , _window_id = TF.Nil
            }

{- | The @aws_ssm_parameter@ AWS resource.

Provides an SSM Parameter resource.
-}
data SsmParameterResource s = SsmParameterResource {
      _key_id    :: !(TF.Attr s Text)
    {- ^ (Optional) The KMS key id or arn for encrypting a SecureString. -}
    , _name      :: !(TF.Attr s Text)
    {- ^ (Required) The name of the parameter. -}
    , _overwrite :: !(TF.Attr s Text)
    {- ^ (Optional) Overwrite an existing parameter. If not specified, will default to @false@ . -}
    , _type'     :: !(TF.Attr s Text)
    {- ^ (Required) The type of the parameter. Valid types are @String@ , @StringList@ and @SecureString@ . -}
    , _value     :: !(TF.Attr s Text)
    {- ^ (Required) The value of the parameter. -}
    } deriving (Show, Eq)

instance TF.ToHCL (SsmParameterResource s) where
    toHCL SsmParameterResource{..} = TF.inline $ catMaybes
        [ TF.assign "key_id" <$> TF.attribute _key_id
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "overwrite" <$> TF.attribute _overwrite
        , TF.assign "type" <$> TF.attribute _type'
        , TF.assign "value" <$> TF.attribute _value
        ]

instance P.HasKeyId (SsmParameterResource s) (TF.Attr s Text) where
    keyId =
        lens (_key_id :: SsmParameterResource s -> TF.Attr s Text)
             (\s a -> s { _key_id = a } :: SsmParameterResource s)

instance P.HasName (SsmParameterResource s) (TF.Attr s Text) where
    name =
        lens (_name :: SsmParameterResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: SsmParameterResource s)

instance P.HasOverwrite (SsmParameterResource s) (TF.Attr s Text) where
    overwrite =
        lens (_overwrite :: SsmParameterResource s -> TF.Attr s Text)
             (\s a -> s { _overwrite = a } :: SsmParameterResource s)

instance P.HasType' (SsmParameterResource s) (TF.Attr s Text) where
    type' =
        lens (_type' :: SsmParameterResource s -> TF.Attr s Text)
             (\s a -> s { _type' = a } :: SsmParameterResource s)

instance P.HasValue (SsmParameterResource s) (TF.Attr s Text) where
    value =
        lens (_value :: SsmParameterResource s -> TF.Attr s Text)
             (\s a -> s { _value = a } :: SsmParameterResource s)

instance P.HasComputedArn (SsmParameterResource s) s (TF.Attr s Text) where
    computedArn x = TF.compute (TF.refKey x) "arn"

instance P.HasComputedKeyId (SsmParameterResource s) s (TF.Attr s Text) where
    computedKeyId =
        (_key_id :: SsmParameterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (SsmParameterResource s) s (TF.Attr s Text) where
    computedName x = TF.compute (TF.refKey x) "name"

instance P.HasComputedOverwrite (SsmParameterResource s) s (TF.Attr s Text) where
    computedOverwrite =
        (_overwrite :: SsmParameterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedType' (SsmParameterResource s) s (TF.Attr s Text) where
    computedType' x = TF.compute (TF.refKey x) "type"

instance P.HasComputedValue (SsmParameterResource s) s (TF.Attr s Text) where
    computedValue x = TF.compute (TF.refKey x) "value"

ssmParameterResource :: TF.Schema TF.Resource P.AWS (SsmParameterResource s)
ssmParameterResource =
    TF.newResource "aws_ssm_parameter" $
        SsmParameterResource {
              _key_id = TF.Nil
            , _name = TF.Nil
            , _overwrite = TF.Nil
            , _type' = TF.Nil
            , _value = TF.Nil
            }

{- | The @aws_ssm_patch_baseline@ AWS resource.

Provides an SSM Patch Baseline resource ~> NOTE on Patch Baselines: The
@approved_patches@ and @approval_rule@ are both marked as optional fields,
but the Patch Baseline requires that at least one of them is specified.
-}
data SsmPatchBaselineResource s = SsmPatchBaselineResource {
      _approval_rule                     :: !(TF.Attr s Text)
    {- ^ (Optional) A set of rules used to include patches in the baseline. up to 10 approval rules can be specified. Each approval_rule block requires the fields documented below. -}
    , _approved_patches                  :: !(TF.Attr s Text)
    {- ^ (Optional) A list of explicitly approved patches for the baseline. -}
    , _approved_patches_compliance_level :: !(TF.Attr s Text)
    {- ^ (Optional) Defines the compliance level for approved patches. This means that if an approved patch is reported as missing, this is the severity of the compliance violation. Valid compliance levels include the following: @CRITICAL@ , @HIGH@ , @MEDIUM@ , @LOW@ , @INFORMATIONAL@ , @UNSPECIFIED@ . The default value is @UNSPECIFIED@ . -}
    , _description                       :: !(TF.Attr s Text)
    {- ^ (Optional) The description of the patch baseline. -}
    , _global_filter                     :: !(TF.Attr s Text)
    {- ^ (Optional) A set of global filters used to exclude patches from the baseline. Up to 4 global filters can be specified using Key/Value pairs. Valid Keys are @PRODUCT | CLASSIFICATION | MSRC_SEVERITY | PATCH_ID@ . -}
    , _name                              :: !(TF.Attr s Text)
    {- ^ (Required) The name of the patch baseline. -}
    , _operating_system                  :: !(TF.Attr s Text)
    {- ^ (Optional) Defines the operating system the patch baseline applies to. Supported operating systems include @WINDOWS@ , @AMAZON_LINUX@ , @UBUNTU@ and @REDHAT_ENTERPRISE_LINUX@ . The Default value is @WINDOWS@ . -}
    , _rejected_patches                  :: !(TF.Attr s Text)
    {- ^ (Optional) A list of rejected patches. -}
    } deriving (Show, Eq)

instance TF.ToHCL (SsmPatchBaselineResource s) where
    toHCL SsmPatchBaselineResource{..} = TF.inline $ catMaybes
        [ TF.assign "approval_rule" <$> TF.attribute _approval_rule
        , TF.assign "approved_patches" <$> TF.attribute _approved_patches
        , TF.assign "approved_patches_compliance_level" <$> TF.attribute _approved_patches_compliance_level
        , TF.assign "description" <$> TF.attribute _description
        , TF.assign "global_filter" <$> TF.attribute _global_filter
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "operating_system" <$> TF.attribute _operating_system
        , TF.assign "rejected_patches" <$> TF.attribute _rejected_patches
        ]

instance P.HasApprovalRule (SsmPatchBaselineResource s) (TF.Attr s Text) where
    approvalRule =
        lens (_approval_rule :: SsmPatchBaselineResource s -> TF.Attr s Text)
             (\s a -> s { _approval_rule = a } :: SsmPatchBaselineResource s)

instance P.HasApprovedPatches (SsmPatchBaselineResource s) (TF.Attr s Text) where
    approvedPatches =
        lens (_approved_patches :: SsmPatchBaselineResource s -> TF.Attr s Text)
             (\s a -> s { _approved_patches = a } :: SsmPatchBaselineResource s)

instance P.HasApprovedPatchesComplianceLevel (SsmPatchBaselineResource s) (TF.Attr s Text) where
    approvedPatchesComplianceLevel =
        lens (_approved_patches_compliance_level :: SsmPatchBaselineResource s -> TF.Attr s Text)
             (\s a -> s { _approved_patches_compliance_level = a } :: SsmPatchBaselineResource s)

instance P.HasDescription (SsmPatchBaselineResource s) (TF.Attr s Text) where
    description =
        lens (_description :: SsmPatchBaselineResource s -> TF.Attr s Text)
             (\s a -> s { _description = a } :: SsmPatchBaselineResource s)

instance P.HasGlobalFilter (SsmPatchBaselineResource s) (TF.Attr s Text) where
    globalFilter =
        lens (_global_filter :: SsmPatchBaselineResource s -> TF.Attr s Text)
             (\s a -> s { _global_filter = a } :: SsmPatchBaselineResource s)

instance P.HasName (SsmPatchBaselineResource s) (TF.Attr s Text) where
    name =
        lens (_name :: SsmPatchBaselineResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: SsmPatchBaselineResource s)

instance P.HasOperatingSystem (SsmPatchBaselineResource s) (TF.Attr s Text) where
    operatingSystem =
        lens (_operating_system :: SsmPatchBaselineResource s -> TF.Attr s Text)
             (\s a -> s { _operating_system = a } :: SsmPatchBaselineResource s)

instance P.HasRejectedPatches (SsmPatchBaselineResource s) (TF.Attr s Text) where
    rejectedPatches =
        lens (_rejected_patches :: SsmPatchBaselineResource s -> TF.Attr s Text)
             (\s a -> s { _rejected_patches = a } :: SsmPatchBaselineResource s)

instance P.HasComputedApprovalRule (SsmPatchBaselineResource s) s (TF.Attr s Text) where
    computedApprovalRule =
        (_approval_rule :: SsmPatchBaselineResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedApprovedPatches (SsmPatchBaselineResource s) s (TF.Attr s Text) where
    computedApprovedPatches =
        (_approved_patches :: SsmPatchBaselineResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedApprovedPatchesComplianceLevel (SsmPatchBaselineResource s) s (TF.Attr s Text) where
    computedApprovedPatchesComplianceLevel =
        (_approved_patches_compliance_level :: SsmPatchBaselineResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDescription (SsmPatchBaselineResource s) s (TF.Attr s Text) where
    computedDescription =
        (_description :: SsmPatchBaselineResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedGlobalFilter (SsmPatchBaselineResource s) s (TF.Attr s Text) where
    computedGlobalFilter =
        (_global_filter :: SsmPatchBaselineResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (SsmPatchBaselineResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (SsmPatchBaselineResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: SsmPatchBaselineResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedOperatingSystem (SsmPatchBaselineResource s) s (TF.Attr s Text) where
    computedOperatingSystem =
        (_operating_system :: SsmPatchBaselineResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRejectedPatches (SsmPatchBaselineResource s) s (TF.Attr s Text) where
    computedRejectedPatches =
        (_rejected_patches :: SsmPatchBaselineResource s -> TF.Attr s Text)
            . TF.refValue

ssmPatchBaselineResource :: TF.Schema TF.Resource P.AWS (SsmPatchBaselineResource s)
ssmPatchBaselineResource =
    TF.newResource "aws_ssm_patch_baseline" $
        SsmPatchBaselineResource {
              _approval_rule = TF.Nil
            , _approved_patches = TF.Nil
            , _approved_patches_compliance_level = TF.Nil
            , _description = TF.Nil
            , _global_filter = TF.Nil
            , _name = TF.Nil
            , _operating_system = TF.Nil
            , _rejected_patches = TF.Nil
            }

{- | The @aws_ssm_patch_group@ AWS resource.

Provides an SSM Patch Group resource
-}
data SsmPatchGroupResource s = SsmPatchGroupResource {
      _baseline_id :: !(TF.Attr s Text)
    {- ^ (Required) The ID of the patch baseline to register the patch group with. -}
    , _patch_group :: !(TF.Attr s Text)
    {- ^ (Required) The name of the patch group that should be registered with the patch baseline. -}
    } deriving (Show, Eq)

instance TF.ToHCL (SsmPatchGroupResource s) where
    toHCL SsmPatchGroupResource{..} = TF.inline $ catMaybes
        [ TF.assign "baseline_id" <$> TF.attribute _baseline_id
        , TF.assign "patch_group" <$> TF.attribute _patch_group
        ]

instance P.HasBaselineId (SsmPatchGroupResource s) (TF.Attr s Text) where
    baselineId =
        lens (_baseline_id :: SsmPatchGroupResource s -> TF.Attr s Text)
             (\s a -> s { _baseline_id = a } :: SsmPatchGroupResource s)

instance P.HasPatchGroup (SsmPatchGroupResource s) (TF.Attr s Text) where
    patchGroup =
        lens (_patch_group :: SsmPatchGroupResource s -> TF.Attr s Text)
             (\s a -> s { _patch_group = a } :: SsmPatchGroupResource s)

instance P.HasComputedBaselineId (SsmPatchGroupResource s) s (TF.Attr s Text) where
    computedBaselineId =
        (_baseline_id :: SsmPatchGroupResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (SsmPatchGroupResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedPatchGroup (SsmPatchGroupResource s) s (TF.Attr s Text) where
    computedPatchGroup =
        (_patch_group :: SsmPatchGroupResource s -> TF.Attr s Text)
            . TF.refValue

ssmPatchGroupResource :: TF.Schema TF.Resource P.AWS (SsmPatchGroupResource s)
ssmPatchGroupResource =
    TF.newResource "aws_ssm_patch_group" $
        SsmPatchGroupResource {
              _baseline_id = TF.Nil
            , _patch_group = TF.Nil
            }

{- | The @sfn_state_machine@ AWS resource.

Provides a Step Function State Machine resource
-}
data StateMachineResource s = StateMachineResource {
      _definition :: !(TF.Attr s Text)
    {- ^ (Required) The Amazon States Language definition of the state machine. -}
    , _name       :: !(TF.Attr s Text)
    {- ^ (Required) The name of the state machine. -}
    , _role_arn   :: !(TF.Attr s Text)
    {- ^ (Required) The Amazon Resource Name (ARN) of the IAM role to use for this state machine. -}
    } deriving (Show, Eq)

instance TF.ToHCL (StateMachineResource s) where
    toHCL StateMachineResource{..} = TF.inline $ catMaybes
        [ TF.assign "definition" <$> TF.attribute _definition
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "role_arn" <$> TF.attribute _role_arn
        ]

instance P.HasDefinition (StateMachineResource s) (TF.Attr s Text) where
    definition =
        lens (_definition :: StateMachineResource s -> TF.Attr s Text)
             (\s a -> s { _definition = a } :: StateMachineResource s)

instance P.HasName (StateMachineResource s) (TF.Attr s Text) where
    name =
        lens (_name :: StateMachineResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: StateMachineResource s)

instance P.HasRoleArn (StateMachineResource s) (TF.Attr s Text) where
    roleArn =
        lens (_role_arn :: StateMachineResource s -> TF.Attr s Text)
             (\s a -> s { _role_arn = a } :: StateMachineResource s)

instance P.HasComputedCreationDate (StateMachineResource s) s (TF.Attr s Text) where
    computedCreationDate x = TF.compute (TF.refKey x) "creation_date"

instance P.HasComputedDefinition (StateMachineResource s) s (TF.Attr s Text) where
    computedDefinition =
        (_definition :: StateMachineResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (StateMachineResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (StateMachineResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: StateMachineResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRoleArn (StateMachineResource s) s (TF.Attr s Text) where
    computedRoleArn =
        (_role_arn :: StateMachineResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedStatus (StateMachineResource s) s (TF.Attr s Text) where
    computedStatus x = TF.compute (TF.refKey x) "status"

stateMachineResource :: TF.Schema TF.Resource P.AWS (StateMachineResource s)
stateMachineResource =
    TF.newResource "sfn_state_machine" $
        StateMachineResource {
              _definition = TF.Nil
            , _name = TF.Nil
            , _role_arn = TF.Nil
            }

{- | The @aws_subnet@ AWS resource.

Provides an VPC subnet resource.
-}
data SubnetResource s = SubnetResource {
      _assign_ipv6_address_on_creation :: !(TF.Attr s Text)
    {- ^ (Optional) Specify true to indicate that network interfaces created in the specified subnet should be assigned an IPv6 address. Default is @false@ -}
    , _availability_zone               :: !(TF.Attr s P.Zone)
    {- ^ (Optional) The AZ for the subnet. -}
    , _cidr_block                      :: !(TF.Attr s P.CIDR)
    {- ^ (Required) The CIDR block for the subnet. -}
    , _ipv6_cidr_block                 :: !(TF.Attr s P.CIDR)
    {- ^ (Optional) The IPv6 network range for the subnet, in CIDR notation. The subnet size must use a /64 prefix length. -}
    , _map_public_ip_on_launch         :: !(TF.Attr s Text)
    {- ^ -  (Optional) Specify true to indicate that instances launched into the subnet should be assigned a public IP address. Default is @false@ . -}
    , _tags                            :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    , _vpc_id                          :: !(TF.Attr s Text)
    {- ^ (Required) The VPC ID. -}
    } deriving (Show, Eq)

instance TF.ToHCL (SubnetResource s) where
    toHCL SubnetResource{..} = TF.inline $ catMaybes
        [ TF.assign "assign_ipv6_address_on_creation" <$> TF.attribute _assign_ipv6_address_on_creation
        , TF.assign "availability_zone" <$> TF.attribute _availability_zone
        , TF.assign "cidr_block" <$> TF.attribute _cidr_block
        , TF.assign "ipv6_cidr_block" <$> TF.attribute _ipv6_cidr_block
        , TF.assign "map_public_ip_on_launch" <$> TF.attribute _map_public_ip_on_launch
        , TF.assign "tags" <$> TF.attribute _tags
        , TF.assign "vpc_id" <$> TF.attribute _vpc_id
        ]

instance P.HasAssignIpv6AddressOnCreation (SubnetResource s) (TF.Attr s Text) where
    assignIpv6AddressOnCreation =
        lens (_assign_ipv6_address_on_creation :: SubnetResource s -> TF.Attr s Text)
             (\s a -> s { _assign_ipv6_address_on_creation = a } :: SubnetResource s)

instance P.HasAvailabilityZone (SubnetResource s) (TF.Attr s P.Zone) where
    availabilityZone =
        lens (_availability_zone :: SubnetResource s -> TF.Attr s P.Zone)
             (\s a -> s { _availability_zone = a } :: SubnetResource s)

instance P.HasCidrBlock (SubnetResource s) (TF.Attr s P.CIDR) where
    cidrBlock =
        lens (_cidr_block :: SubnetResource s -> TF.Attr s P.CIDR)
             (\s a -> s { _cidr_block = a } :: SubnetResource s)

instance P.HasIpv6CidrBlock (SubnetResource s) (TF.Attr s P.CIDR) where
    ipv6CidrBlock =
        lens (_ipv6_cidr_block :: SubnetResource s -> TF.Attr s P.CIDR)
             (\s a -> s { _ipv6_cidr_block = a } :: SubnetResource s)

instance P.HasMapPublicIpOnLaunch (SubnetResource s) (TF.Attr s Text) where
    mapPublicIpOnLaunch =
        lens (_map_public_ip_on_launch :: SubnetResource s -> TF.Attr s Text)
             (\s a -> s { _map_public_ip_on_launch = a } :: SubnetResource s)

instance P.HasTags (SubnetResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: SubnetResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: SubnetResource s)

instance P.HasVpcId (SubnetResource s) (TF.Attr s Text) where
    vpcId =
        lens (_vpc_id :: SubnetResource s -> TF.Attr s Text)
             (\s a -> s { _vpc_id = a } :: SubnetResource s)

instance P.HasComputedAssignIpv6AddressOnCreation (SubnetResource s) s (TF.Attr s Text) where
    computedAssignIpv6AddressOnCreation =
        (_assign_ipv6_address_on_creation :: SubnetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAvailabilityZone (SubnetResource s) s (TF.Attr s P.Zone) where
    computedAvailabilityZone x = TF.compute (TF.refKey x) "availability_zone"

instance P.HasComputedCidrBlock (SubnetResource s) s (TF.Attr s P.CIDR) where
    computedCidrBlock x = TF.compute (TF.refKey x) "cidr_block"

instance P.HasComputedId (SubnetResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedIpv6AssociationId (SubnetResource s) s (TF.Attr s Text) where
    computedIpv6AssociationId x = TF.compute (TF.refKey x) "ipv6_association_id"

instance P.HasComputedIpv6CidrBlock (SubnetResource s) s (TF.Attr s P.CIDR) where
    computedIpv6CidrBlock x = TF.compute (TF.refKey x) "ipv6_cidr_block"

instance P.HasComputedMapPublicIpOnLaunch (SubnetResource s) s (TF.Attr s Text) where
    computedMapPublicIpOnLaunch =
        (_map_public_ip_on_launch :: SubnetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (SubnetResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: SubnetResource s -> TF.Attr s P.Tags)
            . TF.refValue

instance P.HasComputedVpcId (SubnetResource s) s (TF.Attr s Text) where
    computedVpcId x = TF.compute (TF.refKey x) "vpc_id"

subnetResource :: TF.Schema TF.Resource P.AWS (SubnetResource s)
subnetResource =
    TF.newResource "aws_subnet" $
        SubnetResource {
              _assign_ipv6_address_on_creation = TF.Nil
            , _availability_zone = TF.Nil
            , _cidr_block = TF.Nil
            , _ipv6_cidr_block = TF.Nil
            , _map_public_ip_on_launch = TF.Nil
            , _tags = TF.Nil
            , _vpc_id = TF.Nil
            }

{- | The @aws_volume_attachment@ AWS resource.

Provides an AWS EBS Volume Attachment as a top level resource, to attach and
detach volumes from AWS Instances. ~> NOTE on EBS block devices: If you use
@ebs_block_device@ on an @aws_instance@ , Terraform will assume management
over the full set of non-root EBS block devices for the instance, and treats
additional block devices as drift. For this reason, @ebs_block_device@
cannot be mixed with external @aws_ebs_volume@ + @aws_ebs_volume_attachment@
resources for a given instance.
-}
data VolumeAttachmentResource s = VolumeAttachmentResource {
      _device_name  :: !(TF.Attr s Text)
    {- ^ (Required) The device name to expose to the instance (for example, @/dev/sdh@ or @xvdh@ ) -}
    , _force_detach :: !(TF.Attr s Text)
    {- ^ (Optional, Boolean) Set to @true@ if you want to force the volume to detach. Useful if previous attempts failed, but use this option only as a last resort, as this can result in data loss . See <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-detaching-volume.html> for more information. -}
    , _instance_id  :: !(TF.Attr s Text)
    {- ^ (Required) ID of the Instance to attach to -}
    , _skip_destroy :: !(TF.Attr s Text)
    {- ^ (Optional, Boolean) Set this to true if you do not wish to detach the volume from the instance to which it is attached at destroy time, and instead just remove the attachment from Terraform state. This is useful when destroying an instance which has volumes created by some other means attached. -}
    , _volume_id    :: !(TF.Attr s Text)
    {- ^ (Required) ID of the Volume to be attached -}
    } deriving (Show, Eq)

instance TF.ToHCL (VolumeAttachmentResource s) where
    toHCL VolumeAttachmentResource{..} = TF.inline $ catMaybes
        [ TF.assign "device_name" <$> TF.attribute _device_name
        , TF.assign "force_detach" <$> TF.attribute _force_detach
        , TF.assign "instance_id" <$> TF.attribute _instance_id
        , TF.assign "skip_destroy" <$> TF.attribute _skip_destroy
        , TF.assign "volume_id" <$> TF.attribute _volume_id
        ]

instance P.HasDeviceName (VolumeAttachmentResource s) (TF.Attr s Text) where
    deviceName =
        lens (_device_name :: VolumeAttachmentResource s -> TF.Attr s Text)
             (\s a -> s { _device_name = a } :: VolumeAttachmentResource s)

instance P.HasForceDetach (VolumeAttachmentResource s) (TF.Attr s Text) where
    forceDetach =
        lens (_force_detach :: VolumeAttachmentResource s -> TF.Attr s Text)
             (\s a -> s { _force_detach = a } :: VolumeAttachmentResource s)

instance P.HasInstanceId (VolumeAttachmentResource s) (TF.Attr s Text) where
    instanceId =
        lens (_instance_id :: VolumeAttachmentResource s -> TF.Attr s Text)
             (\s a -> s { _instance_id = a } :: VolumeAttachmentResource s)

instance P.HasSkipDestroy (VolumeAttachmentResource s) (TF.Attr s Text) where
    skipDestroy =
        lens (_skip_destroy :: VolumeAttachmentResource s -> TF.Attr s Text)
             (\s a -> s { _skip_destroy = a } :: VolumeAttachmentResource s)

instance P.HasVolumeId (VolumeAttachmentResource s) (TF.Attr s Text) where
    volumeId =
        lens (_volume_id :: VolumeAttachmentResource s -> TF.Attr s Text)
             (\s a -> s { _volume_id = a } :: VolumeAttachmentResource s)

instance P.HasComputedDeviceName (VolumeAttachmentResource s) s (TF.Attr s Text) where
    computedDeviceName x = TF.compute (TF.refKey x) "device_name"

instance P.HasComputedForceDetach (VolumeAttachmentResource s) s (TF.Attr s Text) where
    computedForceDetach =
        (_force_detach :: VolumeAttachmentResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedInstanceId (VolumeAttachmentResource s) s (TF.Attr s Text) where
    computedInstanceId x = TF.compute (TF.refKey x) "instance_id"

instance P.HasComputedSkipDestroy (VolumeAttachmentResource s) s (TF.Attr s Text) where
    computedSkipDestroy =
        (_skip_destroy :: VolumeAttachmentResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedVolumeId (VolumeAttachmentResource s) s (TF.Attr s Text) where
    computedVolumeId x = TF.compute (TF.refKey x) "volume_id"

volumeAttachmentResource :: TF.Schema TF.Resource P.AWS (VolumeAttachmentResource s)
volumeAttachmentResource =
    TF.newResource "aws_volume_attachment" $
        VolumeAttachmentResource {
              _device_name = TF.Nil
            , _force_detach = TF.Nil
            , _instance_id = TF.Nil
            , _skip_destroy = TF.Nil
            , _volume_id = TF.Nil
            }

{- | The @aws_vpc_dhcp_options_association@ AWS resource.

Provides a VPC DHCP Options Association resource.
-}
data VpcDhcpOptionsAssociationResource s = VpcDhcpOptionsAssociationResource {
      _dhcp_options_id :: !(TF.Attr s Text)
    {- ^ (Required) The ID of the DHCP Options Set to associate to the VPC. -}
    , _vpc_id          :: !(TF.Attr s Text)
    {- ^ (Required) The ID of the VPC to which we would like to associate a DHCP Options Set. -}
    } deriving (Show, Eq)

instance TF.ToHCL (VpcDhcpOptionsAssociationResource s) where
    toHCL VpcDhcpOptionsAssociationResource{..} = TF.inline $ catMaybes
        [ TF.assign "dhcp_options_id" <$> TF.attribute _dhcp_options_id
        , TF.assign "vpc_id" <$> TF.attribute _vpc_id
        ]

instance P.HasDhcpOptionsId (VpcDhcpOptionsAssociationResource s) (TF.Attr s Text) where
    dhcpOptionsId =
        lens (_dhcp_options_id :: VpcDhcpOptionsAssociationResource s -> TF.Attr s Text)
             (\s a -> s { _dhcp_options_id = a } :: VpcDhcpOptionsAssociationResource s)

instance P.HasVpcId (VpcDhcpOptionsAssociationResource s) (TF.Attr s Text) where
    vpcId =
        lens (_vpc_id :: VpcDhcpOptionsAssociationResource s -> TF.Attr s Text)
             (\s a -> s { _vpc_id = a } :: VpcDhcpOptionsAssociationResource s)

instance P.HasComputedDhcpOptionsId (VpcDhcpOptionsAssociationResource s) s (TF.Attr s Text) where
    computedDhcpOptionsId =
        (_dhcp_options_id :: VpcDhcpOptionsAssociationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (VpcDhcpOptionsAssociationResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedVpcId (VpcDhcpOptionsAssociationResource s) s (TF.Attr s Text) where
    computedVpcId =
        (_vpc_id :: VpcDhcpOptionsAssociationResource s -> TF.Attr s Text)
            . TF.refValue

vpcDhcpOptionsAssociationResource :: TF.Schema TF.Resource P.AWS (VpcDhcpOptionsAssociationResource s)
vpcDhcpOptionsAssociationResource =
    TF.newResource "aws_vpc_dhcp_options_association" $
        VpcDhcpOptionsAssociationResource {
              _dhcp_options_id = TF.Nil
            , _vpc_id = TF.Nil
            }

{- | The @aws_vpc_dhcp_options@ AWS resource.

Provides a VPC DHCP Options resource.
-}
data VpcDhcpOptionsResource s = VpcDhcpOptionsResource {
      _domain_name          :: !(TF.Attr s Text)
    {- ^ (Optional) the suffix domain name to use by default when resolving non Fully Qualified Domain Names. In other words, this is what ends up being the @search@ value in the @/etc/resolv.conf@ file. -}
    , _domain_name_servers  :: !(TF.Attr s Text)
    {- ^ (Optional) List of name servers to configure in @/etc/resolv.conf@ . If you want to use the default AWS nameservers you should set this to @AmazonProvidedDNS@ . -}
    , _netbios_name_servers :: !(TF.Attr s Text)
    {- ^ (Optional) List of NETBIOS name servers. -}
    , _netbios_node_type    :: !(TF.Attr s Text)
    {- ^ (Optional) The NetBIOS node type (1, 2, 4, or 8). AWS recommends to specify 2 since broadcast and multicast are not supported in their network. For more information about these node types, see <http://www.ietf.org/rfc/rfc2132.txt> . -}
    , _ntp_servers          :: !(TF.Attr s Text)
    {- ^ (Optional) List of NTP servers to configure. -}
    , _tags                 :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    } deriving (Show, Eq)

instance TF.ToHCL (VpcDhcpOptionsResource s) where
    toHCL VpcDhcpOptionsResource{..} = TF.inline $ catMaybes
        [ TF.assign "domain_name" <$> TF.attribute _domain_name
        , TF.assign "domain_name_servers" <$> TF.attribute _domain_name_servers
        , TF.assign "netbios_name_servers" <$> TF.attribute _netbios_name_servers
        , TF.assign "netbios_node_type" <$> TF.attribute _netbios_node_type
        , TF.assign "ntp_servers" <$> TF.attribute _ntp_servers
        , TF.assign "tags" <$> TF.attribute _tags
        ]

instance P.HasDomainName (VpcDhcpOptionsResource s) (TF.Attr s Text) where
    domainName =
        lens (_domain_name :: VpcDhcpOptionsResource s -> TF.Attr s Text)
             (\s a -> s { _domain_name = a } :: VpcDhcpOptionsResource s)

instance P.HasDomainNameServers (VpcDhcpOptionsResource s) (TF.Attr s Text) where
    domainNameServers =
        lens (_domain_name_servers :: VpcDhcpOptionsResource s -> TF.Attr s Text)
             (\s a -> s { _domain_name_servers = a } :: VpcDhcpOptionsResource s)

instance P.HasNetbiosNameServers (VpcDhcpOptionsResource s) (TF.Attr s Text) where
    netbiosNameServers =
        lens (_netbios_name_servers :: VpcDhcpOptionsResource s -> TF.Attr s Text)
             (\s a -> s { _netbios_name_servers = a } :: VpcDhcpOptionsResource s)

instance P.HasNetbiosNodeType (VpcDhcpOptionsResource s) (TF.Attr s Text) where
    netbiosNodeType =
        lens (_netbios_node_type :: VpcDhcpOptionsResource s -> TF.Attr s Text)
             (\s a -> s { _netbios_node_type = a } :: VpcDhcpOptionsResource s)

instance P.HasNtpServers (VpcDhcpOptionsResource s) (TF.Attr s Text) where
    ntpServers =
        lens (_ntp_servers :: VpcDhcpOptionsResource s -> TF.Attr s Text)
             (\s a -> s { _ntp_servers = a } :: VpcDhcpOptionsResource s)

instance P.HasTags (VpcDhcpOptionsResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: VpcDhcpOptionsResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: VpcDhcpOptionsResource s)

instance P.HasComputedDomainName (VpcDhcpOptionsResource s) s (TF.Attr s Text) where
    computedDomainName =
        (_domain_name :: VpcDhcpOptionsResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedDomainNameServers (VpcDhcpOptionsResource s) s (TF.Attr s Text) where
    computedDomainNameServers =
        (_domain_name_servers :: VpcDhcpOptionsResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (VpcDhcpOptionsResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedNetbiosNameServers (VpcDhcpOptionsResource s) s (TF.Attr s Text) where
    computedNetbiosNameServers =
        (_netbios_name_servers :: VpcDhcpOptionsResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedNetbiosNodeType (VpcDhcpOptionsResource s) s (TF.Attr s Text) where
    computedNetbiosNodeType =
        (_netbios_node_type :: VpcDhcpOptionsResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedNtpServers (VpcDhcpOptionsResource s) s (TF.Attr s Text) where
    computedNtpServers =
        (_ntp_servers :: VpcDhcpOptionsResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (VpcDhcpOptionsResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: VpcDhcpOptionsResource s -> TF.Attr s P.Tags)
            . TF.refValue

vpcDhcpOptionsResource :: TF.Schema TF.Resource P.AWS (VpcDhcpOptionsResource s)
vpcDhcpOptionsResource =
    TF.newResource "aws_vpc_dhcp_options" $
        VpcDhcpOptionsResource {
              _domain_name = TF.Nil
            , _domain_name_servers = TF.Nil
            , _netbios_name_servers = TF.Nil
            , _netbios_node_type = TF.Nil
            , _ntp_servers = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_vpc_endpoint_connection_notification@ AWS resource.

Provides a VPC Endpoint connection notification resource. Connection
notifications notify subscribers of VPC Endpoint events.
-}
data VpcEndpointConnectionNotificationResource s = VpcEndpointConnectionNotificationResource {
      _connection_events           :: !(TF.Attr s Text)
    {- ^ (Required) One or more endpoint <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateVpcEndpointConnectionNotification.html#API_CreateVpcEndpointConnectionNotification_RequestParameters> for which to receive notifications. -}
    , _connection_notification_arn :: !(TF.Attr s Text)
    {- ^ (Required) The ARN of the SNS topic for the notifications. -}
    , _vpc_endpoint_id             :: !(TF.Attr s Text)
    {- ^ (Optional) The ID of the VPC Endpoint to receive notifications for. -}
    , _vpc_endpoint_service_id     :: !(TF.Attr s Text)
    {- ^ (Optional) The ID of the VPC Endpoint Service to receive notifications for. -}
    } deriving (Show, Eq)

instance TF.ToHCL (VpcEndpointConnectionNotificationResource s) where
    toHCL VpcEndpointConnectionNotificationResource{..} = TF.inline $ catMaybes
        [ TF.assign "connection_events" <$> TF.attribute _connection_events
        , TF.assign "connection_notification_arn" <$> TF.attribute _connection_notification_arn
        , TF.assign "vpc_endpoint_id" <$> TF.attribute _vpc_endpoint_id
        , TF.assign "vpc_endpoint_service_id" <$> TF.attribute _vpc_endpoint_service_id
        ]

instance P.HasConnectionEvents (VpcEndpointConnectionNotificationResource s) (TF.Attr s Text) where
    connectionEvents =
        lens (_connection_events :: VpcEndpointConnectionNotificationResource s -> TF.Attr s Text)
             (\s a -> s { _connection_events = a } :: VpcEndpointConnectionNotificationResource s)

instance P.HasConnectionNotificationArn (VpcEndpointConnectionNotificationResource s) (TF.Attr s Text) where
    connectionNotificationArn =
        lens (_connection_notification_arn :: VpcEndpointConnectionNotificationResource s -> TF.Attr s Text)
             (\s a -> s { _connection_notification_arn = a } :: VpcEndpointConnectionNotificationResource s)

instance P.HasVpcEndpointId (VpcEndpointConnectionNotificationResource s) (TF.Attr s Text) where
    vpcEndpointId =
        lens (_vpc_endpoint_id :: VpcEndpointConnectionNotificationResource s -> TF.Attr s Text)
             (\s a -> s { _vpc_endpoint_id = a } :: VpcEndpointConnectionNotificationResource s)

instance P.HasVpcEndpointServiceId (VpcEndpointConnectionNotificationResource s) (TF.Attr s Text) where
    vpcEndpointServiceId =
        lens (_vpc_endpoint_service_id :: VpcEndpointConnectionNotificationResource s -> TF.Attr s Text)
             (\s a -> s { _vpc_endpoint_service_id = a } :: VpcEndpointConnectionNotificationResource s)

instance P.HasComputedConnectionEvents (VpcEndpointConnectionNotificationResource s) s (TF.Attr s Text) where
    computedConnectionEvents =
        (_connection_events :: VpcEndpointConnectionNotificationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedConnectionNotificationArn (VpcEndpointConnectionNotificationResource s) s (TF.Attr s Text) where
    computedConnectionNotificationArn =
        (_connection_notification_arn :: VpcEndpointConnectionNotificationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (VpcEndpointConnectionNotificationResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedNotificationType (VpcEndpointConnectionNotificationResource s) s (TF.Attr s Text) where
    computedNotificationType x = TF.compute (TF.refKey x) "notification_type"

instance P.HasComputedState (VpcEndpointConnectionNotificationResource s) s (TF.Attr s Text) where
    computedState x = TF.compute (TF.refKey x) "state"

instance P.HasComputedVpcEndpointId (VpcEndpointConnectionNotificationResource s) s (TF.Attr s Text) where
    computedVpcEndpointId =
        (_vpc_endpoint_id :: VpcEndpointConnectionNotificationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedVpcEndpointServiceId (VpcEndpointConnectionNotificationResource s) s (TF.Attr s Text) where
    computedVpcEndpointServiceId =
        (_vpc_endpoint_service_id :: VpcEndpointConnectionNotificationResource s -> TF.Attr s Text)
            . TF.refValue

vpcEndpointConnectionNotificationResource :: TF.Schema TF.Resource P.AWS (VpcEndpointConnectionNotificationResource s)
vpcEndpointConnectionNotificationResource =
    TF.newResource "aws_vpc_endpoint_connection_notification" $
        VpcEndpointConnectionNotificationResource {
              _connection_events = TF.Nil
            , _connection_notification_arn = TF.Nil
            , _vpc_endpoint_id = TF.Nil
            , _vpc_endpoint_service_id = TF.Nil
            }

{- | The @aws_vpc_endpoint@ AWS resource.

Provides a VPC Endpoint resource. ~> NOTE on VPC Endpoints and VPC Endpoint
Associations: Terraform provides both standalone VPC Endpoint Associations
for <vpc_endpoint_route_table_association.html> - (an association between a
VPC endpoint and a single @route_table_id@ ) and
<vpc_endpoint_subnet_association.html> - (an association between a VPC
endpoint and a single @subnet_id@ ) and a VPC Endpoint resource with
@route_table_ids@ and @subnet_ids@ attributes. Do not use the same resource
ID in both a VPC Endpoint resource and a VPC Endpoint Association resource.
Doing so will cause a conflict of associations and will overwrite the
association.
-}
data VpcEndpointResource s = VpcEndpointResource {
      _auto_accept         :: !(TF.Attr s Text)
    {- ^ (Optional) Accept the VPC endpoint (the VPC endpoint and service need to be in the same AWS account). -}
    , _policy              :: !(TF.Attr s Text)
    {- ^ (Optional) A policy to attach to the endpoint that controls access to the service. Applicable for endpoints of type @Gateway@ . Defaults to full access. -}
    , _private_dns_enabled :: !(TF.Attr s P.Bool)
    {- ^ (Optional) Whether or not to associate a private hosted zone with the specified VPC. Applicable for endpoints of type @Interface@ . Defaults to @false@ . -}
    , _route_table_ids     :: !(TF.Attr s Text)
    {- ^ (Optional) One or more route table IDs. Applicable for endpoints of type @Gateway@ . -}
    , _security_group_ids  :: !(TF.Attr s Text)
    {- ^ (Optional) The ID of one or more security groups to associate with the network interface. Required for endpoints of type @Interface@ . -}
    , _service_name        :: !(TF.Attr s Text)
    {- ^ (Required) The service name, in the form @com.amazonaws.region.service@ for AWS services. -}
    , _subnet_ids          :: !(TF.Attr s Text)
    {- ^ (Optional) The ID of one or more subnets in which to create a network interface for the endpoint. Applicable for endpoints of type @Interface@ . -}
    , _vpc_endpoint_type   :: !(TF.Attr s Text)
    {- ^ (Optional) The VPC endpoint type, @Gateway@ or @Interface@ . Defaults to @Gateway@ . -}
    , _vpc_id              :: !(TF.Attr s Text)
    {- ^ (Required) The ID of the VPC in which the endpoint will be used. -}
    } deriving (Show, Eq)

instance TF.ToHCL (VpcEndpointResource s) where
    toHCL VpcEndpointResource{..} = TF.inline $ catMaybes
        [ TF.assign "auto_accept" <$> TF.attribute _auto_accept
        , TF.assign "policy" <$> TF.attribute _policy
        , TF.assign "private_dns_enabled" <$> TF.attribute _private_dns_enabled
        , TF.assign "route_table_ids" <$> TF.attribute _route_table_ids
        , TF.assign "security_group_ids" <$> TF.attribute _security_group_ids
        , TF.assign "service_name" <$> TF.attribute _service_name
        , TF.assign "subnet_ids" <$> TF.attribute _subnet_ids
        , TF.assign "vpc_endpoint_type" <$> TF.attribute _vpc_endpoint_type
        , TF.assign "vpc_id" <$> TF.attribute _vpc_id
        ]

instance P.HasAutoAccept (VpcEndpointResource s) (TF.Attr s Text) where
    autoAccept =
        lens (_auto_accept :: VpcEndpointResource s -> TF.Attr s Text)
             (\s a -> s { _auto_accept = a } :: VpcEndpointResource s)

instance P.HasPolicy (VpcEndpointResource s) (TF.Attr s Text) where
    policy =
        lens (_policy :: VpcEndpointResource s -> TF.Attr s Text)
             (\s a -> s { _policy = a } :: VpcEndpointResource s)

instance P.HasPrivateDnsEnabled (VpcEndpointResource s) (TF.Attr s P.Bool) where
    privateDnsEnabled =
        lens (_private_dns_enabled :: VpcEndpointResource s -> TF.Attr s P.Bool)
             (\s a -> s { _private_dns_enabled = a } :: VpcEndpointResource s)

instance P.HasRouteTableIds (VpcEndpointResource s) (TF.Attr s Text) where
    routeTableIds =
        lens (_route_table_ids :: VpcEndpointResource s -> TF.Attr s Text)
             (\s a -> s { _route_table_ids = a } :: VpcEndpointResource s)

instance P.HasSecurityGroupIds (VpcEndpointResource s) (TF.Attr s Text) where
    securityGroupIds =
        lens (_security_group_ids :: VpcEndpointResource s -> TF.Attr s Text)
             (\s a -> s { _security_group_ids = a } :: VpcEndpointResource s)

instance P.HasServiceName (VpcEndpointResource s) (TF.Attr s Text) where
    serviceName =
        lens (_service_name :: VpcEndpointResource s -> TF.Attr s Text)
             (\s a -> s { _service_name = a } :: VpcEndpointResource s)

instance P.HasSubnetIds (VpcEndpointResource s) (TF.Attr s Text) where
    subnetIds =
        lens (_subnet_ids :: VpcEndpointResource s -> TF.Attr s Text)
             (\s a -> s { _subnet_ids = a } :: VpcEndpointResource s)

instance P.HasVpcEndpointType (VpcEndpointResource s) (TF.Attr s Text) where
    vpcEndpointType =
        lens (_vpc_endpoint_type :: VpcEndpointResource s -> TF.Attr s Text)
             (\s a -> s { _vpc_endpoint_type = a } :: VpcEndpointResource s)

instance P.HasVpcId (VpcEndpointResource s) (TF.Attr s Text) where
    vpcId =
        lens (_vpc_id :: VpcEndpointResource s -> TF.Attr s Text)
             (\s a -> s { _vpc_id = a } :: VpcEndpointResource s)

instance P.HasComputedAutoAccept (VpcEndpointResource s) s (TF.Attr s Text) where
    computedAutoAccept =
        (_auto_accept :: VpcEndpointResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedCidrBlocks (VpcEndpointResource s) s (TF.Attr s Text) where
    computedCidrBlocks x = TF.compute (TF.refKey x) "cidr_blocks"

instance P.HasComputedDnsEntry (VpcEndpointResource s) s (TF.Attr s Text) where
    computedDnsEntry x = TF.compute (TF.refKey x) "dns_entry"

instance P.HasComputedId (VpcEndpointResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedNetworkInterfaceIds (VpcEndpointResource s) s (TF.Attr s Text) where
    computedNetworkInterfaceIds x = TF.compute (TF.refKey x) "network_interface_ids"

instance P.HasComputedPolicy (VpcEndpointResource s) s (TF.Attr s Text) where
    computedPolicy =
        (_policy :: VpcEndpointResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPrefixListId (VpcEndpointResource s) s (TF.Attr s Text) where
    computedPrefixListId x = TF.compute (TF.refKey x) "prefix_list_id"

instance P.HasComputedPrivateDnsEnabled (VpcEndpointResource s) s (TF.Attr s P.Bool) where
    computedPrivateDnsEnabled =
        (_private_dns_enabled :: VpcEndpointResource s -> TF.Attr s P.Bool)
            . TF.refValue

instance P.HasComputedRouteTableIds (VpcEndpointResource s) s (TF.Attr s Text) where
    computedRouteTableIds =
        (_route_table_ids :: VpcEndpointResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSecurityGroupIds (VpcEndpointResource s) s (TF.Attr s Text) where
    computedSecurityGroupIds =
        (_security_group_ids :: VpcEndpointResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedServiceName (VpcEndpointResource s) s (TF.Attr s Text) where
    computedServiceName =
        (_service_name :: VpcEndpointResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedState (VpcEndpointResource s) s (TF.Attr s Text) where
    computedState x = TF.compute (TF.refKey x) "state"

instance P.HasComputedSubnetIds (VpcEndpointResource s) s (TF.Attr s Text) where
    computedSubnetIds =
        (_subnet_ids :: VpcEndpointResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedVpcEndpointType (VpcEndpointResource s) s (TF.Attr s Text) where
    computedVpcEndpointType =
        (_vpc_endpoint_type :: VpcEndpointResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedVpcId (VpcEndpointResource s) s (TF.Attr s Text) where
    computedVpcId =
        (_vpc_id :: VpcEndpointResource s -> TF.Attr s Text)
            . TF.refValue

vpcEndpointResource :: TF.Schema TF.Resource P.AWS (VpcEndpointResource s)
vpcEndpointResource =
    TF.newResource "aws_vpc_endpoint" $
        VpcEndpointResource {
              _auto_accept = TF.Nil
            , _policy = TF.Nil
            , _private_dns_enabled = TF.Nil
            , _route_table_ids = TF.Nil
            , _security_group_ids = TF.Nil
            , _service_name = TF.Nil
            , _subnet_ids = TF.Nil
            , _vpc_endpoint_type = TF.Nil
            , _vpc_id = TF.Nil
            }

{- | The @aws_vpc_endpoint_route_table_association@ AWS resource.

Provides a resource to create an association between a VPC endpoint and
routing table. ~> NOTE on VPC Endpoints and VPC Endpoint Route Table
Associations: Terraform provides both a standalone VPC Endpoint Route Table
Association (an association between a VPC endpoint and a single
@route_table_id@ ) and a <vpc_endpoint.html> resource with a
@route_table_ids@ attribute. Do not use the same route table ID in both a
VPC Endpoint resource and a VPC Endpoint Route Table Association resource.
Doing so will cause a conflict of associations and will overwrite the
association.
-}
data VpcEndpointRouteTableAssociationResource s = VpcEndpointRouteTableAssociationResource {
      _route_table_id  :: !(TF.Attr s Text)
    {- ^ (Required) The ID of the routing table to be associated with the VPC endpoint. -}
    , _vpc_endpoint_id :: !(TF.Attr s Text)
    {- ^ (Required) The ID of the VPC endpoint with which the routing table will be associated. -}
    } deriving (Show, Eq)

instance TF.ToHCL (VpcEndpointRouteTableAssociationResource s) where
    toHCL VpcEndpointRouteTableAssociationResource{..} = TF.inline $ catMaybes
        [ TF.assign "route_table_id" <$> TF.attribute _route_table_id
        , TF.assign "vpc_endpoint_id" <$> TF.attribute _vpc_endpoint_id
        ]

instance P.HasRouteTableId (VpcEndpointRouteTableAssociationResource s) (TF.Attr s Text) where
    routeTableId =
        lens (_route_table_id :: VpcEndpointRouteTableAssociationResource s -> TF.Attr s Text)
             (\s a -> s { _route_table_id = a } :: VpcEndpointRouteTableAssociationResource s)

instance P.HasVpcEndpointId (VpcEndpointRouteTableAssociationResource s) (TF.Attr s Text) where
    vpcEndpointId =
        lens (_vpc_endpoint_id :: VpcEndpointRouteTableAssociationResource s -> TF.Attr s Text)
             (\s a -> s { _vpc_endpoint_id = a } :: VpcEndpointRouteTableAssociationResource s)

instance P.HasComputedId (VpcEndpointRouteTableAssociationResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedRouteTableId (VpcEndpointRouteTableAssociationResource s) s (TF.Attr s Text) where
    computedRouteTableId =
        (_route_table_id :: VpcEndpointRouteTableAssociationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedVpcEndpointId (VpcEndpointRouteTableAssociationResource s) s (TF.Attr s Text) where
    computedVpcEndpointId =
        (_vpc_endpoint_id :: VpcEndpointRouteTableAssociationResource s -> TF.Attr s Text)
            . TF.refValue

vpcEndpointRouteTableAssociationResource :: TF.Schema TF.Resource P.AWS (VpcEndpointRouteTableAssociationResource s)
vpcEndpointRouteTableAssociationResource =
    TF.newResource "aws_vpc_endpoint_route_table_association" $
        VpcEndpointRouteTableAssociationResource {
              _route_table_id = TF.Nil
            , _vpc_endpoint_id = TF.Nil
            }

{- | The @aws_vpc_endpoint_service_allowed_principal@ AWS resource.

Provides a resource to allow a principal to discover a VPC endpoint service.
~> NOTE on VPC Endpoint Services and VPC Endpoint Service Allowed
Principals: Terraform provides both a standalone
<vpc_endpoint_service_allowed_principal.html> resource and a VPC Endpoint
Service resource with an @allowed_principals@ attribute. Do not use the same
principal ARN in both a VPC Endpoint Service resource and a VPC Endpoint
Service Allowed Principal resource. Doing so will cause a conflict and will
overwrite the association.
-}
data VpcEndpointServiceAllowedPrincipalResource s = VpcEndpointServiceAllowedPrincipalResource {
      _principal_arn           :: !(TF.Attr s Text)
    {- ^ (Required) The ARN of the principal to allow permissions. -}
    , _vpc_endpoint_service_id :: !(TF.Attr s Text)
    {- ^ (Required) The ID of the VPC endpoint service to allow permission. -}
    } deriving (Show, Eq)

instance TF.ToHCL (VpcEndpointServiceAllowedPrincipalResource s) where
    toHCL VpcEndpointServiceAllowedPrincipalResource{..} = TF.inline $ catMaybes
        [ TF.assign "principal_arn" <$> TF.attribute _principal_arn
        , TF.assign "vpc_endpoint_service_id" <$> TF.attribute _vpc_endpoint_service_id
        ]

instance P.HasPrincipalArn (VpcEndpointServiceAllowedPrincipalResource s) (TF.Attr s Text) where
    principalArn =
        lens (_principal_arn :: VpcEndpointServiceAllowedPrincipalResource s -> TF.Attr s Text)
             (\s a -> s { _principal_arn = a } :: VpcEndpointServiceAllowedPrincipalResource s)

instance P.HasVpcEndpointServiceId (VpcEndpointServiceAllowedPrincipalResource s) (TF.Attr s Text) where
    vpcEndpointServiceId =
        lens (_vpc_endpoint_service_id :: VpcEndpointServiceAllowedPrincipalResource s -> TF.Attr s Text)
             (\s a -> s { _vpc_endpoint_service_id = a } :: VpcEndpointServiceAllowedPrincipalResource s)

instance P.HasComputedId (VpcEndpointServiceAllowedPrincipalResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedPrincipalArn (VpcEndpointServiceAllowedPrincipalResource s) s (TF.Attr s Text) where
    computedPrincipalArn =
        (_principal_arn :: VpcEndpointServiceAllowedPrincipalResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedVpcEndpointServiceId (VpcEndpointServiceAllowedPrincipalResource s) s (TF.Attr s Text) where
    computedVpcEndpointServiceId =
        (_vpc_endpoint_service_id :: VpcEndpointServiceAllowedPrincipalResource s -> TF.Attr s Text)
            . TF.refValue

vpcEndpointServiceAllowedPrincipalResource :: TF.Schema TF.Resource P.AWS (VpcEndpointServiceAllowedPrincipalResource s)
vpcEndpointServiceAllowedPrincipalResource =
    TF.newResource "aws_vpc_endpoint_service_allowed_principal" $
        VpcEndpointServiceAllowedPrincipalResource {
              _principal_arn = TF.Nil
            , _vpc_endpoint_service_id = TF.Nil
            }

{- | The @aws_vpc_endpoint_service@ AWS resource.

Provides a VPC Endpoint Service resource. Service consumers can create an
Interface  <vpc_endpoint.html> to connect to the service. ~> NOTE on VPC
Endpoint Services and VPC Endpoint Service Allowed Principals: Terraform
provides both a standalone <vpc_endpoint_service_allowed_principal.html>
resource and a VPC Endpoint Service resource with an @allowed_principals@
attribute. Do not use the same principal ARN in both a VPC Endpoint Service
resource and a VPC Endpoint Service Allowed Principal resource. Doing so
will cause a conflict and will overwrite the association.
-}
data VpcEndpointServiceResource s = VpcEndpointServiceResource {
      _acceptance_required        :: !(TF.Attr s Text)
    {- ^ (Required) Whether or not VPC endpoint connection requests to the service must be accepted by the service owner - @true@ or @false@ . -}
    , _allowed_principals         :: !(TF.Attr s Text)
    {- ^ (Optional) The ARNs of one or more principals allowed to discover the endpoint service. -}
    , _network_load_balancer_arns :: !(TF.Attr s Text)
    {- ^ (Required) The ARNs of one or more Network Load Balancers for the endpoint service. -}
    } deriving (Show, Eq)

instance TF.ToHCL (VpcEndpointServiceResource s) where
    toHCL VpcEndpointServiceResource{..} = TF.inline $ catMaybes
        [ TF.assign "acceptance_required" <$> TF.attribute _acceptance_required
        , TF.assign "allowed_principals" <$> TF.attribute _allowed_principals
        , TF.assign "network_load_balancer_arns" <$> TF.attribute _network_load_balancer_arns
        ]

instance P.HasAcceptanceRequired (VpcEndpointServiceResource s) (TF.Attr s Text) where
    acceptanceRequired =
        lens (_acceptance_required :: VpcEndpointServiceResource s -> TF.Attr s Text)
             (\s a -> s { _acceptance_required = a } :: VpcEndpointServiceResource s)

instance P.HasAllowedPrincipals (VpcEndpointServiceResource s) (TF.Attr s Text) where
    allowedPrincipals =
        lens (_allowed_principals :: VpcEndpointServiceResource s -> TF.Attr s Text)
             (\s a -> s { _allowed_principals = a } :: VpcEndpointServiceResource s)

instance P.HasNetworkLoadBalancerArns (VpcEndpointServiceResource s) (TF.Attr s Text) where
    networkLoadBalancerArns =
        lens (_network_load_balancer_arns :: VpcEndpointServiceResource s -> TF.Attr s Text)
             (\s a -> s { _network_load_balancer_arns = a } :: VpcEndpointServiceResource s)

instance P.HasComputedAcceptanceRequired (VpcEndpointServiceResource s) s (TF.Attr s Text) where
    computedAcceptanceRequired =
        (_acceptance_required :: VpcEndpointServiceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAllowedPrincipals (VpcEndpointServiceResource s) s (TF.Attr s Text) where
    computedAllowedPrincipals =
        (_allowed_principals :: VpcEndpointServiceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAvailabilityZones (VpcEndpointServiceResource s) s (TF.Attr s Text) where
    computedAvailabilityZones x = TF.compute (TF.refKey x) "availability_zones"

instance P.HasComputedBaseEndpointDnsNames (VpcEndpointServiceResource s) s (TF.Attr s Text) where
    computedBaseEndpointDnsNames x = TF.compute (TF.refKey x) "base_endpoint_dns_names"

instance P.HasComputedId (VpcEndpointServiceResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedNetworkLoadBalancerArns (VpcEndpointServiceResource s) s (TF.Attr s Text) where
    computedNetworkLoadBalancerArns =
        (_network_load_balancer_arns :: VpcEndpointServiceResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPrivateDnsName (VpcEndpointServiceResource s) s (TF.Attr s Text) where
    computedPrivateDnsName x = TF.compute (TF.refKey x) "private_dns_name"

instance P.HasComputedServiceName (VpcEndpointServiceResource s) s (TF.Attr s Text) where
    computedServiceName x = TF.compute (TF.refKey x) "service_name"

instance P.HasComputedServiceType (VpcEndpointServiceResource s) s (TF.Attr s Text) where
    computedServiceType x = TF.compute (TF.refKey x) "service_type"

instance P.HasComputedState (VpcEndpointServiceResource s) s (TF.Attr s Text) where
    computedState x = TF.compute (TF.refKey x) "state"

vpcEndpointServiceResource :: TF.Schema TF.Resource P.AWS (VpcEndpointServiceResource s)
vpcEndpointServiceResource =
    TF.newResource "aws_vpc_endpoint_service" $
        VpcEndpointServiceResource {
              _acceptance_required = TF.Nil
            , _allowed_principals = TF.Nil
            , _network_load_balancer_arns = TF.Nil
            }

{- | The @aws_vpc_endpoint_subnet_association@ AWS resource.

Provides a resource to create an association between a VPC endpoint and a
subnet. ~> NOTE on VPC Endpoints and VPC Endpoint Subnet Associations:
Terraform provides both a standalone VPC Endpoint Subnet Association (an
association between a VPC endpoint and a single @subnet_id@ ) and a
<vpc_endpoint.html> resource with a @subnet_ids@ attribute. Do not use the
same subnet ID in both a VPC Endpoint resource and a VPC Endpoint Subnet
Association resource. Doing so will cause a conflict of associations and
will overwrite the association.
-}
data VpcEndpointSubnetAssociationResource s = VpcEndpointSubnetAssociationResource {
      _subnet_id       :: !(TF.Attr s Text)
    {- ^ (Required) The ID of the subnet to be associated with the VPC endpoint. -}
    , _vpc_endpoint_id :: !(TF.Attr s Text)
    {- ^ (Required) The ID of the VPC endpoint with which the subnet will be associated. -}
    } deriving (Show, Eq)

instance TF.ToHCL (VpcEndpointSubnetAssociationResource s) where
    toHCL VpcEndpointSubnetAssociationResource{..} = TF.inline $ catMaybes
        [ TF.assign "subnet_id" <$> TF.attribute _subnet_id
        , TF.assign "vpc_endpoint_id" <$> TF.attribute _vpc_endpoint_id
        ]

instance P.HasSubnetId (VpcEndpointSubnetAssociationResource s) (TF.Attr s Text) where
    subnetId =
        lens (_subnet_id :: VpcEndpointSubnetAssociationResource s -> TF.Attr s Text)
             (\s a -> s { _subnet_id = a } :: VpcEndpointSubnetAssociationResource s)

instance P.HasVpcEndpointId (VpcEndpointSubnetAssociationResource s) (TF.Attr s Text) where
    vpcEndpointId =
        lens (_vpc_endpoint_id :: VpcEndpointSubnetAssociationResource s -> TF.Attr s Text)
             (\s a -> s { _vpc_endpoint_id = a } :: VpcEndpointSubnetAssociationResource s)

instance P.HasComputedId (VpcEndpointSubnetAssociationResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedSubnetId (VpcEndpointSubnetAssociationResource s) s (TF.Attr s Text) where
    computedSubnetId =
        (_subnet_id :: VpcEndpointSubnetAssociationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedVpcEndpointId (VpcEndpointSubnetAssociationResource s) s (TF.Attr s Text) where
    computedVpcEndpointId =
        (_vpc_endpoint_id :: VpcEndpointSubnetAssociationResource s -> TF.Attr s Text)
            . TF.refValue

vpcEndpointSubnetAssociationResource :: TF.Schema TF.Resource P.AWS (VpcEndpointSubnetAssociationResource s)
vpcEndpointSubnetAssociationResource =
    TF.newResource "aws_vpc_endpoint_subnet_association" $
        VpcEndpointSubnetAssociationResource {
              _subnet_id = TF.Nil
            , _vpc_endpoint_id = TF.Nil
            }

{- | The @aws_vpc_peering_connection_accepter@ AWS resource.

Provides a resource to manage the accepter's side of a VPC Peering
Connection. When a cross-account (requester's AWS account differs from the
accepter's AWS account) or an inter-region VPC Peering Connection is
created, a VPC Peering Connection resource is automatically created in the
accepter's account. The requester can use the @aws_vpc_peering_connection@
resource to manage its side of the connection and the accepter can use the
@aws_vpc_peering_connection_accepter@ resource to "adopt" its side of the
connection into management.
-}
data VpcPeeringConnectionAccepterResource s = VpcPeeringConnectionAccepterResource {
      _auto_accept               :: !(TF.Attr s Text)
    {- ^ (Optional) Whether or not to accept the peering request. Defaults to @false@ . -}
    , _tags                      :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    , _vpc_peering_connection_id :: !(TF.Attr s Text)
    {- ^ (Required) The VPC Peering Connection ID to manage. -}
    } deriving (Show, Eq)

instance TF.ToHCL (VpcPeeringConnectionAccepterResource s) where
    toHCL VpcPeeringConnectionAccepterResource{..} = TF.inline $ catMaybes
        [ TF.assign "auto_accept" <$> TF.attribute _auto_accept
        , TF.assign "tags" <$> TF.attribute _tags
        , TF.assign "vpc_peering_connection_id" <$> TF.attribute _vpc_peering_connection_id
        ]

instance P.HasAutoAccept (VpcPeeringConnectionAccepterResource s) (TF.Attr s Text) where
    autoAccept =
        lens (_auto_accept :: VpcPeeringConnectionAccepterResource s -> TF.Attr s Text)
             (\s a -> s { _auto_accept = a } :: VpcPeeringConnectionAccepterResource s)

instance P.HasTags (VpcPeeringConnectionAccepterResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: VpcPeeringConnectionAccepterResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: VpcPeeringConnectionAccepterResource s)

instance P.HasVpcPeeringConnectionId (VpcPeeringConnectionAccepterResource s) (TF.Attr s Text) where
    vpcPeeringConnectionId =
        lens (_vpc_peering_connection_id :: VpcPeeringConnectionAccepterResource s -> TF.Attr s Text)
             (\s a -> s { _vpc_peering_connection_id = a } :: VpcPeeringConnectionAccepterResource s)

instance P.HasComputedAcceptStatus (VpcPeeringConnectionAccepterResource s) s (TF.Attr s Text) where
    computedAcceptStatus x = TF.compute (TF.refKey x) "accept_status"

instance P.HasComputedAccepter (VpcPeeringConnectionAccepterResource s) s (TF.Attr s Text) where
    computedAccepter x = TF.compute (TF.refKey x) "accepter"

instance P.HasComputedAutoAccept (VpcPeeringConnectionAccepterResource s) s (TF.Attr s Text) where
    computedAutoAccept =
        (_auto_accept :: VpcPeeringConnectionAccepterResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (VpcPeeringConnectionAccepterResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedPeerOwnerId (VpcPeeringConnectionAccepterResource s) s (TF.Attr s Text) where
    computedPeerOwnerId x = TF.compute (TF.refKey x) "peer_owner_id"

instance P.HasComputedPeerRegion (VpcPeeringConnectionAccepterResource s) s (TF.Attr s P.Region) where
    computedPeerRegion x = TF.compute (TF.refKey x) "peer_region"

instance P.HasComputedPeerVpcId (VpcPeeringConnectionAccepterResource s) s (TF.Attr s Text) where
    computedPeerVpcId x = TF.compute (TF.refKey x) "peer_vpc_id"

instance P.HasComputedRequester (VpcPeeringConnectionAccepterResource s) s (TF.Attr s Text) where
    computedRequester x = TF.compute (TF.refKey x) "requester"

instance P.HasComputedTags (VpcPeeringConnectionAccepterResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: VpcPeeringConnectionAccepterResource s -> TF.Attr s P.Tags)
            . TF.refValue

instance P.HasComputedVpcId (VpcPeeringConnectionAccepterResource s) s (TF.Attr s Text) where
    computedVpcId x = TF.compute (TF.refKey x) "vpc_id"

instance P.HasComputedVpcPeeringConnectionId (VpcPeeringConnectionAccepterResource s) s (TF.Attr s Text) where
    computedVpcPeeringConnectionId =
        (_vpc_peering_connection_id :: VpcPeeringConnectionAccepterResource s -> TF.Attr s Text)
            . TF.refValue

vpcPeeringConnectionAccepterResource :: TF.Schema TF.Resource P.AWS (VpcPeeringConnectionAccepterResource s)
vpcPeeringConnectionAccepterResource =
    TF.newResource "aws_vpc_peering_connection_accepter" $
        VpcPeeringConnectionAccepterResource {
              _auto_accept = TF.Nil
            , _tags = TF.Nil
            , _vpc_peering_connection_id = TF.Nil
            }

{- | The @aws_vpc_peering_connection@ AWS resource.

Provides a resource to manage a VPC Peering Connection resource. -> Note:
For cross-account (requester's AWS account differs from the accepter's AWS
account) or inter-region VPC Peering Connections use the
@aws_vpc_peering_connection@ resource to manage the requester's side of the
connection and use the @aws_vpc_peering_connection_accepter@ resource to
manage the accepter's side of the connection.
-}
data VpcPeeringConnectionResource s = VpcPeeringConnectionResource {
      _accepter      :: !(TF.Attr s Text)
    {- ^ (Optional) - An optional configuration block that allows for [VPC Peering Connection] (http://docs.aws.amazon.com/AmazonVPC/latest/PeeringGuide) options to be set for the VPC that accepts the peering connection (a maximum of one). -}
    , _auto_accept   :: !(TF.Attr s Text)
    {- ^ (Optional) Accept the peering (both VPCs need to be in the same AWS account). -}
    , _peer_owner_id :: !(TF.Attr s Text)
    {- ^ (Optional) The AWS account ID of the owner of the peer VPC. Defaults to the account ID the </docs/providers/aws/index.html> is currently connected to. -}
    , _peer_region   :: !(TF.Attr s P.Region)
    {- ^ (Optional) The region of the accepter VPC of the [VPC Peering Connection]. @auto_accept@ must be @false@ , and use the @aws_vpc_peering_connection_accepter@ to manage the accepter side. -}
    , _peer_vpc_id   :: !(TF.Attr s Text)
    {- ^ (Required) The ID of the VPC with which you are creating the VPC Peering Connection. -}
    , _requester     :: !(TF.Attr s Text)
    {- ^ (Optional) - A optional configuration block that allows for [VPC Peering Connection] (http://docs.aws.amazon.com/AmazonVPC/latest/PeeringGuide) options to be set for the VPC that requests the peering connection (a maximum of one). -}
    , _tags          :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    , _vpc_id        :: !(TF.Attr s Text)
    {- ^ (Required) The ID of the requester VPC. -}
    } deriving (Show, Eq)

instance TF.ToHCL (VpcPeeringConnectionResource s) where
    toHCL VpcPeeringConnectionResource{..} = TF.inline $ catMaybes
        [ TF.assign "accepter" <$> TF.attribute _accepter
        , TF.assign "auto_accept" <$> TF.attribute _auto_accept
        , TF.assign "peer_owner_id" <$> TF.attribute _peer_owner_id
        , TF.assign "peer_region" <$> TF.attribute _peer_region
        , TF.assign "peer_vpc_id" <$> TF.attribute _peer_vpc_id
        , TF.assign "requester" <$> TF.attribute _requester
        , TF.assign "tags" <$> TF.attribute _tags
        , TF.assign "vpc_id" <$> TF.attribute _vpc_id
        ]

instance P.HasAccepter (VpcPeeringConnectionResource s) (TF.Attr s Text) where
    accepter =
        lens (_accepter :: VpcPeeringConnectionResource s -> TF.Attr s Text)
             (\s a -> s { _accepter = a } :: VpcPeeringConnectionResource s)

instance P.HasAutoAccept (VpcPeeringConnectionResource s) (TF.Attr s Text) where
    autoAccept =
        lens (_auto_accept :: VpcPeeringConnectionResource s -> TF.Attr s Text)
             (\s a -> s { _auto_accept = a } :: VpcPeeringConnectionResource s)

instance P.HasPeerOwnerId (VpcPeeringConnectionResource s) (TF.Attr s Text) where
    peerOwnerId =
        lens (_peer_owner_id :: VpcPeeringConnectionResource s -> TF.Attr s Text)
             (\s a -> s { _peer_owner_id = a } :: VpcPeeringConnectionResource s)

instance P.HasPeerRegion (VpcPeeringConnectionResource s) (TF.Attr s P.Region) where
    peerRegion =
        lens (_peer_region :: VpcPeeringConnectionResource s -> TF.Attr s P.Region)
             (\s a -> s { _peer_region = a } :: VpcPeeringConnectionResource s)

instance P.HasPeerVpcId (VpcPeeringConnectionResource s) (TF.Attr s Text) where
    peerVpcId =
        lens (_peer_vpc_id :: VpcPeeringConnectionResource s -> TF.Attr s Text)
             (\s a -> s { _peer_vpc_id = a } :: VpcPeeringConnectionResource s)

instance P.HasRequester (VpcPeeringConnectionResource s) (TF.Attr s Text) where
    requester =
        lens (_requester :: VpcPeeringConnectionResource s -> TF.Attr s Text)
             (\s a -> s { _requester = a } :: VpcPeeringConnectionResource s)

instance P.HasTags (VpcPeeringConnectionResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: VpcPeeringConnectionResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: VpcPeeringConnectionResource s)

instance P.HasVpcId (VpcPeeringConnectionResource s) (TF.Attr s Text) where
    vpcId =
        lens (_vpc_id :: VpcPeeringConnectionResource s -> TF.Attr s Text)
             (\s a -> s { _vpc_id = a } :: VpcPeeringConnectionResource s)

instance P.HasComputedAcceptStatus (VpcPeeringConnectionResource s) s (TF.Attr s Text) where
    computedAcceptStatus x = TF.compute (TF.refKey x) "accept_status"

instance P.HasComputedAccepter (VpcPeeringConnectionResource s) s (TF.Attr s Text) where
    computedAccepter =
        (_accepter :: VpcPeeringConnectionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAutoAccept (VpcPeeringConnectionResource s) s (TF.Attr s Text) where
    computedAutoAccept =
        (_auto_accept :: VpcPeeringConnectionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (VpcPeeringConnectionResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedPeerOwnerId (VpcPeeringConnectionResource s) s (TF.Attr s Text) where
    computedPeerOwnerId =
        (_peer_owner_id :: VpcPeeringConnectionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPeerRegion (VpcPeeringConnectionResource s) s (TF.Attr s P.Region) where
    computedPeerRegion =
        (_peer_region :: VpcPeeringConnectionResource s -> TF.Attr s P.Region)
            . TF.refValue

instance P.HasComputedPeerVpcId (VpcPeeringConnectionResource s) s (TF.Attr s Text) where
    computedPeerVpcId =
        (_peer_vpc_id :: VpcPeeringConnectionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRequester (VpcPeeringConnectionResource s) s (TF.Attr s Text) where
    computedRequester =
        (_requester :: VpcPeeringConnectionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTags (VpcPeeringConnectionResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: VpcPeeringConnectionResource s -> TF.Attr s P.Tags)
            . TF.refValue

instance P.HasComputedVpcId (VpcPeeringConnectionResource s) s (TF.Attr s Text) where
    computedVpcId =
        (_vpc_id :: VpcPeeringConnectionResource s -> TF.Attr s Text)
            . TF.refValue

vpcPeeringConnectionResource :: TF.Schema TF.Resource P.AWS (VpcPeeringConnectionResource s)
vpcPeeringConnectionResource =
    TF.newResource "aws_vpc_peering_connection" $
        VpcPeeringConnectionResource {
              _accepter = TF.Nil
            , _auto_accept = TF.Nil
            , _peer_owner_id = TF.Nil
            , _peer_region = TF.Nil
            , _peer_vpc_id = TF.Nil
            , _requester = TF.Nil
            , _tags = TF.Nil
            , _vpc_id = TF.Nil
            }

{- | The @aws_vpc@ AWS resource.

Provides an VPC resource.
-}
data VpcResource s = VpcResource {
      _assign_generated_ipv6_cidr_block :: !(TF.Attr s P.CIDR)
    {- ^ (Optional) Requests an Amazon-provided IPv6 CIDR block with a /56 prefix length for the VPC. You cannot specify the range of IP addresses, or the size of the CIDR block. Default is @false@ . -}
    , _cidr_block                       :: !(TF.Attr s P.CIDR)
    {- ^ (Required) The CIDR block for the VPC. -}
    , _enable_classiclink               :: !(TF.Attr s P.Bool)
    {- ^ (Optional) A boolean flag to enable/disable ClassicLink for the VPC. Only valid in regions and accounts that support EC2 Classic. See the <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/vpc-classiclink.html> for more information. Defaults false. -}
    , _enable_classiclink_dns_support   :: !(TF.Attr s P.Bool)
    {- ^ (Optional) A boolean flag to enable/disable ClassicLink DNS Support for the VPC. Only valid in regions and accounts that support EC2 Classic. -}
    , _enable_dns_hostnames             :: !(TF.Attr s P.Bool)
    {- ^ (Optional) A boolean flag to enable/disable DNS hostnames in the VPC. Defaults false. -}
    , _enable_dns_support               :: !(TF.Attr s P.Bool)
    {- ^ (Optional) A boolean flag to enable/disable DNS support in the VPC. Defaults true. -}
    , _instance_tenancy                 :: !(TF.Attr s Text)
    {- ^ (Optional) A tenancy option for instances launched into the VPC -}
    , _tags                             :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    } deriving (Show, Eq)

instance TF.ToHCL (VpcResource s) where
    toHCL VpcResource{..} = TF.inline $ catMaybes
        [ TF.assign "assign_generated_ipv6_cidr_block" <$> TF.attribute _assign_generated_ipv6_cidr_block
        , TF.assign "cidr_block" <$> TF.attribute _cidr_block
        , TF.assign "enable_classiclink" <$> TF.attribute _enable_classiclink
        , TF.assign "enable_classiclink_dns_support" <$> TF.attribute _enable_classiclink_dns_support
        , TF.assign "enable_dns_hostnames" <$> TF.attribute _enable_dns_hostnames
        , TF.assign "enable_dns_support" <$> TF.attribute _enable_dns_support
        , TF.assign "instance_tenancy" <$> TF.attribute _instance_tenancy
        , TF.assign "tags" <$> TF.attribute _tags
        ]

instance P.HasAssignGeneratedIpv6CidrBlock (VpcResource s) (TF.Attr s P.CIDR) where
    assignGeneratedIpv6CidrBlock =
        lens (_assign_generated_ipv6_cidr_block :: VpcResource s -> TF.Attr s P.CIDR)
             (\s a -> s { _assign_generated_ipv6_cidr_block = a } :: VpcResource s)

instance P.HasCidrBlock (VpcResource s) (TF.Attr s P.CIDR) where
    cidrBlock =
        lens (_cidr_block :: VpcResource s -> TF.Attr s P.CIDR)
             (\s a -> s { _cidr_block = a } :: VpcResource s)

instance P.HasEnableClassiclink (VpcResource s) (TF.Attr s P.Bool) where
    enableClassiclink =
        lens (_enable_classiclink :: VpcResource s -> TF.Attr s P.Bool)
             (\s a -> s { _enable_classiclink = a } :: VpcResource s)

instance P.HasEnableClassiclinkDnsSupport (VpcResource s) (TF.Attr s P.Bool) where
    enableClassiclinkDnsSupport =
        lens (_enable_classiclink_dns_support :: VpcResource s -> TF.Attr s P.Bool)
             (\s a -> s { _enable_classiclink_dns_support = a } :: VpcResource s)

instance P.HasEnableDnsHostnames (VpcResource s) (TF.Attr s P.Bool) where
    enableDnsHostnames =
        lens (_enable_dns_hostnames :: VpcResource s -> TF.Attr s P.Bool)
             (\s a -> s { _enable_dns_hostnames = a } :: VpcResource s)

instance P.HasEnableDnsSupport (VpcResource s) (TF.Attr s P.Bool) where
    enableDnsSupport =
        lens (_enable_dns_support :: VpcResource s -> TF.Attr s P.Bool)
             (\s a -> s { _enable_dns_support = a } :: VpcResource s)

instance P.HasInstanceTenancy (VpcResource s) (TF.Attr s Text) where
    instanceTenancy =
        lens (_instance_tenancy :: VpcResource s -> TF.Attr s Text)
             (\s a -> s { _instance_tenancy = a } :: VpcResource s)

instance P.HasTags (VpcResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: VpcResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: VpcResource s)

instance P.HasComputedAssignGeneratedIpv6CidrBlock (VpcResource s) s (TF.Attr s P.CIDR) where
    computedAssignGeneratedIpv6CidrBlock =
        (_assign_generated_ipv6_cidr_block :: VpcResource s -> TF.Attr s P.CIDR)
            . TF.refValue

instance P.HasComputedCidrBlock (VpcResource s) s (TF.Attr s P.CIDR) where
    computedCidrBlock x = TF.compute (TF.refKey x) "cidr_block"

instance P.HasComputedDefaultNetworkAclId (VpcResource s) s (TF.Attr s Text) where
    computedDefaultNetworkAclId x = TF.compute (TF.refKey x) "default_network_acl_id"

instance P.HasComputedDefaultRouteTableId (VpcResource s) s (TF.Attr s Text) where
    computedDefaultRouteTableId x = TF.compute (TF.refKey x) "default_route_table_id"

instance P.HasComputedDefaultSecurityGroupId (VpcResource s) s (TF.Attr s Text) where
    computedDefaultSecurityGroupId x = TF.compute (TF.refKey x) "default_security_group_id"

instance P.HasComputedEnableClassiclink (VpcResource s) s (TF.Attr s P.Bool) where
    computedEnableClassiclink x = TF.compute (TF.refKey x) "enable_classiclink"

instance P.HasComputedEnableClassiclinkDnsSupport (VpcResource s) s (TF.Attr s P.Bool) where
    computedEnableClassiclinkDnsSupport =
        (_enable_classiclink_dns_support :: VpcResource s -> TF.Attr s P.Bool)
            . TF.refValue

instance P.HasComputedEnableDnsHostnames (VpcResource s) s (TF.Attr s P.Bool) where
    computedEnableDnsHostnames x = TF.compute (TF.refKey x) "enable_dns_hostnames"

instance P.HasComputedEnableDnsSupport (VpcResource s) s (TF.Attr s P.Bool) where
    computedEnableDnsSupport x = TF.compute (TF.refKey x) "enable_dns_support"

instance P.HasComputedId (VpcResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedInstanceTenancy (VpcResource s) s (TF.Attr s Text) where
    computedInstanceTenancy x = TF.compute (TF.refKey x) "instance_tenancy"

instance P.HasComputedIpv6AssociationId (VpcResource s) s (TF.Attr s Text) where
    computedIpv6AssociationId x = TF.compute (TF.refKey x) "ipv6_association_id"

instance P.HasComputedIpv6CidrBlock (VpcResource s) s (TF.Attr s P.CIDR) where
    computedIpv6CidrBlock x = TF.compute (TF.refKey x) "ipv6_cidr_block"

instance P.HasComputedMainRouteTableId (VpcResource s) s (TF.Attr s Text) where
    computedMainRouteTableId x = TF.compute (TF.refKey x) "main_route_table_id"

instance P.HasComputedTags (VpcResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: VpcResource s -> TF.Attr s P.Tags)
            . TF.refValue

vpcResource :: TF.Schema TF.Resource P.AWS (VpcResource s)
vpcResource =
    TF.newResource "aws_vpc" $
        VpcResource {
              _assign_generated_ipv6_cidr_block = TF.Nil
            , _cidr_block = TF.Nil
            , _enable_classiclink = TF.Nil
            , _enable_classiclink_dns_support = TF.Nil
            , _enable_dns_hostnames = TF.Nil
            , _enable_dns_support = TF.Nil
            , _instance_tenancy = TF.Nil
            , _tags = TF.Nil
            }

{- | The @aws_vpn_connection@ AWS resource.

Provides a VPN connection connected to a VPC. These objects can be connected
to customer gateways, and allow you to establish tunnels between your
network and the VPC. ~> Note: All arguments including
@tunnel1_preshared_key@ and @tunnel2_preshared_key@ will be stored in the
raw state as plain-text. </docs/state/sensitive-data.html> . ~> Note: The
CIDR blocks in the arguments @tunnel1_inside_cidr@ and @tunnel2_inside_cidr@
must have a prefix of /30 and be a part of a specific range.
<https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_VpnTunnelOptionsSpecification.html>
.
-}
data VpnConnectionResource s = VpnConnectionResource {
      _customer_gateway_id   :: !(TF.Attr s Text)
    {- ^ (Required) The ID of the customer gateway. -}
    , _static_routes_only    :: !(TF.Attr s Text)
    {- ^ (Optional, Default @false@ ) Whether the VPN connection uses static routes exclusively. Static routes must be used for devices that don't support BGP. -}
    , _tags                  :: !(TF.Attr s P.Tags)
    {- ^ (Optional) Tags to apply to the connection. -}
    , _tunnel1_inside_cidr   :: !(TF.Attr s Text)
    {- ^ (Optional) The CIDR block of the inside IP addresses for the first VPN tunnel. -}
    , _tunnel1_preshared_key :: !(TF.Attr s Text)
    {- ^ (Optional) The preshared key of the first VPN tunnel. -}
    , _tunnel2_inside_cidr   :: !(TF.Attr s Text)
    {- ^ (Optional) The CIDR block of the second IP addresses for the first VPN tunnel. -}
    , _tunnel2_preshared_key :: !(TF.Attr s Text)
    {- ^ (Optional) The preshared key of the second VPN tunnel. -}
    , _type'                 :: !(TF.Attr s Text)
    {- ^ (Required) The type of VPN connection. The only type AWS supports at this time is "ipsec.1". -}
    , _vpn_gateway_id        :: !(TF.Attr s Text)
    {- ^ (Required) The ID of the virtual private gateway. -}
    } deriving (Show, Eq)

instance TF.ToHCL (VpnConnectionResource s) where
    toHCL VpnConnectionResource{..} = TF.inline $ catMaybes
        [ TF.assign "customer_gateway_id" <$> TF.attribute _customer_gateway_id
        , TF.assign "static_routes_only" <$> TF.attribute _static_routes_only
        , TF.assign "tags" <$> TF.attribute _tags
        , TF.assign "tunnel1_inside_cidr" <$> TF.attribute _tunnel1_inside_cidr
        , TF.assign "tunnel1_preshared_key" <$> TF.attribute _tunnel1_preshared_key
        , TF.assign "tunnel2_inside_cidr" <$> TF.attribute _tunnel2_inside_cidr
        , TF.assign "tunnel2_preshared_key" <$> TF.attribute _tunnel2_preshared_key
        , TF.assign "type" <$> TF.attribute _type'
        , TF.assign "vpn_gateway_id" <$> TF.attribute _vpn_gateway_id
        ]

instance P.HasCustomerGatewayId (VpnConnectionResource s) (TF.Attr s Text) where
    customerGatewayId =
        lens (_customer_gateway_id :: VpnConnectionResource s -> TF.Attr s Text)
             (\s a -> s { _customer_gateway_id = a } :: VpnConnectionResource s)

instance P.HasStaticRoutesOnly (VpnConnectionResource s) (TF.Attr s Text) where
    staticRoutesOnly =
        lens (_static_routes_only :: VpnConnectionResource s -> TF.Attr s Text)
             (\s a -> s { _static_routes_only = a } :: VpnConnectionResource s)

instance P.HasTags (VpnConnectionResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: VpnConnectionResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: VpnConnectionResource s)

instance P.HasTunnel1InsideCidr (VpnConnectionResource s) (TF.Attr s Text) where
    tunnel1InsideCidr =
        lens (_tunnel1_inside_cidr :: VpnConnectionResource s -> TF.Attr s Text)
             (\s a -> s { _tunnel1_inside_cidr = a } :: VpnConnectionResource s)

instance P.HasTunnel1PresharedKey (VpnConnectionResource s) (TF.Attr s Text) where
    tunnel1PresharedKey =
        lens (_tunnel1_preshared_key :: VpnConnectionResource s -> TF.Attr s Text)
             (\s a -> s { _tunnel1_preshared_key = a } :: VpnConnectionResource s)

instance P.HasTunnel2InsideCidr (VpnConnectionResource s) (TF.Attr s Text) where
    tunnel2InsideCidr =
        lens (_tunnel2_inside_cidr :: VpnConnectionResource s -> TF.Attr s Text)
             (\s a -> s { _tunnel2_inside_cidr = a } :: VpnConnectionResource s)

instance P.HasTunnel2PresharedKey (VpnConnectionResource s) (TF.Attr s Text) where
    tunnel2PresharedKey =
        lens (_tunnel2_preshared_key :: VpnConnectionResource s -> TF.Attr s Text)
             (\s a -> s { _tunnel2_preshared_key = a } :: VpnConnectionResource s)

instance P.HasType' (VpnConnectionResource s) (TF.Attr s Text) where
    type' =
        lens (_type' :: VpnConnectionResource s -> TF.Attr s Text)
             (\s a -> s { _type' = a } :: VpnConnectionResource s)

instance P.HasVpnGatewayId (VpnConnectionResource s) (TF.Attr s Text) where
    vpnGatewayId =
        lens (_vpn_gateway_id :: VpnConnectionResource s -> TF.Attr s Text)
             (\s a -> s { _vpn_gateway_id = a } :: VpnConnectionResource s)

instance P.HasComputedCustomerGatewayConfiguration (VpnConnectionResource s) s (TF.Attr s Text) where
    computedCustomerGatewayConfiguration x = TF.compute (TF.refKey x) "customer_gateway_configuration"

instance P.HasComputedCustomerGatewayId (VpnConnectionResource s) s (TF.Attr s Text) where
    computedCustomerGatewayId x = TF.compute (TF.refKey x) "customer_gateway_id"

instance P.HasComputedId (VpnConnectionResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedStaticRoutesOnly (VpnConnectionResource s) s (TF.Attr s Text) where
    computedStaticRoutesOnly x = TF.compute (TF.refKey x) "static_routes_only"

instance P.HasComputedTags (VpnConnectionResource s) s (TF.Attr s P.Tags) where
    computedTags x = TF.compute (TF.refKey x) "tags"

instance P.HasComputedTunnel1Address (VpnConnectionResource s) s (TF.Attr s Text) where
    computedTunnel1Address x = TF.compute (TF.refKey x) "tunnel1_address"

instance P.HasComputedTunnel1BgpAsn (VpnConnectionResource s) s (TF.Attr s Text) where
    computedTunnel1BgpAsn x = TF.compute (TF.refKey x) "tunnel1_bgp_asn"

instance P.HasComputedTunnel1BgpHoldtime (VpnConnectionResource s) s (TF.Attr s Text) where
    computedTunnel1BgpHoldtime x = TF.compute (TF.refKey x) "tunnel1_bgp_holdtime"

instance P.HasComputedTunnel1CgwInsideAddress (VpnConnectionResource s) s (TF.Attr s Text) where
    computedTunnel1CgwInsideAddress x = TF.compute (TF.refKey x) "tunnel1_cgw_inside_address"

instance P.HasComputedTunnel1InsideCidr (VpnConnectionResource s) s (TF.Attr s Text) where
    computedTunnel1InsideCidr =
        (_tunnel1_inside_cidr :: VpnConnectionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTunnel1PresharedKey (VpnConnectionResource s) s (TF.Attr s Text) where
    computedTunnel1PresharedKey x = TF.compute (TF.refKey x) "tunnel1_preshared_key"

instance P.HasComputedTunnel1VgwInsideAddress (VpnConnectionResource s) s (TF.Attr s Text) where
    computedTunnel1VgwInsideAddress x = TF.compute (TF.refKey x) "tunnel1_vgw_inside_address"

instance P.HasComputedTunnel2Address (VpnConnectionResource s) s (TF.Attr s Text) where
    computedTunnel2Address x = TF.compute (TF.refKey x) "tunnel2_address"

instance P.HasComputedTunnel2BgpAsn (VpnConnectionResource s) s (TF.Attr s Text) where
    computedTunnel2BgpAsn x = TF.compute (TF.refKey x) "tunnel2_bgp_asn"

instance P.HasComputedTunnel2BgpHoldtime (VpnConnectionResource s) s (TF.Attr s Text) where
    computedTunnel2BgpHoldtime x = TF.compute (TF.refKey x) "tunnel2_bgp_holdtime"

instance P.HasComputedTunnel2CgwInsideAddress (VpnConnectionResource s) s (TF.Attr s Text) where
    computedTunnel2CgwInsideAddress x = TF.compute (TF.refKey x) "tunnel2_cgw_inside_address"

instance P.HasComputedTunnel2InsideCidr (VpnConnectionResource s) s (TF.Attr s Text) where
    computedTunnel2InsideCidr =
        (_tunnel2_inside_cidr :: VpnConnectionResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedTunnel2PresharedKey (VpnConnectionResource s) s (TF.Attr s Text) where
    computedTunnel2PresharedKey x = TF.compute (TF.refKey x) "tunnel2_preshared_key"

instance P.HasComputedTunnel2VgwInsideAddress (VpnConnectionResource s) s (TF.Attr s Text) where
    computedTunnel2VgwInsideAddress x = TF.compute (TF.refKey x) "tunnel2_vgw_inside_address"

instance P.HasComputedType' (VpnConnectionResource s) s (TF.Attr s Text) where
    computedType' x = TF.compute (TF.refKey x) "type"

instance P.HasComputedVpnGatewayId (VpnConnectionResource s) s (TF.Attr s Text) where
    computedVpnGatewayId x = TF.compute (TF.refKey x) "vpn_gateway_id"

vpnConnectionResource :: TF.Schema TF.Resource P.AWS (VpnConnectionResource s)
vpnConnectionResource =
    TF.newResource "aws_vpn_connection" $
        VpnConnectionResource {
              _customer_gateway_id = TF.Nil
            , _static_routes_only = TF.Nil
            , _tags = TF.Nil
            , _tunnel1_inside_cidr = TF.Nil
            , _tunnel1_preshared_key = TF.Nil
            , _tunnel2_inside_cidr = TF.Nil
            , _tunnel2_preshared_key = TF.Nil
            , _type' = TF.Nil
            , _vpn_gateway_id = TF.Nil
            }

{- | The @aws_vpn_connection_route@ AWS resource.

Provides a static route between a VPN connection and a customer gateway.
-}
data VpnConnectionRouteResource s = VpnConnectionRouteResource {
      _destination_cidr_block :: !(TF.Attr s P.CIDR)
    {- ^ (Required) The CIDR block associated with the local subnet of the customer network. -}
    , _vpn_connection_id      :: !(TF.Attr s Text)
    {- ^ (Required) The ID of the VPN connection. -}
    } deriving (Show, Eq)

instance TF.ToHCL (VpnConnectionRouteResource s) where
    toHCL VpnConnectionRouteResource{..} = TF.inline $ catMaybes
        [ TF.assign "destination_cidr_block" <$> TF.attribute _destination_cidr_block
        , TF.assign "vpn_connection_id" <$> TF.attribute _vpn_connection_id
        ]

instance P.HasDestinationCidrBlock (VpnConnectionRouteResource s) (TF.Attr s P.CIDR) where
    destinationCidrBlock =
        lens (_destination_cidr_block :: VpnConnectionRouteResource s -> TF.Attr s P.CIDR)
             (\s a -> s { _destination_cidr_block = a } :: VpnConnectionRouteResource s)

instance P.HasVpnConnectionId (VpnConnectionRouteResource s) (TF.Attr s Text) where
    vpnConnectionId =
        lens (_vpn_connection_id :: VpnConnectionRouteResource s -> TF.Attr s Text)
             (\s a -> s { _vpn_connection_id = a } :: VpnConnectionRouteResource s)

instance P.HasComputedDestinationCidrBlock (VpnConnectionRouteResource s) s (TF.Attr s P.CIDR) where
    computedDestinationCidrBlock x = TF.compute (TF.refKey x) "destination_cidr_block"

instance P.HasComputedVpnConnectionId (VpnConnectionRouteResource s) s (TF.Attr s Text) where
    computedVpnConnectionId x = TF.compute (TF.refKey x) "vpn_connection_id"

vpnConnectionRouteResource :: TF.Schema TF.Resource P.AWS (VpnConnectionRouteResource s)
vpnConnectionRouteResource =
    TF.newResource "aws_vpn_connection_route" $
        VpnConnectionRouteResource {
              _destination_cidr_block = TF.Nil
            , _vpn_connection_id = TF.Nil
            }

{- | The @aws_vpn_gateway_attachment@ AWS resource.

Provides a Virtual Private Gateway attachment resource, allowing for an
existing hardware VPN gateway to be attached and/or detached from a VPC. ->
Note: The <vpn_gateway.html> resource can also automatically attach the
Virtual Private Gateway it creates to an existing VPC by setting the
<vpn_gateway.html#vpc_id> attribute accordingly.
-}
data VpnGatewayAttachmentResource s = VpnGatewayAttachmentResource {
      _vpc_id         :: !(TF.Attr s Text)
    {- ^ (Required) The ID of the VPC. -}
    , _vpn_gateway_id :: !(TF.Attr s Text)
    {- ^ (Required) The ID of the Virtual Private Gateway. -}
    } deriving (Show, Eq)

instance TF.ToHCL (VpnGatewayAttachmentResource s) where
    toHCL VpnGatewayAttachmentResource{..} = TF.inline $ catMaybes
        [ TF.assign "vpc_id" <$> TF.attribute _vpc_id
        , TF.assign "vpn_gateway_id" <$> TF.attribute _vpn_gateway_id
        ]

instance P.HasVpcId (VpnGatewayAttachmentResource s) (TF.Attr s Text) where
    vpcId =
        lens (_vpc_id :: VpnGatewayAttachmentResource s -> TF.Attr s Text)
             (\s a -> s { _vpc_id = a } :: VpnGatewayAttachmentResource s)

instance P.HasVpnGatewayId (VpnGatewayAttachmentResource s) (TF.Attr s Text) where
    vpnGatewayId =
        lens (_vpn_gateway_id :: VpnGatewayAttachmentResource s -> TF.Attr s Text)
             (\s a -> s { _vpn_gateway_id = a } :: VpnGatewayAttachmentResource s)

instance P.HasComputedVpcId (VpnGatewayAttachmentResource s) s (TF.Attr s Text) where
    computedVpcId x = TF.compute (TF.refKey x) "vpc_id"

instance P.HasComputedVpnGatewayId (VpnGatewayAttachmentResource s) s (TF.Attr s Text) where
    computedVpnGatewayId x = TF.compute (TF.refKey x) "vpn_gateway_id"

vpnGatewayAttachmentResource :: TF.Schema TF.Resource P.AWS (VpnGatewayAttachmentResource s)
vpnGatewayAttachmentResource =
    TF.newResource "aws_vpn_gateway_attachment" $
        VpnGatewayAttachmentResource {
              _vpc_id = TF.Nil
            , _vpn_gateway_id = TF.Nil
            }

{- | The @aws_vpn_gateway@ AWS resource.

Provides a resource to create a VPC VPN Gateway.
-}
data VpnGatewayResource s = VpnGatewayResource {
      _amazon_side_asn   :: !(TF.Attr s Text)
    {- ^ (Optional) The Autonomous System Number (ASN) for the Amazon side of the gateway. If you don't specify an ASN, the virtual private gateway is created with the default ASN. -}
    , _availability_zone :: !(TF.Attr s P.Zone)
    {- ^ (Optional) The Availability Zone for the virtual private gateway. -}
    , _tags              :: !(TF.Attr s P.Tags)
    {- ^ (Optional) A mapping of tags to assign to the resource. -}
    , _vpc_id            :: !(TF.Attr s Text)
    {- ^ (Optional) The VPC ID to create in. -}
    } deriving (Show, Eq)

instance TF.ToHCL (VpnGatewayResource s) where
    toHCL VpnGatewayResource{..} = TF.inline $ catMaybes
        [ TF.assign "amazon_side_asn" <$> TF.attribute _amazon_side_asn
        , TF.assign "availability_zone" <$> TF.attribute _availability_zone
        , TF.assign "tags" <$> TF.attribute _tags
        , TF.assign "vpc_id" <$> TF.attribute _vpc_id
        ]

instance P.HasAmazonSideAsn (VpnGatewayResource s) (TF.Attr s Text) where
    amazonSideAsn =
        lens (_amazon_side_asn :: VpnGatewayResource s -> TF.Attr s Text)
             (\s a -> s { _amazon_side_asn = a } :: VpnGatewayResource s)

instance P.HasAvailabilityZone (VpnGatewayResource s) (TF.Attr s P.Zone) where
    availabilityZone =
        lens (_availability_zone :: VpnGatewayResource s -> TF.Attr s P.Zone)
             (\s a -> s { _availability_zone = a } :: VpnGatewayResource s)

instance P.HasTags (VpnGatewayResource s) (TF.Attr s P.Tags) where
    tags =
        lens (_tags :: VpnGatewayResource s -> TF.Attr s P.Tags)
             (\s a -> s { _tags = a } :: VpnGatewayResource s)

instance P.HasVpcId (VpnGatewayResource s) (TF.Attr s Text) where
    vpcId =
        lens (_vpc_id :: VpnGatewayResource s -> TF.Attr s Text)
             (\s a -> s { _vpc_id = a } :: VpnGatewayResource s)

instance P.HasComputedAmazonSideAsn (VpnGatewayResource s) s (TF.Attr s Text) where
    computedAmazonSideAsn =
        (_amazon_side_asn :: VpnGatewayResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedAvailabilityZone (VpnGatewayResource s) s (TF.Attr s P.Zone) where
    computedAvailabilityZone =
        (_availability_zone :: VpnGatewayResource s -> TF.Attr s P.Zone)
            . TF.refValue

instance P.HasComputedId (VpnGatewayResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedTags (VpnGatewayResource s) s (TF.Attr s P.Tags) where
    computedTags =
        (_tags :: VpnGatewayResource s -> TF.Attr s P.Tags)
            . TF.refValue

instance P.HasComputedVpcId (VpnGatewayResource s) s (TF.Attr s Text) where
    computedVpcId =
        (_vpc_id :: VpnGatewayResource s -> TF.Attr s Text)
            . TF.refValue

vpnGatewayResource :: TF.Schema TF.Resource P.AWS (VpnGatewayResource s)
vpnGatewayResource =
    TF.newResource "aws_vpn_gateway" $
        VpnGatewayResource {
              _amazon_side_asn = TF.Nil
            , _availability_zone = TF.Nil
            , _tags = TF.Nil
            , _vpc_id = TF.Nil
            }

{- | The @aws_vpn_gateway_route_propagation@ AWS resource.

Requests automatic route propagation between a VPN gateway and a route
table. ~> Note: This resource should not be used with a route table that has
the @propagating_vgws@ argument set. If that argument is set, any route
propagation not explicitly listed in its value will be removed.
-}
data VpnGatewayRoutePropagationResource s = VpnGatewayRoutePropagationResource {
      _route_table_id :: !(TF.Attr s Text)
    {- ^ - The id of the @aws_route_table@ to propagate routes into. -}
    , _vpn_gateway_id :: !(TF.Attr s Text)
    {- ^ - The id of the @aws_vpn_gateway@ to propagate routes from. -}
    } deriving (Show, Eq)

instance TF.ToHCL (VpnGatewayRoutePropagationResource s) where
    toHCL VpnGatewayRoutePropagationResource{..} = TF.inline $ catMaybes
        [ TF.assign "route_table_id" <$> TF.attribute _route_table_id
        , TF.assign "vpn_gateway_id" <$> TF.attribute _vpn_gateway_id
        ]

instance P.HasRouteTableId (VpnGatewayRoutePropagationResource s) (TF.Attr s Text) where
    routeTableId =
        lens (_route_table_id :: VpnGatewayRoutePropagationResource s -> TF.Attr s Text)
             (\s a -> s { _route_table_id = a } :: VpnGatewayRoutePropagationResource s)

instance P.HasVpnGatewayId (VpnGatewayRoutePropagationResource s) (TF.Attr s Text) where
    vpnGatewayId =
        lens (_vpn_gateway_id :: VpnGatewayRoutePropagationResource s -> TF.Attr s Text)
             (\s a -> s { _vpn_gateway_id = a } :: VpnGatewayRoutePropagationResource s)

instance P.HasComputedRouteTableId (VpnGatewayRoutePropagationResource s) s (TF.Attr s Text) where
    computedRouteTableId =
        (_route_table_id :: VpnGatewayRoutePropagationResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedVpnGatewayId (VpnGatewayRoutePropagationResource s) s (TF.Attr s Text) where
    computedVpnGatewayId =
        (_vpn_gateway_id :: VpnGatewayRoutePropagationResource s -> TF.Attr s Text)
            . TF.refValue

vpnGatewayRoutePropagationResource :: TF.Schema TF.Resource P.AWS (VpnGatewayRoutePropagationResource s)
vpnGatewayRoutePropagationResource =
    TF.newResource "aws_vpn_gateway_route_propagation" $
        VpnGatewayRoutePropagationResource {
              _route_table_id = TF.Nil
            , _vpn_gateway_id = TF.Nil
            }

{- | The @aws_waf_byte_match_set@ AWS resource.

Provides a WAF Byte Match Set Resource
-}
data WafByteMatchSetResource s = WafByteMatchSetResource {
      _byte_match_tuples :: !(TF.Attr s Text)
    {- ^ - Specifies the bytes (typically a string that corresponds with ASCII characters) that you want to search for in web requests, the location in requests that you want to search, and other settings. -}
    , _name              :: !(TF.Attr s Text)
    {- ^ (Required) The name or description of the Byte Match Set. -}
    } deriving (Show, Eq)

instance TF.ToHCL (WafByteMatchSetResource s) where
    toHCL WafByteMatchSetResource{..} = TF.inline $ catMaybes
        [ TF.assign "byte_match_tuples" <$> TF.attribute _byte_match_tuples
        , TF.assign "name" <$> TF.attribute _name
        ]

instance P.HasByteMatchTuples (WafByteMatchSetResource s) (TF.Attr s Text) where
    byteMatchTuples =
        lens (_byte_match_tuples :: WafByteMatchSetResource s -> TF.Attr s Text)
             (\s a -> s { _byte_match_tuples = a } :: WafByteMatchSetResource s)

instance P.HasName (WafByteMatchSetResource s) (TF.Attr s Text) where
    name =
        lens (_name :: WafByteMatchSetResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: WafByteMatchSetResource s)

instance P.HasComputedByteMatchTuples (WafByteMatchSetResource s) s (TF.Attr s Text) where
    computedByteMatchTuples =
        (_byte_match_tuples :: WafByteMatchSetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (WafByteMatchSetResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (WafByteMatchSetResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: WafByteMatchSetResource s -> TF.Attr s Text)
            . TF.refValue

wafByteMatchSetResource :: TF.Schema TF.Resource P.AWS (WafByteMatchSetResource s)
wafByteMatchSetResource =
    TF.newResource "aws_waf_byte_match_set" $
        WafByteMatchSetResource {
              _byte_match_tuples = TF.Nil
            , _name = TF.Nil
            }

{- | The @aws_waf_ipset@ AWS resource.

Provides a WAF IPSet Resource
-}
data WafIpsetResource s = WafIpsetResource {
      _ip_set_descriptors :: !(TF.Attr s Text)
    {- ^ (Optional) Specifies the IP address type (IPV4 or IPV6) and the IP address range (in CIDR format) that web requests originate from. -}
    , _name               :: !(TF.Attr s Text)
    {- ^ (Required) The name or description of the IPSet. -}
    } deriving (Show, Eq)

instance TF.ToHCL (WafIpsetResource s) where
    toHCL WafIpsetResource{..} = TF.inline $ catMaybes
        [ TF.assign "ip_set_descriptors" <$> TF.attribute _ip_set_descriptors
        , TF.assign "name" <$> TF.attribute _name
        ]

instance P.HasIpSetDescriptors (WafIpsetResource s) (TF.Attr s Text) where
    ipSetDescriptors =
        lens (_ip_set_descriptors :: WafIpsetResource s -> TF.Attr s Text)
             (\s a -> s { _ip_set_descriptors = a } :: WafIpsetResource s)

instance P.HasName (WafIpsetResource s) (TF.Attr s Text) where
    name =
        lens (_name :: WafIpsetResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: WafIpsetResource s)

instance P.HasComputedId (WafIpsetResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedIpSetDescriptors (WafIpsetResource s) s (TF.Attr s Text) where
    computedIpSetDescriptors =
        (_ip_set_descriptors :: WafIpsetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (WafIpsetResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: WafIpsetResource s -> TF.Attr s Text)
            . TF.refValue

wafIpsetResource :: TF.Schema TF.Resource P.AWS (WafIpsetResource s)
wafIpsetResource =
    TF.newResource "aws_waf_ipset" $
        WafIpsetResource {
              _ip_set_descriptors = TF.Nil
            , _name = TF.Nil
            }

{- | The @aws_waf_rate_based_rule@ AWS resource.

Provides a WAF Rate Based Rule Resource
-}
data WafRateBasedRuleResource s = WafRateBasedRuleResource {
      _metric_name :: !(TF.Attr s Text)
    {- ^ (Required) The name or description for the Amazon CloudWatch metric of this rule. -}
    , _name        :: !(TF.Attr s Text)
    {- ^ (Required) The name or description of the rule. -}
    , _predicates  :: !(TF.Attr s Text)
    {- ^ (Optional) One of ByteMatchSet, IPSet, SizeConstraintSet, SqlInjectionMatchSet, or XssMatchSet objects to include in a rule. -}
    , _rate_key    :: !(TF.Attr s Text)
    {- ^ (Required) Valid value is IP. -}
    , _rate_limit  :: !(TF.Attr s Text)
    {- ^ (Required) The maximum number of requests, which have an identical value in the field specified by the RateKey, allowed in a five-minute period. Minimum value is 2000. -}
    } deriving (Show, Eq)

instance TF.ToHCL (WafRateBasedRuleResource s) where
    toHCL WafRateBasedRuleResource{..} = TF.inline $ catMaybes
        [ TF.assign "metric_name" <$> TF.attribute _metric_name
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "predicates" <$> TF.attribute _predicates
        , TF.assign "rate_key" <$> TF.attribute _rate_key
        , TF.assign "rate_limit" <$> TF.attribute _rate_limit
        ]

instance P.HasMetricName (WafRateBasedRuleResource s) (TF.Attr s Text) where
    metricName =
        lens (_metric_name :: WafRateBasedRuleResource s -> TF.Attr s Text)
             (\s a -> s { _metric_name = a } :: WafRateBasedRuleResource s)

instance P.HasName (WafRateBasedRuleResource s) (TF.Attr s Text) where
    name =
        lens (_name :: WafRateBasedRuleResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: WafRateBasedRuleResource s)

instance P.HasPredicates (WafRateBasedRuleResource s) (TF.Attr s Text) where
    predicates =
        lens (_predicates :: WafRateBasedRuleResource s -> TF.Attr s Text)
             (\s a -> s { _predicates = a } :: WafRateBasedRuleResource s)

instance P.HasRateKey (WafRateBasedRuleResource s) (TF.Attr s Text) where
    rateKey =
        lens (_rate_key :: WafRateBasedRuleResource s -> TF.Attr s Text)
             (\s a -> s { _rate_key = a } :: WafRateBasedRuleResource s)

instance P.HasRateLimit (WafRateBasedRuleResource s) (TF.Attr s Text) where
    rateLimit =
        lens (_rate_limit :: WafRateBasedRuleResource s -> TF.Attr s Text)
             (\s a -> s { _rate_limit = a } :: WafRateBasedRuleResource s)

instance P.HasComputedId (WafRateBasedRuleResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedMetricName (WafRateBasedRuleResource s) s (TF.Attr s Text) where
    computedMetricName =
        (_metric_name :: WafRateBasedRuleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (WafRateBasedRuleResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: WafRateBasedRuleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPredicates (WafRateBasedRuleResource s) s (TF.Attr s Text) where
    computedPredicates =
        (_predicates :: WafRateBasedRuleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRateKey (WafRateBasedRuleResource s) s (TF.Attr s Text) where
    computedRateKey =
        (_rate_key :: WafRateBasedRuleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRateLimit (WafRateBasedRuleResource s) s (TF.Attr s Text) where
    computedRateLimit =
        (_rate_limit :: WafRateBasedRuleResource s -> TF.Attr s Text)
            . TF.refValue

wafRateBasedRuleResource :: TF.Schema TF.Resource P.AWS (WafRateBasedRuleResource s)
wafRateBasedRuleResource =
    TF.newResource "aws_waf_rate_based_rule" $
        WafRateBasedRuleResource {
              _metric_name = TF.Nil
            , _name = TF.Nil
            , _predicates = TF.Nil
            , _rate_key = TF.Nil
            , _rate_limit = TF.Nil
            }

{- | The @aws_waf_rule@ AWS resource.

Provides a WAF Rule Resource
-}
data WafRuleResource s = WafRuleResource {
      _metric_name :: !(TF.Attr s Text)
    {- ^ (Required) The name or description for the Amazon CloudWatch metric of this rule. -}
    , _name        :: !(TF.Attr s Text)
    {- ^ (Required) The name or description of the rule. -}
    , _predicates  :: !(TF.Attr s Text)
    {- ^ (Optional) One of ByteMatchSet, IPSet, SizeConstraintSet, SqlInjectionMatchSet, or XssMatchSet objects to include in a rule. -}
    } deriving (Show, Eq)

instance TF.ToHCL (WafRuleResource s) where
    toHCL WafRuleResource{..} = TF.inline $ catMaybes
        [ TF.assign "metric_name" <$> TF.attribute _metric_name
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "predicates" <$> TF.attribute _predicates
        ]

instance P.HasMetricName (WafRuleResource s) (TF.Attr s Text) where
    metricName =
        lens (_metric_name :: WafRuleResource s -> TF.Attr s Text)
             (\s a -> s { _metric_name = a } :: WafRuleResource s)

instance P.HasName (WafRuleResource s) (TF.Attr s Text) where
    name =
        lens (_name :: WafRuleResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: WafRuleResource s)

instance P.HasPredicates (WafRuleResource s) (TF.Attr s Text) where
    predicates =
        lens (_predicates :: WafRuleResource s -> TF.Attr s Text)
             (\s a -> s { _predicates = a } :: WafRuleResource s)

instance P.HasComputedId (WafRuleResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedMetricName (WafRuleResource s) s (TF.Attr s Text) where
    computedMetricName =
        (_metric_name :: WafRuleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (WafRuleResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: WafRuleResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedPredicates (WafRuleResource s) s (TF.Attr s Text) where
    computedPredicates =
        (_predicates :: WafRuleResource s -> TF.Attr s Text)
            . TF.refValue

wafRuleResource :: TF.Schema TF.Resource P.AWS (WafRuleResource s)
wafRuleResource =
    TF.newResource "aws_waf_rule" $
        WafRuleResource {
              _metric_name = TF.Nil
            , _name = TF.Nil
            , _predicates = TF.Nil
            }

{- | The @aws_waf_size_constraint_set@ AWS resource.

Provides a WAF Size Constraint Set Resource
-}
data WafSizeConstraintSetResource s = WafSizeConstraintSetResource {
      _name             :: !(TF.Attr s Text)
    {- ^ (Required) The name or description of the Size Constraint Set. -}
    , _size_constraints :: !(TF.Attr s Text)
    {- ^ (Optional) Specifies the parts of web requests that you want to inspect the size of. -}
    } deriving (Show, Eq)

instance TF.ToHCL (WafSizeConstraintSetResource s) where
    toHCL WafSizeConstraintSetResource{..} = TF.inline $ catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "size_constraints" <$> TF.attribute _size_constraints
        ]

instance P.HasName (WafSizeConstraintSetResource s) (TF.Attr s Text) where
    name =
        lens (_name :: WafSizeConstraintSetResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: WafSizeConstraintSetResource s)

instance P.HasSizeConstraints (WafSizeConstraintSetResource s) (TF.Attr s Text) where
    sizeConstraints =
        lens (_size_constraints :: WafSizeConstraintSetResource s -> TF.Attr s Text)
             (\s a -> s { _size_constraints = a } :: WafSizeConstraintSetResource s)

instance P.HasComputedId (WafSizeConstraintSetResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (WafSizeConstraintSetResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: WafSizeConstraintSetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSizeConstraints (WafSizeConstraintSetResource s) s (TF.Attr s Text) where
    computedSizeConstraints =
        (_size_constraints :: WafSizeConstraintSetResource s -> TF.Attr s Text)
            . TF.refValue

wafSizeConstraintSetResource :: TF.Schema TF.Resource P.AWS (WafSizeConstraintSetResource s)
wafSizeConstraintSetResource =
    TF.newResource "aws_waf_size_constraint_set" $
        WafSizeConstraintSetResource {
              _name = TF.Nil
            , _size_constraints = TF.Nil
            }

{- | The @aws_waf_sql_injection_match_set@ AWS resource.

Provides a WAF SQL Injection Match Set Resource
-}
data WafSqlInjectionMatchSetResource s = WafSqlInjectionMatchSetResource {
      _name                       :: !(TF.Attr s Text)
    {- ^ (Required) The name or description of the SizeConstraintSet. -}
    , _sql_injection_match_tuples :: !(TF.Attr s Text)
    {- ^ (Optional) The parts of web requests that you want AWS WAF to inspect for malicious SQL code and, if you want AWS WAF to inspect a header, the name of the header. -}
    } deriving (Show, Eq)

instance TF.ToHCL (WafSqlInjectionMatchSetResource s) where
    toHCL WafSqlInjectionMatchSetResource{..} = TF.inline $ catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "sql_injection_match_tuples" <$> TF.attribute _sql_injection_match_tuples
        ]

instance P.HasName (WafSqlInjectionMatchSetResource s) (TF.Attr s Text) where
    name =
        lens (_name :: WafSqlInjectionMatchSetResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: WafSqlInjectionMatchSetResource s)

instance P.HasSqlInjectionMatchTuples (WafSqlInjectionMatchSetResource s) (TF.Attr s Text) where
    sqlInjectionMatchTuples =
        lens (_sql_injection_match_tuples :: WafSqlInjectionMatchSetResource s -> TF.Attr s Text)
             (\s a -> s { _sql_injection_match_tuples = a } :: WafSqlInjectionMatchSetResource s)

instance P.HasComputedId (WafSqlInjectionMatchSetResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (WafSqlInjectionMatchSetResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: WafSqlInjectionMatchSetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedSqlInjectionMatchTuples (WafSqlInjectionMatchSetResource s) s (TF.Attr s Text) where
    computedSqlInjectionMatchTuples =
        (_sql_injection_match_tuples :: WafSqlInjectionMatchSetResource s -> TF.Attr s Text)
            . TF.refValue

wafSqlInjectionMatchSetResource :: TF.Schema TF.Resource P.AWS (WafSqlInjectionMatchSetResource s)
wafSqlInjectionMatchSetResource =
    TF.newResource "aws_waf_sql_injection_match_set" $
        WafSqlInjectionMatchSetResource {
              _name = TF.Nil
            , _sql_injection_match_tuples = TF.Nil
            }

{- | The @aws_waf_web_acl@ AWS resource.

Provides a WAF Web ACL Resource
-}
data WafWebAclResource s = WafWebAclResource {
      _default_action :: !(TF.Attr s Text)
    {- ^ (Required) The action that you want AWS WAF to take when a request doesn't match the criteria in any of the rules that are associated with the web ACL. -}
    , _metric_name    :: !(TF.Attr s Text)
    {- ^ (Required) The name or description for the Amazon CloudWatch metric of this web ACL. -}
    , _name           :: !(TF.Attr s Text)
    {- ^ (Required) The name or description of the web ACL. -}
    , _rules          :: !(TF.Attr s Text)
    {- ^ (Required) The rules to associate with the web ACL and the settings for each rule. -}
    } deriving (Show, Eq)

instance TF.ToHCL (WafWebAclResource s) where
    toHCL WafWebAclResource{..} = TF.inline $ catMaybes
        [ TF.assign "default_action" <$> TF.attribute _default_action
        , TF.assign "metric_name" <$> TF.attribute _metric_name
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "rules" <$> TF.attribute _rules
        ]

instance P.HasDefaultAction (WafWebAclResource s) (TF.Attr s Text) where
    defaultAction =
        lens (_default_action :: WafWebAclResource s -> TF.Attr s Text)
             (\s a -> s { _default_action = a } :: WafWebAclResource s)

instance P.HasMetricName (WafWebAclResource s) (TF.Attr s Text) where
    metricName =
        lens (_metric_name :: WafWebAclResource s -> TF.Attr s Text)
             (\s a -> s { _metric_name = a } :: WafWebAclResource s)

instance P.HasName (WafWebAclResource s) (TF.Attr s Text) where
    name =
        lens (_name :: WafWebAclResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: WafWebAclResource s)

instance P.HasRules (WafWebAclResource s) (TF.Attr s Text) where
    rules =
        lens (_rules :: WafWebAclResource s -> TF.Attr s Text)
             (\s a -> s { _rules = a } :: WafWebAclResource s)

instance P.HasComputedDefaultAction (WafWebAclResource s) s (TF.Attr s Text) where
    computedDefaultAction =
        (_default_action :: WafWebAclResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (WafWebAclResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedMetricName (WafWebAclResource s) s (TF.Attr s Text) where
    computedMetricName =
        (_metric_name :: WafWebAclResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (WafWebAclResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: WafWebAclResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedRules (WafWebAclResource s) s (TF.Attr s Text) where
    computedRules =
        (_rules :: WafWebAclResource s -> TF.Attr s Text)
            . TF.refValue

wafWebAclResource :: TF.Schema TF.Resource P.AWS (WafWebAclResource s)
wafWebAclResource =
    TF.newResource "aws_waf_web_acl" $
        WafWebAclResource {
              _default_action = TF.Nil
            , _metric_name = TF.Nil
            , _name = TF.Nil
            , _rules = TF.Nil
            }

{- | The @aws_waf_xss_match_set@ AWS resource.

Provides a WAF XSS Match Set Resource
-}
data WafXssMatchSetResource s = WafXssMatchSetResource {
      _name             :: !(TF.Attr s Text)
    {- ^ (Required) The name or description of the SizeConstraintSet. -}
    , _xss_match_tuples :: !(TF.Attr s Text)
    {- ^ (Optional) The parts of web requests that you want to inspect for cross-site scripting attacks. -}
    } deriving (Show, Eq)

instance TF.ToHCL (WafXssMatchSetResource s) where
    toHCL WafXssMatchSetResource{..} = TF.inline $ catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "xss_match_tuples" <$> TF.attribute _xss_match_tuples
        ]

instance P.HasName (WafXssMatchSetResource s) (TF.Attr s Text) where
    name =
        lens (_name :: WafXssMatchSetResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: WafXssMatchSetResource s)

instance P.HasXssMatchTuples (WafXssMatchSetResource s) (TF.Attr s Text) where
    xssMatchTuples =
        lens (_xss_match_tuples :: WafXssMatchSetResource s -> TF.Attr s Text)
             (\s a -> s { _xss_match_tuples = a } :: WafXssMatchSetResource s)

instance P.HasComputedId (WafXssMatchSetResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (WafXssMatchSetResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: WafXssMatchSetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedXssMatchTuples (WafXssMatchSetResource s) s (TF.Attr s Text) where
    computedXssMatchTuples =
        (_xss_match_tuples :: WafXssMatchSetResource s -> TF.Attr s Text)
            . TF.refValue

wafXssMatchSetResource :: TF.Schema TF.Resource P.AWS (WafXssMatchSetResource s)
wafXssMatchSetResource =
    TF.newResource "aws_waf_xss_match_set" $
        WafXssMatchSetResource {
              _name = TF.Nil
            , _xss_match_tuples = TF.Nil
            }

{- | The @aws_wafregional_byte_match_set@ AWS resource.

Provides a WAF Regional Byte Match Set Resource for use with Application
Load Balancer.
-}
data WafregionalByteMatchSetResource s = WafregionalByteMatchSetResource {
      _byte_match_tuple :: !(TF.Attr s Text)
    {- ^ (Optional)Settings for the ByteMatchSet, such as the bytes (typically a string that corresponds with ASCII characters) that you want AWS WAF to search for in web requests. ByteMatchTuple documented below. -}
    , _name             :: !(TF.Attr s Text)
    {- ^ (Required) The name or description of the ByteMatchSet. -}
    } deriving (Show, Eq)

instance TF.ToHCL (WafregionalByteMatchSetResource s) where
    toHCL WafregionalByteMatchSetResource{..} = TF.inline $ catMaybes
        [ TF.assign "byte_match_tuple" <$> TF.attribute _byte_match_tuple
        , TF.assign "name" <$> TF.attribute _name
        ]

instance P.HasByteMatchTuple (WafregionalByteMatchSetResource s) (TF.Attr s Text) where
    byteMatchTuple =
        lens (_byte_match_tuple :: WafregionalByteMatchSetResource s -> TF.Attr s Text)
             (\s a -> s { _byte_match_tuple = a } :: WafregionalByteMatchSetResource s)

instance P.HasName (WafregionalByteMatchSetResource s) (TF.Attr s Text) where
    name =
        lens (_name :: WafregionalByteMatchSetResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: WafregionalByteMatchSetResource s)

instance P.HasComputedByteMatchTuple (WafregionalByteMatchSetResource s) s (TF.Attr s Text) where
    computedByteMatchTuple =
        (_byte_match_tuple :: WafregionalByteMatchSetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedId (WafregionalByteMatchSetResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedName (WafregionalByteMatchSetResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: WafregionalByteMatchSetResource s -> TF.Attr s Text)
            . TF.refValue

wafregionalByteMatchSetResource :: TF.Schema TF.Resource P.AWS (WafregionalByteMatchSetResource s)
wafregionalByteMatchSetResource =
    TF.newResource "aws_wafregional_byte_match_set" $
        WafregionalByteMatchSetResource {
              _byte_match_tuple = TF.Nil
            , _name = TF.Nil
            }

{- | The @aws_wafregional_ipset@ AWS resource.

Provides a WAF Regional IPSet Resource for use with Application Load
Balancer.
-}
data WafregionalIpsetResource s = WafregionalIpsetResource {
      _ip_set_descriptor :: !(TF.Attr s Text)
    {- ^ (Optional) The IP address type and IP address range (in CIDR notation) from which web requests originate. -}
    , _name              :: !(TF.Attr s Text)
    {- ^ (Required) The name or description of the IPSet. -}
    } deriving (Show, Eq)

instance TF.ToHCL (WafregionalIpsetResource s) where
    toHCL WafregionalIpsetResource{..} = TF.inline $ catMaybes
        [ TF.assign "ip_set_descriptor" <$> TF.attribute _ip_set_descriptor
        , TF.assign "name" <$> TF.attribute _name
        ]

instance P.HasIpSetDescriptor (WafregionalIpsetResource s) (TF.Attr s Text) where
    ipSetDescriptor =
        lens (_ip_set_descriptor :: WafregionalIpsetResource s -> TF.Attr s Text)
             (\s a -> s { _ip_set_descriptor = a } :: WafregionalIpsetResource s)

instance P.HasName (WafregionalIpsetResource s) (TF.Attr s Text) where
    name =
        lens (_name :: WafregionalIpsetResource s -> TF.Attr s Text)
             (\s a -> s { _name = a } :: WafregionalIpsetResource s)

instance P.HasComputedId (WafregionalIpsetResource s) s (TF.Attr s Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance P.HasComputedIpSetDescriptor (WafregionalIpsetResource s) s (TF.Attr s Text) where
    computedIpSetDescriptor =
        (_ip_set_descriptor :: WafregionalIpsetResource s -> TF.Attr s Text)
            . TF.refValue

instance P.HasComputedName (WafregionalIpsetResource s) s (TF.Attr s Text) where
    computedName =
        (_name :: WafregionalIpsetResource s -> TF.Attr s Text)
            . TF.refValue

wafregionalIpsetResource :: TF.Schema TF.Resource P.AWS (WafregionalIpsetResource s)
wafregionalIpsetResource =
    TF.newResource "aws_wafregional_ipset" $
        WafregionalIpsetResource {
              _ip_set_descriptor = TF.Nil
            , _name = TF.Nil
            }
