{
    "settings": [
        {
            "con": {
                "smart": "newConfigMapMetadataSetting",
                "name": "ConfigMapMetadataSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "An unstructured key value map stored with the config map that may be used to",
                        "store arbitrary metadata. More info:",
                        "http://kubernetes.io/docs/user-guide/annotations"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"annotations\" <$> TF.attribute",
                    "name": "_annotations",
                    "method": "annotations",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasAnnotations",
                    "validate": false,
                    "optional": true,
                    "original": "annotations"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Prefix, used by the server, to generate a unique name ONLY IF the `name`",
                        "field has not been provided. This value will also be combined with a unique",
                        "suffix. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#idempotency"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"generate_name\" <$> TF.attribute",
                    "name": "_generateName",
                    "method": "generateName",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_name",
                            "method": "name"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasGenerateName",
                    "validate": false,
                    "optional": true,
                    "original": "generate_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Map of string keys and values that can be used to organize and categorize",
                        "(scope and select) the config map. May match selectors of replication",
                        "controllers and services. More info:",
                        "http://kubernetes.io/docs/user-guide/labels"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"labels\" <$> TF.attribute",
                    "name": "_labels",
                    "method": "labels",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasLabels",
                    "validate": false,
                    "optional": true,
                    "original": "labels"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the config map, must be unique. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_generateName",
                            "method": "generateName"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.value \"default\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Namespace defines the space within which name of the config map must be",
                        "unique."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"namespace\" <$> TF.attribute",
                    "name": "_namespace",
                    "method": "namespace",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasNamespace",
                    "validate": false,
                    "optional": true,
                    "original": "namespace"
                }
            ],
            "dependencies": [],
            "key": "config_map.metadata",
            "name": "ConfigMapMetadataSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A sequence number representing a specific generation of the desired state."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"generation\" <$> TF.attribute",
                    "name": "_computedGeneration",
                    "method": "computedGeneration",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedGeneration",
                    "validate": false,
                    "optional": false,
                    "original": "generation"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Name of the config map, must be unique. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_computedName",
                    "method": "computedName",
                    "threaded": true,
                    "conflicts": [
                        "_generateName"
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "An opaque value that represents the internal version of this config map that",
                        "can be used by clients to determine when config map has changed. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#concurrency-control-and-consistency"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_version\" <$> TF.attribute",
                    "name": "_computedResourceVersion",
                    "method": "computedResourceVersion",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedResourceVersion",
                    "validate": false,
                    "optional": false,
                    "original": "resource_version"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A URL representing this config map."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"self_link\" <$> TF.attribute",
                    "name": "_computedSelfLink",
                    "method": "computedSelfLink",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedSelfLink",
                    "validate": false,
                    "optional": false,
                    "original": "self_link"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The unique in time and space value for this config map. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#uids"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"uid\" <$> TF.attribute",
                    "name": "_computedUid",
                    "method": "computedUid",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedUid",
                    "validate": false,
                    "optional": false,
                    "original": "uid"
                }
            ],
            "parameters": [],
            "conflicts": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Prefix, used by the server, to generate a unique name ONLY IF the `name`",
                        "field has not been provided. This value will also be combined with a unique",
                        "suffix. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#idempotency"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"generate_name\" <$> TF.attribute",
                    "name": "_generateName",
                    "method": "generateName",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_name",
                            "method": "name"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasGenerateName",
                    "validate": false,
                    "optional": true,
                    "original": "generate_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the config map, must be unique. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_generateName",
                            "method": "generateName"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "type": "ConfigMapMetadataSetting s",
            "original": "metadata"
        },
        {
            "con": {
                "smart": "newHorizontalPodAutoscalerMetadataSetting",
                "name": "HorizontalPodAutoscalerMetadataSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "An unstructured key value map stored with the horizontal pod autoscaler that",
                        "may be used to store arbitrary metadata. More info:",
                        "http://kubernetes.io/docs/user-guide/annotations"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"annotations\" <$> TF.attribute",
                    "name": "_annotations",
                    "method": "annotations",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasAnnotations",
                    "validate": false,
                    "optional": true,
                    "original": "annotations"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Prefix, used by the server, to generate a unique name ONLY IF the `name`",
                        "field has not been provided. This value will also be combined with a unique",
                        "suffix. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#idempotency"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"generate_name\" <$> TF.attribute",
                    "name": "_generateName",
                    "method": "generateName",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_name",
                            "method": "name"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasGenerateName",
                    "validate": false,
                    "optional": true,
                    "original": "generate_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Map of string keys and values that can be used to organize and categorize",
                        "(scope and select) the horizontal pod autoscaler. May match selectors of",
                        "replication controllers and services. More info:",
                        "http://kubernetes.io/docs/user-guide/labels"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"labels\" <$> TF.attribute",
                    "name": "_labels",
                    "method": "labels",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasLabels",
                    "validate": false,
                    "optional": true,
                    "original": "labels"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the horizontal pod autoscaler, must be unique. Cannot be updated.",
                        "More info: http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_generateName",
                            "method": "generateName"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.value \"default\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Namespace defines the space within which name of the horizontal pod",
                        "autoscaler must be unique."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"namespace\" <$> TF.attribute",
                    "name": "_namespace",
                    "method": "namespace",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasNamespace",
                    "validate": false,
                    "optional": true,
                    "original": "namespace"
                }
            ],
            "dependencies": [],
            "key": "horizontal_pod_autoscaler.metadata",
            "name": "HorizontalPodAutoscalerMetadataSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A sequence number representing a specific generation of the desired state."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"generation\" <$> TF.attribute",
                    "name": "_computedGeneration",
                    "method": "computedGeneration",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedGeneration",
                    "validate": false,
                    "optional": false,
                    "original": "generation"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Name of the horizontal pod autoscaler, must be unique. Cannot be updated.",
                        "More info: http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_computedName",
                    "method": "computedName",
                    "threaded": true,
                    "conflicts": [
                        "_generateName"
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "An opaque value that represents the internal version of this horizontal pod",
                        "autoscaler that can be used by clients to determine when horizontal pod",
                        "autoscaler has changed. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#concurrency-control-and-consistency"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_version\" <$> TF.attribute",
                    "name": "_computedResourceVersion",
                    "method": "computedResourceVersion",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedResourceVersion",
                    "validate": false,
                    "optional": false,
                    "original": "resource_version"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A URL representing this horizontal pod autoscaler."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"self_link\" <$> TF.attribute",
                    "name": "_computedSelfLink",
                    "method": "computedSelfLink",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedSelfLink",
                    "validate": false,
                    "optional": false,
                    "original": "self_link"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The unique in time and space value for this horizontal pod autoscaler. More",
                        "info: http://kubernetes.io/docs/user-guide/identifiers#uids"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"uid\" <$> TF.attribute",
                    "name": "_computedUid",
                    "method": "computedUid",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedUid",
                    "validate": false,
                    "optional": false,
                    "original": "uid"
                }
            ],
            "parameters": [],
            "conflicts": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Prefix, used by the server, to generate a unique name ONLY IF the `name`",
                        "field has not been provided. This value will also be combined with a unique",
                        "suffix. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#idempotency"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"generate_name\" <$> TF.attribute",
                    "name": "_generateName",
                    "method": "generateName",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_name",
                            "method": "name"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasGenerateName",
                    "validate": false,
                    "optional": true,
                    "original": "generate_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the horizontal pod autoscaler, must be unique. Cannot be updated.",
                        "More info: http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_generateName",
                            "method": "generateName"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "type": "HorizontalPodAutoscalerMetadataSetting s",
            "original": "metadata"
        },
        {
            "con": {
                "smart": "newHorizontalPodAutoscalerSpecScaleTargetRefSetting",
                "name": "HorizontalPodAutoscalerSpecScaleTargetRefSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "API version of the referent"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"api_version\" <$> TF.attribute",
                    "name": "_apiVersion",
                    "method": "apiVersion",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasApiVersion",
                    "validate": false,
                    "optional": true,
                    "original": "api_version"
                },
                {
                    "default": "_kind",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Kind of the referent. e.g. `ReplicationController`. More info:",
                        "http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#types-kinds"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"kind\" <$> TF.attribute",
                    "name": "_kind",
                    "method": "kind",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasKind",
                    "validate": false,
                    "optional": false,
                    "original": "kind"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "dependencies": [],
            "key": "horizontal_pod_autoscaler.spec.scale_target_ref",
            "name": "HorizontalPodAutoscalerSpecScaleTargetRefSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_kind",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Kind of the referent. e.g. `ReplicationController`. More info:",
                        "http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#types-kinds"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"kind\" <$> TF.attribute",
                    "name": "_kind",
                    "method": "kind",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasKind",
                    "validate": false,
                    "optional": false,
                    "original": "kind"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "HorizontalPodAutoscalerSpecScaleTargetRefSetting s",
            "original": "scale_target_ref"
        },
        {
            "con": {
                "smart": "newHorizontalPodAutoscalerSpecSetting",
                "name": "HorizontalPodAutoscalerSpecSetting'"
            },
            "arguments": [
                {
                    "default": "_maxReplicas",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Upper limit for the number of pods that can be set by the autoscaler."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"max_replicas\" <$> TF.attribute",
                    "name": "_maxReplicas",
                    "method": "maxReplicas",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasMaxReplicas",
                    "validate": false,
                    "optional": false,
                    "original": "max_replicas"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Lower limit for the number of pods that can be set by the autoscaler,",
                        "defaults to `1`."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"min_replicas\" <$> TF.attribute",
                    "name": "_minReplicas",
                    "method": "minReplicas",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasMinReplicas",
                    "validate": false,
                    "optional": true,
                    "original": "min_replicas"
                },
                {
                    "default": "_scaleTargetRef",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Reference to scaled resource. e.g. Replication Controller"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"scale_target_ref\" <$> TF.attribute",
                    "name": "_scaleTargetRef",
                    "method": "scaleTargetRef",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (HorizontalPodAutoscalerSpecScaleTargetRefSetting s)",
                    "class": "HasScaleTargetRef",
                    "validate": true,
                    "optional": false,
                    "original": "scale_target_ref"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Target average CPU utilization (represented as a percentage of requested",
                        "CPU) over all the pods. If not specified the default autoscaling policy will",
                        "be used."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"target_cpu_utilization_percentage\" <$> TF.attribute",
                    "name": "_targetCpuUtilizationPercentage",
                    "method": "targetCpuUtilizationPercentage",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasTargetCpuUtilizationPercentage",
                    "validate": false,
                    "optional": true,
                    "original": "target_cpu_utilization_percentage"
                }
            ],
            "dependencies": [
                "HorizontalPodAutoscalerSpecScaleTargetRefSetting"
            ],
            "key": "horizontal_pod_autoscaler.spec",
            "name": "HorizontalPodAutoscalerSpecSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Target average CPU utilization (represented as a percentage of requested",
                        "CPU) over all the pods. If not specified the default autoscaling policy will",
                        "be used."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"target_cpu_utilization_percentage\" <$> TF.attribute",
                    "name": "_computedTargetCpuUtilizationPercentage",
                    "method": "computedTargetCpuUtilizationPercentage",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedTargetCpuUtilizationPercentage",
                    "validate": false,
                    "optional": false,
                    "original": "target_cpu_utilization_percentage"
                }
            ],
            "parameters": [
                {
                    "default": "_scaleTargetRef",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Reference to scaled resource. e.g. Replication Controller"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"scale_target_ref\" <$> TF.attribute",
                    "name": "_scaleTargetRef",
                    "method": "scaleTargetRef",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (HorizontalPodAutoscalerSpecScaleTargetRefSetting s)",
                    "class": "HasScaleTargetRef",
                    "validate": true,
                    "optional": false,
                    "original": "scale_target_ref"
                },
                {
                    "default": "_maxReplicas",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Upper limit for the number of pods that can be set by the autoscaler."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"max_replicas\" <$> TF.attribute",
                    "name": "_maxReplicas",
                    "method": "maxReplicas",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasMaxReplicas",
                    "validate": false,
                    "optional": false,
                    "original": "max_replicas"
                }
            ],
            "conflicts": [],
            "type": "HorizontalPodAutoscalerSpecSetting s",
            "original": "spec"
        },
        {
            "con": {
                "smart": "newLimitRangeMetadataSetting",
                "name": "LimitRangeMetadataSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "An unstructured key value map stored with the limit range that may be used",
                        "to store arbitrary metadata. More info:",
                        "http://kubernetes.io/docs/user-guide/annotations"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"annotations\" <$> TF.attribute",
                    "name": "_annotations",
                    "method": "annotations",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasAnnotations",
                    "validate": false,
                    "optional": true,
                    "original": "annotations"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Prefix, used by the server, to generate a unique name ONLY IF the `name`",
                        "field has not been provided. This value will also be combined with a unique",
                        "suffix. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#idempotency"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"generate_name\" <$> TF.attribute",
                    "name": "_generateName",
                    "method": "generateName",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_name",
                            "method": "name"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasGenerateName",
                    "validate": false,
                    "optional": true,
                    "original": "generate_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Map of string keys and values that can be used to organize and categorize",
                        "(scope and select) the limit range. May match selectors of replication",
                        "controllers and services. More info:",
                        "http://kubernetes.io/docs/user-guide/labels"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"labels\" <$> TF.attribute",
                    "name": "_labels",
                    "method": "labels",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasLabels",
                    "validate": false,
                    "optional": true,
                    "original": "labels"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the limit range, must be unique. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_generateName",
                            "method": "generateName"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.value \"default\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Namespace defines the space within which name of the limit range must be",
                        "unique."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"namespace\" <$> TF.attribute",
                    "name": "_namespace",
                    "method": "namespace",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasNamespace",
                    "validate": false,
                    "optional": true,
                    "original": "namespace"
                }
            ],
            "dependencies": [],
            "key": "limit_range.metadata",
            "name": "LimitRangeMetadataSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A sequence number representing a specific generation of the desired state."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"generation\" <$> TF.attribute",
                    "name": "_computedGeneration",
                    "method": "computedGeneration",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedGeneration",
                    "validate": false,
                    "optional": false,
                    "original": "generation"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Name of the limit range, must be unique. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_computedName",
                    "method": "computedName",
                    "threaded": true,
                    "conflicts": [
                        "_generateName"
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "An opaque value that represents the internal version of this limit range",
                        "that can be used by clients to determine when limit range has changed. Read",
                        "more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#concurrency-control-and-consistency"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_version\" <$> TF.attribute",
                    "name": "_computedResourceVersion",
                    "method": "computedResourceVersion",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedResourceVersion",
                    "validate": false,
                    "optional": false,
                    "original": "resource_version"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A URL representing this limit range."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"self_link\" <$> TF.attribute",
                    "name": "_computedSelfLink",
                    "method": "computedSelfLink",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedSelfLink",
                    "validate": false,
                    "optional": false,
                    "original": "self_link"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The unique in time and space value for this limit range. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#uids"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"uid\" <$> TF.attribute",
                    "name": "_computedUid",
                    "method": "computedUid",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedUid",
                    "validate": false,
                    "optional": false,
                    "original": "uid"
                }
            ],
            "parameters": [],
            "conflicts": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Prefix, used by the server, to generate a unique name ONLY IF the `name`",
                        "field has not been provided. This value will also be combined with a unique",
                        "suffix. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#idempotency"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"generate_name\" <$> TF.attribute",
                    "name": "_generateName",
                    "method": "generateName",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_name",
                            "method": "name"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasGenerateName",
                    "validate": false,
                    "optional": true,
                    "original": "generate_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the limit range, must be unique. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_generateName",
                            "method": "generateName"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "type": "LimitRangeMetadataSetting s",
            "original": "metadata"
        },
        {
            "con": {
                "smart": "newLimitRangeSpecLimitSetting",
                "name": "LimitRangeSpecLimitSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Default resource requirement limit value by resource name if resource limit",
                        "is omitted."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"default\" <$> TF.attribute",
                    "name": "_default'",
                    "method": "default'",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasDefault'",
                    "validate": false,
                    "optional": true,
                    "original": "default"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The default resource requirement request value by resource name if resource",
                        "request is omitted."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"default_request\" <$> TF.attribute",
                    "name": "_defaultRequest",
                    "method": "defaultRequest",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasDefaultRequest",
                    "validate": false,
                    "optional": true,
                    "original": "default_request"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Max usage constraints on this kind by resource name."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"max\" <$> TF.attribute",
                    "name": "_max",
                    "method": "max",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasMax",
                    "validate": false,
                    "optional": true,
                    "original": "max"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The named resource must have a request and limit that are both non-zero",
                        "where limit divided by request is less than or equal to the enumerated",
                        "value; this represents the max burst for the named resource."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"max_limit_request_ratio\" <$> TF.attribute",
                    "name": "_maxLimitRequestRatio",
                    "method": "maxLimitRequestRatio",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasMaxLimitRequestRatio",
                    "validate": false,
                    "optional": true,
                    "original": "max_limit_request_ratio"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Min usage constraints on this kind by resource name."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"min\" <$> TF.attribute",
                    "name": "_min",
                    "method": "min",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasMin",
                    "validate": false,
                    "optional": true,
                    "original": "min"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Type of resource that this limit applies to."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"type\" <$> TF.attribute",
                    "name": "_type'",
                    "method": "type'",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasType'",
                    "validate": false,
                    "optional": true,
                    "original": "type"
                }
            ],
            "dependencies": [],
            "key": "limit_range.spec.limit",
            "name": "LimitRangeSpecLimitSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The default resource requirement request value by resource name if resource",
                        "request is omitted."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"default_request\" <$> TF.attribute",
                    "name": "_computedDefaultRequest",
                    "method": "computedDefaultRequest",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasComputedDefaultRequest",
                    "validate": false,
                    "optional": false,
                    "original": "default_request"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "LimitRangeSpecLimitSetting s",
            "original": "limit"
        },
        {
            "con": {
                "smart": "newLimitRangeSpecSetting",
                "name": "LimitRangeSpecSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Limits is the list of objects that are enforced."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"limit\" <$> TF.attribute",
                    "name": "_limit",
                    "method": "limit",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (LimitRangeSpecLimitSetting s)]",
                    "class": "HasLimit",
                    "validate": false,
                    "optional": true,
                    "original": "limit"
                }
            ],
            "dependencies": [
                "LimitRangeSpecLimitSetting"
            ],
            "key": "limit_range.spec",
            "name": "LimitRangeSpecSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "LimitRangeSpecSetting s",
            "original": "spec"
        },
        {
            "con": {
                "smart": "newNamespaceMetadataSetting",
                "name": "NamespaceMetadataSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "An unstructured key value map stored with the namespace that may be used to",
                        "store arbitrary metadata. More info:",
                        "http://kubernetes.io/docs/user-guide/annotations"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"annotations\" <$> TF.attribute",
                    "name": "_annotations",
                    "method": "annotations",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasAnnotations",
                    "validate": false,
                    "optional": true,
                    "original": "annotations"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Prefix, used by the server, to generate a unique name ONLY IF the `name`",
                        "field has not been provided. This value will also be combined with a unique",
                        "suffix. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#idempotency"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"generate_name\" <$> TF.attribute",
                    "name": "_generateName",
                    "method": "generateName",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_name",
                            "method": "name"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasGenerateName",
                    "validate": false,
                    "optional": true,
                    "original": "generate_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Map of string keys and values that can be used to organize and categorize",
                        "(scope and select) the namespace. May match selectors of replication",
                        "controllers and services. More info:",
                        "http://kubernetes.io/docs/user-guide/labels"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"labels\" <$> TF.attribute",
                    "name": "_labels",
                    "method": "labels",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasLabels",
                    "validate": false,
                    "optional": true,
                    "original": "labels"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the namespace, must be unique. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_generateName",
                            "method": "generateName"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "dependencies": [],
            "key": "namespace.metadata",
            "name": "NamespaceMetadataSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A sequence number representing a specific generation of the desired state."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"generation\" <$> TF.attribute",
                    "name": "_computedGeneration",
                    "method": "computedGeneration",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedGeneration",
                    "validate": false,
                    "optional": false,
                    "original": "generation"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Name of the namespace, must be unique. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_computedName",
                    "method": "computedName",
                    "threaded": true,
                    "conflicts": [
                        "_generateName"
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "An opaque value that represents the internal version of this namespace that",
                        "can be used by clients to determine when namespace has changed. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#concurrency-control-and-consistency"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_version\" <$> TF.attribute",
                    "name": "_computedResourceVersion",
                    "method": "computedResourceVersion",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedResourceVersion",
                    "validate": false,
                    "optional": false,
                    "original": "resource_version"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A URL representing this namespace."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"self_link\" <$> TF.attribute",
                    "name": "_computedSelfLink",
                    "method": "computedSelfLink",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedSelfLink",
                    "validate": false,
                    "optional": false,
                    "original": "self_link"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The unique in time and space value for this namespace. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#uids"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"uid\" <$> TF.attribute",
                    "name": "_computedUid",
                    "method": "computedUid",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedUid",
                    "validate": false,
                    "optional": false,
                    "original": "uid"
                }
            ],
            "parameters": [],
            "conflicts": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Prefix, used by the server, to generate a unique name ONLY IF the `name`",
                        "field has not been provided. This value will also be combined with a unique",
                        "suffix. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#idempotency"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"generate_name\" <$> TF.attribute",
                    "name": "_generateName",
                    "method": "generateName",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_name",
                            "method": "name"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasGenerateName",
                    "validate": false,
                    "optional": true,
                    "original": "generate_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the namespace, must be unique. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_generateName",
                            "method": "generateName"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "type": "NamespaceMetadataSetting s",
            "original": "metadata"
        },
        {
            "con": {
                "smart": "newPersistentVolumeClaimMetadataSetting",
                "name": "PersistentVolumeClaimMetadataSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "An unstructured key value map stored with the persistent volume claim that",
                        "may be used to store arbitrary metadata. More info:",
                        "http://kubernetes.io/docs/user-guide/annotations"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"annotations\" <$> TF.attribute",
                    "name": "_annotations",
                    "method": "annotations",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasAnnotations",
                    "validate": false,
                    "optional": true,
                    "original": "annotations"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Prefix, used by the server, to generate a unique name ONLY IF the `name`",
                        "field has not been provided. This value will also be combined with a unique",
                        "suffix. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#idempotency"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"generate_name\" <$> TF.attribute",
                    "name": "_generateName",
                    "method": "generateName",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_name",
                            "method": "name"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasGenerateName",
                    "validate": false,
                    "optional": true,
                    "original": "generate_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Map of string keys and values that can be used to organize and categorize",
                        "(scope and select) the persistent volume claim. May match selectors of",
                        "replication controllers and services. More info:",
                        "http://kubernetes.io/docs/user-guide/labels"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"labels\" <$> TF.attribute",
                    "name": "_labels",
                    "method": "labels",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasLabels",
                    "validate": false,
                    "optional": true,
                    "original": "labels"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the persistent volume claim, must be unique. Cannot be updated. More",
                        "info: http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_generateName",
                            "method": "generateName"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.value \"default\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Namespace defines the space within which name of the persistent volume claim",
                        "must be unique."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"namespace\" <$> TF.attribute",
                    "name": "_namespace",
                    "method": "namespace",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasNamespace",
                    "validate": false,
                    "optional": true,
                    "original": "namespace"
                }
            ],
            "dependencies": [],
            "key": "persistent_volume_claim.metadata",
            "name": "PersistentVolumeClaimMetadataSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A sequence number representing a specific generation of the desired state."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"generation\" <$> TF.attribute",
                    "name": "_computedGeneration",
                    "method": "computedGeneration",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedGeneration",
                    "validate": false,
                    "optional": false,
                    "original": "generation"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Name of the persistent volume claim, must be unique. Cannot be updated. More",
                        "info: http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_computedName",
                    "method": "computedName",
                    "threaded": true,
                    "conflicts": [
                        "_generateName"
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "An opaque value that represents the internal version of this persistent",
                        "volume claim that can be used by clients to determine when persistent volume",
                        "claim has changed. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#concurrency-control-and-consistency"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_version\" <$> TF.attribute",
                    "name": "_computedResourceVersion",
                    "method": "computedResourceVersion",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedResourceVersion",
                    "validate": false,
                    "optional": false,
                    "original": "resource_version"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A URL representing this persistent volume claim."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"self_link\" <$> TF.attribute",
                    "name": "_computedSelfLink",
                    "method": "computedSelfLink",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedSelfLink",
                    "validate": false,
                    "optional": false,
                    "original": "self_link"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The unique in time and space value for this persistent volume claim. More",
                        "info: http://kubernetes.io/docs/user-guide/identifiers#uids"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"uid\" <$> TF.attribute",
                    "name": "_computedUid",
                    "method": "computedUid",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedUid",
                    "validate": false,
                    "optional": false,
                    "original": "uid"
                }
            ],
            "parameters": [],
            "conflicts": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Prefix, used by the server, to generate a unique name ONLY IF the `name`",
                        "field has not been provided. This value will also be combined with a unique",
                        "suffix. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#idempotency"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"generate_name\" <$> TF.attribute",
                    "name": "_generateName",
                    "method": "generateName",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_name",
                            "method": "name"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasGenerateName",
                    "validate": false,
                    "optional": true,
                    "original": "generate_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the persistent volume claim, must be unique. Cannot be updated. More",
                        "info: http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_generateName",
                            "method": "generateName"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "type": "PersistentVolumeClaimMetadataSetting s",
            "original": "metadata"
        },
        {
            "con": {
                "smart": "newPersistentVolumeClaimSpecResourcesSetting",
                "name": "PersistentVolumeClaimSpecResourcesSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Map describing the maximum amount of compute resources allowed. More info:",
                        "http://kubernetes.io/docs/user-guide/compute-resources/"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"limits\" <$> TF.attribute",
                    "name": "_limits",
                    "method": "limits",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasLimits",
                    "validate": false,
                    "optional": true,
                    "original": "limits"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Map describing the minimum amount of compute resources required. If this is",
                        "omitted for a container, it defaults to `limits` if that is explicitly",
                        "specified, otherwise to an implementation-defined value. More info:",
                        "http://kubernetes.io/docs/user-guide/compute-resources/"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"requests\" <$> TF.attribute",
                    "name": "_requests",
                    "method": "requests",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasRequests",
                    "validate": false,
                    "optional": true,
                    "original": "requests"
                }
            ],
            "dependencies": [],
            "key": "persistent_volume_claim.spec.resources",
            "name": "PersistentVolumeClaimSpecResourcesSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PersistentVolumeClaimSpecResourcesSetting s",
            "original": "resources"
        },
        {
            "con": {
                "smart": "newPersistentVolumeClaimSpecSelectorMatchExpressionsSetting",
                "name": "PersistentVolumeClaimSpecSelectorMatchExpressionsSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The label key that the selector applies to."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"key\" <$> TF.attribute",
                    "name": "_key",
                    "method": "key",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasKey",
                    "validate": false,
                    "optional": true,
                    "original": "key"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A key's relationship to a set of values. Valid operators ard `In`, `NotIn`,",
                        "`Exists` and `DoesNotExist`."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"operator\" <$> TF.attribute",
                    "name": "_operator",
                    "method": "operator",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasOperator",
                    "validate": false,
                    "optional": true,
                    "original": "operator"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "An array of string values. If the operator is `In` or `NotIn`, the values",
                        "array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the",
                        "values array must be empty. This array is replaced during a strategic merge",
                        "patch."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"values\" <$> TF.attribute",
                    "name": "_values",
                    "method": "values",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasValues",
                    "validate": false,
                    "optional": true,
                    "original": "values"
                }
            ],
            "dependencies": [],
            "key": "persistent_volume_claim.spec.selector.match_expressions",
            "name": "PersistentVolumeClaimSpecSelectorMatchExpressionsSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PersistentVolumeClaimSpecSelectorMatchExpressionsSetting s",
            "original": "match_expressions"
        },
        {
            "con": {
                "smart": "newPersistentVolumeClaimSpecSelectorSetting",
                "name": "PersistentVolumeClaimSpecSelectorSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of label selector requirements. The requirements are ANDed."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"match_expressions\" <$> TF.attribute",
                    "name": "_matchExpressions",
                    "method": "matchExpressions",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (PersistentVolumeClaimSpecSelectorMatchExpressionsSetting s)]",
                    "class": "HasMatchExpressions",
                    "validate": false,
                    "optional": true,
                    "original": "match_expressions"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A map of {key,value} pairs. A single {key,value} in the matchLabels map is",
                        "equivalent to an element of `match_expressions`, whose key field is \"key\",",
                        "the operator is \"In\", and the values array contains only \"value\". The",
                        "requirements are ANDed."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"match_labels\" <$> TF.attribute",
                    "name": "_matchLabels",
                    "method": "matchLabels",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasMatchLabels",
                    "validate": false,
                    "optional": true,
                    "original": "match_labels"
                }
            ],
            "dependencies": [
                "PersistentVolumeClaimSpecSelectorMatchExpressionsSetting"
            ],
            "key": "persistent_volume_claim.spec.selector",
            "name": "PersistentVolumeClaimSpecSelectorSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PersistentVolumeClaimSpecSelectorSetting s",
            "original": "selector"
        },
        {
            "con": {
                "smart": "newPersistentVolumeClaimSpecSetting",
                "name": "PersistentVolumeClaimSpecSetting'"
            },
            "arguments": [
                {
                    "default": "_accessModes",
                    "computed": false,
                    "required": true,
                    "help": [
                        "A set of the desired access modes the volume should have. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#access-modes-1"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"access_modes\" <$> TF.attribute",
                    "name": "_accessModes",
                    "method": "accessModes",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasAccessModes",
                    "validate": false,
                    "optional": false,
                    "original": "access_modes"
                },
                {
                    "default": "_resources",
                    "computed": false,
                    "required": true,
                    "help": [
                        "A list of the minimum resources the volume should have. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#resources"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"resources\" <$> TF.attribute",
                    "name": "_resources",
                    "method": "resources",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeClaimSpecResourcesSetting s)",
                    "class": "HasResources",
                    "validate": true,
                    "optional": false,
                    "original": "resources"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A label query over volumes to consider for binding."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"selector\" <$> TF.attribute",
                    "name": "_selector",
                    "method": "selector",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeClaimSpecSelectorSetting s)",
                    "class": "HasSelector",
                    "validate": true,
                    "optional": true,
                    "original": "selector"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the storage class requested by the claim"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"storage_class_name\" <$> TF.attribute",
                    "name": "_storageClassName",
                    "method": "storageClassName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasStorageClassName",
                    "validate": false,
                    "optional": true,
                    "original": "storage_class_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The binding reference to the PersistentVolume backing this claim."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"volume_name\" <$> TF.attribute",
                    "name": "_volumeName",
                    "method": "volumeName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumeName",
                    "validate": false,
                    "optional": true,
                    "original": "volume_name"
                }
            ],
            "dependencies": [
                "PersistentVolumeClaimSpecResourcesSetting",
                "PersistentVolumeClaimSpecSelectorSetting"
            ],
            "key": "persistent_volume_claim.spec",
            "name": "PersistentVolumeClaimSpecSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Name of the storage class requested by the claim"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"storage_class_name\" <$> TF.attribute",
                    "name": "_computedStorageClassName",
                    "method": "computedStorageClassName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedStorageClassName",
                    "validate": false,
                    "optional": false,
                    "original": "storage_class_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The binding reference to the PersistentVolume backing this claim."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"volume_name\" <$> TF.attribute",
                    "name": "_computedVolumeName",
                    "method": "computedVolumeName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedVolumeName",
                    "validate": false,
                    "optional": false,
                    "original": "volume_name"
                }
            ],
            "parameters": [
                {
                    "default": "_accessModes",
                    "computed": false,
                    "required": true,
                    "help": [
                        "A set of the desired access modes the volume should have. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#access-modes-1"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"access_modes\" <$> TF.attribute",
                    "name": "_accessModes",
                    "method": "accessModes",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasAccessModes",
                    "validate": false,
                    "optional": false,
                    "original": "access_modes"
                },
                {
                    "default": "_resources",
                    "computed": false,
                    "required": true,
                    "help": [
                        "A list of the minimum resources the volume should have. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#resources"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"resources\" <$> TF.attribute",
                    "name": "_resources",
                    "method": "resources",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeClaimSpecResourcesSetting s)",
                    "class": "HasResources",
                    "validate": true,
                    "optional": false,
                    "original": "resources"
                }
            ],
            "conflicts": [],
            "type": "PersistentVolumeClaimSpecSetting s",
            "original": "spec"
        },
        {
            "con": {
                "smart": "newPersistentVolumeMetadataSetting",
                "name": "PersistentVolumeMetadataSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "An unstructured key value map stored with the persistent volume that may be",
                        "used to store arbitrary metadata. More info:",
                        "http://kubernetes.io/docs/user-guide/annotations"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"annotations\" <$> TF.attribute",
                    "name": "_annotations",
                    "method": "annotations",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasAnnotations",
                    "validate": false,
                    "optional": true,
                    "original": "annotations"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Map of string keys and values that can be used to organize and categorize",
                        "(scope and select) the persistent volume. May match selectors of replication",
                        "controllers and services. More info:",
                        "http://kubernetes.io/docs/user-guide/labels"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"labels\" <$> TF.attribute",
                    "name": "_labels",
                    "method": "labels",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasLabels",
                    "validate": false,
                    "optional": true,
                    "original": "labels"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the persistent volume, must be unique. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "dependencies": [],
            "key": "persistent_volume.metadata",
            "name": "PersistentVolumeMetadataSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A sequence number representing a specific generation of the desired state."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"generation\" <$> TF.attribute",
                    "name": "_computedGeneration",
                    "method": "computedGeneration",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedGeneration",
                    "validate": false,
                    "optional": false,
                    "original": "generation"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Name of the persistent volume, must be unique. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_computedName",
                    "method": "computedName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "An opaque value that represents the internal version of this persistent",
                        "volume that can be used by clients to determine when persistent volume has",
                        "changed. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#concurrency-control-and-consistency"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_version\" <$> TF.attribute",
                    "name": "_computedResourceVersion",
                    "method": "computedResourceVersion",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedResourceVersion",
                    "validate": false,
                    "optional": false,
                    "original": "resource_version"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A URL representing this persistent volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"self_link\" <$> TF.attribute",
                    "name": "_computedSelfLink",
                    "method": "computedSelfLink",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedSelfLink",
                    "validate": false,
                    "optional": false,
                    "original": "self_link"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The unique in time and space value for this persistent volume. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#uids"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"uid\" <$> TF.attribute",
                    "name": "_computedUid",
                    "method": "computedUid",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedUid",
                    "validate": false,
                    "optional": false,
                    "original": "uid"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "PersistentVolumeMetadataSetting s",
            "original": "metadata"
        },
        {
            "con": {
                "smart": "newPersistentVolumeSpecPersistentVolumeSourceAwsElasticBlockStoreSetting",
                "name": "PersistentVolumeSpecPersistentVolumeSourceAwsElasticBlockStoreSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type of the volume that you want to mount. Tip: Ensure that the",
                        "filesystem type is supported by the host operating system. Examples: \"ext4\",",
                        "\"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The partition in the volume that you want to mount. If omitted, the default",
                        "is to mount by volume name. Examples: For volume /dev/sda1, you specify the",
                        "partition as \"1\". Similarly, the volume partition for /dev/sda is \"0\" (or",
                        "you can leave the property empty)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"partition\" <$> TF.attribute",
                    "name": "_partition",
                    "method": "partition",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasPartition",
                    "validate": false,
                    "optional": true,
                    "original": "partition"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to set the read-only property in VolumeMounts to \"true\". If omitted,",
                        "the default is \"false\". More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_volumeId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More",
                        "info: http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_id\" <$> TF.attribute",
                    "name": "_volumeId",
                    "method": "volumeId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumeId",
                    "validate": false,
                    "optional": false,
                    "original": "volume_id"
                }
            ],
            "dependencies": [],
            "key": "persistent_volume.spec.persistent_volume_source.aws_elastic_block_store",
            "name": "PersistentVolumeSpecPersistentVolumeSourceAwsElasticBlockStoreSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_volumeId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More",
                        "info: http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_id\" <$> TF.attribute",
                    "name": "_volumeId",
                    "method": "volumeId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumeId",
                    "validate": false,
                    "optional": false,
                    "original": "volume_id"
                }
            ],
            "conflicts": [],
            "type": "PersistentVolumeSpecPersistentVolumeSourceAwsElasticBlockStoreSetting s",
            "original": "aws_elastic_block_store"
        },
        {
            "con": {
                "smart": "newPersistentVolumeSpecPersistentVolumeSourceAzureDiskSetting",
                "name": "PersistentVolumeSpecPersistentVolumeSourceAzureDiskSetting'"
            },
            "arguments": [
                {
                    "default": "_cachingMode",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Host Caching mode: None, Read Only, Read Write."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"caching_mode\" <$> TF.attribute",
                    "name": "_cachingMode",
                    "method": "cachingMode",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasCachingMode",
                    "validate": false,
                    "optional": false,
                    "original": "caching_mode"
                },
                {
                    "default": "_dataDiskUri",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The URI the data disk in the blob storage"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"data_disk_uri\" <$> TF.attribute",
                    "name": "_dataDiskUri",
                    "method": "dataDiskUri",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDataDiskUri",
                    "validate": false,
                    "optional": false,
                    "original": "data_disk_uri"
                },
                {
                    "default": "_diskName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The Name of the data disk in the blob storage"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"disk_name\" <$> TF.attribute",
                    "name": "_diskName",
                    "method": "diskName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDiskName",
                    "validate": false,
                    "optional": false,
                    "original": "disk_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type to mount. Must be a filesystem type supported by the host",
                        "operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be",
                        "\"ext4\" if unspecified."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to false",
                        "(read/write)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                }
            ],
            "dependencies": [],
            "key": "persistent_volume.spec.persistent_volume_source.azure_disk",
            "name": "PersistentVolumeSpecPersistentVolumeSourceAzureDiskSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_cachingMode",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Host Caching mode: None, Read Only, Read Write."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"caching_mode\" <$> TF.attribute",
                    "name": "_cachingMode",
                    "method": "cachingMode",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasCachingMode",
                    "validate": false,
                    "optional": false,
                    "original": "caching_mode"
                },
                {
                    "default": "_diskName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The Name of the data disk in the blob storage"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"disk_name\" <$> TF.attribute",
                    "name": "_diskName",
                    "method": "diskName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDiskName",
                    "validate": false,
                    "optional": false,
                    "original": "disk_name"
                },
                {
                    "default": "_dataDiskUri",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The URI the data disk in the blob storage"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"data_disk_uri\" <$> TF.attribute",
                    "name": "_dataDiskUri",
                    "method": "dataDiskUri",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDataDiskUri",
                    "validate": false,
                    "optional": false,
                    "original": "data_disk_uri"
                }
            ],
            "conflicts": [],
            "type": "PersistentVolumeSpecPersistentVolumeSourceAzureDiskSetting s",
            "original": "azure_disk"
        },
        {
            "con": {
                "smart": "newPersistentVolumeSpecPersistentVolumeSourceAzureFileSetting",
                "name": "PersistentVolumeSpecPersistentVolumeSourceAzureFileSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to false",
                        "(read/write)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_secretName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of secret that contains Azure Storage Account Name and Key"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_name\" <$> TF.attribute",
                    "name": "_secretName",
                    "method": "secretName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSecretName",
                    "validate": false,
                    "optional": false,
                    "original": "secret_name"
                },
                {
                    "default": "_shareName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Share Name"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"share_name\" <$> TF.attribute",
                    "name": "_shareName",
                    "method": "shareName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasShareName",
                    "validate": false,
                    "optional": false,
                    "original": "share_name"
                }
            ],
            "dependencies": [],
            "key": "persistent_volume.spec.persistent_volume_source.azure_file",
            "name": "PersistentVolumeSpecPersistentVolumeSourceAzureFileSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_secretName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of secret that contains Azure Storage Account Name and Key"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_name\" <$> TF.attribute",
                    "name": "_secretName",
                    "method": "secretName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSecretName",
                    "validate": false,
                    "optional": false,
                    "original": "secret_name"
                },
                {
                    "default": "_shareName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Share Name"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"share_name\" <$> TF.attribute",
                    "name": "_shareName",
                    "method": "shareName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasShareName",
                    "validate": false,
                    "optional": false,
                    "original": "share_name"
                }
            ],
            "conflicts": [],
            "type": "PersistentVolumeSpecPersistentVolumeSourceAzureFileSetting s",
            "original": "azure_file"
        },
        {
            "con": {
                "smart": "newPersistentVolumeSpecPersistentVolumeSourceCephFsSecretRefSetting",
                "name": "PersistentVolumeSpecPersistentVolumeSourceCephFsSecretRefSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "dependencies": [],
            "key": "persistent_volume.spec.persistent_volume_source.ceph_fs.secret_ref",
            "name": "PersistentVolumeSpecPersistentVolumeSourceCephFsSecretRefSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PersistentVolumeSpecPersistentVolumeSourceCephFsSecretRefSetting s",
            "original": "secret_ref"
        },
        {
            "con": {
                "smart": "newPersistentVolumeSpecPersistentVolumeSourceCephFsSetting",
                "name": "PersistentVolumeSpecPersistentVolumeSourceCephFsSetting'"
            },
            "arguments": [
                {
                    "default": "_monitors",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Monitors is a collection of Ceph monitors More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"monitors\" <$> TF.attribute",
                    "name": "_monitors",
                    "method": "monitors",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasMonitors",
                    "validate": false,
                    "optional": false,
                    "original": "monitors"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Used as the mounted root, rather than the full Ceph tree, default is /"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": true,
                    "original": "path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to `false`",
                        "(read/write). More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The path to key ring for User, default is /etc/ceph/user.secret More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_file\" <$> TF.attribute",
                    "name": "_secretFile",
                    "method": "secretFile",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSecretFile",
                    "validate": false,
                    "optional": true,
                    "original": "secret_file"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Reference to the authentication secret for User, default is empty. More",
                        "info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_ref\" <$> TF.attribute",
                    "name": "_secretRef",
                    "method": "secretRef",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeSpecPersistentVolumeSourceCephFsSecretRefSetting s)",
                    "class": "HasSecretRef",
                    "validate": true,
                    "optional": true,
                    "original": "secret_ref"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "User is the rados user name, default is admin. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"user\" <$> TF.attribute",
                    "name": "_user",
                    "method": "user",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasUser",
                    "validate": false,
                    "optional": true,
                    "original": "user"
                }
            ],
            "dependencies": [
                "PersistentVolumeSpecPersistentVolumeSourceCephFsSecretRefSetting"
            ],
            "key": "persistent_volume.spec.persistent_volume_source.ceph_fs",
            "name": "PersistentVolumeSpecPersistentVolumeSourceCephFsSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_monitors",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Monitors is a collection of Ceph monitors More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"monitors\" <$> TF.attribute",
                    "name": "_monitors",
                    "method": "monitors",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasMonitors",
                    "validate": false,
                    "optional": false,
                    "original": "monitors"
                }
            ],
            "conflicts": [],
            "type": "PersistentVolumeSpecPersistentVolumeSourceCephFsSetting s",
            "original": "ceph_fs"
        },
        {
            "con": {
                "smart": "newPersistentVolumeSpecPersistentVolumeSourceCinderSetting",
                "name": "PersistentVolumeSpecPersistentVolumeSourceCinderSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type to mount. Must be a filesystem type supported by the host",
                        "operating system. Examples: \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be",
                        "\"ext4\" if unspecified. More info:",
                        "http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to false",
                        "(read/write). More info:",
                        "http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_volumeId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Volume ID used to identify the volume in Cinder. More info:",
                        "http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_id\" <$> TF.attribute",
                    "name": "_volumeId",
                    "method": "volumeId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumeId",
                    "validate": false,
                    "optional": false,
                    "original": "volume_id"
                }
            ],
            "dependencies": [],
            "key": "persistent_volume.spec.persistent_volume_source.cinder",
            "name": "PersistentVolumeSpecPersistentVolumeSourceCinderSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_volumeId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Volume ID used to identify the volume in Cinder. More info:",
                        "http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_id\" <$> TF.attribute",
                    "name": "_volumeId",
                    "method": "volumeId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumeId",
                    "validate": false,
                    "optional": false,
                    "original": "volume_id"
                }
            ],
            "conflicts": [],
            "type": "PersistentVolumeSpecPersistentVolumeSourceCinderSetting s",
            "original": "cinder"
        },
        {
            "con": {
                "smart": "newPersistentVolumeSpecPersistentVolumeSourceFcSetting",
                "name": "PersistentVolumeSpecPersistentVolumeSourceFcSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type to mount. Must be a filesystem type supported by the host",
                        "operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be",
                        "\"ext4\" if unspecified."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "_lun",
                    "computed": false,
                    "required": true,
                    "help": [
                        "FC target lun number"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"lun\" <$> TF.attribute",
                    "name": "_lun",
                    "method": "lun",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasLun",
                    "validate": false,
                    "optional": false,
                    "original": "lun"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to false",
                        "(read/write)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_targetWwNs",
                    "computed": false,
                    "required": true,
                    "help": [
                        "FC target worldwide names (WWNs)"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"target_ww_ns\" <$> TF.attribute",
                    "name": "_targetWwNs",
                    "method": "targetWwNs",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasTargetWwNs",
                    "validate": false,
                    "optional": false,
                    "original": "target_ww_ns"
                }
            ],
            "dependencies": [],
            "key": "persistent_volume.spec.persistent_volume_source.fc",
            "name": "PersistentVolumeSpecPersistentVolumeSourceFcSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_lun",
                    "computed": false,
                    "required": true,
                    "help": [
                        "FC target lun number"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"lun\" <$> TF.attribute",
                    "name": "_lun",
                    "method": "lun",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasLun",
                    "validate": false,
                    "optional": false,
                    "original": "lun"
                },
                {
                    "default": "_targetWwNs",
                    "computed": false,
                    "required": true,
                    "help": [
                        "FC target worldwide names (WWNs)"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"target_ww_ns\" <$> TF.attribute",
                    "name": "_targetWwNs",
                    "method": "targetWwNs",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasTargetWwNs",
                    "validate": false,
                    "optional": false,
                    "original": "target_ww_ns"
                }
            ],
            "conflicts": [],
            "type": "PersistentVolumeSpecPersistentVolumeSourceFcSetting s",
            "original": "fc"
        },
        {
            "con": {
                "smart": "newPersistentVolumeSpecPersistentVolumeSourceFlexVolumeSecretRefSetting",
                "name": "PersistentVolumeSpecPersistentVolumeSourceFlexVolumeSecretRefSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "dependencies": [],
            "key": "persistent_volume.spec.persistent_volume_source.flex_volume.secret_ref",
            "name": "PersistentVolumeSpecPersistentVolumeSourceFlexVolumeSecretRefSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PersistentVolumeSpecPersistentVolumeSourceFlexVolumeSecretRefSetting s",
            "original": "secret_ref"
        },
        {
            "con": {
                "smart": "newPersistentVolumeSpecPersistentVolumeSourceFlexVolumeSetting",
                "name": "PersistentVolumeSpecPersistentVolumeSourceFlexVolumeSetting'"
            },
            "arguments": [
                {
                    "default": "_driver",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Driver is the name of the driver to use for this volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"driver\" <$> TF.attribute",
                    "name": "_driver",
                    "method": "driver",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDriver",
                    "validate": false,
                    "optional": false,
                    "original": "driver"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type to mount. Must be a filesystem type supported by the host",
                        "operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". The default filesystem depends",
                        "on FlexVolume script."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Extra command options if any."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"options\" <$> TF.attribute",
                    "name": "_options",
                    "method": "options",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasOptions",
                    "validate": false,
                    "optional": true,
                    "original": "options"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the ReadOnly setting in VolumeMounts. Defaults to false",
                        "(read/write)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Reference to the secret object containing sensitive information to pass to",
                        "the plugin scripts. This may be empty if no secret object is specified. If",
                        "the secret object contains more than one secret, all secrets are passed to",
                        "the plugin scripts."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_ref\" <$> TF.attribute",
                    "name": "_secretRef",
                    "method": "secretRef",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeSpecPersistentVolumeSourceFlexVolumeSecretRefSetting s)",
                    "class": "HasSecretRef",
                    "validate": true,
                    "optional": true,
                    "original": "secret_ref"
                }
            ],
            "dependencies": [
                "PersistentVolumeSpecPersistentVolumeSourceFlexVolumeSecretRefSetting"
            ],
            "key": "persistent_volume.spec.persistent_volume_source.flex_volume",
            "name": "PersistentVolumeSpecPersistentVolumeSourceFlexVolumeSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_driver",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Driver is the name of the driver to use for this volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"driver\" <$> TF.attribute",
                    "name": "_driver",
                    "method": "driver",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDriver",
                    "validate": false,
                    "optional": false,
                    "original": "driver"
                }
            ],
            "conflicts": [],
            "type": "PersistentVolumeSpecPersistentVolumeSourceFlexVolumeSetting s",
            "original": "flex_volume"
        },
        {
            "con": {
                "smart": "newPersistentVolumeSpecPersistentVolumeSourceFlockerSetting",
                "name": "PersistentVolumeSpecPersistentVolumeSourceFlockerSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the dataset stored as metadata -> name on the dataset for Flocker",
                        "should be considered as deprecated"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"dataset_name\" <$> TF.attribute",
                    "name": "_datasetName",
                    "method": "datasetName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatasetName",
                    "validate": false,
                    "optional": true,
                    "original": "dataset_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "UUID of the dataset. This is unique identifier of a Flocker dataset"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"dataset_uuid\" <$> TF.attribute",
                    "name": "_datasetUuid",
                    "method": "datasetUuid",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatasetUuid",
                    "validate": false,
                    "optional": true,
                    "original": "dataset_uuid"
                }
            ],
            "dependencies": [],
            "key": "persistent_volume.spec.persistent_volume_source.flocker",
            "name": "PersistentVolumeSpecPersistentVolumeSourceFlockerSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PersistentVolumeSpecPersistentVolumeSourceFlockerSetting s",
            "original": "flocker"
        },
        {
            "con": {
                "smart": "newPersistentVolumeSpecPersistentVolumeSourceGcePersistentDiskSetting",
                "name": "PersistentVolumeSpecPersistentVolumeSourceGcePersistentDiskSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type of the volume that you want to mount. Tip: Ensure that the",
                        "filesystem type is supported by the host operating system. Examples: \"ext4\",",
                        "\"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The partition in the volume that you want to mount. If omitted, the default",
                        "is to mount by volume name. Examples: For volume /dev/sda1, you specify the",
                        "partition as \"1\". Similarly, the volume partition for /dev/sda is \"0\" (or",
                        "you can leave the property empty). More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"partition\" <$> TF.attribute",
                    "name": "_partition",
                    "method": "partition",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasPartition",
                    "validate": false,
                    "optional": true,
                    "original": "partition"
                },
                {
                    "default": "_pdName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Unique name of the PD resource in GCE. Used to identify the disk in GCE.",
                        "More info: http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"pd_name\" <$> TF.attribute",
                    "name": "_pdName",
                    "method": "pdName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPdName",
                    "validate": false,
                    "optional": false,
                    "original": "pd_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the ReadOnly setting in VolumeMounts. Defaults to false.",
                        "More info: http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                }
            ],
            "dependencies": [],
            "key": "persistent_volume.spec.persistent_volume_source.gce_persistent_disk",
            "name": "PersistentVolumeSpecPersistentVolumeSourceGcePersistentDiskSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_pdName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Unique name of the PD resource in GCE. Used to identify the disk in GCE.",
                        "More info: http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"pd_name\" <$> TF.attribute",
                    "name": "_pdName",
                    "method": "pdName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPdName",
                    "validate": false,
                    "optional": false,
                    "original": "pd_name"
                }
            ],
            "conflicts": [],
            "type": "PersistentVolumeSpecPersistentVolumeSourceGcePersistentDiskSetting s",
            "original": "gce_persistent_disk"
        },
        {
            "con": {
                "smart": "newPersistentVolumeSpecPersistentVolumeSourceGlusterfsSetting",
                "name": "PersistentVolumeSpecPersistentVolumeSourceGlusterfsSetting'"
            },
            "arguments": [
                {
                    "default": "_endpointsName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The endpoint name that details Glusterfs topology. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"endpoints_name\" <$> TF.attribute",
                    "name": "_endpointsName",
                    "method": "endpointsName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasEndpointsName",
                    "validate": false,
                    "optional": false,
                    "original": "endpoints_name"
                },
                {
                    "default": "_path",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The Glusterfs volume path. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": false,
                    "original": "path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the Glusterfs volume to be mounted with read-only",
                        "permissions. Defaults to false. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                }
            ],
            "dependencies": [],
            "key": "persistent_volume.spec.persistent_volume_source.glusterfs",
            "name": "PersistentVolumeSpecPersistentVolumeSourceGlusterfsSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_endpointsName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The endpoint name that details Glusterfs topology. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"endpoints_name\" <$> TF.attribute",
                    "name": "_endpointsName",
                    "method": "endpointsName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasEndpointsName",
                    "validate": false,
                    "optional": false,
                    "original": "endpoints_name"
                },
                {
                    "default": "_path",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The Glusterfs volume path. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": false,
                    "original": "path"
                }
            ],
            "conflicts": [],
            "type": "PersistentVolumeSpecPersistentVolumeSourceGlusterfsSetting s",
            "original": "glusterfs"
        },
        {
            "con": {
                "smart": "newPersistentVolumeSpecPersistentVolumeSourceHostPathSetting",
                "name": "PersistentVolumeSpecPersistentVolumeSourceHostPathSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path of the directory on the host. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#hostpath"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": true,
                    "original": "path"
                }
            ],
            "dependencies": [],
            "key": "persistent_volume.spec.persistent_volume_source.host_path",
            "name": "PersistentVolumeSpecPersistentVolumeSourceHostPathSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PersistentVolumeSpecPersistentVolumeSourceHostPathSetting s",
            "original": "host_path"
        },
        {
            "con": {
                "smart": "newPersistentVolumeSpecPersistentVolumeSourceIscsiSetting",
                "name": "PersistentVolumeSpecPersistentVolumeSourceIscsiSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type of the volume that you want to mount. Tip: Ensure that the",
                        "filesystem type is supported by the host operating system. Examples: \"ext4\",",
                        "\"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#iscsi"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "_iqn",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Target iSCSI Qualified Name."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"iqn\" <$> TF.attribute",
                    "name": "_iqn",
                    "method": "iqn",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasIqn",
                    "validate": false,
                    "optional": false,
                    "original": "iqn"
                },
                {
                    "default": "TF.value \"default\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "ISCSI interface name that uses an iSCSI transport. Defaults to 'default'",
                        "(tcp)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"iscsi_interface\" <$> TF.attribute",
                    "name": "_iscsiInterface",
                    "method": "iscsiInterface",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasIscsiInterface",
                    "validate": false,
                    "optional": true,
                    "original": "iscsi_interface"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "ISCSI target lun number."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"lun\" <$> TF.attribute",
                    "name": "_lun",
                    "method": "lun",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasLun",
                    "validate": false,
                    "optional": true,
                    "original": "lun"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to false."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_targetPortal",
                    "computed": false,
                    "required": true,
                    "help": [
                        "ISCSI target portal. The portal is either an IP or ip_addr:port if the port",
                        "is other than default (typically TCP ports 860 and 3260)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"target_portal\" <$> TF.attribute",
                    "name": "_targetPortal",
                    "method": "targetPortal",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasTargetPortal",
                    "validate": false,
                    "optional": false,
                    "original": "target_portal"
                }
            ],
            "dependencies": [],
            "key": "persistent_volume.spec.persistent_volume_source.iscsi",
            "name": "PersistentVolumeSpecPersistentVolumeSourceIscsiSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_iqn",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Target iSCSI Qualified Name."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"iqn\" <$> TF.attribute",
                    "name": "_iqn",
                    "method": "iqn",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasIqn",
                    "validate": false,
                    "optional": false,
                    "original": "iqn"
                },
                {
                    "default": "_targetPortal",
                    "computed": false,
                    "required": true,
                    "help": [
                        "ISCSI target portal. The portal is either an IP or ip_addr:port if the port",
                        "is other than default (typically TCP ports 860 and 3260)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"target_portal\" <$> TF.attribute",
                    "name": "_targetPortal",
                    "method": "targetPortal",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasTargetPortal",
                    "validate": false,
                    "optional": false,
                    "original": "target_portal"
                }
            ],
            "conflicts": [],
            "type": "PersistentVolumeSpecPersistentVolumeSourceIscsiSetting s",
            "original": "iscsi"
        },
        {
            "con": {
                "smart": "newPersistentVolumeSpecPersistentVolumeSourceNfsSetting",
                "name": "PersistentVolumeSpecPersistentVolumeSourceNfsSetting'"
            },
            "arguments": [
                {
                    "default": "_path",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path that is exported by the NFS server. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": false,
                    "original": "path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the NFS export to be mounted with read-only permissions.",
                        "Defaults to false. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_server",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Server is the hostname or IP address of the NFS server. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"server\" <$> TF.attribute",
                    "name": "_server",
                    "method": "server",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasServer",
                    "validate": false,
                    "optional": false,
                    "original": "server"
                }
            ],
            "dependencies": [],
            "key": "persistent_volume.spec.persistent_volume_source.nfs",
            "name": "PersistentVolumeSpecPersistentVolumeSourceNfsSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_path",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path that is exported by the NFS server. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": false,
                    "original": "path"
                },
                {
                    "default": "_server",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Server is the hostname or IP address of the NFS server. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"server\" <$> TF.attribute",
                    "name": "_server",
                    "method": "server",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasServer",
                    "validate": false,
                    "optional": false,
                    "original": "server"
                }
            ],
            "conflicts": [],
            "type": "PersistentVolumeSpecPersistentVolumeSourceNfsSetting s",
            "original": "nfs"
        },
        {
            "con": {
                "smart": "newPersistentVolumeSpecPersistentVolumeSourcePhotonPersistentDiskSetting",
                "name": "PersistentVolumeSpecPersistentVolumeSourcePhotonPersistentDiskSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type to mount. Must be a filesystem type supported by the host",
                        "operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be",
                        "\"ext4\" if unspecified."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "_pdId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "ID that identifies Photon Controller persistent disk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"pd_id\" <$> TF.attribute",
                    "name": "_pdId",
                    "method": "pdId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPdId",
                    "validate": false,
                    "optional": false,
                    "original": "pd_id"
                }
            ],
            "dependencies": [],
            "key": "persistent_volume.spec.persistent_volume_source.photon_persistent_disk",
            "name": "PersistentVolumeSpecPersistentVolumeSourcePhotonPersistentDiskSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_pdId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "ID that identifies Photon Controller persistent disk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"pd_id\" <$> TF.attribute",
                    "name": "_pdId",
                    "method": "pdId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPdId",
                    "validate": false,
                    "optional": false,
                    "original": "pd_id"
                }
            ],
            "conflicts": [],
            "type": "PersistentVolumeSpecPersistentVolumeSourcePhotonPersistentDiskSetting s",
            "original": "photon_persistent_disk"
        },
        {
            "con": {
                "smart": "newPersistentVolumeSpecPersistentVolumeSourceQuobyteSetting",
                "name": "PersistentVolumeSpecPersistentVolumeSourceQuobyteSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Group to map volume access to Default is no group"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"group\" <$> TF.attribute",
                    "name": "_group",
                    "method": "group",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasGroup",
                    "validate": false,
                    "optional": true,
                    "original": "group"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the Quobyte volume to be mounted with read-only",
                        "permissions. Defaults to false."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_registry",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Registry represents a single or multiple Quobyte Registry services specified",
                        "as a string as host:port pair (multiple entries are separated with commas)",
                        "which acts as the central registry for volumes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"registry\" <$> TF.attribute",
                    "name": "_registry",
                    "method": "registry",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRegistry",
                    "validate": false,
                    "optional": false,
                    "original": "registry"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "User to map volume access to Defaults to serivceaccount user"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"user\" <$> TF.attribute",
                    "name": "_user",
                    "method": "user",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasUser",
                    "validate": false,
                    "optional": true,
                    "original": "user"
                },
                {
                    "default": "_volume",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Volume is a string that references an already created Quobyte volume by",
                        "name."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume\" <$> TF.attribute",
                    "name": "_volume",
                    "method": "volume",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolume",
                    "validate": false,
                    "optional": false,
                    "original": "volume"
                }
            ],
            "dependencies": [],
            "key": "persistent_volume.spec.persistent_volume_source.quobyte",
            "name": "PersistentVolumeSpecPersistentVolumeSourceQuobyteSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_registry",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Registry represents a single or multiple Quobyte Registry services specified",
                        "as a string as host:port pair (multiple entries are separated with commas)",
                        "which acts as the central registry for volumes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"registry\" <$> TF.attribute",
                    "name": "_registry",
                    "method": "registry",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRegistry",
                    "validate": false,
                    "optional": false,
                    "original": "registry"
                },
                {
                    "default": "_volume",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Volume is a string that references an already created Quobyte volume by",
                        "name."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume\" <$> TF.attribute",
                    "name": "_volume",
                    "method": "volume",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolume",
                    "validate": false,
                    "optional": false,
                    "original": "volume"
                }
            ],
            "conflicts": [],
            "type": "PersistentVolumeSpecPersistentVolumeSourceQuobyteSetting s",
            "original": "quobyte"
        },
        {
            "con": {
                "smart": "newPersistentVolumeSpecPersistentVolumeSourceRbdSecretRefSetting",
                "name": "PersistentVolumeSpecPersistentVolumeSourceRbdSecretRefSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "dependencies": [],
            "key": "persistent_volume.spec.persistent_volume_source.rbd.secret_ref",
            "name": "PersistentVolumeSpecPersistentVolumeSourceRbdSecretRefSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PersistentVolumeSpecPersistentVolumeSourceRbdSecretRefSetting s",
            "original": "secret_ref"
        },
        {
            "con": {
                "smart": "newPersistentVolumeSpecPersistentVolumeSourceRbdSetting",
                "name": "PersistentVolumeSpecPersistentVolumeSourceRbdSetting'"
            },
            "arguments": [
                {
                    "default": "_cephMonitors",
                    "computed": false,
                    "required": true,
                    "help": [
                        "A collection of Ceph monitors. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ceph_monitors\" <$> TF.attribute",
                    "name": "_cephMonitors",
                    "method": "cephMonitors",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCephMonitors",
                    "validate": false,
                    "optional": false,
                    "original": "ceph_monitors"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type of the volume that you want to mount. Tip: Ensure that the",
                        "filesystem type is supported by the host operating system. Examples: \"ext4\",",
                        "\"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#rbd"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring.",
                        "More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"keyring\" <$> TF.attribute",
                    "name": "_keyring",
                    "method": "keyring",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasKeyring",
                    "validate": false,
                    "optional": true,
                    "original": "keyring"
                },
                {
                    "default": "TF.value \"admin\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The rados user name. Default is admin. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"rados_user\" <$> TF.attribute",
                    "name": "_radosUser",
                    "method": "radosUser",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRadosUser",
                    "validate": false,
                    "optional": true,
                    "original": "rados_user"
                },
                {
                    "default": "_rbdImage",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The rados image name. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"rbd_image\" <$> TF.attribute",
                    "name": "_rbdImage",
                    "method": "rbdImage",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRbdImage",
                    "validate": false,
                    "optional": false,
                    "original": "rbd_image"
                },
                {
                    "default": "TF.value \"rbd\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The rados pool name. Default is rbd. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"rbd_pool\" <$> TF.attribute",
                    "name": "_rbdPool",
                    "method": "rbdPool",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRbdPool",
                    "validate": false,
                    "optional": true,
                    "original": "rbd_pool"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to false.",
                        "More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the authentication secret for RBDUser. If provided overrides",
                        "keyring. Default is nil. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_ref\" <$> TF.attribute",
                    "name": "_secretRef",
                    "method": "secretRef",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeSpecPersistentVolumeSourceRbdSecretRefSetting s)",
                    "class": "HasSecretRef",
                    "validate": true,
                    "optional": true,
                    "original": "secret_ref"
                }
            ],
            "dependencies": [
                "PersistentVolumeSpecPersistentVolumeSourceRbdSecretRefSetting"
            ],
            "key": "persistent_volume.spec.persistent_volume_source.rbd",
            "name": "PersistentVolumeSpecPersistentVolumeSourceRbdSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring.",
                        "More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"keyring\" <$> TF.attribute",
                    "name": "_computedKeyring",
                    "method": "computedKeyring",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedKeyring",
                    "validate": false,
                    "optional": false,
                    "original": "keyring"
                }
            ],
            "parameters": [
                {
                    "default": "_rbdImage",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The rados image name. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"rbd_image\" <$> TF.attribute",
                    "name": "_rbdImage",
                    "method": "rbdImage",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRbdImage",
                    "validate": false,
                    "optional": false,
                    "original": "rbd_image"
                },
                {
                    "default": "_cephMonitors",
                    "computed": false,
                    "required": true,
                    "help": [
                        "A collection of Ceph monitors. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ceph_monitors\" <$> TF.attribute",
                    "name": "_cephMonitors",
                    "method": "cephMonitors",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCephMonitors",
                    "validate": false,
                    "optional": false,
                    "original": "ceph_monitors"
                }
            ],
            "conflicts": [],
            "type": "PersistentVolumeSpecPersistentVolumeSourceRbdSetting s",
            "original": "rbd"
        },
        {
            "con": {
                "smart": "newPersistentVolumeSpecPersistentVolumeSourceSetting",
                "name": "PersistentVolumeSpecPersistentVolumeSourceSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an AWS Disk resource that is attached to a kubelet's host machine",
                        "and then exposed to the pod. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"aws_elastic_block_store\" <$> TF.attribute",
                    "name": "_awsElasticBlockStore",
                    "method": "awsElasticBlockStore",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeSpecPersistentVolumeSourceAwsElasticBlockStoreSetting s)",
                    "class": "HasAwsElasticBlockStore",
                    "validate": true,
                    "optional": true,
                    "original": "aws_elastic_block_store"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an Azure Data Disk mount on the host and bind mount to the pod."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"azure_disk\" <$> TF.attribute",
                    "name": "_azureDisk",
                    "method": "azureDisk",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeSpecPersistentVolumeSourceAzureDiskSetting s)",
                    "class": "HasAzureDisk",
                    "validate": true,
                    "optional": true,
                    "original": "azure_disk"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an Azure File Service mount on the host and bind mount to the",
                        "pod."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"azure_file\" <$> TF.attribute",
                    "name": "_azureFile",
                    "method": "azureFile",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeSpecPersistentVolumeSourceAzureFileSetting s)",
                    "class": "HasAzureFile",
                    "validate": true,
                    "optional": true,
                    "original": "azure_file"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Ceph FS mount on the host that shares a pod's lifetime"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ceph_fs\" <$> TF.attribute",
                    "name": "_cephFs",
                    "method": "cephFs",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeSpecPersistentVolumeSourceCephFsSetting s)",
                    "class": "HasCephFs",
                    "validate": true,
                    "optional": true,
                    "original": "ceph_fs"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a cinder volume attached and mounted on kubelets host machine.",
                        "More info: http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cinder\" <$> TF.attribute",
                    "name": "_cinder",
                    "method": "cinder",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeSpecPersistentVolumeSourceCinderSetting s)",
                    "class": "HasCinder",
                    "validate": true,
                    "optional": true,
                    "original": "cinder"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Fibre Channel resource that is attached to a kubelet's host",
                        "machine and then exposed to the pod."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fc\" <$> TF.attribute",
                    "name": "_fc",
                    "method": "fc",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeSpecPersistentVolumeSourceFcSetting s)",
                    "class": "HasFc",
                    "validate": true,
                    "optional": true,
                    "original": "fc"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a generic volume resource that is provisioned/attached using an",
                        "exec based plugin. This is an alpha feature and may change in future."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"flex_volume\" <$> TF.attribute",
                    "name": "_flexVolume",
                    "method": "flexVolume",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeSpecPersistentVolumeSourceFlexVolumeSetting s)",
                    "class": "HasFlexVolume",
                    "validate": true,
                    "optional": true,
                    "original": "flex_volume"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Flocker volume attached to a kubelet's host machine and exposed",
                        "to the pod for its usage. This depends on the Flocker control service being",
                        "running"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"flocker\" <$> TF.attribute",
                    "name": "_flocker",
                    "method": "flocker",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeSpecPersistentVolumeSourceFlockerSetting s)",
                    "class": "HasFlocker",
                    "validate": true,
                    "optional": true,
                    "original": "flocker"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a GCE Disk resource that is attached to a kubelet's host machine",
                        "and then exposed to the pod. Provisioned by an admin. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"gce_persistent_disk\" <$> TF.attribute",
                    "name": "_gcePersistentDisk",
                    "method": "gcePersistentDisk",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeSpecPersistentVolumeSourceGcePersistentDiskSetting s)",
                    "class": "HasGcePersistentDisk",
                    "validate": true,
                    "optional": true,
                    "original": "gce_persistent_disk"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Glusterfs volume that is attached to a host and exposed to the",
                        "pod. Provisioned by an admin. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"glusterfs\" <$> TF.attribute",
                    "name": "_glusterfs",
                    "method": "glusterfs",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeSpecPersistentVolumeSourceGlusterfsSetting s)",
                    "class": "HasGlusterfs",
                    "validate": true,
                    "optional": true,
                    "original": "glusterfs"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a directory on the host. Provisioned by a developer or tester.",
                        "This is useful for single-node development and testing only! On-host storage",
                        "is not supported in any way and WILL NOT WORK in a multi-node cluster. More",
                        "info: http://kubernetes.io/docs/user-guide/volumes#hostpath"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_path\" <$> TF.attribute",
                    "name": "_hostPath",
                    "method": "hostPath",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeSpecPersistentVolumeSourceHostPathSetting s)",
                    "class": "HasHostPath",
                    "validate": true,
                    "optional": true,
                    "original": "host_path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an ISCSI Disk resource that is attached to a kubelet's host",
                        "machine and then exposed to the pod. Provisioned by an admin."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"iscsi\" <$> TF.attribute",
                    "name": "_iscsi",
                    "method": "iscsi",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeSpecPersistentVolumeSourceIscsiSetting s)",
                    "class": "HasIscsi",
                    "validate": true,
                    "optional": true,
                    "original": "iscsi"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an NFS mount on the host. Provisioned by an admin. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"nfs\" <$> TF.attribute",
                    "name": "_nfs",
                    "method": "nfs",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeSpecPersistentVolumeSourceNfsSetting s)",
                    "class": "HasNfs",
                    "validate": true,
                    "optional": true,
                    "original": "nfs"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a PhotonController persistent disk attached and mounted on",
                        "kubelets host machine"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"photon_persistent_disk\" <$> TF.attribute",
                    "name": "_photonPersistentDisk",
                    "method": "photonPersistentDisk",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeSpecPersistentVolumeSourcePhotonPersistentDiskSetting s)",
                    "class": "HasPhotonPersistentDisk",
                    "validate": true,
                    "optional": true,
                    "original": "photon_persistent_disk"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Quobyte represents a Quobyte mount on the host that shares a pod's lifetime"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"quobyte\" <$> TF.attribute",
                    "name": "_quobyte",
                    "method": "quobyte",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeSpecPersistentVolumeSourceQuobyteSetting s)",
                    "class": "HasQuobyte",
                    "validate": true,
                    "optional": true,
                    "original": "quobyte"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Rados Block Device mount on the host that shares a pod's",
                        "lifetime. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"rbd\" <$> TF.attribute",
                    "name": "_rbd",
                    "method": "rbd",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeSpecPersistentVolumeSourceRbdSetting s)",
                    "class": "HasRbd",
                    "validate": true,
                    "optional": true,
                    "original": "rbd"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a vSphere volume attached and mounted on kubelets host machine"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vsphere_volume\" <$> TF.attribute",
                    "name": "_vsphereVolume",
                    "method": "vsphereVolume",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeSpecPersistentVolumeSourceVsphereVolumeSetting s)",
                    "class": "HasVsphereVolume",
                    "validate": true,
                    "optional": true,
                    "original": "vsphere_volume"
                }
            ],
            "dependencies": [
                "PersistentVolumeSpecPersistentVolumeSourceAwsElasticBlockStoreSetting",
                "PersistentVolumeSpecPersistentVolumeSourceAzureDiskSetting",
                "PersistentVolumeSpecPersistentVolumeSourceAzureFileSetting",
                "PersistentVolumeSpecPersistentVolumeSourceCephFsSetting",
                "PersistentVolumeSpecPersistentVolumeSourceCinderSetting",
                "PersistentVolumeSpecPersistentVolumeSourceFcSetting",
                "PersistentVolumeSpecPersistentVolumeSourceFlexVolumeSetting",
                "PersistentVolumeSpecPersistentVolumeSourceFlockerSetting",
                "PersistentVolumeSpecPersistentVolumeSourceGcePersistentDiskSetting",
                "PersistentVolumeSpecPersistentVolumeSourceGlusterfsSetting",
                "PersistentVolumeSpecPersistentVolumeSourceHostPathSetting",
                "PersistentVolumeSpecPersistentVolumeSourceIscsiSetting",
                "PersistentVolumeSpecPersistentVolumeSourceNfsSetting",
                "PersistentVolumeSpecPersistentVolumeSourcePhotonPersistentDiskSetting",
                "PersistentVolumeSpecPersistentVolumeSourceQuobyteSetting",
                "PersistentVolumeSpecPersistentVolumeSourceRbdSetting",
                "PersistentVolumeSpecPersistentVolumeSourceVsphereVolumeSetting"
            ],
            "key": "persistent_volume.spec.persistent_volume_source",
            "name": "PersistentVolumeSpecPersistentVolumeSourceSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PersistentVolumeSpecPersistentVolumeSourceSetting s",
            "original": "persistent_volume_source"
        },
        {
            "con": {
                "smart": "newPersistentVolumeSpecPersistentVolumeSourceVsphereVolumeSetting",
                "name": "PersistentVolumeSpecPersistentVolumeSourceVsphereVolumeSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type to mount. Must be a filesystem type supported by the host",
                        "operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be",
                        "\"ext4\" if unspecified."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "_volumePath",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path that identifies vSphere volume vmdk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_path\" <$> TF.attribute",
                    "name": "_volumePath",
                    "method": "volumePath",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumePath",
                    "validate": false,
                    "optional": false,
                    "original": "volume_path"
                }
            ],
            "dependencies": [],
            "key": "persistent_volume.spec.persistent_volume_source.vsphere_volume",
            "name": "PersistentVolumeSpecPersistentVolumeSourceVsphereVolumeSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_volumePath",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path that identifies vSphere volume vmdk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_path\" <$> TF.attribute",
                    "name": "_volumePath",
                    "method": "volumePath",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumePath",
                    "validate": false,
                    "optional": false,
                    "original": "volume_path"
                }
            ],
            "conflicts": [],
            "type": "PersistentVolumeSpecPersistentVolumeSourceVsphereVolumeSetting s",
            "original": "vsphere_volume"
        },
        {
            "con": {
                "smart": "newPersistentVolumeSpecSetting",
                "name": "PersistentVolumeSpecSetting'"
            },
            "arguments": [
                {
                    "default": "_accessModes",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Contains all ways the volume can be mounted. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#access-modes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"access_modes\" <$> TF.attribute",
                    "name": "_accessModes",
                    "method": "accessModes",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasAccessModes",
                    "validate": false,
                    "optional": false,
                    "original": "access_modes"
                },
                {
                    "default": "_capacity",
                    "computed": false,
                    "required": true,
                    "help": [
                        "A description of the persistent volume's resources and capacity. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#capacity"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"capacity\" <$> TF.attribute",
                    "name": "_capacity",
                    "method": "capacity",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasCapacity",
                    "validate": false,
                    "optional": false,
                    "original": "capacity"
                },
                {
                    "default": "TF.value \"Retain\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "What happens to a persistent volume when released from its claim. Valid",
                        "options are Retain (default) and Recycle. Recycling must be supported by the",
                        "volume plugin underlying this persistent volume. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#recycling-policy"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"persistent_volume_reclaim_policy\" <$> TF.attribute",
                    "name": "_persistentVolumeReclaimPolicy",
                    "method": "persistentVolumeReclaimPolicy",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPersistentVolumeReclaimPolicy",
                    "validate": false,
                    "optional": true,
                    "original": "persistent_volume_reclaim_policy"
                },
                {
                    "default": "_persistentVolumeSource",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The specification of a persistent volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"persistent_volume_source\" <$> TF.attribute",
                    "name": "_persistentVolumeSource",
                    "method": "persistentVolumeSource",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeSpecPersistentVolumeSourceSetting s)",
                    "class": "HasPersistentVolumeSource",
                    "validate": true,
                    "optional": false,
                    "original": "persistent_volume_source"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A description of the persistent volume's class. More info:",
                        "https://kubernetes.io/docs/concepts/storage/persistent-volumes/#class"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"storage_class_name\" <$> TF.attribute",
                    "name": "_storageClassName",
                    "method": "storageClassName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasStorageClassName",
                    "validate": false,
                    "optional": true,
                    "original": "storage_class_name"
                }
            ],
            "dependencies": [
                "PersistentVolumeSpecPersistentVolumeSourceSetting"
            ],
            "key": "persistent_volume.spec",
            "name": "PersistentVolumeSpecSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_capacity",
                    "computed": false,
                    "required": true,
                    "help": [
                        "A description of the persistent volume's resources and capacity. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#capacity"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"capacity\" <$> TF.attribute",
                    "name": "_capacity",
                    "method": "capacity",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasCapacity",
                    "validate": false,
                    "optional": false,
                    "original": "capacity"
                },
                {
                    "default": "_accessModes",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Contains all ways the volume can be mounted. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#access-modes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"access_modes\" <$> TF.attribute",
                    "name": "_accessModes",
                    "method": "accessModes",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasAccessModes",
                    "validate": false,
                    "optional": false,
                    "original": "access_modes"
                },
                {
                    "default": "_persistentVolumeSource",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The specification of a persistent volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"persistent_volume_source\" <$> TF.attribute",
                    "name": "_persistentVolumeSource",
                    "method": "persistentVolumeSource",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeSpecPersistentVolumeSourceSetting s)",
                    "class": "HasPersistentVolumeSource",
                    "validate": true,
                    "optional": false,
                    "original": "persistent_volume_source"
                }
            ],
            "conflicts": [],
            "type": "PersistentVolumeSpecSetting s",
            "original": "spec"
        },
        {
            "con": {
                "smart": "newPodMetadataSetting",
                "name": "PodMetadataSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "An unstructured key value map stored with the pod that may be used to store",
                        "arbitrary metadata. More info:",
                        "http://kubernetes.io/docs/user-guide/annotations"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"annotations\" <$> TF.attribute",
                    "name": "_annotations",
                    "method": "annotations",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasAnnotations",
                    "validate": false,
                    "optional": true,
                    "original": "annotations"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Prefix, used by the server, to generate a unique name ONLY IF the `name`",
                        "field has not been provided. This value will also be combined with a unique",
                        "suffix. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#idempotency"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"generate_name\" <$> TF.attribute",
                    "name": "_generateName",
                    "method": "generateName",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_name",
                            "method": "name"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasGenerateName",
                    "validate": false,
                    "optional": true,
                    "original": "generate_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Map of string keys and values that can be used to organize and categorize",
                        "(scope and select) the pod. May match selectors of replication controllers",
                        "and services. More info: http://kubernetes.io/docs/user-guide/labels"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"labels\" <$> TF.attribute",
                    "name": "_labels",
                    "method": "labels",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasLabels",
                    "validate": false,
                    "optional": true,
                    "original": "labels"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the pod, must be unique. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_generateName",
                            "method": "generateName"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.value \"default\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Namespace defines the space within which name of the pod must be unique."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"namespace\" <$> TF.attribute",
                    "name": "_namespace",
                    "method": "namespace",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasNamespace",
                    "validate": false,
                    "optional": true,
                    "original": "namespace"
                }
            ],
            "dependencies": [],
            "key": "pod.metadata",
            "name": "PodMetadataSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A sequence number representing a specific generation of the desired state."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"generation\" <$> TF.attribute",
                    "name": "_computedGeneration",
                    "method": "computedGeneration",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedGeneration",
                    "validate": false,
                    "optional": false,
                    "original": "generation"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Name of the pod, must be unique. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_computedName",
                    "method": "computedName",
                    "threaded": true,
                    "conflicts": [
                        "_generateName"
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "An opaque value that represents the internal version of this pod that can be",
                        "used by clients to determine when pod has changed. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#concurrency-control-and-consistency"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_version\" <$> TF.attribute",
                    "name": "_computedResourceVersion",
                    "method": "computedResourceVersion",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedResourceVersion",
                    "validate": false,
                    "optional": false,
                    "original": "resource_version"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A URL representing this pod."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"self_link\" <$> TF.attribute",
                    "name": "_computedSelfLink",
                    "method": "computedSelfLink",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedSelfLink",
                    "validate": false,
                    "optional": false,
                    "original": "self_link"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The unique in time and space value for this pod. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#uids"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"uid\" <$> TF.attribute",
                    "name": "_computedUid",
                    "method": "computedUid",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedUid",
                    "validate": false,
                    "optional": false,
                    "original": "uid"
                }
            ],
            "parameters": [],
            "conflicts": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Prefix, used by the server, to generate a unique name ONLY IF the `name`",
                        "field has not been provided. This value will also be combined with a unique",
                        "suffix. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#idempotency"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"generate_name\" <$> TF.attribute",
                    "name": "_generateName",
                    "method": "generateName",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_name",
                            "method": "name"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasGenerateName",
                    "validate": false,
                    "optional": true,
                    "original": "generate_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the pod, must be unique. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_generateName",
                            "method": "generateName"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "type": "PodMetadataSetting s",
            "original": "metadata"
        },
        {
            "con": {
                "smart": "newPodSpecContainerEnvSetting",
                "name": "PodSpecContainerEnvSetting'"
            },
            "arguments": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the environment variable. Must be a C_IDENTIFIER"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Variable references $(VAR_NAME) are expanded using the previous defined",
                        "environment variables in the container and any service environment",
                        "variables. If a variable cannot be resolved, the reference in the input",
                        "string will be unchanged. The $(VAR_NAME) syntax can be escaped with a",
                        "double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,",
                        "regardless of whether the variable exists or not. Defaults to \"\"."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"value\" <$> TF.attribute",
                    "name": "_value",
                    "method": "value",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasValue",
                    "validate": false,
                    "optional": true,
                    "original": "value"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Source for the environment variable's value"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"value_from\" <$> TF.attribute",
                    "name": "_valueFrom",
                    "method": "valueFrom",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecContainerEnvValueFromSetting s)",
                    "class": "HasValueFrom",
                    "validate": true,
                    "optional": true,
                    "original": "value_from"
                }
            ],
            "dependencies": [
                "PodSpecContainerEnvValueFromSetting"
            ],
            "key": "pod.spec.container.env",
            "name": "PodSpecContainerEnvSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the environment variable. Must be a C_IDENTIFIER"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "PodSpecContainerEnvSetting s",
            "original": "env"
        },
        {
            "con": {
                "smart": "newPodSpecContainerEnvValueFromConfigMapKeyRefSetting",
                "name": "PodSpecContainerEnvValueFromConfigMapKeyRefSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The key to select."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"key\" <$> TF.attribute",
                    "name": "_key",
                    "method": "key",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasKey",
                    "validate": false,
                    "optional": true,
                    "original": "key"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.container.env.value_from.config_map_key_ref",
            "name": "PodSpecContainerEnvValueFromConfigMapKeyRefSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecContainerEnvValueFromConfigMapKeyRefSetting s",
            "original": "config_map_key_ref"
        },
        {
            "con": {
                "smart": "newPodSpecContainerEnvValueFromFieldRefSetting",
                "name": "PodSpecContainerEnvValueFromFieldRefSetting'"
            },
            "arguments": [
                {
                    "default": "TF.value \"v1\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Version of the schema the FieldPath is written in terms of, defaults to",
                        "\"v1\"."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"api_version\" <$> TF.attribute",
                    "name": "_apiVersion",
                    "method": "apiVersion",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasApiVersion",
                    "validate": false,
                    "optional": true,
                    "original": "api_version"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path of the field to select in the specified API version"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"field_path\" <$> TF.attribute",
                    "name": "_fieldPath",
                    "method": "fieldPath",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFieldPath",
                    "validate": false,
                    "optional": true,
                    "original": "field_path"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.container.env.value_from.field_ref",
            "name": "PodSpecContainerEnvValueFromFieldRefSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecContainerEnvValueFromFieldRefSetting s",
            "original": "field_ref"
        },
        {
            "con": {
                "smart": "newPodSpecContainerEnvValueFromResourceFieldRefSetting",
                "name": "PodSpecContainerEnvValueFromResourceFieldRefSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"container_name\" <$> TF.attribute",
                    "name": "_containerName",
                    "method": "containerName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasContainerName",
                    "validate": false,
                    "optional": true,
                    "original": "container_name"
                },
                {
                    "default": "_resource'",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Resource to select"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource\" <$> TF.attribute",
                    "name": "_resource'",
                    "method": "resource'",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasResource'",
                    "validate": false,
                    "optional": false,
                    "original": "resource"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.container.env.value_from.resource_field_ref",
            "name": "PodSpecContainerEnvValueFromResourceFieldRefSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_resource'",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Resource to select"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource\" <$> TF.attribute",
                    "name": "_resource'",
                    "method": "resource'",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasResource'",
                    "validate": false,
                    "optional": false,
                    "original": "resource"
                }
            ],
            "conflicts": [],
            "type": "PodSpecContainerEnvValueFromResourceFieldRefSetting s",
            "original": "resource_field_ref"
        },
        {
            "con": {
                "smart": "newPodSpecContainerEnvValueFromSecretKeyRefSetting",
                "name": "PodSpecContainerEnvValueFromSecretKeyRefSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The key of the secret to select from. Must be a valid secret key."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"key\" <$> TF.attribute",
                    "name": "_key",
                    "method": "key",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasKey",
                    "validate": false,
                    "optional": true,
                    "original": "key"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.container.env.value_from.secret_key_ref",
            "name": "PodSpecContainerEnvValueFromSecretKeyRefSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecContainerEnvValueFromSecretKeyRefSetting s",
            "original": "secret_key_ref"
        },
        {
            "con": {
                "smart": "newPodSpecContainerEnvValueFromSetting",
                "name": "PodSpecContainerEnvValueFromSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Selects a key of a ConfigMap."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"config_map_key_ref\" <$> TF.attribute",
                    "name": "_configMapKeyRef",
                    "method": "configMapKeyRef",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecContainerEnvValueFromConfigMapKeyRefSetting s)",
                    "class": "HasConfigMapKeyRef",
                    "validate": true,
                    "optional": true,
                    "original": "config_map_key_ref"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Selects a field of the pod: supports metadata.name, metadata.namespace,",
                        "metadata.labels, metadata.annotations, spec.nodeName,",
                        "spec.serviceAccountName, status.podIP.."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"field_ref\" <$> TF.attribute",
                    "name": "_fieldRef",
                    "method": "fieldRef",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecContainerEnvValueFromFieldRefSetting s)",
                    "class": "HasFieldRef",
                    "validate": true,
                    "optional": true,
                    "original": "field_ref"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Selects a field of the pod: supports metadata.name, metadata.namespace,",
                        "metadata.labels, metadata.annotations, spec.nodeName,",
                        "spec.serviceAccountName, status.podIP.."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_field_ref\" <$> TF.attribute",
                    "name": "_resourceFieldRef",
                    "method": "resourceFieldRef",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecContainerEnvValueFromResourceFieldRefSetting s)",
                    "class": "HasResourceFieldRef",
                    "validate": true,
                    "optional": true,
                    "original": "resource_field_ref"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Selects a field of the pod: supports metadata.name, metadata.namespace,",
                        "metadata.labels, metadata.annotations, spec.nodeName,",
                        "spec.serviceAccountName, status.podIP.."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_key_ref\" <$> TF.attribute",
                    "name": "_secretKeyRef",
                    "method": "secretKeyRef",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecContainerEnvValueFromSecretKeyRefSetting s)",
                    "class": "HasSecretKeyRef",
                    "validate": true,
                    "optional": true,
                    "original": "secret_key_ref"
                }
            ],
            "dependencies": [
                "PodSpecContainerEnvValueFromConfigMapKeyRefSetting",
                "PodSpecContainerEnvValueFromFieldRefSetting",
                "PodSpecContainerEnvValueFromResourceFieldRefSetting",
                "PodSpecContainerEnvValueFromSecretKeyRefSetting"
            ],
            "key": "pod.spec.container.env.value_from",
            "name": "PodSpecContainerEnvValueFromSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecContainerEnvValueFromSetting s",
            "original": "value_from"
        },
        {
            "con": {
                "smart": "newPodSpecContainerLifecyclePostStartExecSetting",
                "name": "PodSpecContainerLifecyclePostStartExecSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Command is the command line to execute inside the container, the working",
                        "directory for the command is root ('/') in the container's filesystem. The",
                        "command is simply exec'd, it is not run inside a shell, so traditional shell",
                        "instructions. To use a shell, you need to explicitly call out to that shell.",
                        "Exit status of 0 is treated as live/healthy and non-zero is unhealthy."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"command\" <$> TF.attribute",
                    "name": "_command",
                    "method": "command",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCommand",
                    "validate": false,
                    "optional": true,
                    "original": "command"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.container.lifecycle.post_start.exec",
            "name": "PodSpecContainerLifecyclePostStartExecSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecContainerLifecyclePostStartExecSetting s",
            "original": "exec"
        },
        {
            "con": {
                "smart": "newPodSpecContainerLifecyclePostStartHttpGetHttpHeaderSetting",
                "name": "PodSpecContainerLifecyclePostStartHttpGetHttpHeaderSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The header field name"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The header field value"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"value\" <$> TF.attribute",
                    "name": "_value",
                    "method": "value",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasValue",
                    "validate": false,
                    "optional": true,
                    "original": "value"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.container.lifecycle.post_start.http_get.http_header",
            "name": "PodSpecContainerLifecyclePostStartHttpGetHttpHeaderSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecContainerLifecyclePostStartHttpGetHttpHeaderSetting s",
            "original": "http_header"
        },
        {
            "con": {
                "smart": "newPodSpecContainerLifecyclePostStartHttpGetSetting",
                "name": "PodSpecContainerLifecyclePostStartHttpGetSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Host name to connect to, defaults to the pod IP. You probably want to set",
                        "\"Host\" in httpHeaders instead."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host\" <$> TF.attribute",
                    "name": "_host",
                    "method": "host",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHost",
                    "validate": false,
                    "optional": true,
                    "original": "host"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Scheme to use for connecting to the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_header\" <$> TF.attribute",
                    "name": "_httpHeader",
                    "method": "httpHeader",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (PodSpecContainerLifecyclePostStartHttpGetHttpHeaderSetting s)]",
                    "class": "HasHttpHeader",
                    "validate": false,
                    "optional": true,
                    "original": "http_header"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path to access on the HTTP server."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": true,
                    "original": "path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name or number of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": true,
                    "original": "port"
                },
                {
                    "default": "TF.value \"HTTP\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Scheme to use for connecting to the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"scheme\" <$> TF.attribute",
                    "name": "_scheme",
                    "method": "scheme",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasScheme",
                    "validate": false,
                    "optional": true,
                    "original": "scheme"
                }
            ],
            "dependencies": [
                "PodSpecContainerLifecyclePostStartHttpGetHttpHeaderSetting"
            ],
            "key": "pod.spec.container.lifecycle.post_start.http_get",
            "name": "PodSpecContainerLifecyclePostStartHttpGetSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecContainerLifecyclePostStartHttpGetSetting s",
            "original": "http_get"
        },
        {
            "con": {
                "smart": "newPodSpecContainerLifecyclePostStartSetting",
                "name": "PodSpecContainerLifecyclePostStartSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Exec specifies the action to take."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"exec\" <$> TF.attribute",
                    "name": "_exec",
                    "method": "exec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecContainerLifecyclePostStartExecSetting s)",
                    "class": "HasExec",
                    "validate": true,
                    "optional": true,
                    "original": "exec"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Specifies the http request to perform."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_get\" <$> TF.attribute",
                    "name": "_httpGet",
                    "method": "httpGet",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecContainerLifecyclePostStartHttpGetSetting s)",
                    "class": "HasHttpGet",
                    "validate": true,
                    "optional": true,
                    "original": "http_get"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "TCPSocket specifies an action involving a TCP port. TCP hooks not yet",
                        "supported"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tcp_socket\" <$> TF.attribute",
                    "name": "_tcpSocket",
                    "method": "tcpSocket",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (PodSpecContainerLifecyclePostStartTcpSocketSetting s)]",
                    "class": "HasTcpSocket",
                    "validate": false,
                    "optional": true,
                    "original": "tcp_socket"
                }
            ],
            "dependencies": [
                "PodSpecContainerLifecyclePostStartExecSetting",
                "PodSpecContainerLifecyclePostStartHttpGetSetting",
                "PodSpecContainerLifecyclePostStartTcpSocketSetting"
            ],
            "key": "pod.spec.container.lifecycle.post_start",
            "name": "PodSpecContainerLifecyclePostStartSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecContainerLifecyclePostStartSetting s",
            "original": "post_start"
        },
        {
            "con": {
                "smart": "newPodSpecContainerLifecyclePostStartTcpSocketSetting",
                "name": "PodSpecContainerLifecyclePostStartTcpSocketSetting'"
            },
            "arguments": [
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number or name of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.container.lifecycle.post_start.tcp_socket",
            "name": "PodSpecContainerLifecyclePostStartTcpSocketSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number or name of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                }
            ],
            "conflicts": [],
            "type": "PodSpecContainerLifecyclePostStartTcpSocketSetting s",
            "original": "tcp_socket"
        },
        {
            "con": {
                "smart": "newPodSpecContainerLifecyclePreStopExecSetting",
                "name": "PodSpecContainerLifecyclePreStopExecSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Command is the command line to execute inside the container, the working",
                        "directory for the command is root ('/') in the container's filesystem. The",
                        "command is simply exec'd, it is not run inside a shell, so traditional shell",
                        "instructions. To use a shell, you need to explicitly call out to that shell.",
                        "Exit status of 0 is treated as live/healthy and non-zero is unhealthy."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"command\" <$> TF.attribute",
                    "name": "_command",
                    "method": "command",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCommand",
                    "validate": false,
                    "optional": true,
                    "original": "command"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.container.lifecycle.pre_stop.exec",
            "name": "PodSpecContainerLifecyclePreStopExecSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecContainerLifecyclePreStopExecSetting s",
            "original": "exec"
        },
        {
            "con": {
                "smart": "newPodSpecContainerLifecyclePreStopHttpGetHttpHeaderSetting",
                "name": "PodSpecContainerLifecyclePreStopHttpGetHttpHeaderSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The header field name"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The header field value"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"value\" <$> TF.attribute",
                    "name": "_value",
                    "method": "value",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasValue",
                    "validate": false,
                    "optional": true,
                    "original": "value"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.container.lifecycle.pre_stop.http_get.http_header",
            "name": "PodSpecContainerLifecyclePreStopHttpGetHttpHeaderSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecContainerLifecyclePreStopHttpGetHttpHeaderSetting s",
            "original": "http_header"
        },
        {
            "con": {
                "smart": "newPodSpecContainerLifecyclePreStopHttpGetSetting",
                "name": "PodSpecContainerLifecyclePreStopHttpGetSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Host name to connect to, defaults to the pod IP. You probably want to set",
                        "\"Host\" in httpHeaders instead."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host\" <$> TF.attribute",
                    "name": "_host",
                    "method": "host",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHost",
                    "validate": false,
                    "optional": true,
                    "original": "host"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Scheme to use for connecting to the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_header\" <$> TF.attribute",
                    "name": "_httpHeader",
                    "method": "httpHeader",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (PodSpecContainerLifecyclePreStopHttpGetHttpHeaderSetting s)]",
                    "class": "HasHttpHeader",
                    "validate": false,
                    "optional": true,
                    "original": "http_header"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path to access on the HTTP server."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": true,
                    "original": "path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name or number of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": true,
                    "original": "port"
                },
                {
                    "default": "TF.value \"HTTP\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Scheme to use for connecting to the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"scheme\" <$> TF.attribute",
                    "name": "_scheme",
                    "method": "scheme",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasScheme",
                    "validate": false,
                    "optional": true,
                    "original": "scheme"
                }
            ],
            "dependencies": [
                "PodSpecContainerLifecyclePreStopHttpGetHttpHeaderSetting"
            ],
            "key": "pod.spec.container.lifecycle.pre_stop.http_get",
            "name": "PodSpecContainerLifecyclePreStopHttpGetSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecContainerLifecyclePreStopHttpGetSetting s",
            "original": "http_get"
        },
        {
            "con": {
                "smart": "newPodSpecContainerLifecyclePreStopSetting",
                "name": "PodSpecContainerLifecyclePreStopSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Exec specifies the action to take."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"exec\" <$> TF.attribute",
                    "name": "_exec",
                    "method": "exec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecContainerLifecyclePreStopExecSetting s)",
                    "class": "HasExec",
                    "validate": true,
                    "optional": true,
                    "original": "exec"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Specifies the http request to perform."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_get\" <$> TF.attribute",
                    "name": "_httpGet",
                    "method": "httpGet",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecContainerLifecyclePreStopHttpGetSetting s)",
                    "class": "HasHttpGet",
                    "validate": true,
                    "optional": true,
                    "original": "http_get"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "TCPSocket specifies an action involving a TCP port. TCP hooks not yet",
                        "supported"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tcp_socket\" <$> TF.attribute",
                    "name": "_tcpSocket",
                    "method": "tcpSocket",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (PodSpecContainerLifecyclePreStopTcpSocketSetting s)]",
                    "class": "HasTcpSocket",
                    "validate": false,
                    "optional": true,
                    "original": "tcp_socket"
                }
            ],
            "dependencies": [
                "PodSpecContainerLifecyclePreStopExecSetting",
                "PodSpecContainerLifecyclePreStopHttpGetSetting",
                "PodSpecContainerLifecyclePreStopTcpSocketSetting"
            ],
            "key": "pod.spec.container.lifecycle.pre_stop",
            "name": "PodSpecContainerLifecyclePreStopSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecContainerLifecyclePreStopSetting s",
            "original": "pre_stop"
        },
        {
            "con": {
                "smart": "newPodSpecContainerLifecyclePreStopTcpSocketSetting",
                "name": "PodSpecContainerLifecyclePreStopTcpSocketSetting'"
            },
            "arguments": [
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number or name of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.container.lifecycle.pre_stop.tcp_socket",
            "name": "PodSpecContainerLifecyclePreStopTcpSocketSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number or name of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                }
            ],
            "conflicts": [],
            "type": "PodSpecContainerLifecyclePreStopTcpSocketSetting s",
            "original": "tcp_socket"
        },
        {
            "con": {
                "smart": "newPodSpecContainerLifecycleSetting",
                "name": "PodSpecContainerLifecycleSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Post_start is called immediately after a container is created. If the",
                        "handler fails, the container is terminated and restarted according to its",
                        "restart policy. Other management of the container blocks until the hook",
                        "completes. More info:",
                        "http://kubernetes.io/docs/user-guide/container-environment#hook-details"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"post_start\" <$> TF.attribute",
                    "name": "_postStart",
                    "method": "postStart",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (PodSpecContainerLifecyclePostStartSetting s)]",
                    "class": "HasPostStart",
                    "validate": false,
                    "optional": true,
                    "original": "post_start"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Pre_stop is called immediately before a container is terminated. The",
                        "container is terminated after the handler completes. The reason for",
                        "termination is passed to the handler. Regardless of the outcome of the",
                        "handler, the container is eventually terminated. Other management of the",
                        "container blocks until the hook completes. More info:",
                        "http://kubernetes.io/docs/user-guide/container-environment#hook-details"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"pre_stop\" <$> TF.attribute",
                    "name": "_preStop",
                    "method": "preStop",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (PodSpecContainerLifecyclePreStopSetting s)]",
                    "class": "HasPreStop",
                    "validate": false,
                    "optional": true,
                    "original": "pre_stop"
                }
            ],
            "dependencies": [
                "PodSpecContainerLifecyclePostStartSetting",
                "PodSpecContainerLifecyclePreStopSetting"
            ],
            "key": "pod.spec.container.lifecycle",
            "name": "PodSpecContainerLifecycleSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecContainerLifecycleSetting s",
            "original": "lifecycle"
        },
        {
            "con": {
                "smart": "newPodSpecContainerLivenessProbeExecSetting",
                "name": "PodSpecContainerLivenessProbeExecSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Command is the command line to execute inside the container, the working",
                        "directory for the command is root ('/') in the container's filesystem. The",
                        "command is simply exec'd, it is not run inside a shell, so traditional shell",
                        "instructions. To use a shell, you need to explicitly call out to that shell.",
                        "Exit status of 0 is treated as live/healthy and non-zero is unhealthy."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"command\" <$> TF.attribute",
                    "name": "_command",
                    "method": "command",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCommand",
                    "validate": false,
                    "optional": true,
                    "original": "command"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.container.liveness_probe.exec",
            "name": "PodSpecContainerLivenessProbeExecSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecContainerLivenessProbeExecSetting s",
            "original": "exec"
        },
        {
            "con": {
                "smart": "newPodSpecContainerLivenessProbeHttpGetHttpHeaderSetting",
                "name": "PodSpecContainerLivenessProbeHttpGetHttpHeaderSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The header field name"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The header field value"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"value\" <$> TF.attribute",
                    "name": "_value",
                    "method": "value",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasValue",
                    "validate": false,
                    "optional": true,
                    "original": "value"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.container.liveness_probe.http_get.http_header",
            "name": "PodSpecContainerLivenessProbeHttpGetHttpHeaderSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecContainerLivenessProbeHttpGetHttpHeaderSetting s",
            "original": "http_header"
        },
        {
            "con": {
                "smart": "newPodSpecContainerLivenessProbeHttpGetSetting",
                "name": "PodSpecContainerLivenessProbeHttpGetSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Host name to connect to, defaults to the pod IP. You probably want to set",
                        "\"Host\" in httpHeaders instead."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host\" <$> TF.attribute",
                    "name": "_host",
                    "method": "host",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHost",
                    "validate": false,
                    "optional": true,
                    "original": "host"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Scheme to use for connecting to the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_header\" <$> TF.attribute",
                    "name": "_httpHeader",
                    "method": "httpHeader",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (PodSpecContainerLivenessProbeHttpGetHttpHeaderSetting s)]",
                    "class": "HasHttpHeader",
                    "validate": false,
                    "optional": true,
                    "original": "http_header"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path to access on the HTTP server."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": true,
                    "original": "path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name or number of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": true,
                    "original": "port"
                },
                {
                    "default": "TF.value \"HTTP\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Scheme to use for connecting to the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"scheme\" <$> TF.attribute",
                    "name": "_scheme",
                    "method": "scheme",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasScheme",
                    "validate": false,
                    "optional": true,
                    "original": "scheme"
                }
            ],
            "dependencies": [
                "PodSpecContainerLivenessProbeHttpGetHttpHeaderSetting"
            ],
            "key": "pod.spec.container.liveness_probe.http_get",
            "name": "PodSpecContainerLivenessProbeHttpGetSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecContainerLivenessProbeHttpGetSetting s",
            "original": "http_get"
        },
        {
            "con": {
                "smart": "newPodSpecContainerLivenessProbeSetting",
                "name": "PodSpecContainerLivenessProbeSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Exec specifies the action to take."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"exec\" <$> TF.attribute",
                    "name": "_exec",
                    "method": "exec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecContainerLivenessProbeExecSetting s)",
                    "class": "HasExec",
                    "validate": true,
                    "optional": true,
                    "original": "exec"
                },
                {
                    "default": "TF.value 3",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Minimum consecutive failures for the probe to be considered failed after",
                        "having succeeded."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"failure_threshold\" <$> TF.attribute",
                    "name": "_failureThreshold",
                    "method": "failureThreshold",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasFailureThreshold",
                    "validate": false,
                    "optional": true,
                    "original": "failure_threshold"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Specifies the http request to perform."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_get\" <$> TF.attribute",
                    "name": "_httpGet",
                    "method": "httpGet",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecContainerLivenessProbeHttpGetSetting s)",
                    "class": "HasHttpGet",
                    "validate": true,
                    "optional": true,
                    "original": "http_get"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Number of seconds after the container has started before liveness probes are",
                        "initiated. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"initial_delay_seconds\" <$> TF.attribute",
                    "name": "_initialDelaySeconds",
                    "method": "initialDelaySeconds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasInitialDelaySeconds",
                    "validate": false,
                    "optional": true,
                    "original": "initial_delay_seconds"
                },
                {
                    "default": "TF.value 10",
                    "computed": false,
                    "required": false,
                    "help": [
                        "How often (in seconds) to perform the probe"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"period_seconds\" <$> TF.attribute",
                    "name": "_periodSeconds",
                    "method": "periodSeconds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasPeriodSeconds",
                    "validate": false,
                    "optional": true,
                    "original": "period_seconds"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Minimum consecutive successes for the probe to be considered successful",
                        "after having failed."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"success_threshold\" <$> TF.attribute",
                    "name": "_successThreshold",
                    "method": "successThreshold",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasSuccessThreshold",
                    "validate": false,
                    "optional": true,
                    "original": "success_threshold"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "TCPSocket specifies an action involving a TCP port. TCP hooks not yet",
                        "supported"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tcp_socket\" <$> TF.attribute",
                    "name": "_tcpSocket",
                    "method": "tcpSocket",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (PodSpecContainerLivenessProbeTcpSocketSetting s)]",
                    "class": "HasTcpSocket",
                    "validate": false,
                    "optional": true,
                    "original": "tcp_socket"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Number of seconds after which the probe times out. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"timeout_seconds\" <$> TF.attribute",
                    "name": "_timeoutSeconds",
                    "method": "timeoutSeconds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasTimeoutSeconds",
                    "validate": false,
                    "optional": true,
                    "original": "timeout_seconds"
                }
            ],
            "dependencies": [
                "PodSpecContainerLivenessProbeExecSetting",
                "PodSpecContainerLivenessProbeHttpGetSetting",
                "PodSpecContainerLivenessProbeTcpSocketSetting"
            ],
            "key": "pod.spec.container.liveness_probe",
            "name": "PodSpecContainerLivenessProbeSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecContainerLivenessProbeSetting s",
            "original": "liveness_probe"
        },
        {
            "con": {
                "smart": "newPodSpecContainerLivenessProbeTcpSocketSetting",
                "name": "PodSpecContainerLivenessProbeTcpSocketSetting'"
            },
            "arguments": [
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number or name of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.container.liveness_probe.tcp_socket",
            "name": "PodSpecContainerLivenessProbeTcpSocketSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number or name of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                }
            ],
            "conflicts": [],
            "type": "PodSpecContainerLivenessProbeTcpSocketSetting s",
            "original": "tcp_socket"
        },
        {
            "con": {
                "smart": "newPodSpecContainerPortSetting",
                "name": "PodSpecContainerPortSetting'"
            },
            "arguments": [
                {
                    "default": "_containerPort",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number of port to expose on the pod's IP address. This must be a valid port",
                        "number, 0 < x < 65536."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"container_port\" <$> TF.attribute",
                    "name": "_containerPort",
                    "method": "containerPort",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasContainerPort",
                    "validate": false,
                    "optional": false,
                    "original": "container_port"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "What host IP to bind the external port to."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_ip\" <$> TF.attribute",
                    "name": "_hostIp",
                    "method": "hostIp",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHostIp",
                    "validate": false,
                    "optional": true,
                    "original": "host_ip"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Number of port to expose on the host. If specified, this must be a valid",
                        "port number, 0 < x < 65536. If HostNetwork is specified, this must match",
                        "ContainerPort. Most containers do not need this."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_port\" <$> TF.attribute",
                    "name": "_hostPort",
                    "method": "hostPort",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasHostPort",
                    "validate": false,
                    "optional": true,
                    "original": "host_port"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If specified, this must be an IANA_SVC_NAME and unique within the pod. Each",
                        "named port in a pod must have a unique name. Name for the port that can be",
                        "referred to by services"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.value \"TCP\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Protocol for port. Must be UDP or TCP. Defaults to \"TCP\"."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"protocol\" <$> TF.attribute",
                    "name": "_protocol",
                    "method": "protocol",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasProtocol",
                    "validate": false,
                    "optional": true,
                    "original": "protocol"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.container.port",
            "name": "PodSpecContainerPortSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_containerPort",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number of port to expose on the pod's IP address. This must be a valid port",
                        "number, 0 < x < 65536."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"container_port\" <$> TF.attribute",
                    "name": "_containerPort",
                    "method": "containerPort",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasContainerPort",
                    "validate": false,
                    "optional": false,
                    "original": "container_port"
                }
            ],
            "conflicts": [],
            "type": "PodSpecContainerPortSetting s",
            "original": "port"
        },
        {
            "con": {
                "smart": "newPodSpecContainerReadinessProbeExecSetting",
                "name": "PodSpecContainerReadinessProbeExecSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Command is the command line to execute inside the container, the working",
                        "directory for the command is root ('/') in the container's filesystem. The",
                        "command is simply exec'd, it is not run inside a shell, so traditional shell",
                        "instructions. To use a shell, you need to explicitly call out to that shell.",
                        "Exit status of 0 is treated as live/healthy and non-zero is unhealthy."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"command\" <$> TF.attribute",
                    "name": "_command",
                    "method": "command",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCommand",
                    "validate": false,
                    "optional": true,
                    "original": "command"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.container.readiness_probe.exec",
            "name": "PodSpecContainerReadinessProbeExecSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecContainerReadinessProbeExecSetting s",
            "original": "exec"
        },
        {
            "con": {
                "smart": "newPodSpecContainerReadinessProbeHttpGetHttpHeaderSetting",
                "name": "PodSpecContainerReadinessProbeHttpGetHttpHeaderSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The header field name"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The header field value"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"value\" <$> TF.attribute",
                    "name": "_value",
                    "method": "value",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasValue",
                    "validate": false,
                    "optional": true,
                    "original": "value"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.container.readiness_probe.http_get.http_header",
            "name": "PodSpecContainerReadinessProbeHttpGetHttpHeaderSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecContainerReadinessProbeHttpGetHttpHeaderSetting s",
            "original": "http_header"
        },
        {
            "con": {
                "smart": "newPodSpecContainerReadinessProbeHttpGetSetting",
                "name": "PodSpecContainerReadinessProbeHttpGetSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Host name to connect to, defaults to the pod IP. You probably want to set",
                        "\"Host\" in httpHeaders instead."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host\" <$> TF.attribute",
                    "name": "_host",
                    "method": "host",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHost",
                    "validate": false,
                    "optional": true,
                    "original": "host"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Scheme to use for connecting to the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_header\" <$> TF.attribute",
                    "name": "_httpHeader",
                    "method": "httpHeader",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (PodSpecContainerReadinessProbeHttpGetHttpHeaderSetting s)]",
                    "class": "HasHttpHeader",
                    "validate": false,
                    "optional": true,
                    "original": "http_header"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path to access on the HTTP server."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": true,
                    "original": "path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name or number of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": true,
                    "original": "port"
                },
                {
                    "default": "TF.value \"HTTP\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Scheme to use for connecting to the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"scheme\" <$> TF.attribute",
                    "name": "_scheme",
                    "method": "scheme",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasScheme",
                    "validate": false,
                    "optional": true,
                    "original": "scheme"
                }
            ],
            "dependencies": [
                "PodSpecContainerReadinessProbeHttpGetHttpHeaderSetting"
            ],
            "key": "pod.spec.container.readiness_probe.http_get",
            "name": "PodSpecContainerReadinessProbeHttpGetSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecContainerReadinessProbeHttpGetSetting s",
            "original": "http_get"
        },
        {
            "con": {
                "smart": "newPodSpecContainerReadinessProbeSetting",
                "name": "PodSpecContainerReadinessProbeSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Exec specifies the action to take."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"exec\" <$> TF.attribute",
                    "name": "_exec",
                    "method": "exec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecContainerReadinessProbeExecSetting s)",
                    "class": "HasExec",
                    "validate": true,
                    "optional": true,
                    "original": "exec"
                },
                {
                    "default": "TF.value 3",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Minimum consecutive failures for the probe to be considered failed after",
                        "having succeeded."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"failure_threshold\" <$> TF.attribute",
                    "name": "_failureThreshold",
                    "method": "failureThreshold",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasFailureThreshold",
                    "validate": false,
                    "optional": true,
                    "original": "failure_threshold"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Specifies the http request to perform."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_get\" <$> TF.attribute",
                    "name": "_httpGet",
                    "method": "httpGet",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecContainerReadinessProbeHttpGetSetting s)",
                    "class": "HasHttpGet",
                    "validate": true,
                    "optional": true,
                    "original": "http_get"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Number of seconds after the container has started before liveness probes are",
                        "initiated. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"initial_delay_seconds\" <$> TF.attribute",
                    "name": "_initialDelaySeconds",
                    "method": "initialDelaySeconds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasInitialDelaySeconds",
                    "validate": false,
                    "optional": true,
                    "original": "initial_delay_seconds"
                },
                {
                    "default": "TF.value 10",
                    "computed": false,
                    "required": false,
                    "help": [
                        "How often (in seconds) to perform the probe"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"period_seconds\" <$> TF.attribute",
                    "name": "_periodSeconds",
                    "method": "periodSeconds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasPeriodSeconds",
                    "validate": false,
                    "optional": true,
                    "original": "period_seconds"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Minimum consecutive successes for the probe to be considered successful",
                        "after having failed."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"success_threshold\" <$> TF.attribute",
                    "name": "_successThreshold",
                    "method": "successThreshold",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasSuccessThreshold",
                    "validate": false,
                    "optional": true,
                    "original": "success_threshold"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "TCPSocket specifies an action involving a TCP port. TCP hooks not yet",
                        "supported"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tcp_socket\" <$> TF.attribute",
                    "name": "_tcpSocket",
                    "method": "tcpSocket",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (PodSpecContainerReadinessProbeTcpSocketSetting s)]",
                    "class": "HasTcpSocket",
                    "validate": false,
                    "optional": true,
                    "original": "tcp_socket"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Number of seconds after which the probe times out. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"timeout_seconds\" <$> TF.attribute",
                    "name": "_timeoutSeconds",
                    "method": "timeoutSeconds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasTimeoutSeconds",
                    "validate": false,
                    "optional": true,
                    "original": "timeout_seconds"
                }
            ],
            "dependencies": [
                "PodSpecContainerReadinessProbeExecSetting",
                "PodSpecContainerReadinessProbeHttpGetSetting",
                "PodSpecContainerReadinessProbeTcpSocketSetting"
            ],
            "key": "pod.spec.container.readiness_probe",
            "name": "PodSpecContainerReadinessProbeSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecContainerReadinessProbeSetting s",
            "original": "readiness_probe"
        },
        {
            "con": {
                "smart": "newPodSpecContainerReadinessProbeTcpSocketSetting",
                "name": "PodSpecContainerReadinessProbeTcpSocketSetting'"
            },
            "arguments": [
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number or name of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.container.readiness_probe.tcp_socket",
            "name": "PodSpecContainerReadinessProbeTcpSocketSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number or name of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                }
            ],
            "conflicts": [],
            "type": "PodSpecContainerReadinessProbeTcpSocketSetting s",
            "original": "tcp_socket"
        },
        {
            "con": {
                "smart": "newPodSpecContainerResourcesLimitsSetting",
                "name": "PodSpecContainerResourcesLimitsSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu\" <$> TF.attribute",
                    "name": "_cpu",
                    "method": "cpu",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasCpu",
                    "validate": false,
                    "optional": true,
                    "original": "cpu"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory\" <$> TF.attribute",
                    "name": "_memory",
                    "method": "memory",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasMemory",
                    "validate": false,
                    "optional": true,
                    "original": "memory"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.container.resources.limits",
            "name": "PodSpecContainerResourcesLimitsSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu\" <$> TF.attribute",
                    "name": "_computedCpu",
                    "method": "computedCpu",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedCpu",
                    "validate": false,
                    "optional": false,
                    "original": "cpu"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory\" <$> TF.attribute",
                    "name": "_computedMemory",
                    "method": "computedMemory",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedMemory",
                    "validate": false,
                    "optional": false,
                    "original": "memory"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecContainerResourcesLimitsSetting s",
            "original": "limits"
        },
        {
            "con": {
                "smart": "newPodSpecContainerResourcesRequestsSetting",
                "name": "PodSpecContainerResourcesRequestsSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu\" <$> TF.attribute",
                    "name": "_cpu",
                    "method": "cpu",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasCpu",
                    "validate": false,
                    "optional": true,
                    "original": "cpu"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory\" <$> TF.attribute",
                    "name": "_memory",
                    "method": "memory",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasMemory",
                    "validate": false,
                    "optional": true,
                    "original": "memory"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.container.resources.requests",
            "name": "PodSpecContainerResourcesRequestsSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu\" <$> TF.attribute",
                    "name": "_computedCpu",
                    "method": "computedCpu",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedCpu",
                    "validate": false,
                    "optional": false,
                    "original": "cpu"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory\" <$> TF.attribute",
                    "name": "_computedMemory",
                    "method": "computedMemory",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedMemory",
                    "validate": false,
                    "optional": false,
                    "original": "memory"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecContainerResourcesRequestsSetting s",
            "original": "requests"
        },
        {
            "con": {
                "smart": "newPodSpecContainerResourcesSetting",
                "name": "PodSpecContainerResourcesSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Describes the maximum amount of compute resources allowed. More info:",
                        "http://kubernetes.io/docs/user-guide/compute-resources/"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"limits\" <$> TF.attribute",
                    "name": "_limits",
                    "method": "limits",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecContainerResourcesLimitsSetting s)",
                    "class": "HasLimits",
                    "validate": true,
                    "optional": true,
                    "original": "limits"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"requests\" <$> TF.attribute",
                    "name": "_requests",
                    "method": "requests",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecContainerResourcesRequestsSetting s)",
                    "class": "HasRequests",
                    "validate": true,
                    "optional": true,
                    "original": "requests"
                }
            ],
            "dependencies": [
                "PodSpecContainerResourcesLimitsSetting",
                "PodSpecContainerResourcesRequestsSetting",
                "PodSpecContainerResourcesLimitsSetting",
                "PodSpecContainerResourcesRequestsSetting"
            ],
            "key": "pod.spec.container.resources",
            "name": "PodSpecContainerResourcesSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Describes the maximum amount of compute resources allowed. More info:",
                        "http://kubernetes.io/docs/user-guide/compute-resources/"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"limits\" <$> TF.attribute",
                    "name": "_computedLimits",
                    "method": "computedLimits",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecContainerResourcesLimitsSetting s)",
                    "class": "HasComputedLimits",
                    "validate": true,
                    "optional": false,
                    "original": "limits"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"requests\" <$> TF.attribute",
                    "name": "_computedRequests",
                    "method": "computedRequests",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecContainerResourcesRequestsSetting s)",
                    "class": "HasComputedRequests",
                    "validate": true,
                    "optional": false,
                    "original": "requests"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecContainerResourcesSetting s",
            "original": "resources"
        },
        {
            "con": {
                "smart": "newPodSpecContainerSecurityContextCapabilitiesSetting",
                "name": "PodSpecContainerSecurityContextCapabilitiesSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Added capabilities"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"add\" <$> TF.attribute",
                    "name": "_add",
                    "method": "add",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasAdd",
                    "validate": false,
                    "optional": true,
                    "original": "add"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Removed capabilities"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"drop\" <$> TF.attribute",
                    "name": "_drop",
                    "method": "drop",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasDrop",
                    "validate": false,
                    "optional": true,
                    "original": "drop"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.container.security_context.capabilities",
            "name": "PodSpecContainerSecurityContextCapabilitiesSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecContainerSecurityContextCapabilitiesSetting s",
            "original": "capabilities"
        },
        {
            "con": {
                "smart": "newPodSpecContainerSecurityContextSeLinuxOptionsSetting",
                "name": "PodSpecContainerSecurityContextSeLinuxOptionsSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Level is SELinux level label that applies to the container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"level\" <$> TF.attribute",
                    "name": "_level",
                    "method": "level",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasLevel",
                    "validate": false,
                    "optional": true,
                    "original": "level"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Role is a SELinux role label that applies to the container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"role\" <$> TF.attribute",
                    "name": "_role",
                    "method": "role",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRole",
                    "validate": false,
                    "optional": true,
                    "original": "role"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Type is a SELinux type label that applies to the container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"type\" <$> TF.attribute",
                    "name": "_type'",
                    "method": "type'",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasType'",
                    "validate": false,
                    "optional": true,
                    "original": "type"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "User is a SELinux user label that applies to the container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"user\" <$> TF.attribute",
                    "name": "_user",
                    "method": "user",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasUser",
                    "validate": false,
                    "optional": true,
                    "original": "user"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.container.security_context.se_linux_options",
            "name": "PodSpecContainerSecurityContextSeLinuxOptionsSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecContainerSecurityContextSeLinuxOptionsSetting s",
            "original": "se_linux_options"
        },
        {
            "con": {
                "smart": "newPodSpecContainerSecurityContextSetting",
                "name": "PodSpecContainerSecurityContextSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The capabilities to add/drop when running containers. Defaults to the",
                        "default set of capabilities granted by the container runtime."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"capabilities\" <$> TF.attribute",
                    "name": "_capabilities",
                    "method": "capabilities",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecContainerSecurityContextCapabilitiesSetting s)",
                    "class": "HasCapabilities",
                    "validate": true,
                    "optional": true,
                    "original": "capabilities"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Run container in privileged mode. Processes in privileged containers are",
                        "essentially equivalent to root on the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"privileged\" <$> TF.attribute",
                    "name": "_privileged",
                    "method": "privileged",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasPrivileged",
                    "validate": false,
                    "optional": true,
                    "original": "privileged"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether this container has a read-only root filesystem."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only_root_filesystem\" <$> TF.attribute",
                    "name": "_readOnlyRootFilesystem",
                    "method": "readOnlyRootFilesystem",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnlyRootFilesystem",
                    "validate": false,
                    "optional": true,
                    "original": "read_only_root_filesystem"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Indicates that the container must run as a non-root user. If true, the",
                        "Kubelet will validate the image at runtime to ensure that it does not run as",
                        "UID 0 (root) and fail to start the container if it does."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"run_as_non_root\" <$> TF.attribute",
                    "name": "_runAsNonRoot",
                    "method": "runAsNonRoot",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasRunAsNonRoot",
                    "validate": false,
                    "optional": true,
                    "original": "run_as_non_root"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The UID to run the entrypoint of the container process. Defaults to user",
                        "specified in image metadata if unspecified"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"run_as_user\" <$> TF.attribute",
                    "name": "_runAsUser",
                    "method": "runAsUser",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasRunAsUser",
                    "validate": false,
                    "optional": true,
                    "original": "run_as_user"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "ImagePullSecrets is an optional list of references to secrets in the same",
                        "namespace to use for pulling any of the images used by this PodSpec. If",
                        "specified, these secrets will be passed to individual puller implementations",
                        "for them to use. For example, in the case of docker, only DockerConfig type",
                        "secrets are honored. More info:",
                        "http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"se_linux_options\" <$> TF.attribute",
                    "name": "_seLinuxOptions",
                    "method": "seLinuxOptions",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecContainerSecurityContextSeLinuxOptionsSetting s)",
                    "class": "HasSeLinuxOptions",
                    "validate": true,
                    "optional": true,
                    "original": "se_linux_options"
                }
            ],
            "dependencies": [
                "PodSpecContainerSecurityContextCapabilitiesSetting",
                "PodSpecContainerSecurityContextSeLinuxOptionsSetting"
            ],
            "key": "pod.spec.container.security_context",
            "name": "PodSpecContainerSecurityContextSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecContainerSecurityContextSetting s",
            "original": "security_context"
        },
        {
            "con": {
                "smart": "newPodSpecContainerSetting",
                "name": "PodSpecContainerSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Arguments to the entrypoint. The docker image's CMD is used if this is not",
                        "provided. Variable references $(VAR_NAME) are expanded using the container's",
                        "environment. If a variable cannot be resolved, the reference in the input",
                        "string will be unchanged. The $(VAR_NAME) syntax can be escaped with a",
                        "double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,",
                        "regardless of whether the variable exists or not. Cannot be updated. More",
                        "info:",
                        "http://kubernetes.io/docs/user-guide/containers#containers-and-commands"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"args\" <$> TF.attribute",
                    "name": "_args",
                    "method": "args",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasArgs",
                    "validate": false,
                    "optional": true,
                    "original": "args"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT",
                        "is used if this is not provided. Variable references $(VAR_NAME) are",
                        "expanded using the container's environment. If a variable cannot be",
                        "resolved, the reference in the input string will be unchanged. The",
                        "$(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).",
                        "Escaped references will never be expanded, regardless of whether the",
                        "variable exists or not. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/containers#containers-and-commands"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"command\" <$> TF.attribute",
                    "name": "_command",
                    "method": "command",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCommand",
                    "validate": false,
                    "optional": true,
                    "original": "command"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of environment variables to set in the container. Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"env\" <$> TF.attribute",
                    "name": "_env",
                    "method": "env",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (PodSpecContainerEnvSetting s)]",
                    "class": "HasEnv",
                    "validate": false,
                    "optional": true,
                    "original": "env"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Docker image name. More info: http://kubernetes.io/docs/user-guide/images"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"image\" <$> TF.attribute",
                    "name": "_image",
                    "method": "image",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasImage",
                    "validate": false,
                    "optional": true,
                    "original": "image"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if",
                        ":latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More",
                        "info: http://kubernetes.io/docs/user-guide/images#updating-images"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"image_pull_policy\" <$> TF.attribute",
                    "name": "_imagePullPolicy",
                    "method": "imagePullPolicy",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasImagePullPolicy",
                    "validate": false,
                    "optional": true,
                    "original": "image_pull_policy"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Actions that the management system should take in response to container",
                        "lifecycle events"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"lifecycle\" <$> TF.attribute",
                    "name": "_lifecycle",
                    "method": "lifecycle",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecContainerLifecycleSetting s)",
                    "class": "HasLifecycle",
                    "validate": true,
                    "optional": true,
                    "original": "lifecycle"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Periodic probe of container liveness. Container will be restarted if the",
                        "probe fails. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"liveness_probe\" <$> TF.attribute",
                    "name": "_livenessProbe",
                    "method": "livenessProbe",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecContainerLivenessProbeSetting s)",
                    "class": "HasLivenessProbe",
                    "validate": true,
                    "optional": true,
                    "original": "liveness_probe"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the container specified as a DNS_LABEL. Each container in a pod must",
                        "have a unique name (DNS_LABEL). Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of ports to expose from the container. Exposing a port here gives the",
                        "system additional information about the network connections a container",
                        "uses, but is primarily informational. Not specifying a port here DOES NOT",
                        "prevent that port from being exposed. Any port which is listening on the",
                        "default \"0.0.0.0\" address inside a container will be accessible from the",
                        "network. Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (PodSpecContainerPortSetting s)]",
                    "class": "HasPort",
                    "validate": false,
                    "optional": true,
                    "original": "port"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Periodic probe of container service readiness. Container will be removed",
                        "from service endpoints if the probe fails. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"readiness_probe\" <$> TF.attribute",
                    "name": "_readinessProbe",
                    "method": "readinessProbe",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecContainerReadinessProbeSetting s)",
                    "class": "HasReadinessProbe",
                    "validate": true,
                    "optional": true,
                    "original": "readiness_probe"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Compute Resources required by this container. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#resources"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"resources\" <$> TF.attribute",
                    "name": "_resources",
                    "method": "resources",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecContainerResourcesSetting s)",
                    "class": "HasResources",
                    "validate": true,
                    "optional": true,
                    "original": "resources"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Security options the pod should run with. More info:",
                        "http://releases.k8s.io/HEAD/docs/design/security_context.md"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"security_context\" <$> TF.attribute",
                    "name": "_securityContext",
                    "method": "securityContext",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecContainerSecurityContextSetting s)",
                    "class": "HasSecurityContext",
                    "validate": true,
                    "optional": true,
                    "original": "security_context"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether this container should allocate a buffer for stdin in the container",
                        "runtime. If this is not set, reads from stdin in the container will always",
                        "result in EOF."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"stdin\" <$> TF.attribute",
                    "name": "_stdin",
                    "method": "stdin",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasStdin",
                    "validate": false,
                    "optional": true,
                    "original": "stdin"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether the container runtime should close the stdin channel after it has",
                        "been opened by a single attach. When stdin is true the stdin stream will",
                        "remain open across multiple attach sessions. If stdinOnce is set to true,",
                        "stdin is opened on container start, is empty until the first client attaches",
                        "to stdin, and then remains open and accepts data until the client",
                        "disconnects, at which time stdin is closed and remains closed until the",
                        "container is restarted. If this flag is false, a container processes that",
                        "reads from stdin will never receive an EOF."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"stdin_once\" <$> TF.attribute",
                    "name": "_stdinOnce",
                    "method": "stdinOnce",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasStdinOnce",
                    "validate": false,
                    "optional": true,
                    "original": "stdin_once"
                },
                {
                    "default": "TF.value \"/dev/termination-log\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional: Path at which the file to which the container's termination",
                        "message will be written is mounted into the container's filesystem. Message",
                        "written is intended to be brief final status, such as an assertion failure",
                        "message. Defaults to /dev/termination-log. Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"termination_message_path\" <$> TF.attribute",
                    "name": "_terminationMessagePath",
                    "method": "terminationMessagePath",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasTerminationMessagePath",
                    "validate": false,
                    "optional": true,
                    "original": "termination_message_path"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether this container should allocate a TTY for itself"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"tty\" <$> TF.attribute",
                    "name": "_tty",
                    "method": "tty",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasTty",
                    "validate": false,
                    "optional": true,
                    "original": "tty"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Pod volumes to mount into the container's filesystem. Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"volume_mount\" <$> TF.attribute",
                    "name": "_volumeMount",
                    "method": "volumeMount",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (PodSpecContainerVolumeMountSetting s)]",
                    "class": "HasVolumeMount",
                    "validate": false,
                    "optional": true,
                    "original": "volume_mount"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Container's working directory. If not specified, the container runtime's",
                        "default will be used, which might be configured in the container image.",
                        "Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"working_dir\" <$> TF.attribute",
                    "name": "_workingDir",
                    "method": "workingDir",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasWorkingDir",
                    "validate": false,
                    "optional": true,
                    "original": "working_dir"
                }
            ],
            "dependencies": [
                "PodSpecContainerEnvSetting",
                "PodSpecContainerLifecycleSetting",
                "PodSpecContainerLivenessProbeSetting",
                "PodSpecContainerPortSetting",
                "PodSpecContainerReadinessProbeSetting",
                "PodSpecContainerResourcesSetting",
                "PodSpecContainerSecurityContextSetting",
                "PodSpecContainerVolumeMountSetting",
                "PodSpecContainerResourcesSetting"
            ],
            "key": "pod.spec.container",
            "name": "PodSpecContainerSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if",
                        ":latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More",
                        "info: http://kubernetes.io/docs/user-guide/images#updating-images"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"image_pull_policy\" <$> TF.attribute",
                    "name": "_computedImagePullPolicy",
                    "method": "computedImagePullPolicy",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedImagePullPolicy",
                    "validate": false,
                    "optional": false,
                    "original": "image_pull_policy"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Compute Resources required by this container. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#resources"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"resources\" <$> TF.attribute",
                    "name": "_computedResources",
                    "method": "computedResources",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecContainerResourcesSetting s)",
                    "class": "HasComputedResources",
                    "validate": true,
                    "optional": false,
                    "original": "resources"
                }
            ],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the container specified as a DNS_LABEL. Each container in a pod must",
                        "have a unique name (DNS_LABEL). Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "PodSpecContainerSetting s",
            "original": "container"
        },
        {
            "con": {
                "smart": "newPodSpecContainerVolumeMountSetting",
                "name": "PodSpecContainerVolumeMountSetting'"
            },
            "arguments": [
                {
                    "default": "_mountPath",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path within the container at which the volume should be mounted. Must not",
                        "contain ':'."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"mount_path\" <$> TF.attribute",
                    "name": "_mountPath",
                    "method": "mountPath",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasMountPath",
                    "validate": false,
                    "optional": false,
                    "original": "mount_path"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "This must match the Name of a Volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Mounted read-only if true, read-write otherwise (false or unspecified).",
                        "Defaults to false."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path within the volume from which the container's volume should be mounted.",
                        "Defaults to \"\" (volume's root)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sub_path\" <$> TF.attribute",
                    "name": "_subPath",
                    "method": "subPath",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSubPath",
                    "validate": false,
                    "optional": true,
                    "original": "sub_path"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.container.volume_mount",
            "name": "PodSpecContainerVolumeMountSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "This must match the Name of a Volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "_mountPath",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path within the container at which the volume should be mounted. Must not",
                        "contain ':'."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"mount_path\" <$> TF.attribute",
                    "name": "_mountPath",
                    "method": "mountPath",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasMountPath",
                    "validate": false,
                    "optional": false,
                    "original": "mount_path"
                }
            ],
            "conflicts": [],
            "type": "PodSpecContainerVolumeMountSetting s",
            "original": "volume_mount"
        },
        {
            "con": {
                "smart": "newPodSpecImagePullSecretsSetting",
                "name": "PodSpecImagePullSecretsSetting'"
            },
            "arguments": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.image_pull_secrets",
            "name": "PodSpecImagePullSecretsSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "PodSpecImagePullSecretsSetting s",
            "original": "image_pull_secrets"
        },
        {
            "con": {
                "smart": "newPodSpecInitContainerEnvSetting",
                "name": "PodSpecInitContainerEnvSetting'"
            },
            "arguments": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the environment variable. Must be a C_IDENTIFIER"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Variable references $(VAR_NAME) are expanded using the previous defined",
                        "environment variables in the container and any service environment",
                        "variables. If a variable cannot be resolved, the reference in the input",
                        "string will be unchanged. The $(VAR_NAME) syntax can be escaped with a",
                        "double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,",
                        "regardless of whether the variable exists or not. Defaults to \"\"."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"value\" <$> TF.attribute",
                    "name": "_value",
                    "method": "value",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasValue",
                    "validate": false,
                    "optional": true,
                    "original": "value"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Source for the environment variable's value"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"value_from\" <$> TF.attribute",
                    "name": "_valueFrom",
                    "method": "valueFrom",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecInitContainerEnvValueFromSetting s)",
                    "class": "HasValueFrom",
                    "validate": true,
                    "optional": true,
                    "original": "value_from"
                }
            ],
            "dependencies": [
                "PodSpecInitContainerEnvValueFromSetting"
            ],
            "key": "pod.spec.init_container.env",
            "name": "PodSpecInitContainerEnvSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the environment variable. Must be a C_IDENTIFIER"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "PodSpecInitContainerEnvSetting s",
            "original": "env"
        },
        {
            "con": {
                "smart": "newPodSpecInitContainerEnvValueFromConfigMapKeyRefSetting",
                "name": "PodSpecInitContainerEnvValueFromConfigMapKeyRefSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The key to select."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"key\" <$> TF.attribute",
                    "name": "_key",
                    "method": "key",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasKey",
                    "validate": false,
                    "optional": true,
                    "original": "key"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.init_container.env.value_from.config_map_key_ref",
            "name": "PodSpecInitContainerEnvValueFromConfigMapKeyRefSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecInitContainerEnvValueFromConfigMapKeyRefSetting s",
            "original": "config_map_key_ref"
        },
        {
            "con": {
                "smart": "newPodSpecInitContainerEnvValueFromFieldRefSetting",
                "name": "PodSpecInitContainerEnvValueFromFieldRefSetting'"
            },
            "arguments": [
                {
                    "default": "TF.value \"v1\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Version of the schema the FieldPath is written in terms of, defaults to",
                        "\"v1\"."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"api_version\" <$> TF.attribute",
                    "name": "_apiVersion",
                    "method": "apiVersion",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasApiVersion",
                    "validate": false,
                    "optional": true,
                    "original": "api_version"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path of the field to select in the specified API version"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"field_path\" <$> TF.attribute",
                    "name": "_fieldPath",
                    "method": "fieldPath",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFieldPath",
                    "validate": false,
                    "optional": true,
                    "original": "field_path"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.init_container.env.value_from.field_ref",
            "name": "PodSpecInitContainerEnvValueFromFieldRefSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecInitContainerEnvValueFromFieldRefSetting s",
            "original": "field_ref"
        },
        {
            "con": {
                "smart": "newPodSpecInitContainerEnvValueFromResourceFieldRefSetting",
                "name": "PodSpecInitContainerEnvValueFromResourceFieldRefSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"container_name\" <$> TF.attribute",
                    "name": "_containerName",
                    "method": "containerName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasContainerName",
                    "validate": false,
                    "optional": true,
                    "original": "container_name"
                },
                {
                    "default": "_resource'",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Resource to select"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource\" <$> TF.attribute",
                    "name": "_resource'",
                    "method": "resource'",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasResource'",
                    "validate": false,
                    "optional": false,
                    "original": "resource"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.init_container.env.value_from.resource_field_ref",
            "name": "PodSpecInitContainerEnvValueFromResourceFieldRefSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_resource'",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Resource to select"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource\" <$> TF.attribute",
                    "name": "_resource'",
                    "method": "resource'",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasResource'",
                    "validate": false,
                    "optional": false,
                    "original": "resource"
                }
            ],
            "conflicts": [],
            "type": "PodSpecInitContainerEnvValueFromResourceFieldRefSetting s",
            "original": "resource_field_ref"
        },
        {
            "con": {
                "smart": "newPodSpecInitContainerEnvValueFromSecretKeyRefSetting",
                "name": "PodSpecInitContainerEnvValueFromSecretKeyRefSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The key of the secret to select from. Must be a valid secret key."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"key\" <$> TF.attribute",
                    "name": "_key",
                    "method": "key",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasKey",
                    "validate": false,
                    "optional": true,
                    "original": "key"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.init_container.env.value_from.secret_key_ref",
            "name": "PodSpecInitContainerEnvValueFromSecretKeyRefSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecInitContainerEnvValueFromSecretKeyRefSetting s",
            "original": "secret_key_ref"
        },
        {
            "con": {
                "smart": "newPodSpecInitContainerEnvValueFromSetting",
                "name": "PodSpecInitContainerEnvValueFromSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Selects a key of a ConfigMap."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"config_map_key_ref\" <$> TF.attribute",
                    "name": "_configMapKeyRef",
                    "method": "configMapKeyRef",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecInitContainerEnvValueFromConfigMapKeyRefSetting s)",
                    "class": "HasConfigMapKeyRef",
                    "validate": true,
                    "optional": true,
                    "original": "config_map_key_ref"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Selects a field of the pod: supports metadata.name, metadata.namespace,",
                        "metadata.labels, metadata.annotations, spec.nodeName,",
                        "spec.serviceAccountName, status.podIP.."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"field_ref\" <$> TF.attribute",
                    "name": "_fieldRef",
                    "method": "fieldRef",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecInitContainerEnvValueFromFieldRefSetting s)",
                    "class": "HasFieldRef",
                    "validate": true,
                    "optional": true,
                    "original": "field_ref"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Selects a field of the pod: supports metadata.name, metadata.namespace,",
                        "metadata.labels, metadata.annotations, spec.nodeName,",
                        "spec.serviceAccountName, status.podIP.."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_field_ref\" <$> TF.attribute",
                    "name": "_resourceFieldRef",
                    "method": "resourceFieldRef",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecInitContainerEnvValueFromResourceFieldRefSetting s)",
                    "class": "HasResourceFieldRef",
                    "validate": true,
                    "optional": true,
                    "original": "resource_field_ref"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Selects a field of the pod: supports metadata.name, metadata.namespace,",
                        "metadata.labels, metadata.annotations, spec.nodeName,",
                        "spec.serviceAccountName, status.podIP.."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_key_ref\" <$> TF.attribute",
                    "name": "_secretKeyRef",
                    "method": "secretKeyRef",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecInitContainerEnvValueFromSecretKeyRefSetting s)",
                    "class": "HasSecretKeyRef",
                    "validate": true,
                    "optional": true,
                    "original": "secret_key_ref"
                }
            ],
            "dependencies": [
                "PodSpecInitContainerEnvValueFromConfigMapKeyRefSetting",
                "PodSpecInitContainerEnvValueFromFieldRefSetting",
                "PodSpecInitContainerEnvValueFromResourceFieldRefSetting",
                "PodSpecInitContainerEnvValueFromSecretKeyRefSetting"
            ],
            "key": "pod.spec.init_container.env.value_from",
            "name": "PodSpecInitContainerEnvValueFromSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecInitContainerEnvValueFromSetting s",
            "original": "value_from"
        },
        {
            "con": {
                "smart": "newPodSpecInitContainerLifecyclePostStartExecSetting",
                "name": "PodSpecInitContainerLifecyclePostStartExecSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Command is the command line to execute inside the container, the working",
                        "directory for the command is root ('/') in the container's filesystem. The",
                        "command is simply exec'd, it is not run inside a shell, so traditional shell",
                        "instructions. To use a shell, you need to explicitly call out to that shell.",
                        "Exit status of 0 is treated as live/healthy and non-zero is unhealthy."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"command\" <$> TF.attribute",
                    "name": "_command",
                    "method": "command",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCommand",
                    "validate": false,
                    "optional": true,
                    "original": "command"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.init_container.lifecycle.post_start.exec",
            "name": "PodSpecInitContainerLifecyclePostStartExecSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecInitContainerLifecyclePostStartExecSetting s",
            "original": "exec"
        },
        {
            "con": {
                "smart": "newPodSpecInitContainerLifecyclePostStartHttpGetHttpHeaderSetting",
                "name": "PodSpecInitContainerLifecyclePostStartHttpGetHttpHeaderSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The header field name"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The header field value"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"value\" <$> TF.attribute",
                    "name": "_value",
                    "method": "value",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasValue",
                    "validate": false,
                    "optional": true,
                    "original": "value"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.init_container.lifecycle.post_start.http_get.http_header",
            "name": "PodSpecInitContainerLifecyclePostStartHttpGetHttpHeaderSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecInitContainerLifecyclePostStartHttpGetHttpHeaderSetting s",
            "original": "http_header"
        },
        {
            "con": {
                "smart": "newPodSpecInitContainerLifecyclePostStartHttpGetSetting",
                "name": "PodSpecInitContainerLifecyclePostStartHttpGetSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Host name to connect to, defaults to the pod IP. You probably want to set",
                        "\"Host\" in httpHeaders instead."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host\" <$> TF.attribute",
                    "name": "_host",
                    "method": "host",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHost",
                    "validate": false,
                    "optional": true,
                    "original": "host"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Scheme to use for connecting to the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_header\" <$> TF.attribute",
                    "name": "_httpHeader",
                    "method": "httpHeader",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (PodSpecInitContainerLifecyclePostStartHttpGetHttpHeaderSetting s)]",
                    "class": "HasHttpHeader",
                    "validate": false,
                    "optional": true,
                    "original": "http_header"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path to access on the HTTP server."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": true,
                    "original": "path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name or number of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": true,
                    "original": "port"
                },
                {
                    "default": "TF.value \"HTTP\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Scheme to use for connecting to the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"scheme\" <$> TF.attribute",
                    "name": "_scheme",
                    "method": "scheme",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasScheme",
                    "validate": false,
                    "optional": true,
                    "original": "scheme"
                }
            ],
            "dependencies": [
                "PodSpecInitContainerLifecyclePostStartHttpGetHttpHeaderSetting"
            ],
            "key": "pod.spec.init_container.lifecycle.post_start.http_get",
            "name": "PodSpecInitContainerLifecyclePostStartHttpGetSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecInitContainerLifecyclePostStartHttpGetSetting s",
            "original": "http_get"
        },
        {
            "con": {
                "smart": "newPodSpecInitContainerLifecyclePostStartSetting",
                "name": "PodSpecInitContainerLifecyclePostStartSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Exec specifies the action to take."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"exec\" <$> TF.attribute",
                    "name": "_exec",
                    "method": "exec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecInitContainerLifecyclePostStartExecSetting s)",
                    "class": "HasExec",
                    "validate": true,
                    "optional": true,
                    "original": "exec"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Specifies the http request to perform."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_get\" <$> TF.attribute",
                    "name": "_httpGet",
                    "method": "httpGet",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecInitContainerLifecyclePostStartHttpGetSetting s)",
                    "class": "HasHttpGet",
                    "validate": true,
                    "optional": true,
                    "original": "http_get"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "TCPSocket specifies an action involving a TCP port. TCP hooks not yet",
                        "supported"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tcp_socket\" <$> TF.attribute",
                    "name": "_tcpSocket",
                    "method": "tcpSocket",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (PodSpecInitContainerLifecyclePostStartTcpSocketSetting s)]",
                    "class": "HasTcpSocket",
                    "validate": false,
                    "optional": true,
                    "original": "tcp_socket"
                }
            ],
            "dependencies": [
                "PodSpecInitContainerLifecyclePostStartExecSetting",
                "PodSpecInitContainerLifecyclePostStartHttpGetSetting",
                "PodSpecInitContainerLifecyclePostStartTcpSocketSetting"
            ],
            "key": "pod.spec.init_container.lifecycle.post_start",
            "name": "PodSpecInitContainerLifecyclePostStartSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecInitContainerLifecyclePostStartSetting s",
            "original": "post_start"
        },
        {
            "con": {
                "smart": "newPodSpecInitContainerLifecyclePostStartTcpSocketSetting",
                "name": "PodSpecInitContainerLifecyclePostStartTcpSocketSetting'"
            },
            "arguments": [
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number or name of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.init_container.lifecycle.post_start.tcp_socket",
            "name": "PodSpecInitContainerLifecyclePostStartTcpSocketSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number or name of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                }
            ],
            "conflicts": [],
            "type": "PodSpecInitContainerLifecyclePostStartTcpSocketSetting s",
            "original": "tcp_socket"
        },
        {
            "con": {
                "smart": "newPodSpecInitContainerLifecyclePreStopExecSetting",
                "name": "PodSpecInitContainerLifecyclePreStopExecSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Command is the command line to execute inside the container, the working",
                        "directory for the command is root ('/') in the container's filesystem. The",
                        "command is simply exec'd, it is not run inside a shell, so traditional shell",
                        "instructions. To use a shell, you need to explicitly call out to that shell.",
                        "Exit status of 0 is treated as live/healthy and non-zero is unhealthy."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"command\" <$> TF.attribute",
                    "name": "_command",
                    "method": "command",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCommand",
                    "validate": false,
                    "optional": true,
                    "original": "command"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.init_container.lifecycle.pre_stop.exec",
            "name": "PodSpecInitContainerLifecyclePreStopExecSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecInitContainerLifecyclePreStopExecSetting s",
            "original": "exec"
        },
        {
            "con": {
                "smart": "newPodSpecInitContainerLifecyclePreStopHttpGetHttpHeaderSetting",
                "name": "PodSpecInitContainerLifecyclePreStopHttpGetHttpHeaderSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The header field name"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The header field value"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"value\" <$> TF.attribute",
                    "name": "_value",
                    "method": "value",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasValue",
                    "validate": false,
                    "optional": true,
                    "original": "value"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.init_container.lifecycle.pre_stop.http_get.http_header",
            "name": "PodSpecInitContainerLifecyclePreStopHttpGetHttpHeaderSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecInitContainerLifecyclePreStopHttpGetHttpHeaderSetting s",
            "original": "http_header"
        },
        {
            "con": {
                "smart": "newPodSpecInitContainerLifecyclePreStopHttpGetSetting",
                "name": "PodSpecInitContainerLifecyclePreStopHttpGetSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Host name to connect to, defaults to the pod IP. You probably want to set",
                        "\"Host\" in httpHeaders instead."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host\" <$> TF.attribute",
                    "name": "_host",
                    "method": "host",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHost",
                    "validate": false,
                    "optional": true,
                    "original": "host"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Scheme to use for connecting to the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_header\" <$> TF.attribute",
                    "name": "_httpHeader",
                    "method": "httpHeader",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (PodSpecInitContainerLifecyclePreStopHttpGetHttpHeaderSetting s)]",
                    "class": "HasHttpHeader",
                    "validate": false,
                    "optional": true,
                    "original": "http_header"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path to access on the HTTP server."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": true,
                    "original": "path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name or number of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": true,
                    "original": "port"
                },
                {
                    "default": "TF.value \"HTTP\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Scheme to use for connecting to the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"scheme\" <$> TF.attribute",
                    "name": "_scheme",
                    "method": "scheme",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasScheme",
                    "validate": false,
                    "optional": true,
                    "original": "scheme"
                }
            ],
            "dependencies": [
                "PodSpecInitContainerLifecyclePreStopHttpGetHttpHeaderSetting"
            ],
            "key": "pod.spec.init_container.lifecycle.pre_stop.http_get",
            "name": "PodSpecInitContainerLifecyclePreStopHttpGetSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecInitContainerLifecyclePreStopHttpGetSetting s",
            "original": "http_get"
        },
        {
            "con": {
                "smart": "newPodSpecInitContainerLifecyclePreStopSetting",
                "name": "PodSpecInitContainerLifecyclePreStopSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Exec specifies the action to take."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"exec\" <$> TF.attribute",
                    "name": "_exec",
                    "method": "exec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecInitContainerLifecyclePreStopExecSetting s)",
                    "class": "HasExec",
                    "validate": true,
                    "optional": true,
                    "original": "exec"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Specifies the http request to perform."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_get\" <$> TF.attribute",
                    "name": "_httpGet",
                    "method": "httpGet",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecInitContainerLifecyclePreStopHttpGetSetting s)",
                    "class": "HasHttpGet",
                    "validate": true,
                    "optional": true,
                    "original": "http_get"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "TCPSocket specifies an action involving a TCP port. TCP hooks not yet",
                        "supported"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tcp_socket\" <$> TF.attribute",
                    "name": "_tcpSocket",
                    "method": "tcpSocket",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (PodSpecInitContainerLifecyclePreStopTcpSocketSetting s)]",
                    "class": "HasTcpSocket",
                    "validate": false,
                    "optional": true,
                    "original": "tcp_socket"
                }
            ],
            "dependencies": [
                "PodSpecInitContainerLifecyclePreStopExecSetting",
                "PodSpecInitContainerLifecyclePreStopHttpGetSetting",
                "PodSpecInitContainerLifecyclePreStopTcpSocketSetting"
            ],
            "key": "pod.spec.init_container.lifecycle.pre_stop",
            "name": "PodSpecInitContainerLifecyclePreStopSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecInitContainerLifecyclePreStopSetting s",
            "original": "pre_stop"
        },
        {
            "con": {
                "smart": "newPodSpecInitContainerLifecyclePreStopTcpSocketSetting",
                "name": "PodSpecInitContainerLifecyclePreStopTcpSocketSetting'"
            },
            "arguments": [
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number or name of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.init_container.lifecycle.pre_stop.tcp_socket",
            "name": "PodSpecInitContainerLifecyclePreStopTcpSocketSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number or name of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                }
            ],
            "conflicts": [],
            "type": "PodSpecInitContainerLifecyclePreStopTcpSocketSetting s",
            "original": "tcp_socket"
        },
        {
            "con": {
                "smart": "newPodSpecInitContainerLifecycleSetting",
                "name": "PodSpecInitContainerLifecycleSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Post_start is called immediately after a container is created. If the",
                        "handler fails, the container is terminated and restarted according to its",
                        "restart policy. Other management of the container blocks until the hook",
                        "completes. More info:",
                        "http://kubernetes.io/docs/user-guide/container-environment#hook-details"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"post_start\" <$> TF.attribute",
                    "name": "_postStart",
                    "method": "postStart",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (PodSpecInitContainerLifecyclePostStartSetting s)]",
                    "class": "HasPostStart",
                    "validate": false,
                    "optional": true,
                    "original": "post_start"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Pre_stop is called immediately before a container is terminated. The",
                        "container is terminated after the handler completes. The reason for",
                        "termination is passed to the handler. Regardless of the outcome of the",
                        "handler, the container is eventually terminated. Other management of the",
                        "container blocks until the hook completes. More info:",
                        "http://kubernetes.io/docs/user-guide/container-environment#hook-details"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"pre_stop\" <$> TF.attribute",
                    "name": "_preStop",
                    "method": "preStop",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (PodSpecInitContainerLifecyclePreStopSetting s)]",
                    "class": "HasPreStop",
                    "validate": false,
                    "optional": true,
                    "original": "pre_stop"
                }
            ],
            "dependencies": [
                "PodSpecInitContainerLifecyclePostStartSetting",
                "PodSpecInitContainerLifecyclePreStopSetting"
            ],
            "key": "pod.spec.init_container.lifecycle",
            "name": "PodSpecInitContainerLifecycleSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecInitContainerLifecycleSetting s",
            "original": "lifecycle"
        },
        {
            "con": {
                "smart": "newPodSpecInitContainerLivenessProbeExecSetting",
                "name": "PodSpecInitContainerLivenessProbeExecSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Command is the command line to execute inside the container, the working",
                        "directory for the command is root ('/') in the container's filesystem. The",
                        "command is simply exec'd, it is not run inside a shell, so traditional shell",
                        "instructions. To use a shell, you need to explicitly call out to that shell.",
                        "Exit status of 0 is treated as live/healthy and non-zero is unhealthy."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"command\" <$> TF.attribute",
                    "name": "_command",
                    "method": "command",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCommand",
                    "validate": false,
                    "optional": true,
                    "original": "command"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.init_container.liveness_probe.exec",
            "name": "PodSpecInitContainerLivenessProbeExecSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecInitContainerLivenessProbeExecSetting s",
            "original": "exec"
        },
        {
            "con": {
                "smart": "newPodSpecInitContainerLivenessProbeHttpGetHttpHeaderSetting",
                "name": "PodSpecInitContainerLivenessProbeHttpGetHttpHeaderSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The header field name"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The header field value"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"value\" <$> TF.attribute",
                    "name": "_value",
                    "method": "value",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasValue",
                    "validate": false,
                    "optional": true,
                    "original": "value"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.init_container.liveness_probe.http_get.http_header",
            "name": "PodSpecInitContainerLivenessProbeHttpGetHttpHeaderSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecInitContainerLivenessProbeHttpGetHttpHeaderSetting s",
            "original": "http_header"
        },
        {
            "con": {
                "smart": "newPodSpecInitContainerLivenessProbeHttpGetSetting",
                "name": "PodSpecInitContainerLivenessProbeHttpGetSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Host name to connect to, defaults to the pod IP. You probably want to set",
                        "\"Host\" in httpHeaders instead."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host\" <$> TF.attribute",
                    "name": "_host",
                    "method": "host",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHost",
                    "validate": false,
                    "optional": true,
                    "original": "host"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Scheme to use for connecting to the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_header\" <$> TF.attribute",
                    "name": "_httpHeader",
                    "method": "httpHeader",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (PodSpecInitContainerLivenessProbeHttpGetHttpHeaderSetting s)]",
                    "class": "HasHttpHeader",
                    "validate": false,
                    "optional": true,
                    "original": "http_header"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path to access on the HTTP server."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": true,
                    "original": "path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name or number of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": true,
                    "original": "port"
                },
                {
                    "default": "TF.value \"HTTP\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Scheme to use for connecting to the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"scheme\" <$> TF.attribute",
                    "name": "_scheme",
                    "method": "scheme",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasScheme",
                    "validate": false,
                    "optional": true,
                    "original": "scheme"
                }
            ],
            "dependencies": [
                "PodSpecInitContainerLivenessProbeHttpGetHttpHeaderSetting"
            ],
            "key": "pod.spec.init_container.liveness_probe.http_get",
            "name": "PodSpecInitContainerLivenessProbeHttpGetSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecInitContainerLivenessProbeHttpGetSetting s",
            "original": "http_get"
        },
        {
            "con": {
                "smart": "newPodSpecInitContainerLivenessProbeSetting",
                "name": "PodSpecInitContainerLivenessProbeSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Exec specifies the action to take."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"exec\" <$> TF.attribute",
                    "name": "_exec",
                    "method": "exec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecInitContainerLivenessProbeExecSetting s)",
                    "class": "HasExec",
                    "validate": true,
                    "optional": true,
                    "original": "exec"
                },
                {
                    "default": "TF.value 3",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Minimum consecutive failures for the probe to be considered failed after",
                        "having succeeded."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"failure_threshold\" <$> TF.attribute",
                    "name": "_failureThreshold",
                    "method": "failureThreshold",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasFailureThreshold",
                    "validate": false,
                    "optional": true,
                    "original": "failure_threshold"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Specifies the http request to perform."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_get\" <$> TF.attribute",
                    "name": "_httpGet",
                    "method": "httpGet",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecInitContainerLivenessProbeHttpGetSetting s)",
                    "class": "HasHttpGet",
                    "validate": true,
                    "optional": true,
                    "original": "http_get"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Number of seconds after the container has started before liveness probes are",
                        "initiated. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"initial_delay_seconds\" <$> TF.attribute",
                    "name": "_initialDelaySeconds",
                    "method": "initialDelaySeconds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasInitialDelaySeconds",
                    "validate": false,
                    "optional": true,
                    "original": "initial_delay_seconds"
                },
                {
                    "default": "TF.value 10",
                    "computed": false,
                    "required": false,
                    "help": [
                        "How often (in seconds) to perform the probe"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"period_seconds\" <$> TF.attribute",
                    "name": "_periodSeconds",
                    "method": "periodSeconds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasPeriodSeconds",
                    "validate": false,
                    "optional": true,
                    "original": "period_seconds"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Minimum consecutive successes for the probe to be considered successful",
                        "after having failed."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"success_threshold\" <$> TF.attribute",
                    "name": "_successThreshold",
                    "method": "successThreshold",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasSuccessThreshold",
                    "validate": false,
                    "optional": true,
                    "original": "success_threshold"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "TCPSocket specifies an action involving a TCP port. TCP hooks not yet",
                        "supported"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tcp_socket\" <$> TF.attribute",
                    "name": "_tcpSocket",
                    "method": "tcpSocket",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (PodSpecInitContainerLivenessProbeTcpSocketSetting s)]",
                    "class": "HasTcpSocket",
                    "validate": false,
                    "optional": true,
                    "original": "tcp_socket"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Number of seconds after which the probe times out. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"timeout_seconds\" <$> TF.attribute",
                    "name": "_timeoutSeconds",
                    "method": "timeoutSeconds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasTimeoutSeconds",
                    "validate": false,
                    "optional": true,
                    "original": "timeout_seconds"
                }
            ],
            "dependencies": [
                "PodSpecInitContainerLivenessProbeExecSetting",
                "PodSpecInitContainerLivenessProbeHttpGetSetting",
                "PodSpecInitContainerLivenessProbeTcpSocketSetting"
            ],
            "key": "pod.spec.init_container.liveness_probe",
            "name": "PodSpecInitContainerLivenessProbeSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecInitContainerLivenessProbeSetting s",
            "original": "liveness_probe"
        },
        {
            "con": {
                "smart": "newPodSpecInitContainerLivenessProbeTcpSocketSetting",
                "name": "PodSpecInitContainerLivenessProbeTcpSocketSetting'"
            },
            "arguments": [
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number or name of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.init_container.liveness_probe.tcp_socket",
            "name": "PodSpecInitContainerLivenessProbeTcpSocketSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number or name of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                }
            ],
            "conflicts": [],
            "type": "PodSpecInitContainerLivenessProbeTcpSocketSetting s",
            "original": "tcp_socket"
        },
        {
            "con": {
                "smart": "newPodSpecInitContainerPortSetting",
                "name": "PodSpecInitContainerPortSetting'"
            },
            "arguments": [
                {
                    "default": "_containerPort",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number of port to expose on the pod's IP address. This must be a valid port",
                        "number, 0 < x < 65536."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"container_port\" <$> TF.attribute",
                    "name": "_containerPort",
                    "method": "containerPort",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasContainerPort",
                    "validate": false,
                    "optional": false,
                    "original": "container_port"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "What host IP to bind the external port to."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_ip\" <$> TF.attribute",
                    "name": "_hostIp",
                    "method": "hostIp",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHostIp",
                    "validate": false,
                    "optional": true,
                    "original": "host_ip"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Number of port to expose on the host. If specified, this must be a valid",
                        "port number, 0 < x < 65536. If HostNetwork is specified, this must match",
                        "ContainerPort. Most containers do not need this."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_port\" <$> TF.attribute",
                    "name": "_hostPort",
                    "method": "hostPort",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasHostPort",
                    "validate": false,
                    "optional": true,
                    "original": "host_port"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If specified, this must be an IANA_SVC_NAME and unique within the pod. Each",
                        "named port in a pod must have a unique name. Name for the port that can be",
                        "referred to by services"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.value \"TCP\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Protocol for port. Must be UDP or TCP. Defaults to \"TCP\"."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"protocol\" <$> TF.attribute",
                    "name": "_protocol",
                    "method": "protocol",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasProtocol",
                    "validate": false,
                    "optional": true,
                    "original": "protocol"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.init_container.port",
            "name": "PodSpecInitContainerPortSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_containerPort",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number of port to expose on the pod's IP address. This must be a valid port",
                        "number, 0 < x < 65536."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"container_port\" <$> TF.attribute",
                    "name": "_containerPort",
                    "method": "containerPort",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasContainerPort",
                    "validate": false,
                    "optional": false,
                    "original": "container_port"
                }
            ],
            "conflicts": [],
            "type": "PodSpecInitContainerPortSetting s",
            "original": "port"
        },
        {
            "con": {
                "smart": "newPodSpecInitContainerReadinessProbeExecSetting",
                "name": "PodSpecInitContainerReadinessProbeExecSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Command is the command line to execute inside the container, the working",
                        "directory for the command is root ('/') in the container's filesystem. The",
                        "command is simply exec'd, it is not run inside a shell, so traditional shell",
                        "instructions. To use a shell, you need to explicitly call out to that shell.",
                        "Exit status of 0 is treated as live/healthy and non-zero is unhealthy."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"command\" <$> TF.attribute",
                    "name": "_command",
                    "method": "command",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCommand",
                    "validate": false,
                    "optional": true,
                    "original": "command"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.init_container.readiness_probe.exec",
            "name": "PodSpecInitContainerReadinessProbeExecSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecInitContainerReadinessProbeExecSetting s",
            "original": "exec"
        },
        {
            "con": {
                "smart": "newPodSpecInitContainerReadinessProbeHttpGetHttpHeaderSetting",
                "name": "PodSpecInitContainerReadinessProbeHttpGetHttpHeaderSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The header field name"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The header field value"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"value\" <$> TF.attribute",
                    "name": "_value",
                    "method": "value",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasValue",
                    "validate": false,
                    "optional": true,
                    "original": "value"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.init_container.readiness_probe.http_get.http_header",
            "name": "PodSpecInitContainerReadinessProbeHttpGetHttpHeaderSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecInitContainerReadinessProbeHttpGetHttpHeaderSetting s",
            "original": "http_header"
        },
        {
            "con": {
                "smart": "newPodSpecInitContainerReadinessProbeHttpGetSetting",
                "name": "PodSpecInitContainerReadinessProbeHttpGetSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Host name to connect to, defaults to the pod IP. You probably want to set",
                        "\"Host\" in httpHeaders instead."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host\" <$> TF.attribute",
                    "name": "_host",
                    "method": "host",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHost",
                    "validate": false,
                    "optional": true,
                    "original": "host"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Scheme to use for connecting to the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_header\" <$> TF.attribute",
                    "name": "_httpHeader",
                    "method": "httpHeader",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (PodSpecInitContainerReadinessProbeHttpGetHttpHeaderSetting s)]",
                    "class": "HasHttpHeader",
                    "validate": false,
                    "optional": true,
                    "original": "http_header"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path to access on the HTTP server."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": true,
                    "original": "path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name or number of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": true,
                    "original": "port"
                },
                {
                    "default": "TF.value \"HTTP\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Scheme to use for connecting to the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"scheme\" <$> TF.attribute",
                    "name": "_scheme",
                    "method": "scheme",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasScheme",
                    "validate": false,
                    "optional": true,
                    "original": "scheme"
                }
            ],
            "dependencies": [
                "PodSpecInitContainerReadinessProbeHttpGetHttpHeaderSetting"
            ],
            "key": "pod.spec.init_container.readiness_probe.http_get",
            "name": "PodSpecInitContainerReadinessProbeHttpGetSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecInitContainerReadinessProbeHttpGetSetting s",
            "original": "http_get"
        },
        {
            "con": {
                "smart": "newPodSpecInitContainerReadinessProbeSetting",
                "name": "PodSpecInitContainerReadinessProbeSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Exec specifies the action to take."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"exec\" <$> TF.attribute",
                    "name": "_exec",
                    "method": "exec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecInitContainerReadinessProbeExecSetting s)",
                    "class": "HasExec",
                    "validate": true,
                    "optional": true,
                    "original": "exec"
                },
                {
                    "default": "TF.value 3",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Minimum consecutive failures for the probe to be considered failed after",
                        "having succeeded."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"failure_threshold\" <$> TF.attribute",
                    "name": "_failureThreshold",
                    "method": "failureThreshold",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasFailureThreshold",
                    "validate": false,
                    "optional": true,
                    "original": "failure_threshold"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Specifies the http request to perform."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_get\" <$> TF.attribute",
                    "name": "_httpGet",
                    "method": "httpGet",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecInitContainerReadinessProbeHttpGetSetting s)",
                    "class": "HasHttpGet",
                    "validate": true,
                    "optional": true,
                    "original": "http_get"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Number of seconds after the container has started before liveness probes are",
                        "initiated. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"initial_delay_seconds\" <$> TF.attribute",
                    "name": "_initialDelaySeconds",
                    "method": "initialDelaySeconds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasInitialDelaySeconds",
                    "validate": false,
                    "optional": true,
                    "original": "initial_delay_seconds"
                },
                {
                    "default": "TF.value 10",
                    "computed": false,
                    "required": false,
                    "help": [
                        "How often (in seconds) to perform the probe"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"period_seconds\" <$> TF.attribute",
                    "name": "_periodSeconds",
                    "method": "periodSeconds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasPeriodSeconds",
                    "validate": false,
                    "optional": true,
                    "original": "period_seconds"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Minimum consecutive successes for the probe to be considered successful",
                        "after having failed."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"success_threshold\" <$> TF.attribute",
                    "name": "_successThreshold",
                    "method": "successThreshold",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasSuccessThreshold",
                    "validate": false,
                    "optional": true,
                    "original": "success_threshold"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "TCPSocket specifies an action involving a TCP port. TCP hooks not yet",
                        "supported"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tcp_socket\" <$> TF.attribute",
                    "name": "_tcpSocket",
                    "method": "tcpSocket",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (PodSpecInitContainerReadinessProbeTcpSocketSetting s)]",
                    "class": "HasTcpSocket",
                    "validate": false,
                    "optional": true,
                    "original": "tcp_socket"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Number of seconds after which the probe times out. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"timeout_seconds\" <$> TF.attribute",
                    "name": "_timeoutSeconds",
                    "method": "timeoutSeconds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasTimeoutSeconds",
                    "validate": false,
                    "optional": true,
                    "original": "timeout_seconds"
                }
            ],
            "dependencies": [
                "PodSpecInitContainerReadinessProbeExecSetting",
                "PodSpecInitContainerReadinessProbeHttpGetSetting",
                "PodSpecInitContainerReadinessProbeTcpSocketSetting"
            ],
            "key": "pod.spec.init_container.readiness_probe",
            "name": "PodSpecInitContainerReadinessProbeSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecInitContainerReadinessProbeSetting s",
            "original": "readiness_probe"
        },
        {
            "con": {
                "smart": "newPodSpecInitContainerReadinessProbeTcpSocketSetting",
                "name": "PodSpecInitContainerReadinessProbeTcpSocketSetting'"
            },
            "arguments": [
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number or name of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.init_container.readiness_probe.tcp_socket",
            "name": "PodSpecInitContainerReadinessProbeTcpSocketSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number or name of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                }
            ],
            "conflicts": [],
            "type": "PodSpecInitContainerReadinessProbeTcpSocketSetting s",
            "original": "tcp_socket"
        },
        {
            "con": {
                "smart": "newPodSpecInitContainerResourcesLimitsSetting",
                "name": "PodSpecInitContainerResourcesLimitsSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu\" <$> TF.attribute",
                    "name": "_cpu",
                    "method": "cpu",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasCpu",
                    "validate": false,
                    "optional": true,
                    "original": "cpu"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory\" <$> TF.attribute",
                    "name": "_memory",
                    "method": "memory",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasMemory",
                    "validate": false,
                    "optional": true,
                    "original": "memory"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.init_container.resources.limits",
            "name": "PodSpecInitContainerResourcesLimitsSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu\" <$> TF.attribute",
                    "name": "_computedCpu",
                    "method": "computedCpu",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedCpu",
                    "validate": false,
                    "optional": false,
                    "original": "cpu"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory\" <$> TF.attribute",
                    "name": "_computedMemory",
                    "method": "computedMemory",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedMemory",
                    "validate": false,
                    "optional": false,
                    "original": "memory"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecInitContainerResourcesLimitsSetting s",
            "original": "limits"
        },
        {
            "con": {
                "smart": "newPodSpecInitContainerResourcesRequestsSetting",
                "name": "PodSpecInitContainerResourcesRequestsSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu\" <$> TF.attribute",
                    "name": "_cpu",
                    "method": "cpu",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasCpu",
                    "validate": false,
                    "optional": true,
                    "original": "cpu"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory\" <$> TF.attribute",
                    "name": "_memory",
                    "method": "memory",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasMemory",
                    "validate": false,
                    "optional": true,
                    "original": "memory"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.init_container.resources.requests",
            "name": "PodSpecInitContainerResourcesRequestsSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu\" <$> TF.attribute",
                    "name": "_computedCpu",
                    "method": "computedCpu",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedCpu",
                    "validate": false,
                    "optional": false,
                    "original": "cpu"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory\" <$> TF.attribute",
                    "name": "_computedMemory",
                    "method": "computedMemory",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedMemory",
                    "validate": false,
                    "optional": false,
                    "original": "memory"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecInitContainerResourcesRequestsSetting s",
            "original": "requests"
        },
        {
            "con": {
                "smart": "newPodSpecInitContainerResourcesSetting",
                "name": "PodSpecInitContainerResourcesSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Describes the maximum amount of compute resources allowed. More info:",
                        "http://kubernetes.io/docs/user-guide/compute-resources/"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"limits\" <$> TF.attribute",
                    "name": "_limits",
                    "method": "limits",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecInitContainerResourcesLimitsSetting s)",
                    "class": "HasLimits",
                    "validate": true,
                    "optional": true,
                    "original": "limits"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"requests\" <$> TF.attribute",
                    "name": "_requests",
                    "method": "requests",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecInitContainerResourcesRequestsSetting s)",
                    "class": "HasRequests",
                    "validate": true,
                    "optional": true,
                    "original": "requests"
                }
            ],
            "dependencies": [
                "PodSpecInitContainerResourcesLimitsSetting",
                "PodSpecInitContainerResourcesRequestsSetting",
                "PodSpecInitContainerResourcesLimitsSetting",
                "PodSpecInitContainerResourcesRequestsSetting"
            ],
            "key": "pod.spec.init_container.resources",
            "name": "PodSpecInitContainerResourcesSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Describes the maximum amount of compute resources allowed. More info:",
                        "http://kubernetes.io/docs/user-guide/compute-resources/"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"limits\" <$> TF.attribute",
                    "name": "_computedLimits",
                    "method": "computedLimits",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecInitContainerResourcesLimitsSetting s)",
                    "class": "HasComputedLimits",
                    "validate": true,
                    "optional": false,
                    "original": "limits"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"requests\" <$> TF.attribute",
                    "name": "_computedRequests",
                    "method": "computedRequests",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecInitContainerResourcesRequestsSetting s)",
                    "class": "HasComputedRequests",
                    "validate": true,
                    "optional": false,
                    "original": "requests"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecInitContainerResourcesSetting s",
            "original": "resources"
        },
        {
            "con": {
                "smart": "newPodSpecInitContainerSecurityContextCapabilitiesSetting",
                "name": "PodSpecInitContainerSecurityContextCapabilitiesSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Added capabilities"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"add\" <$> TF.attribute",
                    "name": "_add",
                    "method": "add",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasAdd",
                    "validate": false,
                    "optional": true,
                    "original": "add"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Removed capabilities"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"drop\" <$> TF.attribute",
                    "name": "_drop",
                    "method": "drop",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasDrop",
                    "validate": false,
                    "optional": true,
                    "original": "drop"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.init_container.security_context.capabilities",
            "name": "PodSpecInitContainerSecurityContextCapabilitiesSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecInitContainerSecurityContextCapabilitiesSetting s",
            "original": "capabilities"
        },
        {
            "con": {
                "smart": "newPodSpecInitContainerSecurityContextSeLinuxOptionsSetting",
                "name": "PodSpecInitContainerSecurityContextSeLinuxOptionsSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Level is SELinux level label that applies to the container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"level\" <$> TF.attribute",
                    "name": "_level",
                    "method": "level",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasLevel",
                    "validate": false,
                    "optional": true,
                    "original": "level"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Role is a SELinux role label that applies to the container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"role\" <$> TF.attribute",
                    "name": "_role",
                    "method": "role",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRole",
                    "validate": false,
                    "optional": true,
                    "original": "role"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Type is a SELinux type label that applies to the container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"type\" <$> TF.attribute",
                    "name": "_type'",
                    "method": "type'",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasType'",
                    "validate": false,
                    "optional": true,
                    "original": "type"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "User is a SELinux user label that applies to the container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"user\" <$> TF.attribute",
                    "name": "_user",
                    "method": "user",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasUser",
                    "validate": false,
                    "optional": true,
                    "original": "user"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.init_container.security_context.se_linux_options",
            "name": "PodSpecInitContainerSecurityContextSeLinuxOptionsSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecInitContainerSecurityContextSeLinuxOptionsSetting s",
            "original": "se_linux_options"
        },
        {
            "con": {
                "smart": "newPodSpecInitContainerSecurityContextSetting",
                "name": "PodSpecInitContainerSecurityContextSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The capabilities to add/drop when running containers. Defaults to the",
                        "default set of capabilities granted by the container runtime."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"capabilities\" <$> TF.attribute",
                    "name": "_capabilities",
                    "method": "capabilities",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecInitContainerSecurityContextCapabilitiesSetting s)",
                    "class": "HasCapabilities",
                    "validate": true,
                    "optional": true,
                    "original": "capabilities"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Run container in privileged mode. Processes in privileged containers are",
                        "essentially equivalent to root on the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"privileged\" <$> TF.attribute",
                    "name": "_privileged",
                    "method": "privileged",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasPrivileged",
                    "validate": false,
                    "optional": true,
                    "original": "privileged"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether this container has a read-only root filesystem."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only_root_filesystem\" <$> TF.attribute",
                    "name": "_readOnlyRootFilesystem",
                    "method": "readOnlyRootFilesystem",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnlyRootFilesystem",
                    "validate": false,
                    "optional": true,
                    "original": "read_only_root_filesystem"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Indicates that the container must run as a non-root user. If true, the",
                        "Kubelet will validate the image at runtime to ensure that it does not run as",
                        "UID 0 (root) and fail to start the container if it does."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"run_as_non_root\" <$> TF.attribute",
                    "name": "_runAsNonRoot",
                    "method": "runAsNonRoot",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasRunAsNonRoot",
                    "validate": false,
                    "optional": true,
                    "original": "run_as_non_root"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The UID to run the entrypoint of the container process. Defaults to user",
                        "specified in image metadata if unspecified"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"run_as_user\" <$> TF.attribute",
                    "name": "_runAsUser",
                    "method": "runAsUser",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasRunAsUser",
                    "validate": false,
                    "optional": true,
                    "original": "run_as_user"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "ImagePullSecrets is an optional list of references to secrets in the same",
                        "namespace to use for pulling any of the images used by this PodSpec. If",
                        "specified, these secrets will be passed to individual puller implementations",
                        "for them to use. For example, in the case of docker, only DockerConfig type",
                        "secrets are honored. More info:",
                        "http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"se_linux_options\" <$> TF.attribute",
                    "name": "_seLinuxOptions",
                    "method": "seLinuxOptions",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecInitContainerSecurityContextSeLinuxOptionsSetting s)",
                    "class": "HasSeLinuxOptions",
                    "validate": true,
                    "optional": true,
                    "original": "se_linux_options"
                }
            ],
            "dependencies": [
                "PodSpecInitContainerSecurityContextCapabilitiesSetting",
                "PodSpecInitContainerSecurityContextSeLinuxOptionsSetting"
            ],
            "key": "pod.spec.init_container.security_context",
            "name": "PodSpecInitContainerSecurityContextSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecInitContainerSecurityContextSetting s",
            "original": "security_context"
        },
        {
            "con": {
                "smart": "newPodSpecInitContainerSetting",
                "name": "PodSpecInitContainerSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Arguments to the entrypoint. The docker image's CMD is used if this is not",
                        "provided. Variable references $(VAR_NAME) are expanded using the container's",
                        "environment. If a variable cannot be resolved, the reference in the input",
                        "string will be unchanged. The $(VAR_NAME) syntax can be escaped with a",
                        "double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,",
                        "regardless of whether the variable exists or not. Cannot be updated. More",
                        "info:",
                        "http://kubernetes.io/docs/user-guide/containers#containers-and-commands"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"args\" <$> TF.attribute",
                    "name": "_args",
                    "method": "args",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasArgs",
                    "validate": false,
                    "optional": true,
                    "original": "args"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT",
                        "is used if this is not provided. Variable references $(VAR_NAME) are",
                        "expanded using the container's environment. If a variable cannot be",
                        "resolved, the reference in the input string will be unchanged. The",
                        "$(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).",
                        "Escaped references will never be expanded, regardless of whether the",
                        "variable exists or not. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/containers#containers-and-commands"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"command\" <$> TF.attribute",
                    "name": "_command",
                    "method": "command",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCommand",
                    "validate": false,
                    "optional": true,
                    "original": "command"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of environment variables to set in the container. Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"env\" <$> TF.attribute",
                    "name": "_env",
                    "method": "env",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (PodSpecInitContainerEnvSetting s)]",
                    "class": "HasEnv",
                    "validate": false,
                    "optional": true,
                    "original": "env"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Docker image name. More info: http://kubernetes.io/docs/user-guide/images"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"image\" <$> TF.attribute",
                    "name": "_image",
                    "method": "image",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasImage",
                    "validate": false,
                    "optional": true,
                    "original": "image"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if",
                        ":latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More",
                        "info: http://kubernetes.io/docs/user-guide/images#updating-images"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"image_pull_policy\" <$> TF.attribute",
                    "name": "_imagePullPolicy",
                    "method": "imagePullPolicy",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasImagePullPolicy",
                    "validate": false,
                    "optional": true,
                    "original": "image_pull_policy"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Actions that the management system should take in response to container",
                        "lifecycle events"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"lifecycle\" <$> TF.attribute",
                    "name": "_lifecycle",
                    "method": "lifecycle",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecInitContainerLifecycleSetting s)",
                    "class": "HasLifecycle",
                    "validate": true,
                    "optional": true,
                    "original": "lifecycle"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Periodic probe of container liveness. Container will be restarted if the",
                        "probe fails. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"liveness_probe\" <$> TF.attribute",
                    "name": "_livenessProbe",
                    "method": "livenessProbe",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecInitContainerLivenessProbeSetting s)",
                    "class": "HasLivenessProbe",
                    "validate": true,
                    "optional": true,
                    "original": "liveness_probe"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the container specified as a DNS_LABEL. Each container in a pod must",
                        "have a unique name (DNS_LABEL). Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of ports to expose from the container. Exposing a port here gives the",
                        "system additional information about the network connections a container",
                        "uses, but is primarily informational. Not specifying a port here DOES NOT",
                        "prevent that port from being exposed. Any port which is listening on the",
                        "default \"0.0.0.0\" address inside a container will be accessible from the",
                        "network. Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (PodSpecInitContainerPortSetting s)]",
                    "class": "HasPort",
                    "validate": false,
                    "optional": true,
                    "original": "port"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Periodic probe of container service readiness. Container will be removed",
                        "from service endpoints if the probe fails. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"readiness_probe\" <$> TF.attribute",
                    "name": "_readinessProbe",
                    "method": "readinessProbe",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecInitContainerReadinessProbeSetting s)",
                    "class": "HasReadinessProbe",
                    "validate": true,
                    "optional": true,
                    "original": "readiness_probe"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Compute Resources required by this container. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#resources"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"resources\" <$> TF.attribute",
                    "name": "_resources",
                    "method": "resources",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecInitContainerResourcesSetting s)",
                    "class": "HasResources",
                    "validate": true,
                    "optional": true,
                    "original": "resources"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Security options the pod should run with. More info:",
                        "http://releases.k8s.io/HEAD/docs/design/security_context.md"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"security_context\" <$> TF.attribute",
                    "name": "_securityContext",
                    "method": "securityContext",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecInitContainerSecurityContextSetting s)",
                    "class": "HasSecurityContext",
                    "validate": true,
                    "optional": true,
                    "original": "security_context"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether this container should allocate a buffer for stdin in the container",
                        "runtime. If this is not set, reads from stdin in the container will always",
                        "result in EOF."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"stdin\" <$> TF.attribute",
                    "name": "_stdin",
                    "method": "stdin",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasStdin",
                    "validate": false,
                    "optional": true,
                    "original": "stdin"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether the container runtime should close the stdin channel after it has",
                        "been opened by a single attach. When stdin is true the stdin stream will",
                        "remain open across multiple attach sessions. If stdinOnce is set to true,",
                        "stdin is opened on container start, is empty until the first client attaches",
                        "to stdin, and then remains open and accepts data until the client",
                        "disconnects, at which time stdin is closed and remains closed until the",
                        "container is restarted. If this flag is false, a container processes that",
                        "reads from stdin will never receive an EOF."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"stdin_once\" <$> TF.attribute",
                    "name": "_stdinOnce",
                    "method": "stdinOnce",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasStdinOnce",
                    "validate": false,
                    "optional": true,
                    "original": "stdin_once"
                },
                {
                    "default": "TF.value \"/dev/termination-log\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional: Path at which the file to which the container's termination",
                        "message will be written is mounted into the container's filesystem. Message",
                        "written is intended to be brief final status, such as an assertion failure",
                        "message. Defaults to /dev/termination-log. Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"termination_message_path\" <$> TF.attribute",
                    "name": "_terminationMessagePath",
                    "method": "terminationMessagePath",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasTerminationMessagePath",
                    "validate": false,
                    "optional": true,
                    "original": "termination_message_path"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether this container should allocate a TTY for itself"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"tty\" <$> TF.attribute",
                    "name": "_tty",
                    "method": "tty",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasTty",
                    "validate": false,
                    "optional": true,
                    "original": "tty"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Pod volumes to mount into the container's filesystem. Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"volume_mount\" <$> TF.attribute",
                    "name": "_volumeMount",
                    "method": "volumeMount",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (PodSpecInitContainerVolumeMountSetting s)]",
                    "class": "HasVolumeMount",
                    "validate": false,
                    "optional": true,
                    "original": "volume_mount"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Container's working directory. If not specified, the container runtime's",
                        "default will be used, which might be configured in the container image.",
                        "Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"working_dir\" <$> TF.attribute",
                    "name": "_workingDir",
                    "method": "workingDir",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasWorkingDir",
                    "validate": false,
                    "optional": true,
                    "original": "working_dir"
                }
            ],
            "dependencies": [
                "PodSpecInitContainerEnvSetting",
                "PodSpecInitContainerLifecycleSetting",
                "PodSpecInitContainerLivenessProbeSetting",
                "PodSpecInitContainerPortSetting",
                "PodSpecInitContainerReadinessProbeSetting",
                "PodSpecInitContainerResourcesSetting",
                "PodSpecInitContainerSecurityContextSetting",
                "PodSpecInitContainerVolumeMountSetting",
                "PodSpecInitContainerResourcesSetting"
            ],
            "key": "pod.spec.init_container",
            "name": "PodSpecInitContainerSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if",
                        ":latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More",
                        "info: http://kubernetes.io/docs/user-guide/images#updating-images"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"image_pull_policy\" <$> TF.attribute",
                    "name": "_computedImagePullPolicy",
                    "method": "computedImagePullPolicy",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedImagePullPolicy",
                    "validate": false,
                    "optional": false,
                    "original": "image_pull_policy"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Compute Resources required by this container. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#resources"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"resources\" <$> TF.attribute",
                    "name": "_computedResources",
                    "method": "computedResources",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecInitContainerResourcesSetting s)",
                    "class": "HasComputedResources",
                    "validate": true,
                    "optional": false,
                    "original": "resources"
                }
            ],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the container specified as a DNS_LABEL. Each container in a pod must",
                        "have a unique name (DNS_LABEL). Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "PodSpecInitContainerSetting s",
            "original": "init_container"
        },
        {
            "con": {
                "smart": "newPodSpecInitContainerVolumeMountSetting",
                "name": "PodSpecInitContainerVolumeMountSetting'"
            },
            "arguments": [
                {
                    "default": "_mountPath",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path within the container at which the volume should be mounted. Must not",
                        "contain ':'."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"mount_path\" <$> TF.attribute",
                    "name": "_mountPath",
                    "method": "mountPath",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasMountPath",
                    "validate": false,
                    "optional": false,
                    "original": "mount_path"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "This must match the Name of a Volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Mounted read-only if true, read-write otherwise (false or unspecified).",
                        "Defaults to false."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path within the volume from which the container's volume should be mounted.",
                        "Defaults to \"\" (volume's root)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sub_path\" <$> TF.attribute",
                    "name": "_subPath",
                    "method": "subPath",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSubPath",
                    "validate": false,
                    "optional": true,
                    "original": "sub_path"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.init_container.volume_mount",
            "name": "PodSpecInitContainerVolumeMountSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "This must match the Name of a Volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "_mountPath",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path within the container at which the volume should be mounted. Must not",
                        "contain ':'."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"mount_path\" <$> TF.attribute",
                    "name": "_mountPath",
                    "method": "mountPath",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasMountPath",
                    "validate": false,
                    "optional": false,
                    "original": "mount_path"
                }
            ],
            "conflicts": [],
            "type": "PodSpecInitContainerVolumeMountSetting s",
            "original": "volume_mount"
        },
        {
            "con": {
                "smart": "newPodSpecSecurityContextSeLinuxOptionsSetting",
                "name": "PodSpecSecurityContextSeLinuxOptionsSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Level is SELinux level label that applies to the container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"level\" <$> TF.attribute",
                    "name": "_level",
                    "method": "level",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasLevel",
                    "validate": false,
                    "optional": true,
                    "original": "level"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Role is a SELinux role label that applies to the container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"role\" <$> TF.attribute",
                    "name": "_role",
                    "method": "role",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRole",
                    "validate": false,
                    "optional": true,
                    "original": "role"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Type is a SELinux type label that applies to the container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"type\" <$> TF.attribute",
                    "name": "_type'",
                    "method": "type'",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasType'",
                    "validate": false,
                    "optional": true,
                    "original": "type"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "User is a SELinux user label that applies to the container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"user\" <$> TF.attribute",
                    "name": "_user",
                    "method": "user",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasUser",
                    "validate": false,
                    "optional": true,
                    "original": "user"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.security_context.se_linux_options",
            "name": "PodSpecSecurityContextSeLinuxOptionsSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecSecurityContextSeLinuxOptionsSetting s",
            "original": "se_linux_options"
        },
        {
            "con": {
                "smart": "newPodSpecSecurityContextSetting",
                "name": "PodSpecSecurityContextSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A special supplemental group that applies to all containers in a pod. Some",
                        "volume types allow the Kubelet to change the ownership of that volume to be",
                        "owned by the pod: 1. The owning GID will be the FSGroup 2. The setgid bit is",
                        "set (new files created in the volume will be owned by FSGroup) 3. The",
                        "permission bits are OR'd with rw-rw---- If unset, the Kubelet will not",
                        "modify the ownership and permissions of any volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_group\" <$> TF.attribute",
                    "name": "_fsGroup",
                    "method": "fsGroup",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasFsGroup",
                    "validate": false,
                    "optional": true,
                    "original": "fs_group"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Indicates that the container must run as a non-root user. If true, the",
                        "Kubelet will validate the image at runtime to ensure that it does not run as",
                        "UID 0 (root) and fail to start the container if it does."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"run_as_non_root\" <$> TF.attribute",
                    "name": "_runAsNonRoot",
                    "method": "runAsNonRoot",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasRunAsNonRoot",
                    "validate": false,
                    "optional": true,
                    "original": "run_as_non_root"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The UID to run the entrypoint of the container process. Defaults to user",
                        "specified in image metadata if unspecified"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"run_as_user\" <$> TF.attribute",
                    "name": "_runAsUser",
                    "method": "runAsUser",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasRunAsUser",
                    "validate": false,
                    "optional": true,
                    "original": "run_as_user"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The SELinux context to be applied to all containers. If unspecified, the",
                        "container runtime will allocate a random SELinux context for each container.",
                        "May also be set in SecurityContext. If set in both SecurityContext and",
                        "PodSecurityContext, the value specified in SecurityContext takes precedence",
                        "for that container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"se_linux_options\" <$> TF.attribute",
                    "name": "_seLinuxOptions",
                    "method": "seLinuxOptions",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecSecurityContextSeLinuxOptionsSetting s)",
                    "class": "HasSeLinuxOptions",
                    "validate": true,
                    "optional": true,
                    "original": "se_linux_options"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of groups applied to the first process run in each container, in",
                        "addition to the container's primary GID. If unspecified, no groups will be",
                        "added to any container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"supplemental_groups\" <$> TF.attribute",
                    "name": "_supplementalGroups",
                    "method": "supplementalGroups",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Int]",
                    "class": "HasSupplementalGroups",
                    "validate": false,
                    "optional": true,
                    "original": "supplemental_groups"
                }
            ],
            "dependencies": [
                "PodSpecSecurityContextSeLinuxOptionsSetting"
            ],
            "key": "pod.spec.security_context",
            "name": "PodSpecSecurityContextSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecSecurityContextSetting s",
            "original": "security_context"
        },
        {
            "con": {
                "smart": "newPodSpecSetting",
                "name": "PodSpecSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional duration in seconds the pod may be active on the node relative to",
                        "StartTime before the system will actively try to mark it failed and kill",
                        "associated containers. Value must be a positive integer."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"active_deadline_seconds\" <$> TF.attribute",
                    "name": "_activeDeadlineSeconds",
                    "method": "activeDeadlineSeconds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasActiveDeadlineSeconds",
                    "validate": false,
                    "optional": true,
                    "original": "active_deadline_seconds"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of containers belonging to the pod. Containers cannot currently be",
                        "added or removed. There must be at least one container in a Pod. Cannot be",
                        "updated. More info: http://kubernetes.io/docs/user-guide/containers"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"container\" <$> TF.attribute",
                    "name": "_container",
                    "method": "container",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (PodSpecContainerSetting s)]",
                    "class": "HasContainer",
                    "validate": false,
                    "optional": true,
                    "original": "container"
                },
                {
                    "default": "TF.value \"ClusterFirst\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Set DNS policy for containers within the pod. One of 'ClusterFirst' or",
                        "'Default'. Defaults to 'ClusterFirst'."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"dns_policy\" <$> TF.attribute",
                    "name": "_dnsPolicy",
                    "method": "dnsPolicy",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDnsPolicy",
                    "validate": false,
                    "optional": true,
                    "original": "dns_policy"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Use the host's ipc namespace. Optional: Default to false."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"host_ipc\" <$> TF.attribute",
                    "name": "_hostIpc",
                    "method": "hostIpc",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasHostIpc",
                    "validate": false,
                    "optional": true,
                    "original": "host_ipc"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Host networking requested for this pod. Use the host's network namespace. If",
                        "this option is set, the ports that will be used must be specified."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"host_network\" <$> TF.attribute",
                    "name": "_hostNetwork",
                    "method": "hostNetwork",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasHostNetwork",
                    "validate": false,
                    "optional": true,
                    "original": "host_network"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Use the host's pid namespace."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"host_pid\" <$> TF.attribute",
                    "name": "_hostPid",
                    "method": "hostPid",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasHostPid",
                    "validate": false,
                    "optional": true,
                    "original": "host_pid"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Specifies the hostname of the Pod If not specified, the pod's hostname will",
                        "be set to a system-defined value."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"hostname\" <$> TF.attribute",
                    "name": "_hostname",
                    "method": "hostname",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHostname",
                    "validate": false,
                    "optional": true,
                    "original": "hostname"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "ImagePullSecrets is an optional list of references to secrets in the same",
                        "namespace to use for pulling any of the images used by this PodSpec. If",
                        "specified, these secrets will be passed to individual puller implementations",
                        "for them to use. For example, in the case of docker, only DockerConfig type",
                        "secrets are honored. More info:",
                        "http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"image_pull_secrets\" <$> TF.attribute",
                    "name": "_imagePullSecrets",
                    "method": "imagePullSecrets",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (PodSpecImagePullSecretsSetting s)]",
                    "class": "HasImagePullSecrets",
                    "validate": false,
                    "optional": true,
                    "original": "image_pull_secrets"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of init containers belonging to the pod. Init containers always run to",
                        "completion and each must complete succesfully before the next is started.",
                        "More info:",
                        "https://kubernetes.io/docs/concepts/workloads/pods/init-containers/"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"init_container\" <$> TF.attribute",
                    "name": "_initContainer",
                    "method": "initContainer",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (PodSpecInitContainerSetting s)]",
                    "class": "HasInitContainer",
                    "validate": false,
                    "optional": true,
                    "original": "init_container"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "NodeName is a request to schedule this pod onto a specific node. If it is",
                        "non-empty, the scheduler simply schedules this pod onto that node, assuming",
                        "that it fits resource requirements."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"node_name\" <$> TF.attribute",
                    "name": "_nodeName",
                    "method": "nodeName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasNodeName",
                    "validate": false,
                    "optional": true,
                    "original": "node_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "NodeSelector is a selector which must be true for the pod to fit on a node.",
                        "Selector which must match a node's labels for the pod to be scheduled on",
                        "that node. More info: http://kubernetes.io/docs/user-guide/node-selection."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"node_selector\" <$> TF.attribute",
                    "name": "_nodeSelector",
                    "method": "nodeSelector",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasNodeSelector",
                    "validate": false,
                    "optional": true,
                    "original": "node_selector"
                },
                {
                    "default": "TF.value \"Always\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Restart policy for all containers within the pod. One of Always, OnFailure,",
                        "Never. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#restartpolicy."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"restart_policy\" <$> TF.attribute",
                    "name": "_restartPolicy",
                    "method": "restartPolicy",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRestartPolicy",
                    "validate": false,
                    "optional": true,
                    "original": "restart_policy"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "SecurityContext holds pod-level security attributes and common container",
                        "settings. Optional: Defaults to empty"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"security_context\" <$> TF.attribute",
                    "name": "_securityContext",
                    "method": "securityContext",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecSecurityContextSetting s)",
                    "class": "HasSecurityContext",
                    "validate": true,
                    "optional": true,
                    "original": "security_context"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "ServiceAccountName is the name of the ServiceAccount to use to run this pod.",
                        "More info: http://releases.k8s.io/HEAD/docs/design/service_accounts.md."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"service_account_name\" <$> TF.attribute",
                    "name": "_serviceAccountName",
                    "method": "serviceAccountName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasServiceAccountName",
                    "validate": false,
                    "optional": true,
                    "original": "service_account_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If specified, the fully qualified Pod hostname will be \"...svc.\". If not",
                        "specified, the pod will not have a domainname at all.."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"subdomain\" <$> TF.attribute",
                    "name": "_subdomain",
                    "method": "subdomain",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSubdomain",
                    "validate": false,
                    "optional": true,
                    "original": "subdomain"
                },
                {
                    "default": "TF.value 30",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional duration in seconds the pod needs to terminate gracefully. May be",
                        "decreased in delete request. Value must be non-negative integer. The value",
                        "zero indicates delete immediately. If this value is nil, the default grace",
                        "period will be used instead. The grace period is the duration in seconds",
                        "after the processes running in the pod are sent a termination signal and the",
                        "time when the processes are forcibly halted with a kill signal. Set this",
                        "value longer than the expected cleanup time for your process."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"termination_grace_period_seconds\" <$> TF.attribute",
                    "name": "_terminationGracePeriodSeconds",
                    "method": "terminationGracePeriodSeconds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasTerminationGracePeriodSeconds",
                    "validate": false,
                    "optional": true,
                    "original": "termination_grace_period_seconds"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of volumes that can be mounted by containers belonging to the pod. More",
                        "info: http://kubernetes.io/docs/user-guide/volumes"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"volume\" <$> TF.attribute",
                    "name": "_volume",
                    "method": "volume",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (PodSpecVolumeSetting s)]",
                    "class": "HasVolume",
                    "validate": false,
                    "optional": true,
                    "original": "volume"
                }
            ],
            "dependencies": [
                "PodSpecContainerSetting",
                "PodSpecImagePullSecretsSetting",
                "PodSpecInitContainerSetting",
                "PodSpecSecurityContextSetting",
                "PodSpecVolumeSetting",
                "PodSpecImagePullSecretsSetting"
            ],
            "key": "pod.spec",
            "name": "PodSpecSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Specifies the hostname of the Pod If not specified, the pod's hostname will",
                        "be set to a system-defined value."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"hostname\" <$> TF.attribute",
                    "name": "_computedHostname",
                    "method": "computedHostname",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedHostname",
                    "validate": false,
                    "optional": false,
                    "original": "hostname"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "ImagePullSecrets is an optional list of references to secrets in the same",
                        "namespace to use for pulling any of the images used by this PodSpec. If",
                        "specified, these secrets will be passed to individual puller implementations",
                        "for them to use. For example, in the case of docker, only DockerConfig type",
                        "secrets are honored. More info:",
                        "http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"image_pull_secrets\" <$> TF.attribute",
                    "name": "_computedImagePullSecrets",
                    "method": "computedImagePullSecrets",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (PodSpecImagePullSecretsSetting s)]",
                    "class": "HasComputedImagePullSecrets",
                    "validate": false,
                    "optional": false,
                    "original": "image_pull_secrets"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "NodeName is a request to schedule this pod onto a specific node. If it is",
                        "non-empty, the scheduler simply schedules this pod onto that node, assuming",
                        "that it fits resource requirements."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"node_name\" <$> TF.attribute",
                    "name": "_computedNodeName",
                    "method": "computedNodeName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedNodeName",
                    "validate": false,
                    "optional": false,
                    "original": "node_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "ServiceAccountName is the name of the ServiceAccount to use to run this pod.",
                        "More info: http://releases.k8s.io/HEAD/docs/design/service_accounts.md."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"service_account_name\" <$> TF.attribute",
                    "name": "_computedServiceAccountName",
                    "method": "computedServiceAccountName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedServiceAccountName",
                    "validate": false,
                    "optional": false,
                    "original": "service_account_name"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecSetting s",
            "original": "spec"
        },
        {
            "con": {
                "smart": "newPodSpecVolumeAwsElasticBlockStoreSetting",
                "name": "PodSpecVolumeAwsElasticBlockStoreSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type of the volume that you want to mount. Tip: Ensure that the",
                        "filesystem type is supported by the host operating system. Examples: \"ext4\",",
                        "\"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The partition in the volume that you want to mount. If omitted, the default",
                        "is to mount by volume name. Examples: For volume /dev/sda1, you specify the",
                        "partition as \"1\". Similarly, the volume partition for /dev/sda is \"0\" (or",
                        "you can leave the property empty)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"partition\" <$> TF.attribute",
                    "name": "_partition",
                    "method": "partition",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasPartition",
                    "validate": false,
                    "optional": true,
                    "original": "partition"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to set the read-only property in VolumeMounts to \"true\". If omitted,",
                        "the default is \"false\". More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_volumeId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More",
                        "info: http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_id\" <$> TF.attribute",
                    "name": "_volumeId",
                    "method": "volumeId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumeId",
                    "validate": false,
                    "optional": false,
                    "original": "volume_id"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.volume.aws_elastic_block_store",
            "name": "PodSpecVolumeAwsElasticBlockStoreSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_volumeId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More",
                        "info: http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_id\" <$> TF.attribute",
                    "name": "_volumeId",
                    "method": "volumeId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumeId",
                    "validate": false,
                    "optional": false,
                    "original": "volume_id"
                }
            ],
            "conflicts": [],
            "type": "PodSpecVolumeAwsElasticBlockStoreSetting s",
            "original": "aws_elastic_block_store"
        },
        {
            "con": {
                "smart": "newPodSpecVolumeAzureDiskSetting",
                "name": "PodSpecVolumeAzureDiskSetting'"
            },
            "arguments": [
                {
                    "default": "_cachingMode",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Host Caching mode: None, Read Only, Read Write."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"caching_mode\" <$> TF.attribute",
                    "name": "_cachingMode",
                    "method": "cachingMode",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasCachingMode",
                    "validate": false,
                    "optional": false,
                    "original": "caching_mode"
                },
                {
                    "default": "_dataDiskUri",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The URI the data disk in the blob storage"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"data_disk_uri\" <$> TF.attribute",
                    "name": "_dataDiskUri",
                    "method": "dataDiskUri",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDataDiskUri",
                    "validate": false,
                    "optional": false,
                    "original": "data_disk_uri"
                },
                {
                    "default": "_diskName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The Name of the data disk in the blob storage"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"disk_name\" <$> TF.attribute",
                    "name": "_diskName",
                    "method": "diskName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDiskName",
                    "validate": false,
                    "optional": false,
                    "original": "disk_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type to mount. Must be a filesystem type supported by the host",
                        "operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be",
                        "\"ext4\" if unspecified."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to false",
                        "(read/write)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.volume.azure_disk",
            "name": "PodSpecVolumeAzureDiskSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_cachingMode",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Host Caching mode: None, Read Only, Read Write."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"caching_mode\" <$> TF.attribute",
                    "name": "_cachingMode",
                    "method": "cachingMode",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasCachingMode",
                    "validate": false,
                    "optional": false,
                    "original": "caching_mode"
                },
                {
                    "default": "_diskName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The Name of the data disk in the blob storage"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"disk_name\" <$> TF.attribute",
                    "name": "_diskName",
                    "method": "diskName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDiskName",
                    "validate": false,
                    "optional": false,
                    "original": "disk_name"
                },
                {
                    "default": "_dataDiskUri",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The URI the data disk in the blob storage"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"data_disk_uri\" <$> TF.attribute",
                    "name": "_dataDiskUri",
                    "method": "dataDiskUri",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDataDiskUri",
                    "validate": false,
                    "optional": false,
                    "original": "data_disk_uri"
                }
            ],
            "conflicts": [],
            "type": "PodSpecVolumeAzureDiskSetting s",
            "original": "azure_disk"
        },
        {
            "con": {
                "smart": "newPodSpecVolumeAzureFileSetting",
                "name": "PodSpecVolumeAzureFileSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to false",
                        "(read/write)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_secretName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of secret that contains Azure Storage Account Name and Key"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_name\" <$> TF.attribute",
                    "name": "_secretName",
                    "method": "secretName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSecretName",
                    "validate": false,
                    "optional": false,
                    "original": "secret_name"
                },
                {
                    "default": "_shareName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Share Name"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"share_name\" <$> TF.attribute",
                    "name": "_shareName",
                    "method": "shareName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasShareName",
                    "validate": false,
                    "optional": false,
                    "original": "share_name"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.volume.azure_file",
            "name": "PodSpecVolumeAzureFileSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_secretName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of secret that contains Azure Storage Account Name and Key"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_name\" <$> TF.attribute",
                    "name": "_secretName",
                    "method": "secretName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSecretName",
                    "validate": false,
                    "optional": false,
                    "original": "secret_name"
                },
                {
                    "default": "_shareName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Share Name"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"share_name\" <$> TF.attribute",
                    "name": "_shareName",
                    "method": "shareName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasShareName",
                    "validate": false,
                    "optional": false,
                    "original": "share_name"
                }
            ],
            "conflicts": [],
            "type": "PodSpecVolumeAzureFileSetting s",
            "original": "azure_file"
        },
        {
            "con": {
                "smart": "newPodSpecVolumeCephFsSecretRefSetting",
                "name": "PodSpecVolumeCephFsSecretRefSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.volume.ceph_fs.secret_ref",
            "name": "PodSpecVolumeCephFsSecretRefSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecVolumeCephFsSecretRefSetting s",
            "original": "secret_ref"
        },
        {
            "con": {
                "smart": "newPodSpecVolumeCephFsSetting",
                "name": "PodSpecVolumeCephFsSetting'"
            },
            "arguments": [
                {
                    "default": "_monitors",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Monitors is a collection of Ceph monitors More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"monitors\" <$> TF.attribute",
                    "name": "_monitors",
                    "method": "monitors",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasMonitors",
                    "validate": false,
                    "optional": false,
                    "original": "monitors"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Used as the mounted root, rather than the full Ceph tree, default is /"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": true,
                    "original": "path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to `false`",
                        "(read/write). More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The path to key ring for User, default is /etc/ceph/user.secret More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_file\" <$> TF.attribute",
                    "name": "_secretFile",
                    "method": "secretFile",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSecretFile",
                    "validate": false,
                    "optional": true,
                    "original": "secret_file"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Reference to the authentication secret for User, default is empty. More",
                        "info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_ref\" <$> TF.attribute",
                    "name": "_secretRef",
                    "method": "secretRef",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecVolumeCephFsSecretRefSetting s)",
                    "class": "HasSecretRef",
                    "validate": true,
                    "optional": true,
                    "original": "secret_ref"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "User is the rados user name, default is admin. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"user\" <$> TF.attribute",
                    "name": "_user",
                    "method": "user",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasUser",
                    "validate": false,
                    "optional": true,
                    "original": "user"
                }
            ],
            "dependencies": [
                "PodSpecVolumeCephFsSecretRefSetting"
            ],
            "key": "pod.spec.volume.ceph_fs",
            "name": "PodSpecVolumeCephFsSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_monitors",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Monitors is a collection of Ceph monitors More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"monitors\" <$> TF.attribute",
                    "name": "_monitors",
                    "method": "monitors",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasMonitors",
                    "validate": false,
                    "optional": false,
                    "original": "monitors"
                }
            ],
            "conflicts": [],
            "type": "PodSpecVolumeCephFsSetting s",
            "original": "ceph_fs"
        },
        {
            "con": {
                "smart": "newPodSpecVolumeCinderSetting",
                "name": "PodSpecVolumeCinderSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type to mount. Must be a filesystem type supported by the host",
                        "operating system. Examples: \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be",
                        "\"ext4\" if unspecified. More info:",
                        "http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to false",
                        "(read/write). More info:",
                        "http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_volumeId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Volume ID used to identify the volume in Cinder. More info:",
                        "http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_id\" <$> TF.attribute",
                    "name": "_volumeId",
                    "method": "volumeId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumeId",
                    "validate": false,
                    "optional": false,
                    "original": "volume_id"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.volume.cinder",
            "name": "PodSpecVolumeCinderSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_volumeId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Volume ID used to identify the volume in Cinder. More info:",
                        "http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_id\" <$> TF.attribute",
                    "name": "_volumeId",
                    "method": "volumeId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumeId",
                    "validate": false,
                    "optional": false,
                    "original": "volume_id"
                }
            ],
            "conflicts": [],
            "type": "PodSpecVolumeCinderSetting s",
            "original": "cinder"
        },
        {
            "con": {
                "smart": "newPodSpecVolumeConfigMapItemsSetting",
                "name": "PodSpecVolumeConfigMapItemsSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The key to project."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"key\" <$> TF.attribute",
                    "name": "_key",
                    "method": "key",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasKey",
                    "validate": false,
                    "optional": true,
                    "original": "key"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional: mode bits to use on this file, must be a value between 0 and 0777.",
                        "If not specified, the volume defaultMode will be used. This might be in",
                        "conflict with other options that affect the file mode, like fsGroup, and the",
                        "result can be other mode bits set."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"mode\" <$> TF.attribute",
                    "name": "_mode",
                    "method": "mode",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasMode",
                    "validate": false,
                    "optional": true,
                    "original": "mode"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The relative path of the file to map the key to. May not be an absolute",
                        "path. May not contain the path element '..'. May not start with the string",
                        "'..'."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": true,
                    "original": "path"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.volume.config_map.items",
            "name": "PodSpecVolumeConfigMapItemsSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecVolumeConfigMapItemsSetting s",
            "original": "items"
        },
        {
            "con": {
                "smart": "newPodSpecVolumeConfigMapSetting",
                "name": "PodSpecVolumeConfigMapSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional: mode bits to use on created files by default. Must be a value",
                        "between 0 and 0777. Defaults to 0644. Directories within the path are not",
                        "affected by this setting. This might be in conflict with other options that",
                        "affect the file mode, like fsGroup, and the result can be other mode bits",
                        "set."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"default_mode\" <$> TF.attribute",
                    "name": "_defaultMode",
                    "method": "defaultMode",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasDefaultMode",
                    "validate": false,
                    "optional": true,
                    "original": "default_mode"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If unspecified, each key-value pair in the Data field of the referenced",
                        "ConfigMap will be projected into the volume as a file whose name is the key",
                        "and content is the value. If specified, the listed keys will be projected",
                        "into the specified paths, and unlisted keys will not be present. If a key is",
                        "specified which is not present in the ConfigMap, the volume setup will",
                        "error. Paths must be relative and may not contain the '..' path or start",
                        "with '..'."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"items\" <$> TF.attribute",
                    "name": "_items",
                    "method": "items",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (PodSpecVolumeConfigMapItemsSetting s)]",
                    "class": "HasItems",
                    "validate": false,
                    "optional": true,
                    "original": "items"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "dependencies": [
                "PodSpecVolumeConfigMapItemsSetting"
            ],
            "key": "pod.spec.volume.config_map",
            "name": "PodSpecVolumeConfigMapSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecVolumeConfigMapSetting s",
            "original": "config_map"
        },
        {
            "con": {
                "smart": "newPodSpecVolumeDownwardApiItemsFieldRefSetting",
                "name": "PodSpecVolumeDownwardApiItemsFieldRefSetting'"
            },
            "arguments": [
                {
                    "default": "TF.value \"v1\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Version of the schema the FieldPath is written in terms of, defaults to",
                        "\"v1\"."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"api_version\" <$> TF.attribute",
                    "name": "_apiVersion",
                    "method": "apiVersion",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasApiVersion",
                    "validate": false,
                    "optional": true,
                    "original": "api_version"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path of the field to select in the specified API version"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"field_path\" <$> TF.attribute",
                    "name": "_fieldPath",
                    "method": "fieldPath",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFieldPath",
                    "validate": false,
                    "optional": true,
                    "original": "field_path"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.volume.downward_api.items.field_ref",
            "name": "PodSpecVolumeDownwardApiItemsFieldRefSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecVolumeDownwardApiItemsFieldRefSetting s",
            "original": "field_ref"
        },
        {
            "con": {
                "smart": "newPodSpecVolumeDownwardApiItemsResourceFieldRefSetting",
                "name": "PodSpecVolumeDownwardApiItemsResourceFieldRefSetting'"
            },
            "arguments": [
                {
                    "default": "_containerName",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"container_name\" <$> TF.attribute",
                    "name": "_containerName",
                    "method": "containerName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasContainerName",
                    "validate": false,
                    "optional": false,
                    "original": "container_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"quantity\" <$> TF.attribute",
                    "name": "_quantity",
                    "method": "quantity",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasQuantity",
                    "validate": false,
                    "optional": true,
                    "original": "quantity"
                },
                {
                    "default": "_resource'",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Resource to select"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource\" <$> TF.attribute",
                    "name": "_resource'",
                    "method": "resource'",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasResource'",
                    "validate": false,
                    "optional": false,
                    "original": "resource"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.volume.downward_api.items.resource_field_ref",
            "name": "PodSpecVolumeDownwardApiItemsResourceFieldRefSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_containerName",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"container_name\" <$> TF.attribute",
                    "name": "_containerName",
                    "method": "containerName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasContainerName",
                    "validate": false,
                    "optional": false,
                    "original": "container_name"
                },
                {
                    "default": "_resource'",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Resource to select"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource\" <$> TF.attribute",
                    "name": "_resource'",
                    "method": "resource'",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasResource'",
                    "validate": false,
                    "optional": false,
                    "original": "resource"
                }
            ],
            "conflicts": [],
            "type": "PodSpecVolumeDownwardApiItemsResourceFieldRefSetting s",
            "original": "resource_field_ref"
        },
        {
            "con": {
                "smart": "newPodSpecVolumeDownwardApiItemsSetting",
                "name": "PodSpecVolumeDownwardApiItemsSetting'"
            },
            "arguments": [
                {
                    "default": "_fieldRef",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Required: Selects a field of the pod: only annotations, labels, name and",
                        "namespace are supported."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"field_ref\" <$> TF.attribute",
                    "name": "_fieldRef",
                    "method": "fieldRef",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecVolumeDownwardApiItemsFieldRefSetting s)",
                    "class": "HasFieldRef",
                    "validate": true,
                    "optional": false,
                    "original": "field_ref"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional: mode bits to use on this file, must be a value between 0 and 0777.",
                        "If not specified, the volume defaultMode will be used. This might be in",
                        "conflict with other options that affect the file mode, like fsGroup, and the",
                        "result can be other mode bits set."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"mode\" <$> TF.attribute",
                    "name": "_mode",
                    "method": "mode",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasMode",
                    "validate": false,
                    "optional": true,
                    "original": "mode"
                },
                {
                    "default": "_path",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path is the relative path name of the file to be created. Must not be",
                        "absolute or contain the '..' path. Must be utf-8 encoded. The first item of",
                        "the relative path must not start with '..'"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": false,
                    "original": "path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Selects a resource of the container: only resources limits and requests",
                        "(limits.cpu, limits.memory, requests.cpu and requests.memory) are currently",
                        "supported."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_field_ref\" <$> TF.attribute",
                    "name": "_resourceFieldRef",
                    "method": "resourceFieldRef",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecVolumeDownwardApiItemsResourceFieldRefSetting s)",
                    "class": "HasResourceFieldRef",
                    "validate": true,
                    "optional": true,
                    "original": "resource_field_ref"
                }
            ],
            "dependencies": [
                "PodSpecVolumeDownwardApiItemsFieldRefSetting",
                "PodSpecVolumeDownwardApiItemsResourceFieldRefSetting"
            ],
            "key": "pod.spec.volume.downward_api.items",
            "name": "PodSpecVolumeDownwardApiItemsSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_path",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path is the relative path name of the file to be created. Must not be",
                        "absolute or contain the '..' path. Must be utf-8 encoded. The first item of",
                        "the relative path must not start with '..'"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": false,
                    "original": "path"
                },
                {
                    "default": "_fieldRef",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Required: Selects a field of the pod: only annotations, labels, name and",
                        "namespace are supported."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"field_ref\" <$> TF.attribute",
                    "name": "_fieldRef",
                    "method": "fieldRef",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecVolumeDownwardApiItemsFieldRefSetting s)",
                    "class": "HasFieldRef",
                    "validate": true,
                    "optional": false,
                    "original": "field_ref"
                }
            ],
            "conflicts": [],
            "type": "PodSpecVolumeDownwardApiItemsSetting s",
            "original": "items"
        },
        {
            "con": {
                "smart": "newPodSpecVolumeDownwardApiSetting",
                "name": "PodSpecVolumeDownwardApiSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional: mode bits to use on created files by default. Must be a value",
                        "between 0 and 0777. Defaults to 0644. Directories within the path are not",
                        "affected by this setting. This might be in conflict with other options that",
                        "affect the file mode, like fsGroup, and the result can be other mode bits",
                        "set."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"default_mode\" <$> TF.attribute",
                    "name": "_defaultMode",
                    "method": "defaultMode",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasDefaultMode",
                    "validate": false,
                    "optional": true,
                    "original": "default_mode"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If unspecified, each key-value pair in the Data field of the referenced",
                        "ConfigMap will be projected into the volume as a file whose name is the key",
                        "and content is the value. If specified, the listed keys will be projected",
                        "into the specified paths, and unlisted keys will not be present. If a key is",
                        "specified which is not present in the ConfigMap, the volume setup will",
                        "error. Paths must be relative and may not contain the '..' path or start",
                        "with '..'."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"items\" <$> TF.attribute",
                    "name": "_items",
                    "method": "items",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (PodSpecVolumeDownwardApiItemsSetting s)]",
                    "class": "HasItems",
                    "validate": false,
                    "optional": true,
                    "original": "items"
                }
            ],
            "dependencies": [
                "PodSpecVolumeDownwardApiItemsSetting"
            ],
            "key": "pod.spec.volume.downward_api",
            "name": "PodSpecVolumeDownwardApiSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecVolumeDownwardApiSetting s",
            "original": "downward_api"
        },
        {
            "con": {
                "smart": "newPodSpecVolumeEmptyDirSetting",
                "name": "PodSpecVolumeEmptyDirSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "What type of storage medium should back this directory. The default is \"\"",
                        "which means to use the node's default medium. Must be an empty string",
                        "(default) or Memory. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#emptydir"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"medium\" <$> TF.attribute",
                    "name": "_medium",
                    "method": "medium",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasMedium",
                    "validate": false,
                    "optional": true,
                    "original": "medium"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.volume.empty_dir",
            "name": "PodSpecVolumeEmptyDirSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecVolumeEmptyDirSetting s",
            "original": "empty_dir"
        },
        {
            "con": {
                "smart": "newPodSpecVolumeFcSetting",
                "name": "PodSpecVolumeFcSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type to mount. Must be a filesystem type supported by the host",
                        "operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be",
                        "\"ext4\" if unspecified."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "_lun",
                    "computed": false,
                    "required": true,
                    "help": [
                        "FC target lun number"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"lun\" <$> TF.attribute",
                    "name": "_lun",
                    "method": "lun",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasLun",
                    "validate": false,
                    "optional": false,
                    "original": "lun"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to false",
                        "(read/write)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_targetWwNs",
                    "computed": false,
                    "required": true,
                    "help": [
                        "FC target worldwide names (WWNs)"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"target_ww_ns\" <$> TF.attribute",
                    "name": "_targetWwNs",
                    "method": "targetWwNs",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasTargetWwNs",
                    "validate": false,
                    "optional": false,
                    "original": "target_ww_ns"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.volume.fc",
            "name": "PodSpecVolumeFcSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_lun",
                    "computed": false,
                    "required": true,
                    "help": [
                        "FC target lun number"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"lun\" <$> TF.attribute",
                    "name": "_lun",
                    "method": "lun",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasLun",
                    "validate": false,
                    "optional": false,
                    "original": "lun"
                },
                {
                    "default": "_targetWwNs",
                    "computed": false,
                    "required": true,
                    "help": [
                        "FC target worldwide names (WWNs)"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"target_ww_ns\" <$> TF.attribute",
                    "name": "_targetWwNs",
                    "method": "targetWwNs",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasTargetWwNs",
                    "validate": false,
                    "optional": false,
                    "original": "target_ww_ns"
                }
            ],
            "conflicts": [],
            "type": "PodSpecVolumeFcSetting s",
            "original": "fc"
        },
        {
            "con": {
                "smart": "newPodSpecVolumeFlexVolumeSecretRefSetting",
                "name": "PodSpecVolumeFlexVolumeSecretRefSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.volume.flex_volume.secret_ref",
            "name": "PodSpecVolumeFlexVolumeSecretRefSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecVolumeFlexVolumeSecretRefSetting s",
            "original": "secret_ref"
        },
        {
            "con": {
                "smart": "newPodSpecVolumeFlexVolumeSetting",
                "name": "PodSpecVolumeFlexVolumeSetting'"
            },
            "arguments": [
                {
                    "default": "_driver",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Driver is the name of the driver to use for this volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"driver\" <$> TF.attribute",
                    "name": "_driver",
                    "method": "driver",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDriver",
                    "validate": false,
                    "optional": false,
                    "original": "driver"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type to mount. Must be a filesystem type supported by the host",
                        "operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". The default filesystem depends",
                        "on FlexVolume script."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Extra command options if any."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"options\" <$> TF.attribute",
                    "name": "_options",
                    "method": "options",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasOptions",
                    "validate": false,
                    "optional": true,
                    "original": "options"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the ReadOnly setting in VolumeMounts. Defaults to false",
                        "(read/write)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Reference to the secret object containing sensitive information to pass to",
                        "the plugin scripts. This may be empty if no secret object is specified. If",
                        "the secret object contains more than one secret, all secrets are passed to",
                        "the plugin scripts."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_ref\" <$> TF.attribute",
                    "name": "_secretRef",
                    "method": "secretRef",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecVolumeFlexVolumeSecretRefSetting s)",
                    "class": "HasSecretRef",
                    "validate": true,
                    "optional": true,
                    "original": "secret_ref"
                }
            ],
            "dependencies": [
                "PodSpecVolumeFlexVolumeSecretRefSetting"
            ],
            "key": "pod.spec.volume.flex_volume",
            "name": "PodSpecVolumeFlexVolumeSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_driver",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Driver is the name of the driver to use for this volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"driver\" <$> TF.attribute",
                    "name": "_driver",
                    "method": "driver",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDriver",
                    "validate": false,
                    "optional": false,
                    "original": "driver"
                }
            ],
            "conflicts": [],
            "type": "PodSpecVolumeFlexVolumeSetting s",
            "original": "flex_volume"
        },
        {
            "con": {
                "smart": "newPodSpecVolumeFlockerSetting",
                "name": "PodSpecVolumeFlockerSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the dataset stored as metadata -> name on the dataset for Flocker",
                        "should be considered as deprecated"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"dataset_name\" <$> TF.attribute",
                    "name": "_datasetName",
                    "method": "datasetName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatasetName",
                    "validate": false,
                    "optional": true,
                    "original": "dataset_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "UUID of the dataset. This is unique identifier of a Flocker dataset"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"dataset_uuid\" <$> TF.attribute",
                    "name": "_datasetUuid",
                    "method": "datasetUuid",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatasetUuid",
                    "validate": false,
                    "optional": true,
                    "original": "dataset_uuid"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.volume.flocker",
            "name": "PodSpecVolumeFlockerSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecVolumeFlockerSetting s",
            "original": "flocker"
        },
        {
            "con": {
                "smart": "newPodSpecVolumeGcePersistentDiskSetting",
                "name": "PodSpecVolumeGcePersistentDiskSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type of the volume that you want to mount. Tip: Ensure that the",
                        "filesystem type is supported by the host operating system. Examples: \"ext4\",",
                        "\"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The partition in the volume that you want to mount. If omitted, the default",
                        "is to mount by volume name. Examples: For volume /dev/sda1, you specify the",
                        "partition as \"1\". Similarly, the volume partition for /dev/sda is \"0\" (or",
                        "you can leave the property empty). More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"partition\" <$> TF.attribute",
                    "name": "_partition",
                    "method": "partition",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasPartition",
                    "validate": false,
                    "optional": true,
                    "original": "partition"
                },
                {
                    "default": "_pdName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Unique name of the PD resource in GCE. Used to identify the disk in GCE.",
                        "More info: http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"pd_name\" <$> TF.attribute",
                    "name": "_pdName",
                    "method": "pdName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPdName",
                    "validate": false,
                    "optional": false,
                    "original": "pd_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the ReadOnly setting in VolumeMounts. Defaults to false.",
                        "More info: http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.volume.gce_persistent_disk",
            "name": "PodSpecVolumeGcePersistentDiskSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_pdName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Unique name of the PD resource in GCE. Used to identify the disk in GCE.",
                        "More info: http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"pd_name\" <$> TF.attribute",
                    "name": "_pdName",
                    "method": "pdName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPdName",
                    "validate": false,
                    "optional": false,
                    "original": "pd_name"
                }
            ],
            "conflicts": [],
            "type": "PodSpecVolumeGcePersistentDiskSetting s",
            "original": "gce_persistent_disk"
        },
        {
            "con": {
                "smart": "newPodSpecVolumeGitRepoSetting",
                "name": "PodSpecVolumeGitRepoSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Target directory name. Must not contain or start with '..'. If '.' is",
                        "supplied, the volume directory will be the git repository. Otherwise, if",
                        "specified, the volume will contain the git repository in the subdirectory",
                        "with the given name."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"directory\" <$> TF.attribute",
                    "name": "_directory",
                    "method": "directory",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDirectory",
                    "validate": false,
                    "optional": true,
                    "original": "directory"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Repository URL"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"repository\" <$> TF.attribute",
                    "name": "_repository",
                    "method": "repository",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRepository",
                    "validate": false,
                    "optional": true,
                    "original": "repository"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Commit hash for the specified revision."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"revision\" <$> TF.attribute",
                    "name": "_revision",
                    "method": "revision",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRevision",
                    "validate": false,
                    "optional": true,
                    "original": "revision"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.volume.git_repo",
            "name": "PodSpecVolumeGitRepoSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecVolumeGitRepoSetting s",
            "original": "git_repo"
        },
        {
            "con": {
                "smart": "newPodSpecVolumeGlusterfsSetting",
                "name": "PodSpecVolumeGlusterfsSetting'"
            },
            "arguments": [
                {
                    "default": "_endpointsName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The endpoint name that details Glusterfs topology. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"endpoints_name\" <$> TF.attribute",
                    "name": "_endpointsName",
                    "method": "endpointsName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasEndpointsName",
                    "validate": false,
                    "optional": false,
                    "original": "endpoints_name"
                },
                {
                    "default": "_path",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The Glusterfs volume path. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": false,
                    "original": "path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the Glusterfs volume to be mounted with read-only",
                        "permissions. Defaults to false. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.volume.glusterfs",
            "name": "PodSpecVolumeGlusterfsSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_endpointsName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The endpoint name that details Glusterfs topology. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"endpoints_name\" <$> TF.attribute",
                    "name": "_endpointsName",
                    "method": "endpointsName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasEndpointsName",
                    "validate": false,
                    "optional": false,
                    "original": "endpoints_name"
                },
                {
                    "default": "_path",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The Glusterfs volume path. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": false,
                    "original": "path"
                }
            ],
            "conflicts": [],
            "type": "PodSpecVolumeGlusterfsSetting s",
            "original": "glusterfs"
        },
        {
            "con": {
                "smart": "newPodSpecVolumeHostPathSetting",
                "name": "PodSpecVolumeHostPathSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path of the directory on the host. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#hostpath"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": true,
                    "original": "path"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.volume.host_path",
            "name": "PodSpecVolumeHostPathSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecVolumeHostPathSetting s",
            "original": "host_path"
        },
        {
            "con": {
                "smart": "newPodSpecVolumeIscsiSetting",
                "name": "PodSpecVolumeIscsiSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type of the volume that you want to mount. Tip: Ensure that the",
                        "filesystem type is supported by the host operating system. Examples: \"ext4\",",
                        "\"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#iscsi"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "_iqn",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Target iSCSI Qualified Name."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"iqn\" <$> TF.attribute",
                    "name": "_iqn",
                    "method": "iqn",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasIqn",
                    "validate": false,
                    "optional": false,
                    "original": "iqn"
                },
                {
                    "default": "TF.value \"default\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "ISCSI interface name that uses an iSCSI transport. Defaults to 'default'",
                        "(tcp)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"iscsi_interface\" <$> TF.attribute",
                    "name": "_iscsiInterface",
                    "method": "iscsiInterface",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasIscsiInterface",
                    "validate": false,
                    "optional": true,
                    "original": "iscsi_interface"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "ISCSI target lun number."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"lun\" <$> TF.attribute",
                    "name": "_lun",
                    "method": "lun",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasLun",
                    "validate": false,
                    "optional": true,
                    "original": "lun"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to false."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_targetPortal",
                    "computed": false,
                    "required": true,
                    "help": [
                        "ISCSI target portal. The portal is either an IP or ip_addr:port if the port",
                        "is other than default (typically TCP ports 860 and 3260)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"target_portal\" <$> TF.attribute",
                    "name": "_targetPortal",
                    "method": "targetPortal",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasTargetPortal",
                    "validate": false,
                    "optional": false,
                    "original": "target_portal"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.volume.iscsi",
            "name": "PodSpecVolumeIscsiSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_iqn",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Target iSCSI Qualified Name."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"iqn\" <$> TF.attribute",
                    "name": "_iqn",
                    "method": "iqn",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasIqn",
                    "validate": false,
                    "optional": false,
                    "original": "iqn"
                },
                {
                    "default": "_targetPortal",
                    "computed": false,
                    "required": true,
                    "help": [
                        "ISCSI target portal. The portal is either an IP or ip_addr:port if the port",
                        "is other than default (typically TCP ports 860 and 3260)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"target_portal\" <$> TF.attribute",
                    "name": "_targetPortal",
                    "method": "targetPortal",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasTargetPortal",
                    "validate": false,
                    "optional": false,
                    "original": "target_portal"
                }
            ],
            "conflicts": [],
            "type": "PodSpecVolumeIscsiSetting s",
            "original": "iscsi"
        },
        {
            "con": {
                "smart": "newPodSpecVolumeNfsSetting",
                "name": "PodSpecVolumeNfsSetting'"
            },
            "arguments": [
                {
                    "default": "_path",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path that is exported by the NFS server. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": false,
                    "original": "path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the NFS export to be mounted with read-only permissions.",
                        "Defaults to false. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_server",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Server is the hostname or IP address of the NFS server. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"server\" <$> TF.attribute",
                    "name": "_server",
                    "method": "server",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasServer",
                    "validate": false,
                    "optional": false,
                    "original": "server"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.volume.nfs",
            "name": "PodSpecVolumeNfsSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_path",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path that is exported by the NFS server. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": false,
                    "original": "path"
                },
                {
                    "default": "_server",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Server is the hostname or IP address of the NFS server. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"server\" <$> TF.attribute",
                    "name": "_server",
                    "method": "server",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasServer",
                    "validate": false,
                    "optional": false,
                    "original": "server"
                }
            ],
            "conflicts": [],
            "type": "PodSpecVolumeNfsSetting s",
            "original": "nfs"
        },
        {
            "con": {
                "smart": "newPodSpecVolumePersistentVolumeClaimSetting",
                "name": "PodSpecVolumePersistentVolumeClaimSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "ClaimName is the name of a PersistentVolumeClaim in the same"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"claim_name\" <$> TF.attribute",
                    "name": "_claimName",
                    "method": "claimName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasClaimName",
                    "validate": false,
                    "optional": true,
                    "original": "claim_name"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Will force the ReadOnly setting in VolumeMounts."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.volume.persistent_volume_claim",
            "name": "PodSpecVolumePersistentVolumeClaimSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecVolumePersistentVolumeClaimSetting s",
            "original": "persistent_volume_claim"
        },
        {
            "con": {
                "smart": "newPodSpecVolumePhotonPersistentDiskSetting",
                "name": "PodSpecVolumePhotonPersistentDiskSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type to mount. Must be a filesystem type supported by the host",
                        "operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be",
                        "\"ext4\" if unspecified."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "_pdId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "ID that identifies Photon Controller persistent disk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"pd_id\" <$> TF.attribute",
                    "name": "_pdId",
                    "method": "pdId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPdId",
                    "validate": false,
                    "optional": false,
                    "original": "pd_id"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.volume.photon_persistent_disk",
            "name": "PodSpecVolumePhotonPersistentDiskSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_pdId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "ID that identifies Photon Controller persistent disk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"pd_id\" <$> TF.attribute",
                    "name": "_pdId",
                    "method": "pdId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPdId",
                    "validate": false,
                    "optional": false,
                    "original": "pd_id"
                }
            ],
            "conflicts": [],
            "type": "PodSpecVolumePhotonPersistentDiskSetting s",
            "original": "photon_persistent_disk"
        },
        {
            "con": {
                "smart": "newPodSpecVolumeQuobyteSetting",
                "name": "PodSpecVolumeQuobyteSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Group to map volume access to Default is no group"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"group\" <$> TF.attribute",
                    "name": "_group",
                    "method": "group",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasGroup",
                    "validate": false,
                    "optional": true,
                    "original": "group"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the Quobyte volume to be mounted with read-only",
                        "permissions. Defaults to false."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_registry",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Registry represents a single or multiple Quobyte Registry services specified",
                        "as a string as host:port pair (multiple entries are separated with commas)",
                        "which acts as the central registry for volumes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"registry\" <$> TF.attribute",
                    "name": "_registry",
                    "method": "registry",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRegistry",
                    "validate": false,
                    "optional": false,
                    "original": "registry"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "User to map volume access to Defaults to serivceaccount user"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"user\" <$> TF.attribute",
                    "name": "_user",
                    "method": "user",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasUser",
                    "validate": false,
                    "optional": true,
                    "original": "user"
                },
                {
                    "default": "_volume",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Volume is a string that references an already created Quobyte volume by",
                        "name."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume\" <$> TF.attribute",
                    "name": "_volume",
                    "method": "volume",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolume",
                    "validate": false,
                    "optional": false,
                    "original": "volume"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.volume.quobyte",
            "name": "PodSpecVolumeQuobyteSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_registry",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Registry represents a single or multiple Quobyte Registry services specified",
                        "as a string as host:port pair (multiple entries are separated with commas)",
                        "which acts as the central registry for volumes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"registry\" <$> TF.attribute",
                    "name": "_registry",
                    "method": "registry",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRegistry",
                    "validate": false,
                    "optional": false,
                    "original": "registry"
                },
                {
                    "default": "_volume",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Volume is a string that references an already created Quobyte volume by",
                        "name."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume\" <$> TF.attribute",
                    "name": "_volume",
                    "method": "volume",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolume",
                    "validate": false,
                    "optional": false,
                    "original": "volume"
                }
            ],
            "conflicts": [],
            "type": "PodSpecVolumeQuobyteSetting s",
            "original": "quobyte"
        },
        {
            "con": {
                "smart": "newPodSpecVolumeRbdSecretRefSetting",
                "name": "PodSpecVolumeRbdSecretRefSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.volume.rbd.secret_ref",
            "name": "PodSpecVolumeRbdSecretRefSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecVolumeRbdSecretRefSetting s",
            "original": "secret_ref"
        },
        {
            "con": {
                "smart": "newPodSpecVolumeRbdSetting",
                "name": "PodSpecVolumeRbdSetting'"
            },
            "arguments": [
                {
                    "default": "_cephMonitors",
                    "computed": false,
                    "required": true,
                    "help": [
                        "A collection of Ceph monitors. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ceph_monitors\" <$> TF.attribute",
                    "name": "_cephMonitors",
                    "method": "cephMonitors",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCephMonitors",
                    "validate": false,
                    "optional": false,
                    "original": "ceph_monitors"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type of the volume that you want to mount. Tip: Ensure that the",
                        "filesystem type is supported by the host operating system. Examples: \"ext4\",",
                        "\"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#rbd"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring.",
                        "More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"keyring\" <$> TF.attribute",
                    "name": "_keyring",
                    "method": "keyring",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasKeyring",
                    "validate": false,
                    "optional": true,
                    "original": "keyring"
                },
                {
                    "default": "TF.value \"admin\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The rados user name. Default is admin. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"rados_user\" <$> TF.attribute",
                    "name": "_radosUser",
                    "method": "radosUser",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRadosUser",
                    "validate": false,
                    "optional": true,
                    "original": "rados_user"
                },
                {
                    "default": "_rbdImage",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The rados image name. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"rbd_image\" <$> TF.attribute",
                    "name": "_rbdImage",
                    "method": "rbdImage",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRbdImage",
                    "validate": false,
                    "optional": false,
                    "original": "rbd_image"
                },
                {
                    "default": "TF.value \"rbd\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The rados pool name. Default is rbd. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"rbd_pool\" <$> TF.attribute",
                    "name": "_rbdPool",
                    "method": "rbdPool",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRbdPool",
                    "validate": false,
                    "optional": true,
                    "original": "rbd_pool"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to false.",
                        "More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the authentication secret for RBDUser. If provided overrides",
                        "keyring. Default is nil. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_ref\" <$> TF.attribute",
                    "name": "_secretRef",
                    "method": "secretRef",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecVolumeRbdSecretRefSetting s)",
                    "class": "HasSecretRef",
                    "validate": true,
                    "optional": true,
                    "original": "secret_ref"
                }
            ],
            "dependencies": [
                "PodSpecVolumeRbdSecretRefSetting"
            ],
            "key": "pod.spec.volume.rbd",
            "name": "PodSpecVolumeRbdSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring.",
                        "More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"keyring\" <$> TF.attribute",
                    "name": "_computedKeyring",
                    "method": "computedKeyring",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedKeyring",
                    "validate": false,
                    "optional": false,
                    "original": "keyring"
                }
            ],
            "parameters": [
                {
                    "default": "_rbdImage",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The rados image name. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"rbd_image\" <$> TF.attribute",
                    "name": "_rbdImage",
                    "method": "rbdImage",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRbdImage",
                    "validate": false,
                    "optional": false,
                    "original": "rbd_image"
                },
                {
                    "default": "_cephMonitors",
                    "computed": false,
                    "required": true,
                    "help": [
                        "A collection of Ceph monitors. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ceph_monitors\" <$> TF.attribute",
                    "name": "_cephMonitors",
                    "method": "cephMonitors",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCephMonitors",
                    "validate": false,
                    "optional": false,
                    "original": "ceph_monitors"
                }
            ],
            "conflicts": [],
            "type": "PodSpecVolumeRbdSetting s",
            "original": "rbd"
        },
        {
            "con": {
                "smart": "newPodSpecVolumeSecretItemsSetting",
                "name": "PodSpecVolumeSecretItemsSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The key to project."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"key\" <$> TF.attribute",
                    "name": "_key",
                    "method": "key",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasKey",
                    "validate": false,
                    "optional": true,
                    "original": "key"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional: mode bits to use on this file, must be a value between 0 and 0777.",
                        "If not specified, the volume defaultMode will be used. This might be in",
                        "conflict with other options that affect the file mode, like fsGroup, and the",
                        "result can be other mode bits set."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"mode\" <$> TF.attribute",
                    "name": "_mode",
                    "method": "mode",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasMode",
                    "validate": false,
                    "optional": true,
                    "original": "mode"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The relative path of the file to map the key to. May not be an absolute",
                        "path. May not contain the path element '..'. May not start with the string",
                        "'..'."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": true,
                    "original": "path"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.volume.secret.items",
            "name": "PodSpecVolumeSecretItemsSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecVolumeSecretItemsSetting s",
            "original": "items"
        },
        {
            "con": {
                "smart": "newPodSpecVolumeSecretSetting",
                "name": "PodSpecVolumeSecretSetting'"
            },
            "arguments": [
                {
                    "default": "TF.value 420",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional: mode bits to use on created files by default. Must be a value",
                        "between 0 and 0777. Defaults to 0644. Directories within the path are not",
                        "affected by this setting. This might be in conflict with other options that",
                        "affect the file mode, like fsGroup, and the result can be other mode bits",
                        "set."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"default_mode\" <$> TF.attribute",
                    "name": "_defaultMode",
                    "method": "defaultMode",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasDefaultMode",
                    "validate": false,
                    "optional": true,
                    "original": "default_mode"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If unspecified, each key-value pair in the Data field of the referenced",
                        "Secret will be projected into the volume as a file whose name is the key and",
                        "content is the value. If specified, the listed keys will be projected into",
                        "the specified paths, and unlisted keys will not be present. If a key is",
                        "specified which is not present in the Secret, the volume setup will error",
                        "unless it is marked optional. Paths must be relative and may not contain the",
                        "'..' path or start with '..'."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"items\" <$> TF.attribute",
                    "name": "_items",
                    "method": "items",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (PodSpecVolumeSecretItemsSetting s)]",
                    "class": "HasItems",
                    "validate": false,
                    "optional": true,
                    "original": "items"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional: Specify whether the Secret or it's keys must be defined."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"optional\" <$> TF.attribute",
                    "name": "_optional",
                    "method": "optional",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasOptional",
                    "validate": false,
                    "optional": true,
                    "original": "optional"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the secret in the pod's namespace to use. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#secrets"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_name\" <$> TF.attribute",
                    "name": "_secretName",
                    "method": "secretName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSecretName",
                    "validate": false,
                    "optional": true,
                    "original": "secret_name"
                }
            ],
            "dependencies": [
                "PodSpecVolumeSecretItemsSetting"
            ],
            "key": "pod.spec.volume.secret",
            "name": "PodSpecVolumeSecretSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecVolumeSecretSetting s",
            "original": "secret"
        },
        {
            "con": {
                "smart": "newPodSpecVolumeSetting",
                "name": "PodSpecVolumeSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an AWS Disk resource that is attached to a kubelet's host machine",
                        "and then exposed to the pod. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"aws_elastic_block_store\" <$> TF.attribute",
                    "name": "_awsElasticBlockStore",
                    "method": "awsElasticBlockStore",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecVolumeAwsElasticBlockStoreSetting s)",
                    "class": "HasAwsElasticBlockStore",
                    "validate": true,
                    "optional": true,
                    "original": "aws_elastic_block_store"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an Azure Data Disk mount on the host and bind mount to the pod."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"azure_disk\" <$> TF.attribute",
                    "name": "_azureDisk",
                    "method": "azureDisk",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecVolumeAzureDiskSetting s)",
                    "class": "HasAzureDisk",
                    "validate": true,
                    "optional": true,
                    "original": "azure_disk"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an Azure File Service mount on the host and bind mount to the",
                        "pod."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"azure_file\" <$> TF.attribute",
                    "name": "_azureFile",
                    "method": "azureFile",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecVolumeAzureFileSetting s)",
                    "class": "HasAzureFile",
                    "validate": true,
                    "optional": true,
                    "original": "azure_file"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Ceph FS mount on the host that shares a pod's lifetime"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ceph_fs\" <$> TF.attribute",
                    "name": "_cephFs",
                    "method": "cephFs",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecVolumeCephFsSetting s)",
                    "class": "HasCephFs",
                    "validate": true,
                    "optional": true,
                    "original": "ceph_fs"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a cinder volume attached and mounted on kubelets host machine.",
                        "More info: http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cinder\" <$> TF.attribute",
                    "name": "_cinder",
                    "method": "cinder",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecVolumeCinderSetting s)",
                    "class": "HasCinder",
                    "validate": true,
                    "optional": true,
                    "original": "cinder"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "ConfigMap represents a configMap that should populate this volume"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"config_map\" <$> TF.attribute",
                    "name": "_configMap",
                    "method": "configMap",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecVolumeConfigMapSetting s)",
                    "class": "HasConfigMap",
                    "validate": true,
                    "optional": true,
                    "original": "config_map"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "DownwardAPI represents downward API about the pod that should populate this",
                        "volume"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"downward_api\" <$> TF.attribute",
                    "name": "_downwardApi",
                    "method": "downwardApi",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecVolumeDownwardApiSetting s)",
                    "class": "HasDownwardApi",
                    "validate": true,
                    "optional": true,
                    "original": "downward_api"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "EmptyDir represents a temporary directory that shares a pod's lifetime. More",
                        "info: http://kubernetes.io/docs/user-guide/volumes#emptydir"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"empty_dir\" <$> TF.attribute",
                    "name": "_emptyDir",
                    "method": "emptyDir",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecVolumeEmptyDirSetting s)",
                    "class": "HasEmptyDir",
                    "validate": true,
                    "optional": true,
                    "original": "empty_dir"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Fibre Channel resource that is attached to a kubelet's host",
                        "machine and then exposed to the pod."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fc\" <$> TF.attribute",
                    "name": "_fc",
                    "method": "fc",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecVolumeFcSetting s)",
                    "class": "HasFc",
                    "validate": true,
                    "optional": true,
                    "original": "fc"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a generic volume resource that is provisioned/attached using an",
                        "exec based plugin. This is an alpha feature and may change in future."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"flex_volume\" <$> TF.attribute",
                    "name": "_flexVolume",
                    "method": "flexVolume",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecVolumeFlexVolumeSetting s)",
                    "class": "HasFlexVolume",
                    "validate": true,
                    "optional": true,
                    "original": "flex_volume"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Flocker volume attached to a kubelet's host machine and exposed",
                        "to the pod for its usage. This depends on the Flocker control service being",
                        "running"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"flocker\" <$> TF.attribute",
                    "name": "_flocker",
                    "method": "flocker",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecVolumeFlockerSetting s)",
                    "class": "HasFlocker",
                    "validate": true,
                    "optional": true,
                    "original": "flocker"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a GCE Disk resource that is attached to a kubelet's host machine",
                        "and then exposed to the pod. Provisioned by an admin. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"gce_persistent_disk\" <$> TF.attribute",
                    "name": "_gcePersistentDisk",
                    "method": "gcePersistentDisk",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecVolumeGcePersistentDiskSetting s)",
                    "class": "HasGcePersistentDisk",
                    "validate": true,
                    "optional": true,
                    "original": "gce_persistent_disk"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "GitRepo represents a git repository at a particular revision."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"git_repo\" <$> TF.attribute",
                    "name": "_gitRepo",
                    "method": "gitRepo",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecVolumeGitRepoSetting s)",
                    "class": "HasGitRepo",
                    "validate": true,
                    "optional": true,
                    "original": "git_repo"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Glusterfs volume that is attached to a host and exposed to the",
                        "pod. Provisioned by an admin. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"glusterfs\" <$> TF.attribute",
                    "name": "_glusterfs",
                    "method": "glusterfs",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecVolumeGlusterfsSetting s)",
                    "class": "HasGlusterfs",
                    "validate": true,
                    "optional": true,
                    "original": "glusterfs"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a directory on the host. Provisioned by a developer or tester.",
                        "This is useful for single-node development and testing only! On-host storage",
                        "is not supported in any way and WILL NOT WORK in a multi-node cluster. More",
                        "info: http://kubernetes.io/docs/user-guide/volumes#hostpath"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_path\" <$> TF.attribute",
                    "name": "_hostPath",
                    "method": "hostPath",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecVolumeHostPathSetting s)",
                    "class": "HasHostPath",
                    "validate": true,
                    "optional": true,
                    "original": "host_path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an ISCSI Disk resource that is attached to a kubelet's host",
                        "machine and then exposed to the pod. Provisioned by an admin."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"iscsi\" <$> TF.attribute",
                    "name": "_iscsi",
                    "method": "iscsi",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecVolumeIscsiSetting s)",
                    "class": "HasIscsi",
                    "validate": true,
                    "optional": true,
                    "original": "iscsi"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Volume's name. Must be a DNS_LABEL and unique within the pod. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an NFS mount on the host. Provisioned by an admin. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"nfs\" <$> TF.attribute",
                    "name": "_nfs",
                    "method": "nfs",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecVolumeNfsSetting s)",
                    "class": "HasNfs",
                    "validate": true,
                    "optional": true,
                    "original": "nfs"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The specification of a persistent volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"persistent_volume_claim\" <$> TF.attribute",
                    "name": "_persistentVolumeClaim",
                    "method": "persistentVolumeClaim",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecVolumePersistentVolumeClaimSetting s)",
                    "class": "HasPersistentVolumeClaim",
                    "validate": true,
                    "optional": true,
                    "original": "persistent_volume_claim"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a PhotonController persistent disk attached and mounted on",
                        "kubelets host machine"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"photon_persistent_disk\" <$> TF.attribute",
                    "name": "_photonPersistentDisk",
                    "method": "photonPersistentDisk",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecVolumePhotonPersistentDiskSetting s)",
                    "class": "HasPhotonPersistentDisk",
                    "validate": true,
                    "optional": true,
                    "original": "photon_persistent_disk"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Quobyte represents a Quobyte mount on the host that shares a pod's lifetime"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"quobyte\" <$> TF.attribute",
                    "name": "_quobyte",
                    "method": "quobyte",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecVolumeQuobyteSetting s)",
                    "class": "HasQuobyte",
                    "validate": true,
                    "optional": true,
                    "original": "quobyte"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Rados Block Device mount on the host that shares a pod's",
                        "lifetime. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"rbd\" <$> TF.attribute",
                    "name": "_rbd",
                    "method": "rbd",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecVolumeRbdSetting s)",
                    "class": "HasRbd",
                    "validate": true,
                    "optional": true,
                    "original": "rbd"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Secret represents a secret that should populate this volume. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#secrets"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret\" <$> TF.attribute",
                    "name": "_secret",
                    "method": "secret",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecVolumeSecretSetting s)",
                    "class": "HasSecret",
                    "validate": true,
                    "optional": true,
                    "original": "secret"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a vSphere volume attached and mounted on kubelets host machine"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vsphere_volume\" <$> TF.attribute",
                    "name": "_vsphereVolume",
                    "method": "vsphereVolume",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecVolumeVsphereVolumeSetting s)",
                    "class": "HasVsphereVolume",
                    "validate": true,
                    "optional": true,
                    "original": "vsphere_volume"
                }
            ],
            "dependencies": [
                "PodSpecVolumeAwsElasticBlockStoreSetting",
                "PodSpecVolumeAzureDiskSetting",
                "PodSpecVolumeAzureFileSetting",
                "PodSpecVolumeCephFsSetting",
                "PodSpecVolumeCinderSetting",
                "PodSpecVolumeConfigMapSetting",
                "PodSpecVolumeDownwardApiSetting",
                "PodSpecVolumeEmptyDirSetting",
                "PodSpecVolumeFcSetting",
                "PodSpecVolumeFlexVolumeSetting",
                "PodSpecVolumeFlockerSetting",
                "PodSpecVolumeGcePersistentDiskSetting",
                "PodSpecVolumeGitRepoSetting",
                "PodSpecVolumeGlusterfsSetting",
                "PodSpecVolumeHostPathSetting",
                "PodSpecVolumeIscsiSetting",
                "PodSpecVolumeNfsSetting",
                "PodSpecVolumePersistentVolumeClaimSetting",
                "PodSpecVolumePhotonPersistentDiskSetting",
                "PodSpecVolumeQuobyteSetting",
                "PodSpecVolumeRbdSetting",
                "PodSpecVolumeSecretSetting",
                "PodSpecVolumeVsphereVolumeSetting"
            ],
            "key": "pod.spec.volume",
            "name": "PodSpecVolumeSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpecVolumeSetting s",
            "original": "volume"
        },
        {
            "con": {
                "smart": "newPodSpecVolumeVsphereVolumeSetting",
                "name": "PodSpecVolumeVsphereVolumeSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type to mount. Must be a filesystem type supported by the host",
                        "operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be",
                        "\"ext4\" if unspecified."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "_volumePath",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path that identifies vSphere volume vmdk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_path\" <$> TF.attribute",
                    "name": "_volumePath",
                    "method": "volumePath",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumePath",
                    "validate": false,
                    "optional": false,
                    "original": "volume_path"
                }
            ],
            "dependencies": [],
            "key": "pod.spec.volume.vsphere_volume",
            "name": "PodSpecVolumeVsphereVolumeSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_volumePath",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path that identifies vSphere volume vmdk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_path\" <$> TF.attribute",
                    "name": "_volumePath",
                    "method": "volumePath",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumePath",
                    "validate": false,
                    "optional": false,
                    "original": "volume_path"
                }
            ],
            "conflicts": [],
            "type": "PodSpecVolumeVsphereVolumeSetting s",
            "original": "vsphere_volume"
        },
        {
            "con": {
                "smart": "newReplicationControllerMetadataSetting",
                "name": "ReplicationControllerMetadataSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "An unstructured key value map stored with the replication controller that",
                        "may be used to store arbitrary metadata. More info:",
                        "http://kubernetes.io/docs/user-guide/annotations"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"annotations\" <$> TF.attribute",
                    "name": "_annotations",
                    "method": "annotations",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasAnnotations",
                    "validate": false,
                    "optional": true,
                    "original": "annotations"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Prefix, used by the server, to generate a unique name ONLY IF the `name`",
                        "field has not been provided. This value will also be combined with a unique",
                        "suffix. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#idempotency"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"generate_name\" <$> TF.attribute",
                    "name": "_generateName",
                    "method": "generateName",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_name",
                            "method": "name"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasGenerateName",
                    "validate": false,
                    "optional": true,
                    "original": "generate_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Map of string keys and values that can be used to organize and categorize",
                        "(scope and select) the replication controller. May match selectors of",
                        "replication controllers and services. More info:",
                        "http://kubernetes.io/docs/user-guide/labels"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"labels\" <$> TF.attribute",
                    "name": "_labels",
                    "method": "labels",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasLabels",
                    "validate": false,
                    "optional": true,
                    "original": "labels"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the replication controller, must be unique. Cannot be updated. More",
                        "info: http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_generateName",
                            "method": "generateName"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.value \"default\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Namespace defines the space within which name of the replication controller",
                        "must be unique."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"namespace\" <$> TF.attribute",
                    "name": "_namespace",
                    "method": "namespace",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasNamespace",
                    "validate": false,
                    "optional": true,
                    "original": "namespace"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.metadata",
            "name": "ReplicationControllerMetadataSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A sequence number representing a specific generation of the desired state."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"generation\" <$> TF.attribute",
                    "name": "_computedGeneration",
                    "method": "computedGeneration",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedGeneration",
                    "validate": false,
                    "optional": false,
                    "original": "generation"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Name of the replication controller, must be unique. Cannot be updated. More",
                        "info: http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_computedName",
                    "method": "computedName",
                    "threaded": true,
                    "conflicts": [
                        "_generateName"
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "An opaque value that represents the internal version of this replication",
                        "controller that can be used by clients to determine when replication",
                        "controller has changed. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#concurrency-control-and-consistency"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_version\" <$> TF.attribute",
                    "name": "_computedResourceVersion",
                    "method": "computedResourceVersion",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedResourceVersion",
                    "validate": false,
                    "optional": false,
                    "original": "resource_version"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A URL representing this replication controller."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"self_link\" <$> TF.attribute",
                    "name": "_computedSelfLink",
                    "method": "computedSelfLink",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedSelfLink",
                    "validate": false,
                    "optional": false,
                    "original": "self_link"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The unique in time and space value for this replication controller. More",
                        "info: http://kubernetes.io/docs/user-guide/identifiers#uids"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"uid\" <$> TF.attribute",
                    "name": "_computedUid",
                    "method": "computedUid",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedUid",
                    "validate": false,
                    "optional": false,
                    "original": "uid"
                }
            ],
            "parameters": [],
            "conflicts": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Prefix, used by the server, to generate a unique name ONLY IF the `name`",
                        "field has not been provided. This value will also be combined with a unique",
                        "suffix. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#idempotency"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"generate_name\" <$> TF.attribute",
                    "name": "_generateName",
                    "method": "generateName",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_name",
                            "method": "name"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasGenerateName",
                    "validate": false,
                    "optional": true,
                    "original": "generate_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the replication controller, must be unique. Cannot be updated. More",
                        "info: http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_generateName",
                            "method": "generateName"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "type": "ReplicationControllerMetadataSetting s",
            "original": "metadata"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecSetting",
                "name": "ReplicationControllerSpecSetting'"
            },
            "arguments": [
                {
                    "default": "TF.value 0",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Minimum number of seconds for which a newly created pod should be ready",
                        "without any of its container crashing, for it to be considered available.",
                        "Defaults to 0 (pod will be considered available as soon as it is ready)"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"min_ready_seconds\" <$> TF.attribute",
                    "name": "_minReadySeconds",
                    "method": "minReadySeconds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasMinReadySeconds",
                    "validate": false,
                    "optional": true,
                    "original": "min_ready_seconds"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The number of desired replicas. Defaults to 1. More info:",
                        "http://kubernetes.io/docs/user-guide/replication-controller#what-is-a-replication-controller"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"replicas\" <$> TF.attribute",
                    "name": "_replicas",
                    "method": "replicas",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasReplicas",
                    "validate": false,
                    "optional": true,
                    "original": "replicas"
                },
                {
                    "default": "_selector",
                    "computed": false,
                    "required": true,
                    "help": [
                        "A label query over pods that should match the Replicas count. If Selector is",
                        "empty, it is defaulted to the labels present on the Pod template. Label keys",
                        "and values that must match in order to be controlled by this replication",
                        "controller, if empty defaulted to labels on Pod template. More info:",
                        "http://kubernetes.io/docs/user-guide/labels#label-selectors"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"selector\" <$> TF.attribute",
                    "name": "_selector",
                    "method": "selector",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasSelector",
                    "validate": false,
                    "optional": false,
                    "original": "selector"
                },
                {
                    "default": "_template",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Describes the pod that will be created if insufficient replicas are",
                        "detected. This takes precedence over a TemplateRef. More info:",
                        "http://kubernetes.io/docs/user-guide/replication-controller#pod-template"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"template\" <$> TF.attribute",
                    "name": "_template",
                    "method": "template",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateSetting s)",
                    "class": "HasTemplate",
                    "validate": true,
                    "optional": false,
                    "original": "template"
                }
            ],
            "dependencies": [
                "ReplicationControllerSpecTemplateSetting"
            ],
            "key": "replication_controller.spec",
            "name": "ReplicationControllerSpecSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_selector",
                    "computed": false,
                    "required": true,
                    "help": [
                        "A label query over pods that should match the Replicas count. If Selector is",
                        "empty, it is defaulted to the labels present on the Pod template. Label keys",
                        "and values that must match in order to be controlled by this replication",
                        "controller, if empty defaulted to labels on Pod template. More info:",
                        "http://kubernetes.io/docs/user-guide/labels#label-selectors"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"selector\" <$> TF.attribute",
                    "name": "_selector",
                    "method": "selector",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasSelector",
                    "validate": false,
                    "optional": false,
                    "original": "selector"
                },
                {
                    "default": "_template",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Describes the pod that will be created if insufficient replicas are",
                        "detected. This takes precedence over a TemplateRef. More info:",
                        "http://kubernetes.io/docs/user-guide/replication-controller#pod-template"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"template\" <$> TF.attribute",
                    "name": "_template",
                    "method": "template",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateSetting s)",
                    "class": "HasTemplate",
                    "validate": true,
                    "optional": false,
                    "original": "template"
                }
            ],
            "conflicts": [],
            "type": "ReplicationControllerSpecSetting s",
            "original": "spec"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateContainerEnvSetting",
                "name": "ReplicationControllerSpecTemplateContainerEnvSetting'"
            },
            "arguments": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the environment variable. Must be a C_IDENTIFIER"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Variable references $(VAR_NAME) are expanded using the previous defined",
                        "environment variables in the container and any service environment",
                        "variables. If a variable cannot be resolved, the reference in the input",
                        "string will be unchanged. The $(VAR_NAME) syntax can be escaped with a",
                        "double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,",
                        "regardless of whether the variable exists or not. Defaults to \"\"."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"value\" <$> TF.attribute",
                    "name": "_value",
                    "method": "value",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasValue",
                    "validate": false,
                    "optional": true,
                    "original": "value"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Source for the environment variable's value"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"value_from\" <$> TF.attribute",
                    "name": "_valueFrom",
                    "method": "valueFrom",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateContainerEnvValueFromSetting s)",
                    "class": "HasValueFrom",
                    "validate": true,
                    "optional": true,
                    "original": "value_from"
                }
            ],
            "dependencies": [
                "ReplicationControllerSpecTemplateContainerEnvValueFromSetting"
            ],
            "key": "replication_controller.spec.template.container.env",
            "name": "ReplicationControllerSpecTemplateContainerEnvSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the environment variable. Must be a C_IDENTIFIER"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateContainerEnvSetting s",
            "original": "env"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateContainerEnvValueFromConfigMapKeyRefSetting",
                "name": "ReplicationControllerSpecTemplateContainerEnvValueFromConfigMapKeyRefSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The key to select."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"key\" <$> TF.attribute",
                    "name": "_key",
                    "method": "key",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasKey",
                    "validate": false,
                    "optional": true,
                    "original": "key"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.container.env.value_from.config_map_key_ref",
            "name": "ReplicationControllerSpecTemplateContainerEnvValueFromConfigMapKeyRefSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateContainerEnvValueFromConfigMapKeyRefSetting s",
            "original": "config_map_key_ref"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateContainerEnvValueFromFieldRefSetting",
                "name": "ReplicationControllerSpecTemplateContainerEnvValueFromFieldRefSetting'"
            },
            "arguments": [
                {
                    "default": "TF.value \"v1\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Version of the schema the FieldPath is written in terms of, defaults to",
                        "\"v1\"."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"api_version\" <$> TF.attribute",
                    "name": "_apiVersion",
                    "method": "apiVersion",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasApiVersion",
                    "validate": false,
                    "optional": true,
                    "original": "api_version"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path of the field to select in the specified API version"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"field_path\" <$> TF.attribute",
                    "name": "_fieldPath",
                    "method": "fieldPath",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFieldPath",
                    "validate": false,
                    "optional": true,
                    "original": "field_path"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.container.env.value_from.field_ref",
            "name": "ReplicationControllerSpecTemplateContainerEnvValueFromFieldRefSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateContainerEnvValueFromFieldRefSetting s",
            "original": "field_ref"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateContainerEnvValueFromResourceFieldRefSetting",
                "name": "ReplicationControllerSpecTemplateContainerEnvValueFromResourceFieldRefSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"container_name\" <$> TF.attribute",
                    "name": "_containerName",
                    "method": "containerName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasContainerName",
                    "validate": false,
                    "optional": true,
                    "original": "container_name"
                },
                {
                    "default": "_resource'",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Resource to select"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource\" <$> TF.attribute",
                    "name": "_resource'",
                    "method": "resource'",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasResource'",
                    "validate": false,
                    "optional": false,
                    "original": "resource"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.container.env.value_from.resource_field_ref",
            "name": "ReplicationControllerSpecTemplateContainerEnvValueFromResourceFieldRefSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_resource'",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Resource to select"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource\" <$> TF.attribute",
                    "name": "_resource'",
                    "method": "resource'",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasResource'",
                    "validate": false,
                    "optional": false,
                    "original": "resource"
                }
            ],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateContainerEnvValueFromResourceFieldRefSetting s",
            "original": "resource_field_ref"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateContainerEnvValueFromSecretKeyRefSetting",
                "name": "ReplicationControllerSpecTemplateContainerEnvValueFromSecretKeyRefSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The key of the secret to select from. Must be a valid secret key."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"key\" <$> TF.attribute",
                    "name": "_key",
                    "method": "key",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasKey",
                    "validate": false,
                    "optional": true,
                    "original": "key"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.container.env.value_from.secret_key_ref",
            "name": "ReplicationControllerSpecTemplateContainerEnvValueFromSecretKeyRefSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateContainerEnvValueFromSecretKeyRefSetting s",
            "original": "secret_key_ref"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateContainerEnvValueFromSetting",
                "name": "ReplicationControllerSpecTemplateContainerEnvValueFromSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Selects a key of a ConfigMap."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"config_map_key_ref\" <$> TF.attribute",
                    "name": "_configMapKeyRef",
                    "method": "configMapKeyRef",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateContainerEnvValueFromConfigMapKeyRefSetting s)",
                    "class": "HasConfigMapKeyRef",
                    "validate": true,
                    "optional": true,
                    "original": "config_map_key_ref"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Selects a field of the pod: supports metadata.name, metadata.namespace,",
                        "metadata.labels, metadata.annotations, spec.nodeName,",
                        "spec.serviceAccountName, status.podIP.."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"field_ref\" <$> TF.attribute",
                    "name": "_fieldRef",
                    "method": "fieldRef",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateContainerEnvValueFromFieldRefSetting s)",
                    "class": "HasFieldRef",
                    "validate": true,
                    "optional": true,
                    "original": "field_ref"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Selects a field of the pod: supports metadata.name, metadata.namespace,",
                        "metadata.labels, metadata.annotations, spec.nodeName,",
                        "spec.serviceAccountName, status.podIP.."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_field_ref\" <$> TF.attribute",
                    "name": "_resourceFieldRef",
                    "method": "resourceFieldRef",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateContainerEnvValueFromResourceFieldRefSetting s)",
                    "class": "HasResourceFieldRef",
                    "validate": true,
                    "optional": true,
                    "original": "resource_field_ref"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Selects a field of the pod: supports metadata.name, metadata.namespace,",
                        "metadata.labels, metadata.annotations, spec.nodeName,",
                        "spec.serviceAccountName, status.podIP.."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_key_ref\" <$> TF.attribute",
                    "name": "_secretKeyRef",
                    "method": "secretKeyRef",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateContainerEnvValueFromSecretKeyRefSetting s)",
                    "class": "HasSecretKeyRef",
                    "validate": true,
                    "optional": true,
                    "original": "secret_key_ref"
                }
            ],
            "dependencies": [
                "ReplicationControllerSpecTemplateContainerEnvValueFromConfigMapKeyRefSetting",
                "ReplicationControllerSpecTemplateContainerEnvValueFromFieldRefSetting",
                "ReplicationControllerSpecTemplateContainerEnvValueFromResourceFieldRefSetting",
                "ReplicationControllerSpecTemplateContainerEnvValueFromSecretKeyRefSetting"
            ],
            "key": "replication_controller.spec.template.container.env.value_from",
            "name": "ReplicationControllerSpecTemplateContainerEnvValueFromSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateContainerEnvValueFromSetting s",
            "original": "value_from"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateContainerLifecyclePostStartExecSetting",
                "name": "ReplicationControllerSpecTemplateContainerLifecyclePostStartExecSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Command is the command line to execute inside the container, the working",
                        "directory for the command is root ('/') in the container's filesystem. The",
                        "command is simply exec'd, it is not run inside a shell, so traditional shell",
                        "instructions. To use a shell, you need to explicitly call out to that shell.",
                        "Exit status of 0 is treated as live/healthy and non-zero is unhealthy."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"command\" <$> TF.attribute",
                    "name": "_command",
                    "method": "command",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCommand",
                    "validate": false,
                    "optional": true,
                    "original": "command"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.container.lifecycle.post_start.exec",
            "name": "ReplicationControllerSpecTemplateContainerLifecyclePostStartExecSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateContainerLifecyclePostStartExecSetting s",
            "original": "exec"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateContainerLifecyclePostStartHttpGetHttpHeaderSetting",
                "name": "ReplicationControllerSpecTemplateContainerLifecyclePostStartHttpGetHttpHeaderSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The header field name"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The header field value"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"value\" <$> TF.attribute",
                    "name": "_value",
                    "method": "value",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasValue",
                    "validate": false,
                    "optional": true,
                    "original": "value"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.container.lifecycle.post_start.http_get.http_header",
            "name": "ReplicationControllerSpecTemplateContainerLifecyclePostStartHttpGetHttpHeaderSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateContainerLifecyclePostStartHttpGetHttpHeaderSetting s",
            "original": "http_header"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateContainerLifecyclePostStartHttpGetSetting",
                "name": "ReplicationControllerSpecTemplateContainerLifecyclePostStartHttpGetSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Host name to connect to, defaults to the pod IP. You probably want to set",
                        "\"Host\" in httpHeaders instead."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host\" <$> TF.attribute",
                    "name": "_host",
                    "method": "host",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHost",
                    "validate": false,
                    "optional": true,
                    "original": "host"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Scheme to use for connecting to the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_header\" <$> TF.attribute",
                    "name": "_httpHeader",
                    "method": "httpHeader",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ReplicationControllerSpecTemplateContainerLifecyclePostStartHttpGetHttpHeaderSetting s)]",
                    "class": "HasHttpHeader",
                    "validate": false,
                    "optional": true,
                    "original": "http_header"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path to access on the HTTP server."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": true,
                    "original": "path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name or number of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": true,
                    "original": "port"
                },
                {
                    "default": "TF.value \"HTTP\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Scheme to use for connecting to the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"scheme\" <$> TF.attribute",
                    "name": "_scheme",
                    "method": "scheme",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasScheme",
                    "validate": false,
                    "optional": true,
                    "original": "scheme"
                }
            ],
            "dependencies": [
                "ReplicationControllerSpecTemplateContainerLifecyclePostStartHttpGetHttpHeaderSetting"
            ],
            "key": "replication_controller.spec.template.container.lifecycle.post_start.http_get",
            "name": "ReplicationControllerSpecTemplateContainerLifecyclePostStartHttpGetSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateContainerLifecyclePostStartHttpGetSetting s",
            "original": "http_get"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateContainerLifecyclePostStartSetting",
                "name": "ReplicationControllerSpecTemplateContainerLifecyclePostStartSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Exec specifies the action to take."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"exec\" <$> TF.attribute",
                    "name": "_exec",
                    "method": "exec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateContainerLifecyclePostStartExecSetting s)",
                    "class": "HasExec",
                    "validate": true,
                    "optional": true,
                    "original": "exec"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Specifies the http request to perform."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_get\" <$> TF.attribute",
                    "name": "_httpGet",
                    "method": "httpGet",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateContainerLifecyclePostStartHttpGetSetting s)",
                    "class": "HasHttpGet",
                    "validate": true,
                    "optional": true,
                    "original": "http_get"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "TCPSocket specifies an action involving a TCP port. TCP hooks not yet",
                        "supported"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tcp_socket\" <$> TF.attribute",
                    "name": "_tcpSocket",
                    "method": "tcpSocket",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ReplicationControllerSpecTemplateContainerLifecyclePostStartTcpSocketSetting s)]",
                    "class": "HasTcpSocket",
                    "validate": false,
                    "optional": true,
                    "original": "tcp_socket"
                }
            ],
            "dependencies": [
                "ReplicationControllerSpecTemplateContainerLifecyclePostStartExecSetting",
                "ReplicationControllerSpecTemplateContainerLifecyclePostStartHttpGetSetting",
                "ReplicationControllerSpecTemplateContainerLifecyclePostStartTcpSocketSetting"
            ],
            "key": "replication_controller.spec.template.container.lifecycle.post_start",
            "name": "ReplicationControllerSpecTemplateContainerLifecyclePostStartSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateContainerLifecyclePostStartSetting s",
            "original": "post_start"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateContainerLifecyclePostStartTcpSocketSetting",
                "name": "ReplicationControllerSpecTemplateContainerLifecyclePostStartTcpSocketSetting'"
            },
            "arguments": [
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number or name of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.container.lifecycle.post_start.tcp_socket",
            "name": "ReplicationControllerSpecTemplateContainerLifecyclePostStartTcpSocketSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number or name of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                }
            ],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateContainerLifecyclePostStartTcpSocketSetting s",
            "original": "tcp_socket"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateContainerLifecyclePreStopExecSetting",
                "name": "ReplicationControllerSpecTemplateContainerLifecyclePreStopExecSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Command is the command line to execute inside the container, the working",
                        "directory for the command is root ('/') in the container's filesystem. The",
                        "command is simply exec'd, it is not run inside a shell, so traditional shell",
                        "instructions. To use a shell, you need to explicitly call out to that shell.",
                        "Exit status of 0 is treated as live/healthy and non-zero is unhealthy."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"command\" <$> TF.attribute",
                    "name": "_command",
                    "method": "command",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCommand",
                    "validate": false,
                    "optional": true,
                    "original": "command"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.container.lifecycle.pre_stop.exec",
            "name": "ReplicationControllerSpecTemplateContainerLifecyclePreStopExecSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateContainerLifecyclePreStopExecSetting s",
            "original": "exec"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateContainerLifecyclePreStopHttpGetHttpHeaderSetting",
                "name": "ReplicationControllerSpecTemplateContainerLifecyclePreStopHttpGetHttpHeaderSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The header field name"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The header field value"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"value\" <$> TF.attribute",
                    "name": "_value",
                    "method": "value",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasValue",
                    "validate": false,
                    "optional": true,
                    "original": "value"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.container.lifecycle.pre_stop.http_get.http_header",
            "name": "ReplicationControllerSpecTemplateContainerLifecyclePreStopHttpGetHttpHeaderSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateContainerLifecyclePreStopHttpGetHttpHeaderSetting s",
            "original": "http_header"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateContainerLifecyclePreStopHttpGetSetting",
                "name": "ReplicationControllerSpecTemplateContainerLifecyclePreStopHttpGetSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Host name to connect to, defaults to the pod IP. You probably want to set",
                        "\"Host\" in httpHeaders instead."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host\" <$> TF.attribute",
                    "name": "_host",
                    "method": "host",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHost",
                    "validate": false,
                    "optional": true,
                    "original": "host"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Scheme to use for connecting to the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_header\" <$> TF.attribute",
                    "name": "_httpHeader",
                    "method": "httpHeader",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ReplicationControllerSpecTemplateContainerLifecyclePreStopHttpGetHttpHeaderSetting s)]",
                    "class": "HasHttpHeader",
                    "validate": false,
                    "optional": true,
                    "original": "http_header"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path to access on the HTTP server."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": true,
                    "original": "path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name or number of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": true,
                    "original": "port"
                },
                {
                    "default": "TF.value \"HTTP\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Scheme to use for connecting to the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"scheme\" <$> TF.attribute",
                    "name": "_scheme",
                    "method": "scheme",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasScheme",
                    "validate": false,
                    "optional": true,
                    "original": "scheme"
                }
            ],
            "dependencies": [
                "ReplicationControllerSpecTemplateContainerLifecyclePreStopHttpGetHttpHeaderSetting"
            ],
            "key": "replication_controller.spec.template.container.lifecycle.pre_stop.http_get",
            "name": "ReplicationControllerSpecTemplateContainerLifecyclePreStopHttpGetSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateContainerLifecyclePreStopHttpGetSetting s",
            "original": "http_get"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateContainerLifecyclePreStopSetting",
                "name": "ReplicationControllerSpecTemplateContainerLifecyclePreStopSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Exec specifies the action to take."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"exec\" <$> TF.attribute",
                    "name": "_exec",
                    "method": "exec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateContainerLifecyclePreStopExecSetting s)",
                    "class": "HasExec",
                    "validate": true,
                    "optional": true,
                    "original": "exec"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Specifies the http request to perform."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_get\" <$> TF.attribute",
                    "name": "_httpGet",
                    "method": "httpGet",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateContainerLifecyclePreStopHttpGetSetting s)",
                    "class": "HasHttpGet",
                    "validate": true,
                    "optional": true,
                    "original": "http_get"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "TCPSocket specifies an action involving a TCP port. TCP hooks not yet",
                        "supported"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tcp_socket\" <$> TF.attribute",
                    "name": "_tcpSocket",
                    "method": "tcpSocket",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ReplicationControllerSpecTemplateContainerLifecyclePreStopTcpSocketSetting s)]",
                    "class": "HasTcpSocket",
                    "validate": false,
                    "optional": true,
                    "original": "tcp_socket"
                }
            ],
            "dependencies": [
                "ReplicationControllerSpecTemplateContainerLifecyclePreStopExecSetting",
                "ReplicationControllerSpecTemplateContainerLifecyclePreStopHttpGetSetting",
                "ReplicationControllerSpecTemplateContainerLifecyclePreStopTcpSocketSetting"
            ],
            "key": "replication_controller.spec.template.container.lifecycle.pre_stop",
            "name": "ReplicationControllerSpecTemplateContainerLifecyclePreStopSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateContainerLifecyclePreStopSetting s",
            "original": "pre_stop"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateContainerLifecyclePreStopTcpSocketSetting",
                "name": "ReplicationControllerSpecTemplateContainerLifecyclePreStopTcpSocketSetting'"
            },
            "arguments": [
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number or name of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.container.lifecycle.pre_stop.tcp_socket",
            "name": "ReplicationControllerSpecTemplateContainerLifecyclePreStopTcpSocketSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number or name of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                }
            ],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateContainerLifecyclePreStopTcpSocketSetting s",
            "original": "tcp_socket"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateContainerLifecycleSetting",
                "name": "ReplicationControllerSpecTemplateContainerLifecycleSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Post_start is called immediately after a container is created. If the",
                        "handler fails, the container is terminated and restarted according to its",
                        "restart policy. Other management of the container blocks until the hook",
                        "completes. More info:",
                        "http://kubernetes.io/docs/user-guide/container-environment#hook-details"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"post_start\" <$> TF.attribute",
                    "name": "_postStart",
                    "method": "postStart",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ReplicationControllerSpecTemplateContainerLifecyclePostStartSetting s)]",
                    "class": "HasPostStart",
                    "validate": false,
                    "optional": true,
                    "original": "post_start"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Pre_stop is called immediately before a container is terminated. The",
                        "container is terminated after the handler completes. The reason for",
                        "termination is passed to the handler. Regardless of the outcome of the",
                        "handler, the container is eventually terminated. Other management of the",
                        "container blocks until the hook completes. More info:",
                        "http://kubernetes.io/docs/user-guide/container-environment#hook-details"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"pre_stop\" <$> TF.attribute",
                    "name": "_preStop",
                    "method": "preStop",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ReplicationControllerSpecTemplateContainerLifecyclePreStopSetting s)]",
                    "class": "HasPreStop",
                    "validate": false,
                    "optional": true,
                    "original": "pre_stop"
                }
            ],
            "dependencies": [
                "ReplicationControllerSpecTemplateContainerLifecyclePostStartSetting",
                "ReplicationControllerSpecTemplateContainerLifecyclePreStopSetting"
            ],
            "key": "replication_controller.spec.template.container.lifecycle",
            "name": "ReplicationControllerSpecTemplateContainerLifecycleSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateContainerLifecycleSetting s",
            "original": "lifecycle"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateContainerLivenessProbeExecSetting",
                "name": "ReplicationControllerSpecTemplateContainerLivenessProbeExecSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Command is the command line to execute inside the container, the working",
                        "directory for the command is root ('/') in the container's filesystem. The",
                        "command is simply exec'd, it is not run inside a shell, so traditional shell",
                        "instructions. To use a shell, you need to explicitly call out to that shell.",
                        "Exit status of 0 is treated as live/healthy and non-zero is unhealthy."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"command\" <$> TF.attribute",
                    "name": "_command",
                    "method": "command",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCommand",
                    "validate": false,
                    "optional": true,
                    "original": "command"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.container.liveness_probe.exec",
            "name": "ReplicationControllerSpecTemplateContainerLivenessProbeExecSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateContainerLivenessProbeExecSetting s",
            "original": "exec"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateContainerLivenessProbeHttpGetHttpHeaderSetting",
                "name": "ReplicationControllerSpecTemplateContainerLivenessProbeHttpGetHttpHeaderSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The header field name"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The header field value"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"value\" <$> TF.attribute",
                    "name": "_value",
                    "method": "value",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasValue",
                    "validate": false,
                    "optional": true,
                    "original": "value"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.container.liveness_probe.http_get.http_header",
            "name": "ReplicationControllerSpecTemplateContainerLivenessProbeHttpGetHttpHeaderSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateContainerLivenessProbeHttpGetHttpHeaderSetting s",
            "original": "http_header"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateContainerLivenessProbeHttpGetSetting",
                "name": "ReplicationControllerSpecTemplateContainerLivenessProbeHttpGetSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Host name to connect to, defaults to the pod IP. You probably want to set",
                        "\"Host\" in httpHeaders instead."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host\" <$> TF.attribute",
                    "name": "_host",
                    "method": "host",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHost",
                    "validate": false,
                    "optional": true,
                    "original": "host"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Scheme to use for connecting to the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_header\" <$> TF.attribute",
                    "name": "_httpHeader",
                    "method": "httpHeader",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ReplicationControllerSpecTemplateContainerLivenessProbeHttpGetHttpHeaderSetting s)]",
                    "class": "HasHttpHeader",
                    "validate": false,
                    "optional": true,
                    "original": "http_header"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path to access on the HTTP server."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": true,
                    "original": "path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name or number of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": true,
                    "original": "port"
                },
                {
                    "default": "TF.value \"HTTP\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Scheme to use for connecting to the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"scheme\" <$> TF.attribute",
                    "name": "_scheme",
                    "method": "scheme",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasScheme",
                    "validate": false,
                    "optional": true,
                    "original": "scheme"
                }
            ],
            "dependencies": [
                "ReplicationControllerSpecTemplateContainerLivenessProbeHttpGetHttpHeaderSetting"
            ],
            "key": "replication_controller.spec.template.container.liveness_probe.http_get",
            "name": "ReplicationControllerSpecTemplateContainerLivenessProbeHttpGetSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateContainerLivenessProbeHttpGetSetting s",
            "original": "http_get"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateContainerLivenessProbeSetting",
                "name": "ReplicationControllerSpecTemplateContainerLivenessProbeSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Exec specifies the action to take."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"exec\" <$> TF.attribute",
                    "name": "_exec",
                    "method": "exec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateContainerLivenessProbeExecSetting s)",
                    "class": "HasExec",
                    "validate": true,
                    "optional": true,
                    "original": "exec"
                },
                {
                    "default": "TF.value 3",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Minimum consecutive failures for the probe to be considered failed after",
                        "having succeeded."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"failure_threshold\" <$> TF.attribute",
                    "name": "_failureThreshold",
                    "method": "failureThreshold",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasFailureThreshold",
                    "validate": false,
                    "optional": true,
                    "original": "failure_threshold"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Specifies the http request to perform."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_get\" <$> TF.attribute",
                    "name": "_httpGet",
                    "method": "httpGet",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateContainerLivenessProbeHttpGetSetting s)",
                    "class": "HasHttpGet",
                    "validate": true,
                    "optional": true,
                    "original": "http_get"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Number of seconds after the container has started before liveness probes are",
                        "initiated. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"initial_delay_seconds\" <$> TF.attribute",
                    "name": "_initialDelaySeconds",
                    "method": "initialDelaySeconds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasInitialDelaySeconds",
                    "validate": false,
                    "optional": true,
                    "original": "initial_delay_seconds"
                },
                {
                    "default": "TF.value 10",
                    "computed": false,
                    "required": false,
                    "help": [
                        "How often (in seconds) to perform the probe"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"period_seconds\" <$> TF.attribute",
                    "name": "_periodSeconds",
                    "method": "periodSeconds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasPeriodSeconds",
                    "validate": false,
                    "optional": true,
                    "original": "period_seconds"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Minimum consecutive successes for the probe to be considered successful",
                        "after having failed."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"success_threshold\" <$> TF.attribute",
                    "name": "_successThreshold",
                    "method": "successThreshold",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasSuccessThreshold",
                    "validate": false,
                    "optional": true,
                    "original": "success_threshold"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "TCPSocket specifies an action involving a TCP port. TCP hooks not yet",
                        "supported"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tcp_socket\" <$> TF.attribute",
                    "name": "_tcpSocket",
                    "method": "tcpSocket",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ReplicationControllerSpecTemplateContainerLivenessProbeTcpSocketSetting s)]",
                    "class": "HasTcpSocket",
                    "validate": false,
                    "optional": true,
                    "original": "tcp_socket"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Number of seconds after which the probe times out. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"timeout_seconds\" <$> TF.attribute",
                    "name": "_timeoutSeconds",
                    "method": "timeoutSeconds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasTimeoutSeconds",
                    "validate": false,
                    "optional": true,
                    "original": "timeout_seconds"
                }
            ],
            "dependencies": [
                "ReplicationControllerSpecTemplateContainerLivenessProbeExecSetting",
                "ReplicationControllerSpecTemplateContainerLivenessProbeHttpGetSetting",
                "ReplicationControllerSpecTemplateContainerLivenessProbeTcpSocketSetting"
            ],
            "key": "replication_controller.spec.template.container.liveness_probe",
            "name": "ReplicationControllerSpecTemplateContainerLivenessProbeSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateContainerLivenessProbeSetting s",
            "original": "liveness_probe"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateContainerLivenessProbeTcpSocketSetting",
                "name": "ReplicationControllerSpecTemplateContainerLivenessProbeTcpSocketSetting'"
            },
            "arguments": [
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number or name of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.container.liveness_probe.tcp_socket",
            "name": "ReplicationControllerSpecTemplateContainerLivenessProbeTcpSocketSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number or name of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                }
            ],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateContainerLivenessProbeTcpSocketSetting s",
            "original": "tcp_socket"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateContainerPortSetting",
                "name": "ReplicationControllerSpecTemplateContainerPortSetting'"
            },
            "arguments": [
                {
                    "default": "_containerPort",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number of port to expose on the pod's IP address. This must be a valid port",
                        "number, 0 < x < 65536."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"container_port\" <$> TF.attribute",
                    "name": "_containerPort",
                    "method": "containerPort",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasContainerPort",
                    "validate": false,
                    "optional": false,
                    "original": "container_port"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "What host IP to bind the external port to."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_ip\" <$> TF.attribute",
                    "name": "_hostIp",
                    "method": "hostIp",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHostIp",
                    "validate": false,
                    "optional": true,
                    "original": "host_ip"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Number of port to expose on the host. If specified, this must be a valid",
                        "port number, 0 < x < 65536. If HostNetwork is specified, this must match",
                        "ContainerPort. Most containers do not need this."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_port\" <$> TF.attribute",
                    "name": "_hostPort",
                    "method": "hostPort",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasHostPort",
                    "validate": false,
                    "optional": true,
                    "original": "host_port"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If specified, this must be an IANA_SVC_NAME and unique within the pod. Each",
                        "named port in a pod must have a unique name. Name for the port that can be",
                        "referred to by services"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.value \"TCP\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Protocol for port. Must be UDP or TCP. Defaults to \"TCP\"."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"protocol\" <$> TF.attribute",
                    "name": "_protocol",
                    "method": "protocol",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasProtocol",
                    "validate": false,
                    "optional": true,
                    "original": "protocol"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.container.port",
            "name": "ReplicationControllerSpecTemplateContainerPortSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_containerPort",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number of port to expose on the pod's IP address. This must be a valid port",
                        "number, 0 < x < 65536."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"container_port\" <$> TF.attribute",
                    "name": "_containerPort",
                    "method": "containerPort",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasContainerPort",
                    "validate": false,
                    "optional": false,
                    "original": "container_port"
                }
            ],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateContainerPortSetting s",
            "original": "port"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateContainerReadinessProbeExecSetting",
                "name": "ReplicationControllerSpecTemplateContainerReadinessProbeExecSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Command is the command line to execute inside the container, the working",
                        "directory for the command is root ('/') in the container's filesystem. The",
                        "command is simply exec'd, it is not run inside a shell, so traditional shell",
                        "instructions. To use a shell, you need to explicitly call out to that shell.",
                        "Exit status of 0 is treated as live/healthy and non-zero is unhealthy."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"command\" <$> TF.attribute",
                    "name": "_command",
                    "method": "command",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCommand",
                    "validate": false,
                    "optional": true,
                    "original": "command"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.container.readiness_probe.exec",
            "name": "ReplicationControllerSpecTemplateContainerReadinessProbeExecSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateContainerReadinessProbeExecSetting s",
            "original": "exec"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateContainerReadinessProbeHttpGetHttpHeaderSetting",
                "name": "ReplicationControllerSpecTemplateContainerReadinessProbeHttpGetHttpHeaderSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The header field name"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The header field value"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"value\" <$> TF.attribute",
                    "name": "_value",
                    "method": "value",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasValue",
                    "validate": false,
                    "optional": true,
                    "original": "value"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.container.readiness_probe.http_get.http_header",
            "name": "ReplicationControllerSpecTemplateContainerReadinessProbeHttpGetHttpHeaderSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateContainerReadinessProbeHttpGetHttpHeaderSetting s",
            "original": "http_header"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateContainerReadinessProbeHttpGetSetting",
                "name": "ReplicationControllerSpecTemplateContainerReadinessProbeHttpGetSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Host name to connect to, defaults to the pod IP. You probably want to set",
                        "\"Host\" in httpHeaders instead."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host\" <$> TF.attribute",
                    "name": "_host",
                    "method": "host",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHost",
                    "validate": false,
                    "optional": true,
                    "original": "host"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Scheme to use for connecting to the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_header\" <$> TF.attribute",
                    "name": "_httpHeader",
                    "method": "httpHeader",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ReplicationControllerSpecTemplateContainerReadinessProbeHttpGetHttpHeaderSetting s)]",
                    "class": "HasHttpHeader",
                    "validate": false,
                    "optional": true,
                    "original": "http_header"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path to access on the HTTP server."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": true,
                    "original": "path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name or number of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": true,
                    "original": "port"
                },
                {
                    "default": "TF.value \"HTTP\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Scheme to use for connecting to the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"scheme\" <$> TF.attribute",
                    "name": "_scheme",
                    "method": "scheme",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasScheme",
                    "validate": false,
                    "optional": true,
                    "original": "scheme"
                }
            ],
            "dependencies": [
                "ReplicationControllerSpecTemplateContainerReadinessProbeHttpGetHttpHeaderSetting"
            ],
            "key": "replication_controller.spec.template.container.readiness_probe.http_get",
            "name": "ReplicationControllerSpecTemplateContainerReadinessProbeHttpGetSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateContainerReadinessProbeHttpGetSetting s",
            "original": "http_get"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateContainerReadinessProbeSetting",
                "name": "ReplicationControllerSpecTemplateContainerReadinessProbeSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Exec specifies the action to take."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"exec\" <$> TF.attribute",
                    "name": "_exec",
                    "method": "exec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateContainerReadinessProbeExecSetting s)",
                    "class": "HasExec",
                    "validate": true,
                    "optional": true,
                    "original": "exec"
                },
                {
                    "default": "TF.value 3",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Minimum consecutive failures for the probe to be considered failed after",
                        "having succeeded."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"failure_threshold\" <$> TF.attribute",
                    "name": "_failureThreshold",
                    "method": "failureThreshold",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasFailureThreshold",
                    "validate": false,
                    "optional": true,
                    "original": "failure_threshold"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Specifies the http request to perform."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_get\" <$> TF.attribute",
                    "name": "_httpGet",
                    "method": "httpGet",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateContainerReadinessProbeHttpGetSetting s)",
                    "class": "HasHttpGet",
                    "validate": true,
                    "optional": true,
                    "original": "http_get"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Number of seconds after the container has started before liveness probes are",
                        "initiated. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"initial_delay_seconds\" <$> TF.attribute",
                    "name": "_initialDelaySeconds",
                    "method": "initialDelaySeconds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasInitialDelaySeconds",
                    "validate": false,
                    "optional": true,
                    "original": "initial_delay_seconds"
                },
                {
                    "default": "TF.value 10",
                    "computed": false,
                    "required": false,
                    "help": [
                        "How often (in seconds) to perform the probe"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"period_seconds\" <$> TF.attribute",
                    "name": "_periodSeconds",
                    "method": "periodSeconds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasPeriodSeconds",
                    "validate": false,
                    "optional": true,
                    "original": "period_seconds"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Minimum consecutive successes for the probe to be considered successful",
                        "after having failed."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"success_threshold\" <$> TF.attribute",
                    "name": "_successThreshold",
                    "method": "successThreshold",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasSuccessThreshold",
                    "validate": false,
                    "optional": true,
                    "original": "success_threshold"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "TCPSocket specifies an action involving a TCP port. TCP hooks not yet",
                        "supported"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tcp_socket\" <$> TF.attribute",
                    "name": "_tcpSocket",
                    "method": "tcpSocket",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ReplicationControllerSpecTemplateContainerReadinessProbeTcpSocketSetting s)]",
                    "class": "HasTcpSocket",
                    "validate": false,
                    "optional": true,
                    "original": "tcp_socket"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Number of seconds after which the probe times out. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"timeout_seconds\" <$> TF.attribute",
                    "name": "_timeoutSeconds",
                    "method": "timeoutSeconds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasTimeoutSeconds",
                    "validate": false,
                    "optional": true,
                    "original": "timeout_seconds"
                }
            ],
            "dependencies": [
                "ReplicationControllerSpecTemplateContainerReadinessProbeExecSetting",
                "ReplicationControllerSpecTemplateContainerReadinessProbeHttpGetSetting",
                "ReplicationControllerSpecTemplateContainerReadinessProbeTcpSocketSetting"
            ],
            "key": "replication_controller.spec.template.container.readiness_probe",
            "name": "ReplicationControllerSpecTemplateContainerReadinessProbeSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateContainerReadinessProbeSetting s",
            "original": "readiness_probe"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateContainerReadinessProbeTcpSocketSetting",
                "name": "ReplicationControllerSpecTemplateContainerReadinessProbeTcpSocketSetting'"
            },
            "arguments": [
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number or name of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.container.readiness_probe.tcp_socket",
            "name": "ReplicationControllerSpecTemplateContainerReadinessProbeTcpSocketSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number or name of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                }
            ],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateContainerReadinessProbeTcpSocketSetting s",
            "original": "tcp_socket"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateContainerResourcesLimitsSetting",
                "name": "ReplicationControllerSpecTemplateContainerResourcesLimitsSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu\" <$> TF.attribute",
                    "name": "_cpu",
                    "method": "cpu",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasCpu",
                    "validate": false,
                    "optional": true,
                    "original": "cpu"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory\" <$> TF.attribute",
                    "name": "_memory",
                    "method": "memory",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasMemory",
                    "validate": false,
                    "optional": true,
                    "original": "memory"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.container.resources.limits",
            "name": "ReplicationControllerSpecTemplateContainerResourcesLimitsSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu\" <$> TF.attribute",
                    "name": "_computedCpu",
                    "method": "computedCpu",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedCpu",
                    "validate": false,
                    "optional": false,
                    "original": "cpu"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory\" <$> TF.attribute",
                    "name": "_computedMemory",
                    "method": "computedMemory",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedMemory",
                    "validate": false,
                    "optional": false,
                    "original": "memory"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateContainerResourcesLimitsSetting s",
            "original": "limits"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateContainerResourcesRequestsSetting",
                "name": "ReplicationControllerSpecTemplateContainerResourcesRequestsSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu\" <$> TF.attribute",
                    "name": "_cpu",
                    "method": "cpu",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasCpu",
                    "validate": false,
                    "optional": true,
                    "original": "cpu"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory\" <$> TF.attribute",
                    "name": "_memory",
                    "method": "memory",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasMemory",
                    "validate": false,
                    "optional": true,
                    "original": "memory"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.container.resources.requests",
            "name": "ReplicationControllerSpecTemplateContainerResourcesRequestsSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu\" <$> TF.attribute",
                    "name": "_computedCpu",
                    "method": "computedCpu",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedCpu",
                    "validate": false,
                    "optional": false,
                    "original": "cpu"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory\" <$> TF.attribute",
                    "name": "_computedMemory",
                    "method": "computedMemory",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedMemory",
                    "validate": false,
                    "optional": false,
                    "original": "memory"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateContainerResourcesRequestsSetting s",
            "original": "requests"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateContainerResourcesSetting",
                "name": "ReplicationControllerSpecTemplateContainerResourcesSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Describes the maximum amount of compute resources allowed. More info:",
                        "http://kubernetes.io/docs/user-guide/compute-resources/"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"limits\" <$> TF.attribute",
                    "name": "_limits",
                    "method": "limits",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateContainerResourcesLimitsSetting s)",
                    "class": "HasLimits",
                    "validate": true,
                    "optional": true,
                    "original": "limits"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"requests\" <$> TF.attribute",
                    "name": "_requests",
                    "method": "requests",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateContainerResourcesRequestsSetting s)",
                    "class": "HasRequests",
                    "validate": true,
                    "optional": true,
                    "original": "requests"
                }
            ],
            "dependencies": [
                "ReplicationControllerSpecTemplateContainerResourcesLimitsSetting",
                "ReplicationControllerSpecTemplateContainerResourcesRequestsSetting",
                "ReplicationControllerSpecTemplateContainerResourcesLimitsSetting",
                "ReplicationControllerSpecTemplateContainerResourcesRequestsSetting"
            ],
            "key": "replication_controller.spec.template.container.resources",
            "name": "ReplicationControllerSpecTemplateContainerResourcesSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Describes the maximum amount of compute resources allowed. More info:",
                        "http://kubernetes.io/docs/user-guide/compute-resources/"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"limits\" <$> TF.attribute",
                    "name": "_computedLimits",
                    "method": "computedLimits",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateContainerResourcesLimitsSetting s)",
                    "class": "HasComputedLimits",
                    "validate": true,
                    "optional": false,
                    "original": "limits"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"requests\" <$> TF.attribute",
                    "name": "_computedRequests",
                    "method": "computedRequests",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateContainerResourcesRequestsSetting s)",
                    "class": "HasComputedRequests",
                    "validate": true,
                    "optional": false,
                    "original": "requests"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateContainerResourcesSetting s",
            "original": "resources"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateContainerSecurityContextCapabilitiesSetting",
                "name": "ReplicationControllerSpecTemplateContainerSecurityContextCapabilitiesSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Added capabilities"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"add\" <$> TF.attribute",
                    "name": "_add",
                    "method": "add",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasAdd",
                    "validate": false,
                    "optional": true,
                    "original": "add"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Removed capabilities"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"drop\" <$> TF.attribute",
                    "name": "_drop",
                    "method": "drop",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasDrop",
                    "validate": false,
                    "optional": true,
                    "original": "drop"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.container.security_context.capabilities",
            "name": "ReplicationControllerSpecTemplateContainerSecurityContextCapabilitiesSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateContainerSecurityContextCapabilitiesSetting s",
            "original": "capabilities"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateContainerSecurityContextSeLinuxOptionsSetting",
                "name": "ReplicationControllerSpecTemplateContainerSecurityContextSeLinuxOptionsSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Level is SELinux level label that applies to the container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"level\" <$> TF.attribute",
                    "name": "_level",
                    "method": "level",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasLevel",
                    "validate": false,
                    "optional": true,
                    "original": "level"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Role is a SELinux role label that applies to the container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"role\" <$> TF.attribute",
                    "name": "_role",
                    "method": "role",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRole",
                    "validate": false,
                    "optional": true,
                    "original": "role"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Type is a SELinux type label that applies to the container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"type\" <$> TF.attribute",
                    "name": "_type'",
                    "method": "type'",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasType'",
                    "validate": false,
                    "optional": true,
                    "original": "type"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "User is a SELinux user label that applies to the container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"user\" <$> TF.attribute",
                    "name": "_user",
                    "method": "user",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasUser",
                    "validate": false,
                    "optional": true,
                    "original": "user"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.container.security_context.se_linux_options",
            "name": "ReplicationControllerSpecTemplateContainerSecurityContextSeLinuxOptionsSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateContainerSecurityContextSeLinuxOptionsSetting s",
            "original": "se_linux_options"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateContainerSecurityContextSetting",
                "name": "ReplicationControllerSpecTemplateContainerSecurityContextSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The capabilities to add/drop when running containers. Defaults to the",
                        "default set of capabilities granted by the container runtime."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"capabilities\" <$> TF.attribute",
                    "name": "_capabilities",
                    "method": "capabilities",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateContainerSecurityContextCapabilitiesSetting s)",
                    "class": "HasCapabilities",
                    "validate": true,
                    "optional": true,
                    "original": "capabilities"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Run container in privileged mode. Processes in privileged containers are",
                        "essentially equivalent to root on the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"privileged\" <$> TF.attribute",
                    "name": "_privileged",
                    "method": "privileged",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasPrivileged",
                    "validate": false,
                    "optional": true,
                    "original": "privileged"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether this container has a read-only root filesystem."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only_root_filesystem\" <$> TF.attribute",
                    "name": "_readOnlyRootFilesystem",
                    "method": "readOnlyRootFilesystem",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnlyRootFilesystem",
                    "validate": false,
                    "optional": true,
                    "original": "read_only_root_filesystem"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Indicates that the container must run as a non-root user. If true, the",
                        "Kubelet will validate the image at runtime to ensure that it does not run as",
                        "UID 0 (root) and fail to start the container if it does."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"run_as_non_root\" <$> TF.attribute",
                    "name": "_runAsNonRoot",
                    "method": "runAsNonRoot",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasRunAsNonRoot",
                    "validate": false,
                    "optional": true,
                    "original": "run_as_non_root"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The UID to run the entrypoint of the container process. Defaults to user",
                        "specified in image metadata if unspecified"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"run_as_user\" <$> TF.attribute",
                    "name": "_runAsUser",
                    "method": "runAsUser",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasRunAsUser",
                    "validate": false,
                    "optional": true,
                    "original": "run_as_user"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "ImagePullSecrets is an optional list of references to secrets in the same",
                        "namespace to use for pulling any of the images used by this PodSpec. If",
                        "specified, these secrets will be passed to individual puller implementations",
                        "for them to use. For example, in the case of docker, only DockerConfig type",
                        "secrets are honored. More info:",
                        "http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"se_linux_options\" <$> TF.attribute",
                    "name": "_seLinuxOptions",
                    "method": "seLinuxOptions",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateContainerSecurityContextSeLinuxOptionsSetting s)",
                    "class": "HasSeLinuxOptions",
                    "validate": true,
                    "optional": true,
                    "original": "se_linux_options"
                }
            ],
            "dependencies": [
                "ReplicationControllerSpecTemplateContainerSecurityContextCapabilitiesSetting",
                "ReplicationControllerSpecTemplateContainerSecurityContextSeLinuxOptionsSetting"
            ],
            "key": "replication_controller.spec.template.container.security_context",
            "name": "ReplicationControllerSpecTemplateContainerSecurityContextSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateContainerSecurityContextSetting s",
            "original": "security_context"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateContainerSetting",
                "name": "ReplicationControllerSpecTemplateContainerSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Arguments to the entrypoint. The docker image's CMD is used if this is not",
                        "provided. Variable references $(VAR_NAME) are expanded using the container's",
                        "environment. If a variable cannot be resolved, the reference in the input",
                        "string will be unchanged. The $(VAR_NAME) syntax can be escaped with a",
                        "double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,",
                        "regardless of whether the variable exists or not. Cannot be updated. More",
                        "info:",
                        "http://kubernetes.io/docs/user-guide/containers#containers-and-commands"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"args\" <$> TF.attribute",
                    "name": "_args",
                    "method": "args",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasArgs",
                    "validate": false,
                    "optional": true,
                    "original": "args"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT",
                        "is used if this is not provided. Variable references $(VAR_NAME) are",
                        "expanded using the container's environment. If a variable cannot be",
                        "resolved, the reference in the input string will be unchanged. The",
                        "$(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).",
                        "Escaped references will never be expanded, regardless of whether the",
                        "variable exists or not. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/containers#containers-and-commands"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"command\" <$> TF.attribute",
                    "name": "_command",
                    "method": "command",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCommand",
                    "validate": false,
                    "optional": true,
                    "original": "command"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of environment variables to set in the container. Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"env\" <$> TF.attribute",
                    "name": "_env",
                    "method": "env",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ReplicationControllerSpecTemplateContainerEnvSetting s)]",
                    "class": "HasEnv",
                    "validate": false,
                    "optional": true,
                    "original": "env"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Docker image name. More info: http://kubernetes.io/docs/user-guide/images"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"image\" <$> TF.attribute",
                    "name": "_image",
                    "method": "image",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasImage",
                    "validate": false,
                    "optional": true,
                    "original": "image"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if",
                        ":latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More",
                        "info: http://kubernetes.io/docs/user-guide/images#updating-images"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"image_pull_policy\" <$> TF.attribute",
                    "name": "_imagePullPolicy",
                    "method": "imagePullPolicy",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasImagePullPolicy",
                    "validate": false,
                    "optional": true,
                    "original": "image_pull_policy"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Actions that the management system should take in response to container",
                        "lifecycle events"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"lifecycle\" <$> TF.attribute",
                    "name": "_lifecycle",
                    "method": "lifecycle",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateContainerLifecycleSetting s)",
                    "class": "HasLifecycle",
                    "validate": true,
                    "optional": true,
                    "original": "lifecycle"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Periodic probe of container liveness. Container will be restarted if the",
                        "probe fails. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"liveness_probe\" <$> TF.attribute",
                    "name": "_livenessProbe",
                    "method": "livenessProbe",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateContainerLivenessProbeSetting s)",
                    "class": "HasLivenessProbe",
                    "validate": true,
                    "optional": true,
                    "original": "liveness_probe"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the container specified as a DNS_LABEL. Each container in a pod must",
                        "have a unique name (DNS_LABEL). Cannot be updated."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of ports to expose from the container. Exposing a port here gives the",
                        "system additional information about the network connections a container",
                        "uses, but is primarily informational. Not specifying a port here DOES NOT",
                        "prevent that port from being exposed. Any port which is listening on the",
                        "default \"0.0.0.0\" address inside a container will be accessible from the",
                        "network. Cannot be updated."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ReplicationControllerSpecTemplateContainerPortSetting s)]",
                    "class": "HasPort",
                    "validate": false,
                    "optional": true,
                    "original": "port"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Periodic probe of container service readiness. Container will be removed",
                        "from service endpoints if the probe fails. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"readiness_probe\" <$> TF.attribute",
                    "name": "_readinessProbe",
                    "method": "readinessProbe",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateContainerReadinessProbeSetting s)",
                    "class": "HasReadinessProbe",
                    "validate": true,
                    "optional": true,
                    "original": "readiness_probe"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Compute Resources required by this container. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#resources"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resources\" <$> TF.attribute",
                    "name": "_resources",
                    "method": "resources",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateContainerResourcesSetting s)",
                    "class": "HasResources",
                    "validate": true,
                    "optional": true,
                    "original": "resources"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Security options the pod should run with. More info:",
                        "http://releases.k8s.io/HEAD/docs/design/security_context.md"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"security_context\" <$> TF.attribute",
                    "name": "_securityContext",
                    "method": "securityContext",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateContainerSecurityContextSetting s)",
                    "class": "HasSecurityContext",
                    "validate": true,
                    "optional": true,
                    "original": "security_context"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether this container should allocate a buffer for stdin in the container",
                        "runtime. If this is not set, reads from stdin in the container will always",
                        "result in EOF."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"stdin\" <$> TF.attribute",
                    "name": "_stdin",
                    "method": "stdin",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasStdin",
                    "validate": false,
                    "optional": true,
                    "original": "stdin"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether the container runtime should close the stdin channel after it has",
                        "been opened by a single attach. When stdin is true the stdin stream will",
                        "remain open across multiple attach sessions. If stdinOnce is set to true,",
                        "stdin is opened on container start, is empty until the first client attaches",
                        "to stdin, and then remains open and accepts data until the client",
                        "disconnects, at which time stdin is closed and remains closed until the",
                        "container is restarted. If this flag is false, a container processes that",
                        "reads from stdin will never receive an EOF."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"stdin_once\" <$> TF.attribute",
                    "name": "_stdinOnce",
                    "method": "stdinOnce",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasStdinOnce",
                    "validate": false,
                    "optional": true,
                    "original": "stdin_once"
                },
                {
                    "default": "TF.value \"/dev/termination-log\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional: Path at which the file to which the container's termination",
                        "message will be written is mounted into the container's filesystem. Message",
                        "written is intended to be brief final status, such as an assertion failure",
                        "message. Defaults to /dev/termination-log. Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"termination_message_path\" <$> TF.attribute",
                    "name": "_terminationMessagePath",
                    "method": "terminationMessagePath",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasTerminationMessagePath",
                    "validate": false,
                    "optional": true,
                    "original": "termination_message_path"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether this container should allocate a TTY for itself"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tty\" <$> TF.attribute",
                    "name": "_tty",
                    "method": "tty",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasTty",
                    "validate": false,
                    "optional": true,
                    "original": "tty"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Pod volumes to mount into the container's filesystem. Cannot be updated."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_mount\" <$> TF.attribute",
                    "name": "_volumeMount",
                    "method": "volumeMount",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ReplicationControllerSpecTemplateContainerVolumeMountSetting s)]",
                    "class": "HasVolumeMount",
                    "validate": false,
                    "optional": true,
                    "original": "volume_mount"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Container's working directory. If not specified, the container runtime's",
                        "default will be used, which might be configured in the container image.",
                        "Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"working_dir\" <$> TF.attribute",
                    "name": "_workingDir",
                    "method": "workingDir",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasWorkingDir",
                    "validate": false,
                    "optional": true,
                    "original": "working_dir"
                }
            ],
            "dependencies": [
                "ReplicationControllerSpecTemplateContainerEnvSetting",
                "ReplicationControllerSpecTemplateContainerLifecycleSetting",
                "ReplicationControllerSpecTemplateContainerLivenessProbeSetting",
                "ReplicationControllerSpecTemplateContainerPortSetting",
                "ReplicationControllerSpecTemplateContainerReadinessProbeSetting",
                "ReplicationControllerSpecTemplateContainerResourcesSetting",
                "ReplicationControllerSpecTemplateContainerSecurityContextSetting",
                "ReplicationControllerSpecTemplateContainerVolumeMountSetting",
                "ReplicationControllerSpecTemplateContainerResourcesSetting"
            ],
            "key": "replication_controller.spec.template.container",
            "name": "ReplicationControllerSpecTemplateContainerSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if",
                        ":latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More",
                        "info: http://kubernetes.io/docs/user-guide/images#updating-images"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"image_pull_policy\" <$> TF.attribute",
                    "name": "_computedImagePullPolicy",
                    "method": "computedImagePullPolicy",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedImagePullPolicy",
                    "validate": false,
                    "optional": false,
                    "original": "image_pull_policy"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Compute Resources required by this container. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#resources"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resources\" <$> TF.attribute",
                    "name": "_computedResources",
                    "method": "computedResources",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateContainerResourcesSetting s)",
                    "class": "HasComputedResources",
                    "validate": true,
                    "optional": false,
                    "original": "resources"
                }
            ],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the container specified as a DNS_LABEL. Each container in a pod must",
                        "have a unique name (DNS_LABEL). Cannot be updated."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateContainerSetting s",
            "original": "container"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateContainerVolumeMountSetting",
                "name": "ReplicationControllerSpecTemplateContainerVolumeMountSetting'"
            },
            "arguments": [
                {
                    "default": "_mountPath",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path within the container at which the volume should be mounted. Must not",
                        "contain ':'."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"mount_path\" <$> TF.attribute",
                    "name": "_mountPath",
                    "method": "mountPath",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasMountPath",
                    "validate": false,
                    "optional": false,
                    "original": "mount_path"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "This must match the Name of a Volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Mounted read-only if true, read-write otherwise (false or unspecified).",
                        "Defaults to false."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path within the volume from which the container's volume should be mounted.",
                        "Defaults to \"\" (volume's root)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sub_path\" <$> TF.attribute",
                    "name": "_subPath",
                    "method": "subPath",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSubPath",
                    "validate": false,
                    "optional": true,
                    "original": "sub_path"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.container.volume_mount",
            "name": "ReplicationControllerSpecTemplateContainerVolumeMountSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "This must match the Name of a Volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "_mountPath",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path within the container at which the volume should be mounted. Must not",
                        "contain ':'."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"mount_path\" <$> TF.attribute",
                    "name": "_mountPath",
                    "method": "mountPath",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasMountPath",
                    "validate": false,
                    "optional": false,
                    "original": "mount_path"
                }
            ],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateContainerVolumeMountSetting s",
            "original": "volume_mount"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateImagePullSecretsSetting",
                "name": "ReplicationControllerSpecTemplateImagePullSecretsSetting'"
            },
            "arguments": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.image_pull_secrets",
            "name": "ReplicationControllerSpecTemplateImagePullSecretsSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateImagePullSecretsSetting s",
            "original": "image_pull_secrets"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateInitContainerEnvSetting",
                "name": "ReplicationControllerSpecTemplateInitContainerEnvSetting'"
            },
            "arguments": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the environment variable. Must be a C_IDENTIFIER"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Variable references $(VAR_NAME) are expanded using the previous defined",
                        "environment variables in the container and any service environment",
                        "variables. If a variable cannot be resolved, the reference in the input",
                        "string will be unchanged. The $(VAR_NAME) syntax can be escaped with a",
                        "double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,",
                        "regardless of whether the variable exists or not. Defaults to \"\"."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"value\" <$> TF.attribute",
                    "name": "_value",
                    "method": "value",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasValue",
                    "validate": false,
                    "optional": true,
                    "original": "value"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Source for the environment variable's value"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"value_from\" <$> TF.attribute",
                    "name": "_valueFrom",
                    "method": "valueFrom",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateInitContainerEnvValueFromSetting s)",
                    "class": "HasValueFrom",
                    "validate": true,
                    "optional": true,
                    "original": "value_from"
                }
            ],
            "dependencies": [
                "ReplicationControllerSpecTemplateInitContainerEnvValueFromSetting"
            ],
            "key": "replication_controller.spec.template.init_container.env",
            "name": "ReplicationControllerSpecTemplateInitContainerEnvSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the environment variable. Must be a C_IDENTIFIER"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateInitContainerEnvSetting s",
            "original": "env"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateInitContainerEnvValueFromConfigMapKeyRefSetting",
                "name": "ReplicationControllerSpecTemplateInitContainerEnvValueFromConfigMapKeyRefSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The key to select."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"key\" <$> TF.attribute",
                    "name": "_key",
                    "method": "key",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasKey",
                    "validate": false,
                    "optional": true,
                    "original": "key"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.init_container.env.value_from.config_map_key_ref",
            "name": "ReplicationControllerSpecTemplateInitContainerEnvValueFromConfigMapKeyRefSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateInitContainerEnvValueFromConfigMapKeyRefSetting s",
            "original": "config_map_key_ref"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateInitContainerEnvValueFromFieldRefSetting",
                "name": "ReplicationControllerSpecTemplateInitContainerEnvValueFromFieldRefSetting'"
            },
            "arguments": [
                {
                    "default": "TF.value \"v1\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Version of the schema the FieldPath is written in terms of, defaults to",
                        "\"v1\"."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"api_version\" <$> TF.attribute",
                    "name": "_apiVersion",
                    "method": "apiVersion",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasApiVersion",
                    "validate": false,
                    "optional": true,
                    "original": "api_version"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path of the field to select in the specified API version"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"field_path\" <$> TF.attribute",
                    "name": "_fieldPath",
                    "method": "fieldPath",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFieldPath",
                    "validate": false,
                    "optional": true,
                    "original": "field_path"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.init_container.env.value_from.field_ref",
            "name": "ReplicationControllerSpecTemplateInitContainerEnvValueFromFieldRefSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateInitContainerEnvValueFromFieldRefSetting s",
            "original": "field_ref"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateInitContainerEnvValueFromResourceFieldRefSetting",
                "name": "ReplicationControllerSpecTemplateInitContainerEnvValueFromResourceFieldRefSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"container_name\" <$> TF.attribute",
                    "name": "_containerName",
                    "method": "containerName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasContainerName",
                    "validate": false,
                    "optional": true,
                    "original": "container_name"
                },
                {
                    "default": "_resource'",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Resource to select"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource\" <$> TF.attribute",
                    "name": "_resource'",
                    "method": "resource'",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasResource'",
                    "validate": false,
                    "optional": false,
                    "original": "resource"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.init_container.env.value_from.resource_field_ref",
            "name": "ReplicationControllerSpecTemplateInitContainerEnvValueFromResourceFieldRefSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_resource'",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Resource to select"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource\" <$> TF.attribute",
                    "name": "_resource'",
                    "method": "resource'",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasResource'",
                    "validate": false,
                    "optional": false,
                    "original": "resource"
                }
            ],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateInitContainerEnvValueFromResourceFieldRefSetting s",
            "original": "resource_field_ref"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateInitContainerEnvValueFromSecretKeyRefSetting",
                "name": "ReplicationControllerSpecTemplateInitContainerEnvValueFromSecretKeyRefSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The key of the secret to select from. Must be a valid secret key."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"key\" <$> TF.attribute",
                    "name": "_key",
                    "method": "key",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasKey",
                    "validate": false,
                    "optional": true,
                    "original": "key"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.init_container.env.value_from.secret_key_ref",
            "name": "ReplicationControllerSpecTemplateInitContainerEnvValueFromSecretKeyRefSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateInitContainerEnvValueFromSecretKeyRefSetting s",
            "original": "secret_key_ref"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateInitContainerEnvValueFromSetting",
                "name": "ReplicationControllerSpecTemplateInitContainerEnvValueFromSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Selects a key of a ConfigMap."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"config_map_key_ref\" <$> TF.attribute",
                    "name": "_configMapKeyRef",
                    "method": "configMapKeyRef",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateInitContainerEnvValueFromConfigMapKeyRefSetting s)",
                    "class": "HasConfigMapKeyRef",
                    "validate": true,
                    "optional": true,
                    "original": "config_map_key_ref"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Selects a field of the pod: supports metadata.name, metadata.namespace,",
                        "metadata.labels, metadata.annotations, spec.nodeName,",
                        "spec.serviceAccountName, status.podIP.."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"field_ref\" <$> TF.attribute",
                    "name": "_fieldRef",
                    "method": "fieldRef",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateInitContainerEnvValueFromFieldRefSetting s)",
                    "class": "HasFieldRef",
                    "validate": true,
                    "optional": true,
                    "original": "field_ref"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Selects a field of the pod: supports metadata.name, metadata.namespace,",
                        "metadata.labels, metadata.annotations, spec.nodeName,",
                        "spec.serviceAccountName, status.podIP.."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_field_ref\" <$> TF.attribute",
                    "name": "_resourceFieldRef",
                    "method": "resourceFieldRef",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateInitContainerEnvValueFromResourceFieldRefSetting s)",
                    "class": "HasResourceFieldRef",
                    "validate": true,
                    "optional": true,
                    "original": "resource_field_ref"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Selects a field of the pod: supports metadata.name, metadata.namespace,",
                        "metadata.labels, metadata.annotations, spec.nodeName,",
                        "spec.serviceAccountName, status.podIP.."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_key_ref\" <$> TF.attribute",
                    "name": "_secretKeyRef",
                    "method": "secretKeyRef",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateInitContainerEnvValueFromSecretKeyRefSetting s)",
                    "class": "HasSecretKeyRef",
                    "validate": true,
                    "optional": true,
                    "original": "secret_key_ref"
                }
            ],
            "dependencies": [
                "ReplicationControllerSpecTemplateInitContainerEnvValueFromConfigMapKeyRefSetting",
                "ReplicationControllerSpecTemplateInitContainerEnvValueFromFieldRefSetting",
                "ReplicationControllerSpecTemplateInitContainerEnvValueFromResourceFieldRefSetting",
                "ReplicationControllerSpecTemplateInitContainerEnvValueFromSecretKeyRefSetting"
            ],
            "key": "replication_controller.spec.template.init_container.env.value_from",
            "name": "ReplicationControllerSpecTemplateInitContainerEnvValueFromSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateInitContainerEnvValueFromSetting s",
            "original": "value_from"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateInitContainerLifecyclePostStartExecSetting",
                "name": "ReplicationControllerSpecTemplateInitContainerLifecyclePostStartExecSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Command is the command line to execute inside the container, the working",
                        "directory for the command is root ('/') in the container's filesystem. The",
                        "command is simply exec'd, it is not run inside a shell, so traditional shell",
                        "instructions. To use a shell, you need to explicitly call out to that shell.",
                        "Exit status of 0 is treated as live/healthy and non-zero is unhealthy."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"command\" <$> TF.attribute",
                    "name": "_command",
                    "method": "command",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCommand",
                    "validate": false,
                    "optional": true,
                    "original": "command"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.init_container.lifecycle.post_start.exec",
            "name": "ReplicationControllerSpecTemplateInitContainerLifecyclePostStartExecSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateInitContainerLifecyclePostStartExecSetting s",
            "original": "exec"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateInitContainerLifecyclePostStartHttpGetHttpHeaderSetting",
                "name": "ReplicationControllerSpecTemplateInitContainerLifecyclePostStartHttpGetHttpHeaderSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The header field name"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The header field value"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"value\" <$> TF.attribute",
                    "name": "_value",
                    "method": "value",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasValue",
                    "validate": false,
                    "optional": true,
                    "original": "value"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.init_container.lifecycle.post_start.http_get.http_header",
            "name": "ReplicationControllerSpecTemplateInitContainerLifecyclePostStartHttpGetHttpHeaderSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateInitContainerLifecyclePostStartHttpGetHttpHeaderSetting s",
            "original": "http_header"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateInitContainerLifecyclePostStartHttpGetSetting",
                "name": "ReplicationControllerSpecTemplateInitContainerLifecyclePostStartHttpGetSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Host name to connect to, defaults to the pod IP. You probably want to set",
                        "\"Host\" in httpHeaders instead."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host\" <$> TF.attribute",
                    "name": "_host",
                    "method": "host",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHost",
                    "validate": false,
                    "optional": true,
                    "original": "host"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Scheme to use for connecting to the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_header\" <$> TF.attribute",
                    "name": "_httpHeader",
                    "method": "httpHeader",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ReplicationControllerSpecTemplateInitContainerLifecyclePostStartHttpGetHttpHeaderSetting s)]",
                    "class": "HasHttpHeader",
                    "validate": false,
                    "optional": true,
                    "original": "http_header"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path to access on the HTTP server."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": true,
                    "original": "path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name or number of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": true,
                    "original": "port"
                },
                {
                    "default": "TF.value \"HTTP\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Scheme to use for connecting to the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"scheme\" <$> TF.attribute",
                    "name": "_scheme",
                    "method": "scheme",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasScheme",
                    "validate": false,
                    "optional": true,
                    "original": "scheme"
                }
            ],
            "dependencies": [
                "ReplicationControllerSpecTemplateInitContainerLifecyclePostStartHttpGetHttpHeaderSetting"
            ],
            "key": "replication_controller.spec.template.init_container.lifecycle.post_start.http_get",
            "name": "ReplicationControllerSpecTemplateInitContainerLifecyclePostStartHttpGetSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateInitContainerLifecyclePostStartHttpGetSetting s",
            "original": "http_get"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateInitContainerLifecyclePostStartSetting",
                "name": "ReplicationControllerSpecTemplateInitContainerLifecyclePostStartSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Exec specifies the action to take."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"exec\" <$> TF.attribute",
                    "name": "_exec",
                    "method": "exec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateInitContainerLifecyclePostStartExecSetting s)",
                    "class": "HasExec",
                    "validate": true,
                    "optional": true,
                    "original": "exec"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Specifies the http request to perform."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_get\" <$> TF.attribute",
                    "name": "_httpGet",
                    "method": "httpGet",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateInitContainerLifecyclePostStartHttpGetSetting s)",
                    "class": "HasHttpGet",
                    "validate": true,
                    "optional": true,
                    "original": "http_get"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "TCPSocket specifies an action involving a TCP port. TCP hooks not yet",
                        "supported"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tcp_socket\" <$> TF.attribute",
                    "name": "_tcpSocket",
                    "method": "tcpSocket",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ReplicationControllerSpecTemplateInitContainerLifecyclePostStartTcpSocketSetting s)]",
                    "class": "HasTcpSocket",
                    "validate": false,
                    "optional": true,
                    "original": "tcp_socket"
                }
            ],
            "dependencies": [
                "ReplicationControllerSpecTemplateInitContainerLifecyclePostStartExecSetting",
                "ReplicationControllerSpecTemplateInitContainerLifecyclePostStartHttpGetSetting",
                "ReplicationControllerSpecTemplateInitContainerLifecyclePostStartTcpSocketSetting"
            ],
            "key": "replication_controller.spec.template.init_container.lifecycle.post_start",
            "name": "ReplicationControllerSpecTemplateInitContainerLifecyclePostStartSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateInitContainerLifecyclePostStartSetting s",
            "original": "post_start"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateInitContainerLifecyclePostStartTcpSocketSetting",
                "name": "ReplicationControllerSpecTemplateInitContainerLifecyclePostStartTcpSocketSetting'"
            },
            "arguments": [
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number or name of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.init_container.lifecycle.post_start.tcp_socket",
            "name": "ReplicationControllerSpecTemplateInitContainerLifecyclePostStartTcpSocketSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number or name of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                }
            ],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateInitContainerLifecyclePostStartTcpSocketSetting s",
            "original": "tcp_socket"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateInitContainerLifecyclePreStopExecSetting",
                "name": "ReplicationControllerSpecTemplateInitContainerLifecyclePreStopExecSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Command is the command line to execute inside the container, the working",
                        "directory for the command is root ('/') in the container's filesystem. The",
                        "command is simply exec'd, it is not run inside a shell, so traditional shell",
                        "instructions. To use a shell, you need to explicitly call out to that shell.",
                        "Exit status of 0 is treated as live/healthy and non-zero is unhealthy."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"command\" <$> TF.attribute",
                    "name": "_command",
                    "method": "command",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCommand",
                    "validate": false,
                    "optional": true,
                    "original": "command"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.init_container.lifecycle.pre_stop.exec",
            "name": "ReplicationControllerSpecTemplateInitContainerLifecyclePreStopExecSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateInitContainerLifecyclePreStopExecSetting s",
            "original": "exec"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateInitContainerLifecyclePreStopHttpGetHttpHeaderSetting",
                "name": "ReplicationControllerSpecTemplateInitContainerLifecyclePreStopHttpGetHttpHeaderSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The header field name"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The header field value"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"value\" <$> TF.attribute",
                    "name": "_value",
                    "method": "value",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasValue",
                    "validate": false,
                    "optional": true,
                    "original": "value"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.init_container.lifecycle.pre_stop.http_get.http_header",
            "name": "ReplicationControllerSpecTemplateInitContainerLifecyclePreStopHttpGetHttpHeaderSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateInitContainerLifecyclePreStopHttpGetHttpHeaderSetting s",
            "original": "http_header"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateInitContainerLifecyclePreStopHttpGetSetting",
                "name": "ReplicationControllerSpecTemplateInitContainerLifecyclePreStopHttpGetSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Host name to connect to, defaults to the pod IP. You probably want to set",
                        "\"Host\" in httpHeaders instead."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host\" <$> TF.attribute",
                    "name": "_host",
                    "method": "host",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHost",
                    "validate": false,
                    "optional": true,
                    "original": "host"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Scheme to use for connecting to the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_header\" <$> TF.attribute",
                    "name": "_httpHeader",
                    "method": "httpHeader",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ReplicationControllerSpecTemplateInitContainerLifecyclePreStopHttpGetHttpHeaderSetting s)]",
                    "class": "HasHttpHeader",
                    "validate": false,
                    "optional": true,
                    "original": "http_header"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path to access on the HTTP server."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": true,
                    "original": "path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name or number of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": true,
                    "original": "port"
                },
                {
                    "default": "TF.value \"HTTP\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Scheme to use for connecting to the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"scheme\" <$> TF.attribute",
                    "name": "_scheme",
                    "method": "scheme",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasScheme",
                    "validate": false,
                    "optional": true,
                    "original": "scheme"
                }
            ],
            "dependencies": [
                "ReplicationControllerSpecTemplateInitContainerLifecyclePreStopHttpGetHttpHeaderSetting"
            ],
            "key": "replication_controller.spec.template.init_container.lifecycle.pre_stop.http_get",
            "name": "ReplicationControllerSpecTemplateInitContainerLifecyclePreStopHttpGetSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateInitContainerLifecyclePreStopHttpGetSetting s",
            "original": "http_get"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateInitContainerLifecyclePreStopSetting",
                "name": "ReplicationControllerSpecTemplateInitContainerLifecyclePreStopSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Exec specifies the action to take."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"exec\" <$> TF.attribute",
                    "name": "_exec",
                    "method": "exec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateInitContainerLifecyclePreStopExecSetting s)",
                    "class": "HasExec",
                    "validate": true,
                    "optional": true,
                    "original": "exec"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Specifies the http request to perform."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_get\" <$> TF.attribute",
                    "name": "_httpGet",
                    "method": "httpGet",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateInitContainerLifecyclePreStopHttpGetSetting s)",
                    "class": "HasHttpGet",
                    "validate": true,
                    "optional": true,
                    "original": "http_get"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "TCPSocket specifies an action involving a TCP port. TCP hooks not yet",
                        "supported"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tcp_socket\" <$> TF.attribute",
                    "name": "_tcpSocket",
                    "method": "tcpSocket",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ReplicationControllerSpecTemplateInitContainerLifecyclePreStopTcpSocketSetting s)]",
                    "class": "HasTcpSocket",
                    "validate": false,
                    "optional": true,
                    "original": "tcp_socket"
                }
            ],
            "dependencies": [
                "ReplicationControllerSpecTemplateInitContainerLifecyclePreStopExecSetting",
                "ReplicationControllerSpecTemplateInitContainerLifecyclePreStopHttpGetSetting",
                "ReplicationControllerSpecTemplateInitContainerLifecyclePreStopTcpSocketSetting"
            ],
            "key": "replication_controller.spec.template.init_container.lifecycle.pre_stop",
            "name": "ReplicationControllerSpecTemplateInitContainerLifecyclePreStopSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateInitContainerLifecyclePreStopSetting s",
            "original": "pre_stop"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateInitContainerLifecyclePreStopTcpSocketSetting",
                "name": "ReplicationControllerSpecTemplateInitContainerLifecyclePreStopTcpSocketSetting'"
            },
            "arguments": [
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number or name of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.init_container.lifecycle.pre_stop.tcp_socket",
            "name": "ReplicationControllerSpecTemplateInitContainerLifecyclePreStopTcpSocketSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number or name of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                }
            ],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateInitContainerLifecyclePreStopTcpSocketSetting s",
            "original": "tcp_socket"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateInitContainerLifecycleSetting",
                "name": "ReplicationControllerSpecTemplateInitContainerLifecycleSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Post_start is called immediately after a container is created. If the",
                        "handler fails, the container is terminated and restarted according to its",
                        "restart policy. Other management of the container blocks until the hook",
                        "completes. More info:",
                        "http://kubernetes.io/docs/user-guide/container-environment#hook-details"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"post_start\" <$> TF.attribute",
                    "name": "_postStart",
                    "method": "postStart",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ReplicationControllerSpecTemplateInitContainerLifecyclePostStartSetting s)]",
                    "class": "HasPostStart",
                    "validate": false,
                    "optional": true,
                    "original": "post_start"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Pre_stop is called immediately before a container is terminated. The",
                        "container is terminated after the handler completes. The reason for",
                        "termination is passed to the handler. Regardless of the outcome of the",
                        "handler, the container is eventually terminated. Other management of the",
                        "container blocks until the hook completes. More info:",
                        "http://kubernetes.io/docs/user-guide/container-environment#hook-details"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"pre_stop\" <$> TF.attribute",
                    "name": "_preStop",
                    "method": "preStop",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ReplicationControllerSpecTemplateInitContainerLifecyclePreStopSetting s)]",
                    "class": "HasPreStop",
                    "validate": false,
                    "optional": true,
                    "original": "pre_stop"
                }
            ],
            "dependencies": [
                "ReplicationControllerSpecTemplateInitContainerLifecyclePostStartSetting",
                "ReplicationControllerSpecTemplateInitContainerLifecyclePreStopSetting"
            ],
            "key": "replication_controller.spec.template.init_container.lifecycle",
            "name": "ReplicationControllerSpecTemplateInitContainerLifecycleSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateInitContainerLifecycleSetting s",
            "original": "lifecycle"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateInitContainerLivenessProbeExecSetting",
                "name": "ReplicationControllerSpecTemplateInitContainerLivenessProbeExecSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Command is the command line to execute inside the container, the working",
                        "directory for the command is root ('/') in the container's filesystem. The",
                        "command is simply exec'd, it is not run inside a shell, so traditional shell",
                        "instructions. To use a shell, you need to explicitly call out to that shell.",
                        "Exit status of 0 is treated as live/healthy and non-zero is unhealthy."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"command\" <$> TF.attribute",
                    "name": "_command",
                    "method": "command",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCommand",
                    "validate": false,
                    "optional": true,
                    "original": "command"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.init_container.liveness_probe.exec",
            "name": "ReplicationControllerSpecTemplateInitContainerLivenessProbeExecSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateInitContainerLivenessProbeExecSetting s",
            "original": "exec"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateInitContainerLivenessProbeHttpGetHttpHeaderSetting",
                "name": "ReplicationControllerSpecTemplateInitContainerLivenessProbeHttpGetHttpHeaderSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The header field name"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The header field value"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"value\" <$> TF.attribute",
                    "name": "_value",
                    "method": "value",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasValue",
                    "validate": false,
                    "optional": true,
                    "original": "value"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.init_container.liveness_probe.http_get.http_header",
            "name": "ReplicationControllerSpecTemplateInitContainerLivenessProbeHttpGetHttpHeaderSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateInitContainerLivenessProbeHttpGetHttpHeaderSetting s",
            "original": "http_header"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateInitContainerLivenessProbeHttpGetSetting",
                "name": "ReplicationControllerSpecTemplateInitContainerLivenessProbeHttpGetSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Host name to connect to, defaults to the pod IP. You probably want to set",
                        "\"Host\" in httpHeaders instead."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host\" <$> TF.attribute",
                    "name": "_host",
                    "method": "host",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHost",
                    "validate": false,
                    "optional": true,
                    "original": "host"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Scheme to use for connecting to the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_header\" <$> TF.attribute",
                    "name": "_httpHeader",
                    "method": "httpHeader",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ReplicationControllerSpecTemplateInitContainerLivenessProbeHttpGetHttpHeaderSetting s)]",
                    "class": "HasHttpHeader",
                    "validate": false,
                    "optional": true,
                    "original": "http_header"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path to access on the HTTP server."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": true,
                    "original": "path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name or number of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": true,
                    "original": "port"
                },
                {
                    "default": "TF.value \"HTTP\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Scheme to use for connecting to the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"scheme\" <$> TF.attribute",
                    "name": "_scheme",
                    "method": "scheme",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasScheme",
                    "validate": false,
                    "optional": true,
                    "original": "scheme"
                }
            ],
            "dependencies": [
                "ReplicationControllerSpecTemplateInitContainerLivenessProbeHttpGetHttpHeaderSetting"
            ],
            "key": "replication_controller.spec.template.init_container.liveness_probe.http_get",
            "name": "ReplicationControllerSpecTemplateInitContainerLivenessProbeHttpGetSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateInitContainerLivenessProbeHttpGetSetting s",
            "original": "http_get"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateInitContainerLivenessProbeSetting",
                "name": "ReplicationControllerSpecTemplateInitContainerLivenessProbeSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Exec specifies the action to take."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"exec\" <$> TF.attribute",
                    "name": "_exec",
                    "method": "exec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateInitContainerLivenessProbeExecSetting s)",
                    "class": "HasExec",
                    "validate": true,
                    "optional": true,
                    "original": "exec"
                },
                {
                    "default": "TF.value 3",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Minimum consecutive failures for the probe to be considered failed after",
                        "having succeeded."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"failure_threshold\" <$> TF.attribute",
                    "name": "_failureThreshold",
                    "method": "failureThreshold",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasFailureThreshold",
                    "validate": false,
                    "optional": true,
                    "original": "failure_threshold"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Specifies the http request to perform."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_get\" <$> TF.attribute",
                    "name": "_httpGet",
                    "method": "httpGet",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateInitContainerLivenessProbeHttpGetSetting s)",
                    "class": "HasHttpGet",
                    "validate": true,
                    "optional": true,
                    "original": "http_get"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Number of seconds after the container has started before liveness probes are",
                        "initiated. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"initial_delay_seconds\" <$> TF.attribute",
                    "name": "_initialDelaySeconds",
                    "method": "initialDelaySeconds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasInitialDelaySeconds",
                    "validate": false,
                    "optional": true,
                    "original": "initial_delay_seconds"
                },
                {
                    "default": "TF.value 10",
                    "computed": false,
                    "required": false,
                    "help": [
                        "How often (in seconds) to perform the probe"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"period_seconds\" <$> TF.attribute",
                    "name": "_periodSeconds",
                    "method": "periodSeconds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasPeriodSeconds",
                    "validate": false,
                    "optional": true,
                    "original": "period_seconds"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Minimum consecutive successes for the probe to be considered successful",
                        "after having failed."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"success_threshold\" <$> TF.attribute",
                    "name": "_successThreshold",
                    "method": "successThreshold",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasSuccessThreshold",
                    "validate": false,
                    "optional": true,
                    "original": "success_threshold"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "TCPSocket specifies an action involving a TCP port. TCP hooks not yet",
                        "supported"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tcp_socket\" <$> TF.attribute",
                    "name": "_tcpSocket",
                    "method": "tcpSocket",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ReplicationControllerSpecTemplateInitContainerLivenessProbeTcpSocketSetting s)]",
                    "class": "HasTcpSocket",
                    "validate": false,
                    "optional": true,
                    "original": "tcp_socket"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Number of seconds after which the probe times out. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"timeout_seconds\" <$> TF.attribute",
                    "name": "_timeoutSeconds",
                    "method": "timeoutSeconds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasTimeoutSeconds",
                    "validate": false,
                    "optional": true,
                    "original": "timeout_seconds"
                }
            ],
            "dependencies": [
                "ReplicationControllerSpecTemplateInitContainerLivenessProbeExecSetting",
                "ReplicationControllerSpecTemplateInitContainerLivenessProbeHttpGetSetting",
                "ReplicationControllerSpecTemplateInitContainerLivenessProbeTcpSocketSetting"
            ],
            "key": "replication_controller.spec.template.init_container.liveness_probe",
            "name": "ReplicationControllerSpecTemplateInitContainerLivenessProbeSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateInitContainerLivenessProbeSetting s",
            "original": "liveness_probe"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateInitContainerLivenessProbeTcpSocketSetting",
                "name": "ReplicationControllerSpecTemplateInitContainerLivenessProbeTcpSocketSetting'"
            },
            "arguments": [
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number or name of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.init_container.liveness_probe.tcp_socket",
            "name": "ReplicationControllerSpecTemplateInitContainerLivenessProbeTcpSocketSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number or name of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                }
            ],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateInitContainerLivenessProbeTcpSocketSetting s",
            "original": "tcp_socket"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateInitContainerPortSetting",
                "name": "ReplicationControllerSpecTemplateInitContainerPortSetting'"
            },
            "arguments": [
                {
                    "default": "_containerPort",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number of port to expose on the pod's IP address. This must be a valid port",
                        "number, 0 < x < 65536."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"container_port\" <$> TF.attribute",
                    "name": "_containerPort",
                    "method": "containerPort",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasContainerPort",
                    "validate": false,
                    "optional": false,
                    "original": "container_port"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "What host IP to bind the external port to."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_ip\" <$> TF.attribute",
                    "name": "_hostIp",
                    "method": "hostIp",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHostIp",
                    "validate": false,
                    "optional": true,
                    "original": "host_ip"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Number of port to expose on the host. If specified, this must be a valid",
                        "port number, 0 < x < 65536. If HostNetwork is specified, this must match",
                        "ContainerPort. Most containers do not need this."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_port\" <$> TF.attribute",
                    "name": "_hostPort",
                    "method": "hostPort",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasHostPort",
                    "validate": false,
                    "optional": true,
                    "original": "host_port"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If specified, this must be an IANA_SVC_NAME and unique within the pod. Each",
                        "named port in a pod must have a unique name. Name for the port that can be",
                        "referred to by services"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.value \"TCP\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Protocol for port. Must be UDP or TCP. Defaults to \"TCP\"."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"protocol\" <$> TF.attribute",
                    "name": "_protocol",
                    "method": "protocol",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasProtocol",
                    "validate": false,
                    "optional": true,
                    "original": "protocol"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.init_container.port",
            "name": "ReplicationControllerSpecTemplateInitContainerPortSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_containerPort",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number of port to expose on the pod's IP address. This must be a valid port",
                        "number, 0 < x < 65536."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"container_port\" <$> TF.attribute",
                    "name": "_containerPort",
                    "method": "containerPort",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasContainerPort",
                    "validate": false,
                    "optional": false,
                    "original": "container_port"
                }
            ],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateInitContainerPortSetting s",
            "original": "port"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateInitContainerReadinessProbeExecSetting",
                "name": "ReplicationControllerSpecTemplateInitContainerReadinessProbeExecSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Command is the command line to execute inside the container, the working",
                        "directory for the command is root ('/') in the container's filesystem. The",
                        "command is simply exec'd, it is not run inside a shell, so traditional shell",
                        "instructions. To use a shell, you need to explicitly call out to that shell.",
                        "Exit status of 0 is treated as live/healthy and non-zero is unhealthy."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"command\" <$> TF.attribute",
                    "name": "_command",
                    "method": "command",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCommand",
                    "validate": false,
                    "optional": true,
                    "original": "command"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.init_container.readiness_probe.exec",
            "name": "ReplicationControllerSpecTemplateInitContainerReadinessProbeExecSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateInitContainerReadinessProbeExecSetting s",
            "original": "exec"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateInitContainerReadinessProbeHttpGetHttpHeaderSetting",
                "name": "ReplicationControllerSpecTemplateInitContainerReadinessProbeHttpGetHttpHeaderSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The header field name"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The header field value"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"value\" <$> TF.attribute",
                    "name": "_value",
                    "method": "value",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasValue",
                    "validate": false,
                    "optional": true,
                    "original": "value"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.init_container.readiness_probe.http_get.http_header",
            "name": "ReplicationControllerSpecTemplateInitContainerReadinessProbeHttpGetHttpHeaderSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateInitContainerReadinessProbeHttpGetHttpHeaderSetting s",
            "original": "http_header"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateInitContainerReadinessProbeHttpGetSetting",
                "name": "ReplicationControllerSpecTemplateInitContainerReadinessProbeHttpGetSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Host name to connect to, defaults to the pod IP. You probably want to set",
                        "\"Host\" in httpHeaders instead."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host\" <$> TF.attribute",
                    "name": "_host",
                    "method": "host",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHost",
                    "validate": false,
                    "optional": true,
                    "original": "host"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Scheme to use for connecting to the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_header\" <$> TF.attribute",
                    "name": "_httpHeader",
                    "method": "httpHeader",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ReplicationControllerSpecTemplateInitContainerReadinessProbeHttpGetHttpHeaderSetting s)]",
                    "class": "HasHttpHeader",
                    "validate": false,
                    "optional": true,
                    "original": "http_header"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path to access on the HTTP server."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": true,
                    "original": "path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name or number of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": true,
                    "original": "port"
                },
                {
                    "default": "TF.value \"HTTP\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Scheme to use for connecting to the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"scheme\" <$> TF.attribute",
                    "name": "_scheme",
                    "method": "scheme",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasScheme",
                    "validate": false,
                    "optional": true,
                    "original": "scheme"
                }
            ],
            "dependencies": [
                "ReplicationControllerSpecTemplateInitContainerReadinessProbeHttpGetHttpHeaderSetting"
            ],
            "key": "replication_controller.spec.template.init_container.readiness_probe.http_get",
            "name": "ReplicationControllerSpecTemplateInitContainerReadinessProbeHttpGetSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateInitContainerReadinessProbeHttpGetSetting s",
            "original": "http_get"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateInitContainerReadinessProbeSetting",
                "name": "ReplicationControllerSpecTemplateInitContainerReadinessProbeSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Exec specifies the action to take."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"exec\" <$> TF.attribute",
                    "name": "_exec",
                    "method": "exec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateInitContainerReadinessProbeExecSetting s)",
                    "class": "HasExec",
                    "validate": true,
                    "optional": true,
                    "original": "exec"
                },
                {
                    "default": "TF.value 3",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Minimum consecutive failures for the probe to be considered failed after",
                        "having succeeded."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"failure_threshold\" <$> TF.attribute",
                    "name": "_failureThreshold",
                    "method": "failureThreshold",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasFailureThreshold",
                    "validate": false,
                    "optional": true,
                    "original": "failure_threshold"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Specifies the http request to perform."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_get\" <$> TF.attribute",
                    "name": "_httpGet",
                    "method": "httpGet",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateInitContainerReadinessProbeHttpGetSetting s)",
                    "class": "HasHttpGet",
                    "validate": true,
                    "optional": true,
                    "original": "http_get"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Number of seconds after the container has started before liveness probes are",
                        "initiated. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"initial_delay_seconds\" <$> TF.attribute",
                    "name": "_initialDelaySeconds",
                    "method": "initialDelaySeconds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasInitialDelaySeconds",
                    "validate": false,
                    "optional": true,
                    "original": "initial_delay_seconds"
                },
                {
                    "default": "TF.value 10",
                    "computed": false,
                    "required": false,
                    "help": [
                        "How often (in seconds) to perform the probe"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"period_seconds\" <$> TF.attribute",
                    "name": "_periodSeconds",
                    "method": "periodSeconds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasPeriodSeconds",
                    "validate": false,
                    "optional": true,
                    "original": "period_seconds"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Minimum consecutive successes for the probe to be considered successful",
                        "after having failed."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"success_threshold\" <$> TF.attribute",
                    "name": "_successThreshold",
                    "method": "successThreshold",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasSuccessThreshold",
                    "validate": false,
                    "optional": true,
                    "original": "success_threshold"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "TCPSocket specifies an action involving a TCP port. TCP hooks not yet",
                        "supported"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tcp_socket\" <$> TF.attribute",
                    "name": "_tcpSocket",
                    "method": "tcpSocket",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ReplicationControllerSpecTemplateInitContainerReadinessProbeTcpSocketSetting s)]",
                    "class": "HasTcpSocket",
                    "validate": false,
                    "optional": true,
                    "original": "tcp_socket"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Number of seconds after which the probe times out. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"timeout_seconds\" <$> TF.attribute",
                    "name": "_timeoutSeconds",
                    "method": "timeoutSeconds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasTimeoutSeconds",
                    "validate": false,
                    "optional": true,
                    "original": "timeout_seconds"
                }
            ],
            "dependencies": [
                "ReplicationControllerSpecTemplateInitContainerReadinessProbeExecSetting",
                "ReplicationControllerSpecTemplateInitContainerReadinessProbeHttpGetSetting",
                "ReplicationControllerSpecTemplateInitContainerReadinessProbeTcpSocketSetting"
            ],
            "key": "replication_controller.spec.template.init_container.readiness_probe",
            "name": "ReplicationControllerSpecTemplateInitContainerReadinessProbeSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateInitContainerReadinessProbeSetting s",
            "original": "readiness_probe"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateInitContainerReadinessProbeTcpSocketSetting",
                "name": "ReplicationControllerSpecTemplateInitContainerReadinessProbeTcpSocketSetting'"
            },
            "arguments": [
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number or name of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.init_container.readiness_probe.tcp_socket",
            "name": "ReplicationControllerSpecTemplateInitContainerReadinessProbeTcpSocketSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number or name of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                }
            ],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateInitContainerReadinessProbeTcpSocketSetting s",
            "original": "tcp_socket"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateInitContainerResourcesLimitsSetting",
                "name": "ReplicationControllerSpecTemplateInitContainerResourcesLimitsSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu\" <$> TF.attribute",
                    "name": "_cpu",
                    "method": "cpu",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasCpu",
                    "validate": false,
                    "optional": true,
                    "original": "cpu"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory\" <$> TF.attribute",
                    "name": "_memory",
                    "method": "memory",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasMemory",
                    "validate": false,
                    "optional": true,
                    "original": "memory"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.init_container.resources.limits",
            "name": "ReplicationControllerSpecTemplateInitContainerResourcesLimitsSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu\" <$> TF.attribute",
                    "name": "_computedCpu",
                    "method": "computedCpu",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedCpu",
                    "validate": false,
                    "optional": false,
                    "original": "cpu"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory\" <$> TF.attribute",
                    "name": "_computedMemory",
                    "method": "computedMemory",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedMemory",
                    "validate": false,
                    "optional": false,
                    "original": "memory"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateInitContainerResourcesLimitsSetting s",
            "original": "limits"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateInitContainerResourcesRequestsSetting",
                "name": "ReplicationControllerSpecTemplateInitContainerResourcesRequestsSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu\" <$> TF.attribute",
                    "name": "_cpu",
                    "method": "cpu",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasCpu",
                    "validate": false,
                    "optional": true,
                    "original": "cpu"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory\" <$> TF.attribute",
                    "name": "_memory",
                    "method": "memory",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasMemory",
                    "validate": false,
                    "optional": true,
                    "original": "memory"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.init_container.resources.requests",
            "name": "ReplicationControllerSpecTemplateInitContainerResourcesRequestsSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu\" <$> TF.attribute",
                    "name": "_computedCpu",
                    "method": "computedCpu",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedCpu",
                    "validate": false,
                    "optional": false,
                    "original": "cpu"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory\" <$> TF.attribute",
                    "name": "_computedMemory",
                    "method": "computedMemory",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedMemory",
                    "validate": false,
                    "optional": false,
                    "original": "memory"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateInitContainerResourcesRequestsSetting s",
            "original": "requests"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateInitContainerResourcesSetting",
                "name": "ReplicationControllerSpecTemplateInitContainerResourcesSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Describes the maximum amount of compute resources allowed. More info:",
                        "http://kubernetes.io/docs/user-guide/compute-resources/"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"limits\" <$> TF.attribute",
                    "name": "_limits",
                    "method": "limits",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateInitContainerResourcesLimitsSetting s)",
                    "class": "HasLimits",
                    "validate": true,
                    "optional": true,
                    "original": "limits"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"requests\" <$> TF.attribute",
                    "name": "_requests",
                    "method": "requests",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateInitContainerResourcesRequestsSetting s)",
                    "class": "HasRequests",
                    "validate": true,
                    "optional": true,
                    "original": "requests"
                }
            ],
            "dependencies": [
                "ReplicationControllerSpecTemplateInitContainerResourcesLimitsSetting",
                "ReplicationControllerSpecTemplateInitContainerResourcesRequestsSetting",
                "ReplicationControllerSpecTemplateInitContainerResourcesLimitsSetting",
                "ReplicationControllerSpecTemplateInitContainerResourcesRequestsSetting"
            ],
            "key": "replication_controller.spec.template.init_container.resources",
            "name": "ReplicationControllerSpecTemplateInitContainerResourcesSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Describes the maximum amount of compute resources allowed. More info:",
                        "http://kubernetes.io/docs/user-guide/compute-resources/"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"limits\" <$> TF.attribute",
                    "name": "_computedLimits",
                    "method": "computedLimits",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateInitContainerResourcesLimitsSetting s)",
                    "class": "HasComputedLimits",
                    "validate": true,
                    "optional": false,
                    "original": "limits"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"requests\" <$> TF.attribute",
                    "name": "_computedRequests",
                    "method": "computedRequests",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateInitContainerResourcesRequestsSetting s)",
                    "class": "HasComputedRequests",
                    "validate": true,
                    "optional": false,
                    "original": "requests"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateInitContainerResourcesSetting s",
            "original": "resources"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateInitContainerSecurityContextCapabilitiesSetting",
                "name": "ReplicationControllerSpecTemplateInitContainerSecurityContextCapabilitiesSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Added capabilities"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"add\" <$> TF.attribute",
                    "name": "_add",
                    "method": "add",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasAdd",
                    "validate": false,
                    "optional": true,
                    "original": "add"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Removed capabilities"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"drop\" <$> TF.attribute",
                    "name": "_drop",
                    "method": "drop",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasDrop",
                    "validate": false,
                    "optional": true,
                    "original": "drop"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.init_container.security_context.capabilities",
            "name": "ReplicationControllerSpecTemplateInitContainerSecurityContextCapabilitiesSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateInitContainerSecurityContextCapabilitiesSetting s",
            "original": "capabilities"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateInitContainerSecurityContextSeLinuxOptionsSetting",
                "name": "ReplicationControllerSpecTemplateInitContainerSecurityContextSeLinuxOptionsSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Level is SELinux level label that applies to the container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"level\" <$> TF.attribute",
                    "name": "_level",
                    "method": "level",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasLevel",
                    "validate": false,
                    "optional": true,
                    "original": "level"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Role is a SELinux role label that applies to the container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"role\" <$> TF.attribute",
                    "name": "_role",
                    "method": "role",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRole",
                    "validate": false,
                    "optional": true,
                    "original": "role"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Type is a SELinux type label that applies to the container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"type\" <$> TF.attribute",
                    "name": "_type'",
                    "method": "type'",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasType'",
                    "validate": false,
                    "optional": true,
                    "original": "type"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "User is a SELinux user label that applies to the container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"user\" <$> TF.attribute",
                    "name": "_user",
                    "method": "user",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasUser",
                    "validate": false,
                    "optional": true,
                    "original": "user"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.init_container.security_context.se_linux_options",
            "name": "ReplicationControllerSpecTemplateInitContainerSecurityContextSeLinuxOptionsSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateInitContainerSecurityContextSeLinuxOptionsSetting s",
            "original": "se_linux_options"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateInitContainerSecurityContextSetting",
                "name": "ReplicationControllerSpecTemplateInitContainerSecurityContextSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The capabilities to add/drop when running containers. Defaults to the",
                        "default set of capabilities granted by the container runtime."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"capabilities\" <$> TF.attribute",
                    "name": "_capabilities",
                    "method": "capabilities",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateInitContainerSecurityContextCapabilitiesSetting s)",
                    "class": "HasCapabilities",
                    "validate": true,
                    "optional": true,
                    "original": "capabilities"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Run container in privileged mode. Processes in privileged containers are",
                        "essentially equivalent to root on the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"privileged\" <$> TF.attribute",
                    "name": "_privileged",
                    "method": "privileged",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasPrivileged",
                    "validate": false,
                    "optional": true,
                    "original": "privileged"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether this container has a read-only root filesystem."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only_root_filesystem\" <$> TF.attribute",
                    "name": "_readOnlyRootFilesystem",
                    "method": "readOnlyRootFilesystem",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnlyRootFilesystem",
                    "validate": false,
                    "optional": true,
                    "original": "read_only_root_filesystem"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Indicates that the container must run as a non-root user. If true, the",
                        "Kubelet will validate the image at runtime to ensure that it does not run as",
                        "UID 0 (root) and fail to start the container if it does."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"run_as_non_root\" <$> TF.attribute",
                    "name": "_runAsNonRoot",
                    "method": "runAsNonRoot",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasRunAsNonRoot",
                    "validate": false,
                    "optional": true,
                    "original": "run_as_non_root"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The UID to run the entrypoint of the container process. Defaults to user",
                        "specified in image metadata if unspecified"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"run_as_user\" <$> TF.attribute",
                    "name": "_runAsUser",
                    "method": "runAsUser",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasRunAsUser",
                    "validate": false,
                    "optional": true,
                    "original": "run_as_user"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "ImagePullSecrets is an optional list of references to secrets in the same",
                        "namespace to use for pulling any of the images used by this PodSpec. If",
                        "specified, these secrets will be passed to individual puller implementations",
                        "for them to use. For example, in the case of docker, only DockerConfig type",
                        "secrets are honored. More info:",
                        "http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"se_linux_options\" <$> TF.attribute",
                    "name": "_seLinuxOptions",
                    "method": "seLinuxOptions",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateInitContainerSecurityContextSeLinuxOptionsSetting s)",
                    "class": "HasSeLinuxOptions",
                    "validate": true,
                    "optional": true,
                    "original": "se_linux_options"
                }
            ],
            "dependencies": [
                "ReplicationControllerSpecTemplateInitContainerSecurityContextCapabilitiesSetting",
                "ReplicationControllerSpecTemplateInitContainerSecurityContextSeLinuxOptionsSetting"
            ],
            "key": "replication_controller.spec.template.init_container.security_context",
            "name": "ReplicationControllerSpecTemplateInitContainerSecurityContextSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateInitContainerSecurityContextSetting s",
            "original": "security_context"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateInitContainerSetting",
                "name": "ReplicationControllerSpecTemplateInitContainerSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Arguments to the entrypoint. The docker image's CMD is used if this is not",
                        "provided. Variable references $(VAR_NAME) are expanded using the container's",
                        "environment. If a variable cannot be resolved, the reference in the input",
                        "string will be unchanged. The $(VAR_NAME) syntax can be escaped with a",
                        "double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,",
                        "regardless of whether the variable exists or not. Cannot be updated. More",
                        "info:",
                        "http://kubernetes.io/docs/user-guide/containers#containers-and-commands"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"args\" <$> TF.attribute",
                    "name": "_args",
                    "method": "args",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasArgs",
                    "validate": false,
                    "optional": true,
                    "original": "args"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT",
                        "is used if this is not provided. Variable references $(VAR_NAME) are",
                        "expanded using the container's environment. If a variable cannot be",
                        "resolved, the reference in the input string will be unchanged. The",
                        "$(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).",
                        "Escaped references will never be expanded, regardless of whether the",
                        "variable exists or not. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/containers#containers-and-commands"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"command\" <$> TF.attribute",
                    "name": "_command",
                    "method": "command",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCommand",
                    "validate": false,
                    "optional": true,
                    "original": "command"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of environment variables to set in the container. Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"env\" <$> TF.attribute",
                    "name": "_env",
                    "method": "env",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ReplicationControllerSpecTemplateInitContainerEnvSetting s)]",
                    "class": "HasEnv",
                    "validate": false,
                    "optional": true,
                    "original": "env"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Docker image name. More info: http://kubernetes.io/docs/user-guide/images"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"image\" <$> TF.attribute",
                    "name": "_image",
                    "method": "image",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasImage",
                    "validate": false,
                    "optional": true,
                    "original": "image"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if",
                        ":latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More",
                        "info: http://kubernetes.io/docs/user-guide/images#updating-images"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"image_pull_policy\" <$> TF.attribute",
                    "name": "_imagePullPolicy",
                    "method": "imagePullPolicy",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasImagePullPolicy",
                    "validate": false,
                    "optional": true,
                    "original": "image_pull_policy"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Actions that the management system should take in response to container",
                        "lifecycle events"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"lifecycle\" <$> TF.attribute",
                    "name": "_lifecycle",
                    "method": "lifecycle",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateInitContainerLifecycleSetting s)",
                    "class": "HasLifecycle",
                    "validate": true,
                    "optional": true,
                    "original": "lifecycle"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Periodic probe of container liveness. Container will be restarted if the",
                        "probe fails. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"liveness_probe\" <$> TF.attribute",
                    "name": "_livenessProbe",
                    "method": "livenessProbe",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateInitContainerLivenessProbeSetting s)",
                    "class": "HasLivenessProbe",
                    "validate": true,
                    "optional": true,
                    "original": "liveness_probe"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the container specified as a DNS_LABEL. Each container in a pod must",
                        "have a unique name (DNS_LABEL). Cannot be updated."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of ports to expose from the container. Exposing a port here gives the",
                        "system additional information about the network connections a container",
                        "uses, but is primarily informational. Not specifying a port here DOES NOT",
                        "prevent that port from being exposed. Any port which is listening on the",
                        "default \"0.0.0.0\" address inside a container will be accessible from the",
                        "network. Cannot be updated."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ReplicationControllerSpecTemplateInitContainerPortSetting s)]",
                    "class": "HasPort",
                    "validate": false,
                    "optional": true,
                    "original": "port"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Periodic probe of container service readiness. Container will be removed",
                        "from service endpoints if the probe fails. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"readiness_probe\" <$> TF.attribute",
                    "name": "_readinessProbe",
                    "method": "readinessProbe",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateInitContainerReadinessProbeSetting s)",
                    "class": "HasReadinessProbe",
                    "validate": true,
                    "optional": true,
                    "original": "readiness_probe"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Compute Resources required by this container. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#resources"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resources\" <$> TF.attribute",
                    "name": "_resources",
                    "method": "resources",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateInitContainerResourcesSetting s)",
                    "class": "HasResources",
                    "validate": true,
                    "optional": true,
                    "original": "resources"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Security options the pod should run with. More info:",
                        "http://releases.k8s.io/HEAD/docs/design/security_context.md"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"security_context\" <$> TF.attribute",
                    "name": "_securityContext",
                    "method": "securityContext",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateInitContainerSecurityContextSetting s)",
                    "class": "HasSecurityContext",
                    "validate": true,
                    "optional": true,
                    "original": "security_context"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether this container should allocate a buffer for stdin in the container",
                        "runtime. If this is not set, reads from stdin in the container will always",
                        "result in EOF."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"stdin\" <$> TF.attribute",
                    "name": "_stdin",
                    "method": "stdin",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasStdin",
                    "validate": false,
                    "optional": true,
                    "original": "stdin"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether the container runtime should close the stdin channel after it has",
                        "been opened by a single attach. When stdin is true the stdin stream will",
                        "remain open across multiple attach sessions. If stdinOnce is set to true,",
                        "stdin is opened on container start, is empty until the first client attaches",
                        "to stdin, and then remains open and accepts data until the client",
                        "disconnects, at which time stdin is closed and remains closed until the",
                        "container is restarted. If this flag is false, a container processes that",
                        "reads from stdin will never receive an EOF."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"stdin_once\" <$> TF.attribute",
                    "name": "_stdinOnce",
                    "method": "stdinOnce",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasStdinOnce",
                    "validate": false,
                    "optional": true,
                    "original": "stdin_once"
                },
                {
                    "default": "TF.value \"/dev/termination-log\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional: Path at which the file to which the container's termination",
                        "message will be written is mounted into the container's filesystem. Message",
                        "written is intended to be brief final status, such as an assertion failure",
                        "message. Defaults to /dev/termination-log. Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"termination_message_path\" <$> TF.attribute",
                    "name": "_terminationMessagePath",
                    "method": "terminationMessagePath",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasTerminationMessagePath",
                    "validate": false,
                    "optional": true,
                    "original": "termination_message_path"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether this container should allocate a TTY for itself"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tty\" <$> TF.attribute",
                    "name": "_tty",
                    "method": "tty",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasTty",
                    "validate": false,
                    "optional": true,
                    "original": "tty"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Pod volumes to mount into the container's filesystem. Cannot be updated."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_mount\" <$> TF.attribute",
                    "name": "_volumeMount",
                    "method": "volumeMount",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ReplicationControllerSpecTemplateInitContainerVolumeMountSetting s)]",
                    "class": "HasVolumeMount",
                    "validate": false,
                    "optional": true,
                    "original": "volume_mount"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Container's working directory. If not specified, the container runtime's",
                        "default will be used, which might be configured in the container image.",
                        "Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"working_dir\" <$> TF.attribute",
                    "name": "_workingDir",
                    "method": "workingDir",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasWorkingDir",
                    "validate": false,
                    "optional": true,
                    "original": "working_dir"
                }
            ],
            "dependencies": [
                "ReplicationControllerSpecTemplateInitContainerEnvSetting",
                "ReplicationControllerSpecTemplateInitContainerLifecycleSetting",
                "ReplicationControllerSpecTemplateInitContainerLivenessProbeSetting",
                "ReplicationControllerSpecTemplateInitContainerPortSetting",
                "ReplicationControllerSpecTemplateInitContainerReadinessProbeSetting",
                "ReplicationControllerSpecTemplateInitContainerResourcesSetting",
                "ReplicationControllerSpecTemplateInitContainerSecurityContextSetting",
                "ReplicationControllerSpecTemplateInitContainerVolumeMountSetting",
                "ReplicationControllerSpecTemplateInitContainerResourcesSetting"
            ],
            "key": "replication_controller.spec.template.init_container",
            "name": "ReplicationControllerSpecTemplateInitContainerSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if",
                        ":latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More",
                        "info: http://kubernetes.io/docs/user-guide/images#updating-images"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"image_pull_policy\" <$> TF.attribute",
                    "name": "_computedImagePullPolicy",
                    "method": "computedImagePullPolicy",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedImagePullPolicy",
                    "validate": false,
                    "optional": false,
                    "original": "image_pull_policy"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Compute Resources required by this container. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#resources"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resources\" <$> TF.attribute",
                    "name": "_computedResources",
                    "method": "computedResources",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateInitContainerResourcesSetting s)",
                    "class": "HasComputedResources",
                    "validate": true,
                    "optional": false,
                    "original": "resources"
                }
            ],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the container specified as a DNS_LABEL. Each container in a pod must",
                        "have a unique name (DNS_LABEL). Cannot be updated."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateInitContainerSetting s",
            "original": "init_container"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateInitContainerVolumeMountSetting",
                "name": "ReplicationControllerSpecTemplateInitContainerVolumeMountSetting'"
            },
            "arguments": [
                {
                    "default": "_mountPath",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path within the container at which the volume should be mounted. Must not",
                        "contain ':'."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"mount_path\" <$> TF.attribute",
                    "name": "_mountPath",
                    "method": "mountPath",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasMountPath",
                    "validate": false,
                    "optional": false,
                    "original": "mount_path"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "This must match the Name of a Volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Mounted read-only if true, read-write otherwise (false or unspecified).",
                        "Defaults to false."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path within the volume from which the container's volume should be mounted.",
                        "Defaults to \"\" (volume's root)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sub_path\" <$> TF.attribute",
                    "name": "_subPath",
                    "method": "subPath",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSubPath",
                    "validate": false,
                    "optional": true,
                    "original": "sub_path"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.init_container.volume_mount",
            "name": "ReplicationControllerSpecTemplateInitContainerVolumeMountSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "This must match the Name of a Volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "_mountPath",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path within the container at which the volume should be mounted. Must not",
                        "contain ':'."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"mount_path\" <$> TF.attribute",
                    "name": "_mountPath",
                    "method": "mountPath",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasMountPath",
                    "validate": false,
                    "optional": false,
                    "original": "mount_path"
                }
            ],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateInitContainerVolumeMountSetting s",
            "original": "volume_mount"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateSecurityContextSeLinuxOptionsSetting",
                "name": "ReplicationControllerSpecTemplateSecurityContextSeLinuxOptionsSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Level is SELinux level label that applies to the container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"level\" <$> TF.attribute",
                    "name": "_level",
                    "method": "level",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasLevel",
                    "validate": false,
                    "optional": true,
                    "original": "level"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Role is a SELinux role label that applies to the container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"role\" <$> TF.attribute",
                    "name": "_role",
                    "method": "role",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRole",
                    "validate": false,
                    "optional": true,
                    "original": "role"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Type is a SELinux type label that applies to the container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"type\" <$> TF.attribute",
                    "name": "_type'",
                    "method": "type'",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasType'",
                    "validate": false,
                    "optional": true,
                    "original": "type"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "User is a SELinux user label that applies to the container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"user\" <$> TF.attribute",
                    "name": "_user",
                    "method": "user",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasUser",
                    "validate": false,
                    "optional": true,
                    "original": "user"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.security_context.se_linux_options",
            "name": "ReplicationControllerSpecTemplateSecurityContextSeLinuxOptionsSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateSecurityContextSeLinuxOptionsSetting s",
            "original": "se_linux_options"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateSecurityContextSetting",
                "name": "ReplicationControllerSpecTemplateSecurityContextSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A special supplemental group that applies to all containers in a pod. Some",
                        "volume types allow the Kubelet to change the ownership of that volume to be",
                        "owned by the pod: 1. The owning GID will be the FSGroup 2. The setgid bit is",
                        "set (new files created in the volume will be owned by FSGroup) 3. The",
                        "permission bits are OR'd with rw-rw---- If unset, the Kubelet will not",
                        "modify the ownership and permissions of any volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_group\" <$> TF.attribute",
                    "name": "_fsGroup",
                    "method": "fsGroup",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasFsGroup",
                    "validate": false,
                    "optional": true,
                    "original": "fs_group"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Indicates that the container must run as a non-root user. If true, the",
                        "Kubelet will validate the image at runtime to ensure that it does not run as",
                        "UID 0 (root) and fail to start the container if it does."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"run_as_non_root\" <$> TF.attribute",
                    "name": "_runAsNonRoot",
                    "method": "runAsNonRoot",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasRunAsNonRoot",
                    "validate": false,
                    "optional": true,
                    "original": "run_as_non_root"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The UID to run the entrypoint of the container process. Defaults to user",
                        "specified in image metadata if unspecified"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"run_as_user\" <$> TF.attribute",
                    "name": "_runAsUser",
                    "method": "runAsUser",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasRunAsUser",
                    "validate": false,
                    "optional": true,
                    "original": "run_as_user"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The SELinux context to be applied to all containers. If unspecified, the",
                        "container runtime will allocate a random SELinux context for each container.",
                        "May also be set in SecurityContext. If set in both SecurityContext and",
                        "PodSecurityContext, the value specified in SecurityContext takes precedence",
                        "for that container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"se_linux_options\" <$> TF.attribute",
                    "name": "_seLinuxOptions",
                    "method": "seLinuxOptions",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateSecurityContextSeLinuxOptionsSetting s)",
                    "class": "HasSeLinuxOptions",
                    "validate": true,
                    "optional": true,
                    "original": "se_linux_options"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of groups applied to the first process run in each container, in",
                        "addition to the container's primary GID. If unspecified, no groups will be",
                        "added to any container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"supplemental_groups\" <$> TF.attribute",
                    "name": "_supplementalGroups",
                    "method": "supplementalGroups",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Int]",
                    "class": "HasSupplementalGroups",
                    "validate": false,
                    "optional": true,
                    "original": "supplemental_groups"
                }
            ],
            "dependencies": [
                "ReplicationControllerSpecTemplateSecurityContextSeLinuxOptionsSetting"
            ],
            "key": "replication_controller.spec.template.security_context",
            "name": "ReplicationControllerSpecTemplateSecurityContextSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateSecurityContextSetting s",
            "original": "security_context"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateSetting",
                "name": "ReplicationControllerSpecTemplateSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional duration in seconds the pod may be active on the node relative to",
                        "StartTime before the system will actively try to mark it failed and kill",
                        "associated containers. Value must be a positive integer."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"active_deadline_seconds\" <$> TF.attribute",
                    "name": "_activeDeadlineSeconds",
                    "method": "activeDeadlineSeconds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasActiveDeadlineSeconds",
                    "validate": false,
                    "optional": true,
                    "original": "active_deadline_seconds"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of containers belonging to the pod. Containers cannot currently be",
                        "added or removed. There must be at least one container in a Pod. Cannot be",
                        "updated. More info: http://kubernetes.io/docs/user-guide/containers"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"container\" <$> TF.attribute",
                    "name": "_container",
                    "method": "container",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ReplicationControllerSpecTemplateContainerSetting s)]",
                    "class": "HasContainer",
                    "validate": false,
                    "optional": true,
                    "original": "container"
                },
                {
                    "default": "TF.value \"ClusterFirst\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Set DNS policy for containers within the pod. One of 'ClusterFirst' or",
                        "'Default'. Defaults to 'ClusterFirst'."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"dns_policy\" <$> TF.attribute",
                    "name": "_dnsPolicy",
                    "method": "dnsPolicy",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDnsPolicy",
                    "validate": false,
                    "optional": true,
                    "original": "dns_policy"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Use the host's ipc namespace. Optional: Default to false."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_ipc\" <$> TF.attribute",
                    "name": "_hostIpc",
                    "method": "hostIpc",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasHostIpc",
                    "validate": false,
                    "optional": true,
                    "original": "host_ipc"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Host networking requested for this pod. Use the host's network namespace. If",
                        "this option is set, the ports that will be used must be specified."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_network\" <$> TF.attribute",
                    "name": "_hostNetwork",
                    "method": "hostNetwork",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasHostNetwork",
                    "validate": false,
                    "optional": true,
                    "original": "host_network"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Use the host's pid namespace."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_pid\" <$> TF.attribute",
                    "name": "_hostPid",
                    "method": "hostPid",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasHostPid",
                    "validate": false,
                    "optional": true,
                    "original": "host_pid"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Specifies the hostname of the Pod If not specified, the pod's hostname will",
                        "be set to a system-defined value."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"hostname\" <$> TF.attribute",
                    "name": "_hostname",
                    "method": "hostname",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHostname",
                    "validate": false,
                    "optional": true,
                    "original": "hostname"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "ImagePullSecrets is an optional list of references to secrets in the same",
                        "namespace to use for pulling any of the images used by this PodSpec. If",
                        "specified, these secrets will be passed to individual puller implementations",
                        "for them to use. For example, in the case of docker, only DockerConfig type",
                        "secrets are honored. More info:",
                        "http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"image_pull_secrets\" <$> TF.attribute",
                    "name": "_imagePullSecrets",
                    "method": "imagePullSecrets",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ReplicationControllerSpecTemplateImagePullSecretsSetting s)]",
                    "class": "HasImagePullSecrets",
                    "validate": false,
                    "optional": true,
                    "original": "image_pull_secrets"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of init containers belonging to the pod. Init containers always run to",
                        "completion and each must complete succesfully before the next is started.",
                        "More info:",
                        "https://kubernetes.io/docs/concepts/workloads/pods/init-containers/"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"init_container\" <$> TF.attribute",
                    "name": "_initContainer",
                    "method": "initContainer",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ReplicationControllerSpecTemplateInitContainerSetting s)]",
                    "class": "HasInitContainer",
                    "validate": false,
                    "optional": true,
                    "original": "init_container"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "NodeName is a request to schedule this pod onto a specific node. If it is",
                        "non-empty, the scheduler simply schedules this pod onto that node, assuming",
                        "that it fits resource requirements."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"node_name\" <$> TF.attribute",
                    "name": "_nodeName",
                    "method": "nodeName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasNodeName",
                    "validate": false,
                    "optional": true,
                    "original": "node_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "NodeSelector is a selector which must be true for the pod to fit on a node.",
                        "Selector which must match a node's labels for the pod to be scheduled on",
                        "that node. More info: http://kubernetes.io/docs/user-guide/node-selection."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"node_selector\" <$> TF.attribute",
                    "name": "_nodeSelector",
                    "method": "nodeSelector",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasNodeSelector",
                    "validate": false,
                    "optional": true,
                    "original": "node_selector"
                },
                {
                    "default": "TF.value \"Always\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Restart policy for all containers within the pod. One of Always, OnFailure,",
                        "Never. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#restartpolicy."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"restart_policy\" <$> TF.attribute",
                    "name": "_restartPolicy",
                    "method": "restartPolicy",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRestartPolicy",
                    "validate": false,
                    "optional": true,
                    "original": "restart_policy"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "SecurityContext holds pod-level security attributes and common container",
                        "settings. Optional: Defaults to empty"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"security_context\" <$> TF.attribute",
                    "name": "_securityContext",
                    "method": "securityContext",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateSecurityContextSetting s)",
                    "class": "HasSecurityContext",
                    "validate": true,
                    "optional": true,
                    "original": "security_context"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "ServiceAccountName is the name of the ServiceAccount to use to run this pod.",
                        "More info: http://releases.k8s.io/HEAD/docs/design/service_accounts.md."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"service_account_name\" <$> TF.attribute",
                    "name": "_serviceAccountName",
                    "method": "serviceAccountName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasServiceAccountName",
                    "validate": false,
                    "optional": true,
                    "original": "service_account_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If specified, the fully qualified Pod hostname will be \"...svc.\". If not",
                        "specified, the pod will not have a domainname at all.."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"subdomain\" <$> TF.attribute",
                    "name": "_subdomain",
                    "method": "subdomain",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSubdomain",
                    "validate": false,
                    "optional": true,
                    "original": "subdomain"
                },
                {
                    "default": "TF.value 30",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional duration in seconds the pod needs to terminate gracefully. May be",
                        "decreased in delete request. Value must be non-negative integer. The value",
                        "zero indicates delete immediately. If this value is nil, the default grace",
                        "period will be used instead. The grace period is the duration in seconds",
                        "after the processes running in the pod are sent a termination signal and the",
                        "time when the processes are forcibly halted with a kill signal. Set this",
                        "value longer than the expected cleanup time for your process."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"termination_grace_period_seconds\" <$> TF.attribute",
                    "name": "_terminationGracePeriodSeconds",
                    "method": "terminationGracePeriodSeconds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasTerminationGracePeriodSeconds",
                    "validate": false,
                    "optional": true,
                    "original": "termination_grace_period_seconds"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of volumes that can be mounted by containers belonging to the pod. More",
                        "info: http://kubernetes.io/docs/user-guide/volumes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume\" <$> TF.attribute",
                    "name": "_volume",
                    "method": "volume",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ReplicationControllerSpecTemplateVolumeSetting s)]",
                    "class": "HasVolume",
                    "validate": false,
                    "optional": true,
                    "original": "volume"
                }
            ],
            "dependencies": [
                "ReplicationControllerSpecTemplateContainerSetting",
                "ReplicationControllerSpecTemplateImagePullSecretsSetting",
                "ReplicationControllerSpecTemplateInitContainerSetting",
                "ReplicationControllerSpecTemplateSecurityContextSetting",
                "ReplicationControllerSpecTemplateVolumeSetting",
                "ReplicationControllerSpecTemplateImagePullSecretsSetting"
            ],
            "key": "replication_controller.spec.template",
            "name": "ReplicationControllerSpecTemplateSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Specifies the hostname of the Pod If not specified, the pod's hostname will",
                        "be set to a system-defined value."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"hostname\" <$> TF.attribute",
                    "name": "_computedHostname",
                    "method": "computedHostname",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedHostname",
                    "validate": false,
                    "optional": false,
                    "original": "hostname"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "ImagePullSecrets is an optional list of references to secrets in the same",
                        "namespace to use for pulling any of the images used by this PodSpec. If",
                        "specified, these secrets will be passed to individual puller implementations",
                        "for them to use. For example, in the case of docker, only DockerConfig type",
                        "secrets are honored. More info:",
                        "http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"image_pull_secrets\" <$> TF.attribute",
                    "name": "_computedImagePullSecrets",
                    "method": "computedImagePullSecrets",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ReplicationControllerSpecTemplateImagePullSecretsSetting s)]",
                    "class": "HasComputedImagePullSecrets",
                    "validate": false,
                    "optional": false,
                    "original": "image_pull_secrets"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "NodeName is a request to schedule this pod onto a specific node. If it is",
                        "non-empty, the scheduler simply schedules this pod onto that node, assuming",
                        "that it fits resource requirements."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"node_name\" <$> TF.attribute",
                    "name": "_computedNodeName",
                    "method": "computedNodeName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedNodeName",
                    "validate": false,
                    "optional": false,
                    "original": "node_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "ServiceAccountName is the name of the ServiceAccount to use to run this pod.",
                        "More info: http://releases.k8s.io/HEAD/docs/design/service_accounts.md."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"service_account_name\" <$> TF.attribute",
                    "name": "_computedServiceAccountName",
                    "method": "computedServiceAccountName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedServiceAccountName",
                    "validate": false,
                    "optional": false,
                    "original": "service_account_name"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateSetting s",
            "original": "template"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateVolumeAwsElasticBlockStoreSetting",
                "name": "ReplicationControllerSpecTemplateVolumeAwsElasticBlockStoreSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type of the volume that you want to mount. Tip: Ensure that the",
                        "filesystem type is supported by the host operating system. Examples: \"ext4\",",
                        "\"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The partition in the volume that you want to mount. If omitted, the default",
                        "is to mount by volume name. Examples: For volume /dev/sda1, you specify the",
                        "partition as \"1\". Similarly, the volume partition for /dev/sda is \"0\" (or",
                        "you can leave the property empty)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"partition\" <$> TF.attribute",
                    "name": "_partition",
                    "method": "partition",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasPartition",
                    "validate": false,
                    "optional": true,
                    "original": "partition"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to set the read-only property in VolumeMounts to \"true\". If omitted,",
                        "the default is \"false\". More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_volumeId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More",
                        "info: http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_id\" <$> TF.attribute",
                    "name": "_volumeId",
                    "method": "volumeId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumeId",
                    "validate": false,
                    "optional": false,
                    "original": "volume_id"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.volume.aws_elastic_block_store",
            "name": "ReplicationControllerSpecTemplateVolumeAwsElasticBlockStoreSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_volumeId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More",
                        "info: http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_id\" <$> TF.attribute",
                    "name": "_volumeId",
                    "method": "volumeId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumeId",
                    "validate": false,
                    "optional": false,
                    "original": "volume_id"
                }
            ],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateVolumeAwsElasticBlockStoreSetting s",
            "original": "aws_elastic_block_store"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateVolumeAzureDiskSetting",
                "name": "ReplicationControllerSpecTemplateVolumeAzureDiskSetting'"
            },
            "arguments": [
                {
                    "default": "_cachingMode",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Host Caching mode: None, Read Only, Read Write."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"caching_mode\" <$> TF.attribute",
                    "name": "_cachingMode",
                    "method": "cachingMode",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasCachingMode",
                    "validate": false,
                    "optional": false,
                    "original": "caching_mode"
                },
                {
                    "default": "_dataDiskUri",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The URI the data disk in the blob storage"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"data_disk_uri\" <$> TF.attribute",
                    "name": "_dataDiskUri",
                    "method": "dataDiskUri",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDataDiskUri",
                    "validate": false,
                    "optional": false,
                    "original": "data_disk_uri"
                },
                {
                    "default": "_diskName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The Name of the data disk in the blob storage"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"disk_name\" <$> TF.attribute",
                    "name": "_diskName",
                    "method": "diskName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDiskName",
                    "validate": false,
                    "optional": false,
                    "original": "disk_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type to mount. Must be a filesystem type supported by the host",
                        "operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be",
                        "\"ext4\" if unspecified."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to false",
                        "(read/write)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.volume.azure_disk",
            "name": "ReplicationControllerSpecTemplateVolumeAzureDiskSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_cachingMode",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Host Caching mode: None, Read Only, Read Write."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"caching_mode\" <$> TF.attribute",
                    "name": "_cachingMode",
                    "method": "cachingMode",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasCachingMode",
                    "validate": false,
                    "optional": false,
                    "original": "caching_mode"
                },
                {
                    "default": "_diskName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The Name of the data disk in the blob storage"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"disk_name\" <$> TF.attribute",
                    "name": "_diskName",
                    "method": "diskName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDiskName",
                    "validate": false,
                    "optional": false,
                    "original": "disk_name"
                },
                {
                    "default": "_dataDiskUri",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The URI the data disk in the blob storage"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"data_disk_uri\" <$> TF.attribute",
                    "name": "_dataDiskUri",
                    "method": "dataDiskUri",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDataDiskUri",
                    "validate": false,
                    "optional": false,
                    "original": "data_disk_uri"
                }
            ],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateVolumeAzureDiskSetting s",
            "original": "azure_disk"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateVolumeAzureFileSetting",
                "name": "ReplicationControllerSpecTemplateVolumeAzureFileSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to false",
                        "(read/write)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_secretName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of secret that contains Azure Storage Account Name and Key"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_name\" <$> TF.attribute",
                    "name": "_secretName",
                    "method": "secretName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSecretName",
                    "validate": false,
                    "optional": false,
                    "original": "secret_name"
                },
                {
                    "default": "_shareName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Share Name"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"share_name\" <$> TF.attribute",
                    "name": "_shareName",
                    "method": "shareName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasShareName",
                    "validate": false,
                    "optional": false,
                    "original": "share_name"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.volume.azure_file",
            "name": "ReplicationControllerSpecTemplateVolumeAzureFileSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_secretName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of secret that contains Azure Storage Account Name and Key"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_name\" <$> TF.attribute",
                    "name": "_secretName",
                    "method": "secretName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSecretName",
                    "validate": false,
                    "optional": false,
                    "original": "secret_name"
                },
                {
                    "default": "_shareName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Share Name"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"share_name\" <$> TF.attribute",
                    "name": "_shareName",
                    "method": "shareName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasShareName",
                    "validate": false,
                    "optional": false,
                    "original": "share_name"
                }
            ],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateVolumeAzureFileSetting s",
            "original": "azure_file"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateVolumeCephFsSecretRefSetting",
                "name": "ReplicationControllerSpecTemplateVolumeCephFsSecretRefSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.volume.ceph_fs.secret_ref",
            "name": "ReplicationControllerSpecTemplateVolumeCephFsSecretRefSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateVolumeCephFsSecretRefSetting s",
            "original": "secret_ref"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateVolumeCephFsSetting",
                "name": "ReplicationControllerSpecTemplateVolumeCephFsSetting'"
            },
            "arguments": [
                {
                    "default": "_monitors",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Monitors is a collection of Ceph monitors More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"monitors\" <$> TF.attribute",
                    "name": "_monitors",
                    "method": "monitors",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasMonitors",
                    "validate": false,
                    "optional": false,
                    "original": "monitors"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Used as the mounted root, rather than the full Ceph tree, default is /"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": true,
                    "original": "path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to `false`",
                        "(read/write). More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The path to key ring for User, default is /etc/ceph/user.secret More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_file\" <$> TF.attribute",
                    "name": "_secretFile",
                    "method": "secretFile",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSecretFile",
                    "validate": false,
                    "optional": true,
                    "original": "secret_file"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Reference to the authentication secret for User, default is empty. More",
                        "info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_ref\" <$> TF.attribute",
                    "name": "_secretRef",
                    "method": "secretRef",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateVolumeCephFsSecretRefSetting s)",
                    "class": "HasSecretRef",
                    "validate": true,
                    "optional": true,
                    "original": "secret_ref"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "User is the rados user name, default is admin. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"user\" <$> TF.attribute",
                    "name": "_user",
                    "method": "user",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasUser",
                    "validate": false,
                    "optional": true,
                    "original": "user"
                }
            ],
            "dependencies": [
                "ReplicationControllerSpecTemplateVolumeCephFsSecretRefSetting"
            ],
            "key": "replication_controller.spec.template.volume.ceph_fs",
            "name": "ReplicationControllerSpecTemplateVolumeCephFsSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_monitors",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Monitors is a collection of Ceph monitors More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"monitors\" <$> TF.attribute",
                    "name": "_monitors",
                    "method": "monitors",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasMonitors",
                    "validate": false,
                    "optional": false,
                    "original": "monitors"
                }
            ],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateVolumeCephFsSetting s",
            "original": "ceph_fs"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateVolumeCinderSetting",
                "name": "ReplicationControllerSpecTemplateVolumeCinderSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type to mount. Must be a filesystem type supported by the host",
                        "operating system. Examples: \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be",
                        "\"ext4\" if unspecified. More info:",
                        "http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to false",
                        "(read/write). More info:",
                        "http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_volumeId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Volume ID used to identify the volume in Cinder. More info:",
                        "http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_id\" <$> TF.attribute",
                    "name": "_volumeId",
                    "method": "volumeId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumeId",
                    "validate": false,
                    "optional": false,
                    "original": "volume_id"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.volume.cinder",
            "name": "ReplicationControllerSpecTemplateVolumeCinderSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_volumeId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Volume ID used to identify the volume in Cinder. More info:",
                        "http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_id\" <$> TF.attribute",
                    "name": "_volumeId",
                    "method": "volumeId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumeId",
                    "validate": false,
                    "optional": false,
                    "original": "volume_id"
                }
            ],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateVolumeCinderSetting s",
            "original": "cinder"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateVolumeConfigMapItemsSetting",
                "name": "ReplicationControllerSpecTemplateVolumeConfigMapItemsSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The key to project."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"key\" <$> TF.attribute",
                    "name": "_key",
                    "method": "key",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasKey",
                    "validate": false,
                    "optional": true,
                    "original": "key"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional: mode bits to use on this file, must be a value between 0 and 0777.",
                        "If not specified, the volume defaultMode will be used. This might be in",
                        "conflict with other options that affect the file mode, like fsGroup, and the",
                        "result can be other mode bits set."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"mode\" <$> TF.attribute",
                    "name": "_mode",
                    "method": "mode",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasMode",
                    "validate": false,
                    "optional": true,
                    "original": "mode"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The relative path of the file to map the key to. May not be an absolute",
                        "path. May not contain the path element '..'. May not start with the string",
                        "'..'."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": true,
                    "original": "path"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.volume.config_map.items",
            "name": "ReplicationControllerSpecTemplateVolumeConfigMapItemsSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateVolumeConfigMapItemsSetting s",
            "original": "items"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateVolumeConfigMapSetting",
                "name": "ReplicationControllerSpecTemplateVolumeConfigMapSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional: mode bits to use on created files by default. Must be a value",
                        "between 0 and 0777. Defaults to 0644. Directories within the path are not",
                        "affected by this setting. This might be in conflict with other options that",
                        "affect the file mode, like fsGroup, and the result can be other mode bits",
                        "set."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"default_mode\" <$> TF.attribute",
                    "name": "_defaultMode",
                    "method": "defaultMode",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasDefaultMode",
                    "validate": false,
                    "optional": true,
                    "original": "default_mode"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If unspecified, each key-value pair in the Data field of the referenced",
                        "ConfigMap will be projected into the volume as a file whose name is the key",
                        "and content is the value. If specified, the listed keys will be projected",
                        "into the specified paths, and unlisted keys will not be present. If a key is",
                        "specified which is not present in the ConfigMap, the volume setup will",
                        "error. Paths must be relative and may not contain the '..' path or start",
                        "with '..'."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"items\" <$> TF.attribute",
                    "name": "_items",
                    "method": "items",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ReplicationControllerSpecTemplateVolumeConfigMapItemsSetting s)]",
                    "class": "HasItems",
                    "validate": false,
                    "optional": true,
                    "original": "items"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "dependencies": [
                "ReplicationControllerSpecTemplateVolumeConfigMapItemsSetting"
            ],
            "key": "replication_controller.spec.template.volume.config_map",
            "name": "ReplicationControllerSpecTemplateVolumeConfigMapSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateVolumeConfigMapSetting s",
            "original": "config_map"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateVolumeDownwardApiItemsFieldRefSetting",
                "name": "ReplicationControllerSpecTemplateVolumeDownwardApiItemsFieldRefSetting'"
            },
            "arguments": [
                {
                    "default": "TF.value \"v1\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Version of the schema the FieldPath is written in terms of, defaults to",
                        "\"v1\"."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"api_version\" <$> TF.attribute",
                    "name": "_apiVersion",
                    "method": "apiVersion",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasApiVersion",
                    "validate": false,
                    "optional": true,
                    "original": "api_version"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path of the field to select in the specified API version"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"field_path\" <$> TF.attribute",
                    "name": "_fieldPath",
                    "method": "fieldPath",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFieldPath",
                    "validate": false,
                    "optional": true,
                    "original": "field_path"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.volume.downward_api.items.field_ref",
            "name": "ReplicationControllerSpecTemplateVolumeDownwardApiItemsFieldRefSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateVolumeDownwardApiItemsFieldRefSetting s",
            "original": "field_ref"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateVolumeDownwardApiItemsResourceFieldRefSetting",
                "name": "ReplicationControllerSpecTemplateVolumeDownwardApiItemsResourceFieldRefSetting'"
            },
            "arguments": [
                {
                    "default": "_containerName",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"container_name\" <$> TF.attribute",
                    "name": "_containerName",
                    "method": "containerName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasContainerName",
                    "validate": false,
                    "optional": false,
                    "original": "container_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"quantity\" <$> TF.attribute",
                    "name": "_quantity",
                    "method": "quantity",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasQuantity",
                    "validate": false,
                    "optional": true,
                    "original": "quantity"
                },
                {
                    "default": "_resource'",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Resource to select"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource\" <$> TF.attribute",
                    "name": "_resource'",
                    "method": "resource'",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasResource'",
                    "validate": false,
                    "optional": false,
                    "original": "resource"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.volume.downward_api.items.resource_field_ref",
            "name": "ReplicationControllerSpecTemplateVolumeDownwardApiItemsResourceFieldRefSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_containerName",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"container_name\" <$> TF.attribute",
                    "name": "_containerName",
                    "method": "containerName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasContainerName",
                    "validate": false,
                    "optional": false,
                    "original": "container_name"
                },
                {
                    "default": "_resource'",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Resource to select"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource\" <$> TF.attribute",
                    "name": "_resource'",
                    "method": "resource'",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasResource'",
                    "validate": false,
                    "optional": false,
                    "original": "resource"
                }
            ],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateVolumeDownwardApiItemsResourceFieldRefSetting s",
            "original": "resource_field_ref"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateVolumeDownwardApiItemsSetting",
                "name": "ReplicationControllerSpecTemplateVolumeDownwardApiItemsSetting'"
            },
            "arguments": [
                {
                    "default": "_fieldRef",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Required: Selects a field of the pod: only annotations, labels, name and",
                        "namespace are supported."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"field_ref\" <$> TF.attribute",
                    "name": "_fieldRef",
                    "method": "fieldRef",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateVolumeDownwardApiItemsFieldRefSetting s)",
                    "class": "HasFieldRef",
                    "validate": true,
                    "optional": false,
                    "original": "field_ref"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional: mode bits to use on this file, must be a value between 0 and 0777.",
                        "If not specified, the volume defaultMode will be used. This might be in",
                        "conflict with other options that affect the file mode, like fsGroup, and the",
                        "result can be other mode bits set."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"mode\" <$> TF.attribute",
                    "name": "_mode",
                    "method": "mode",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasMode",
                    "validate": false,
                    "optional": true,
                    "original": "mode"
                },
                {
                    "default": "_path",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path is the relative path name of the file to be created. Must not be",
                        "absolute or contain the '..' path. Must be utf-8 encoded. The first item of",
                        "the relative path must not start with '..'"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": false,
                    "original": "path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Selects a resource of the container: only resources limits and requests",
                        "(limits.cpu, limits.memory, requests.cpu and requests.memory) are currently",
                        "supported."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_field_ref\" <$> TF.attribute",
                    "name": "_resourceFieldRef",
                    "method": "resourceFieldRef",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateVolumeDownwardApiItemsResourceFieldRefSetting s)",
                    "class": "HasResourceFieldRef",
                    "validate": true,
                    "optional": true,
                    "original": "resource_field_ref"
                }
            ],
            "dependencies": [
                "ReplicationControllerSpecTemplateVolumeDownwardApiItemsFieldRefSetting",
                "ReplicationControllerSpecTemplateVolumeDownwardApiItemsResourceFieldRefSetting"
            ],
            "key": "replication_controller.spec.template.volume.downward_api.items",
            "name": "ReplicationControllerSpecTemplateVolumeDownwardApiItemsSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_path",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path is the relative path name of the file to be created. Must not be",
                        "absolute or contain the '..' path. Must be utf-8 encoded. The first item of",
                        "the relative path must not start with '..'"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": false,
                    "original": "path"
                },
                {
                    "default": "_fieldRef",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Required: Selects a field of the pod: only annotations, labels, name and",
                        "namespace are supported."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"field_ref\" <$> TF.attribute",
                    "name": "_fieldRef",
                    "method": "fieldRef",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateVolumeDownwardApiItemsFieldRefSetting s)",
                    "class": "HasFieldRef",
                    "validate": true,
                    "optional": false,
                    "original": "field_ref"
                }
            ],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateVolumeDownwardApiItemsSetting s",
            "original": "items"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateVolumeDownwardApiSetting",
                "name": "ReplicationControllerSpecTemplateVolumeDownwardApiSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional: mode bits to use on created files by default. Must be a value",
                        "between 0 and 0777. Defaults to 0644. Directories within the path are not",
                        "affected by this setting. This might be in conflict with other options that",
                        "affect the file mode, like fsGroup, and the result can be other mode bits",
                        "set."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"default_mode\" <$> TF.attribute",
                    "name": "_defaultMode",
                    "method": "defaultMode",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasDefaultMode",
                    "validate": false,
                    "optional": true,
                    "original": "default_mode"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If unspecified, each key-value pair in the Data field of the referenced",
                        "ConfigMap will be projected into the volume as a file whose name is the key",
                        "and content is the value. If specified, the listed keys will be projected",
                        "into the specified paths, and unlisted keys will not be present. If a key is",
                        "specified which is not present in the ConfigMap, the volume setup will",
                        "error. Paths must be relative and may not contain the '..' path or start",
                        "with '..'."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"items\" <$> TF.attribute",
                    "name": "_items",
                    "method": "items",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ReplicationControllerSpecTemplateVolumeDownwardApiItemsSetting s)]",
                    "class": "HasItems",
                    "validate": false,
                    "optional": true,
                    "original": "items"
                }
            ],
            "dependencies": [
                "ReplicationControllerSpecTemplateVolumeDownwardApiItemsSetting"
            ],
            "key": "replication_controller.spec.template.volume.downward_api",
            "name": "ReplicationControllerSpecTemplateVolumeDownwardApiSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateVolumeDownwardApiSetting s",
            "original": "downward_api"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateVolumeEmptyDirSetting",
                "name": "ReplicationControllerSpecTemplateVolumeEmptyDirSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "What type of storage medium should back this directory. The default is \"\"",
                        "which means to use the node's default medium. Must be an empty string",
                        "(default) or Memory. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#emptydir"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"medium\" <$> TF.attribute",
                    "name": "_medium",
                    "method": "medium",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasMedium",
                    "validate": false,
                    "optional": true,
                    "original": "medium"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.volume.empty_dir",
            "name": "ReplicationControllerSpecTemplateVolumeEmptyDirSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateVolumeEmptyDirSetting s",
            "original": "empty_dir"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateVolumeFcSetting",
                "name": "ReplicationControllerSpecTemplateVolumeFcSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type to mount. Must be a filesystem type supported by the host",
                        "operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be",
                        "\"ext4\" if unspecified."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "_lun",
                    "computed": false,
                    "required": true,
                    "help": [
                        "FC target lun number"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"lun\" <$> TF.attribute",
                    "name": "_lun",
                    "method": "lun",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasLun",
                    "validate": false,
                    "optional": false,
                    "original": "lun"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to false",
                        "(read/write)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_targetWwNs",
                    "computed": false,
                    "required": true,
                    "help": [
                        "FC target worldwide names (WWNs)"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"target_ww_ns\" <$> TF.attribute",
                    "name": "_targetWwNs",
                    "method": "targetWwNs",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasTargetWwNs",
                    "validate": false,
                    "optional": false,
                    "original": "target_ww_ns"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.volume.fc",
            "name": "ReplicationControllerSpecTemplateVolumeFcSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_lun",
                    "computed": false,
                    "required": true,
                    "help": [
                        "FC target lun number"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"lun\" <$> TF.attribute",
                    "name": "_lun",
                    "method": "lun",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasLun",
                    "validate": false,
                    "optional": false,
                    "original": "lun"
                },
                {
                    "default": "_targetWwNs",
                    "computed": false,
                    "required": true,
                    "help": [
                        "FC target worldwide names (WWNs)"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"target_ww_ns\" <$> TF.attribute",
                    "name": "_targetWwNs",
                    "method": "targetWwNs",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasTargetWwNs",
                    "validate": false,
                    "optional": false,
                    "original": "target_ww_ns"
                }
            ],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateVolumeFcSetting s",
            "original": "fc"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateVolumeFlexVolumeSecretRefSetting",
                "name": "ReplicationControllerSpecTemplateVolumeFlexVolumeSecretRefSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.volume.flex_volume.secret_ref",
            "name": "ReplicationControllerSpecTemplateVolumeFlexVolumeSecretRefSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateVolumeFlexVolumeSecretRefSetting s",
            "original": "secret_ref"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateVolumeFlexVolumeSetting",
                "name": "ReplicationControllerSpecTemplateVolumeFlexVolumeSetting'"
            },
            "arguments": [
                {
                    "default": "_driver",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Driver is the name of the driver to use for this volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"driver\" <$> TF.attribute",
                    "name": "_driver",
                    "method": "driver",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDriver",
                    "validate": false,
                    "optional": false,
                    "original": "driver"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type to mount. Must be a filesystem type supported by the host",
                        "operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". The default filesystem depends",
                        "on FlexVolume script."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Extra command options if any."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"options\" <$> TF.attribute",
                    "name": "_options",
                    "method": "options",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasOptions",
                    "validate": false,
                    "optional": true,
                    "original": "options"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the ReadOnly setting in VolumeMounts. Defaults to false",
                        "(read/write)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Reference to the secret object containing sensitive information to pass to",
                        "the plugin scripts. This may be empty if no secret object is specified. If",
                        "the secret object contains more than one secret, all secrets are passed to",
                        "the plugin scripts."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_ref\" <$> TF.attribute",
                    "name": "_secretRef",
                    "method": "secretRef",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateVolumeFlexVolumeSecretRefSetting s)",
                    "class": "HasSecretRef",
                    "validate": true,
                    "optional": true,
                    "original": "secret_ref"
                }
            ],
            "dependencies": [
                "ReplicationControllerSpecTemplateVolumeFlexVolumeSecretRefSetting"
            ],
            "key": "replication_controller.spec.template.volume.flex_volume",
            "name": "ReplicationControllerSpecTemplateVolumeFlexVolumeSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_driver",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Driver is the name of the driver to use for this volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"driver\" <$> TF.attribute",
                    "name": "_driver",
                    "method": "driver",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDriver",
                    "validate": false,
                    "optional": false,
                    "original": "driver"
                }
            ],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateVolumeFlexVolumeSetting s",
            "original": "flex_volume"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateVolumeFlockerSetting",
                "name": "ReplicationControllerSpecTemplateVolumeFlockerSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the dataset stored as metadata -> name on the dataset for Flocker",
                        "should be considered as deprecated"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"dataset_name\" <$> TF.attribute",
                    "name": "_datasetName",
                    "method": "datasetName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatasetName",
                    "validate": false,
                    "optional": true,
                    "original": "dataset_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "UUID of the dataset. This is unique identifier of a Flocker dataset"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"dataset_uuid\" <$> TF.attribute",
                    "name": "_datasetUuid",
                    "method": "datasetUuid",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatasetUuid",
                    "validate": false,
                    "optional": true,
                    "original": "dataset_uuid"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.volume.flocker",
            "name": "ReplicationControllerSpecTemplateVolumeFlockerSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateVolumeFlockerSetting s",
            "original": "flocker"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateVolumeGcePersistentDiskSetting",
                "name": "ReplicationControllerSpecTemplateVolumeGcePersistentDiskSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type of the volume that you want to mount. Tip: Ensure that the",
                        "filesystem type is supported by the host operating system. Examples: \"ext4\",",
                        "\"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The partition in the volume that you want to mount. If omitted, the default",
                        "is to mount by volume name. Examples: For volume /dev/sda1, you specify the",
                        "partition as \"1\". Similarly, the volume partition for /dev/sda is \"0\" (or",
                        "you can leave the property empty). More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"partition\" <$> TF.attribute",
                    "name": "_partition",
                    "method": "partition",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasPartition",
                    "validate": false,
                    "optional": true,
                    "original": "partition"
                },
                {
                    "default": "_pdName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Unique name of the PD resource in GCE. Used to identify the disk in GCE.",
                        "More info: http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"pd_name\" <$> TF.attribute",
                    "name": "_pdName",
                    "method": "pdName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPdName",
                    "validate": false,
                    "optional": false,
                    "original": "pd_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the ReadOnly setting in VolumeMounts. Defaults to false.",
                        "More info: http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.volume.gce_persistent_disk",
            "name": "ReplicationControllerSpecTemplateVolumeGcePersistentDiskSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_pdName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Unique name of the PD resource in GCE. Used to identify the disk in GCE.",
                        "More info: http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"pd_name\" <$> TF.attribute",
                    "name": "_pdName",
                    "method": "pdName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPdName",
                    "validate": false,
                    "optional": false,
                    "original": "pd_name"
                }
            ],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateVolumeGcePersistentDiskSetting s",
            "original": "gce_persistent_disk"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateVolumeGitRepoSetting",
                "name": "ReplicationControllerSpecTemplateVolumeGitRepoSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Target directory name. Must not contain or start with '..'. If '.' is",
                        "supplied, the volume directory will be the git repository. Otherwise, if",
                        "specified, the volume will contain the git repository in the subdirectory",
                        "with the given name."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"directory\" <$> TF.attribute",
                    "name": "_directory",
                    "method": "directory",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDirectory",
                    "validate": false,
                    "optional": true,
                    "original": "directory"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Repository URL"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"repository\" <$> TF.attribute",
                    "name": "_repository",
                    "method": "repository",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRepository",
                    "validate": false,
                    "optional": true,
                    "original": "repository"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Commit hash for the specified revision."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"revision\" <$> TF.attribute",
                    "name": "_revision",
                    "method": "revision",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRevision",
                    "validate": false,
                    "optional": true,
                    "original": "revision"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.volume.git_repo",
            "name": "ReplicationControllerSpecTemplateVolumeGitRepoSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateVolumeGitRepoSetting s",
            "original": "git_repo"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateVolumeGlusterfsSetting",
                "name": "ReplicationControllerSpecTemplateVolumeGlusterfsSetting'"
            },
            "arguments": [
                {
                    "default": "_endpointsName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The endpoint name that details Glusterfs topology. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"endpoints_name\" <$> TF.attribute",
                    "name": "_endpointsName",
                    "method": "endpointsName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasEndpointsName",
                    "validate": false,
                    "optional": false,
                    "original": "endpoints_name"
                },
                {
                    "default": "_path",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The Glusterfs volume path. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": false,
                    "original": "path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the Glusterfs volume to be mounted with read-only",
                        "permissions. Defaults to false. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.volume.glusterfs",
            "name": "ReplicationControllerSpecTemplateVolumeGlusterfsSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_endpointsName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The endpoint name that details Glusterfs topology. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"endpoints_name\" <$> TF.attribute",
                    "name": "_endpointsName",
                    "method": "endpointsName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasEndpointsName",
                    "validate": false,
                    "optional": false,
                    "original": "endpoints_name"
                },
                {
                    "default": "_path",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The Glusterfs volume path. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": false,
                    "original": "path"
                }
            ],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateVolumeGlusterfsSetting s",
            "original": "glusterfs"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateVolumeHostPathSetting",
                "name": "ReplicationControllerSpecTemplateVolumeHostPathSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path of the directory on the host. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#hostpath"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": true,
                    "original": "path"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.volume.host_path",
            "name": "ReplicationControllerSpecTemplateVolumeHostPathSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateVolumeHostPathSetting s",
            "original": "host_path"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateVolumeIscsiSetting",
                "name": "ReplicationControllerSpecTemplateVolumeIscsiSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type of the volume that you want to mount. Tip: Ensure that the",
                        "filesystem type is supported by the host operating system. Examples: \"ext4\",",
                        "\"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#iscsi"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "_iqn",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Target iSCSI Qualified Name."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"iqn\" <$> TF.attribute",
                    "name": "_iqn",
                    "method": "iqn",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasIqn",
                    "validate": false,
                    "optional": false,
                    "original": "iqn"
                },
                {
                    "default": "TF.value \"default\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "ISCSI interface name that uses an iSCSI transport. Defaults to 'default'",
                        "(tcp)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"iscsi_interface\" <$> TF.attribute",
                    "name": "_iscsiInterface",
                    "method": "iscsiInterface",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasIscsiInterface",
                    "validate": false,
                    "optional": true,
                    "original": "iscsi_interface"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "ISCSI target lun number."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"lun\" <$> TF.attribute",
                    "name": "_lun",
                    "method": "lun",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasLun",
                    "validate": false,
                    "optional": true,
                    "original": "lun"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to false."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_targetPortal",
                    "computed": false,
                    "required": true,
                    "help": [
                        "ISCSI target portal. The portal is either an IP or ip_addr:port if the port",
                        "is other than default (typically TCP ports 860 and 3260)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"target_portal\" <$> TF.attribute",
                    "name": "_targetPortal",
                    "method": "targetPortal",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasTargetPortal",
                    "validate": false,
                    "optional": false,
                    "original": "target_portal"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.volume.iscsi",
            "name": "ReplicationControllerSpecTemplateVolumeIscsiSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_iqn",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Target iSCSI Qualified Name."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"iqn\" <$> TF.attribute",
                    "name": "_iqn",
                    "method": "iqn",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasIqn",
                    "validate": false,
                    "optional": false,
                    "original": "iqn"
                },
                {
                    "default": "_targetPortal",
                    "computed": false,
                    "required": true,
                    "help": [
                        "ISCSI target portal. The portal is either an IP or ip_addr:port if the port",
                        "is other than default (typically TCP ports 860 and 3260)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"target_portal\" <$> TF.attribute",
                    "name": "_targetPortal",
                    "method": "targetPortal",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasTargetPortal",
                    "validate": false,
                    "optional": false,
                    "original": "target_portal"
                }
            ],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateVolumeIscsiSetting s",
            "original": "iscsi"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateVolumeNfsSetting",
                "name": "ReplicationControllerSpecTemplateVolumeNfsSetting'"
            },
            "arguments": [
                {
                    "default": "_path",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path that is exported by the NFS server. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": false,
                    "original": "path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the NFS export to be mounted with read-only permissions.",
                        "Defaults to false. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_server",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Server is the hostname or IP address of the NFS server. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"server\" <$> TF.attribute",
                    "name": "_server",
                    "method": "server",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasServer",
                    "validate": false,
                    "optional": false,
                    "original": "server"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.volume.nfs",
            "name": "ReplicationControllerSpecTemplateVolumeNfsSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_path",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path that is exported by the NFS server. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": false,
                    "original": "path"
                },
                {
                    "default": "_server",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Server is the hostname or IP address of the NFS server. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"server\" <$> TF.attribute",
                    "name": "_server",
                    "method": "server",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasServer",
                    "validate": false,
                    "optional": false,
                    "original": "server"
                }
            ],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateVolumeNfsSetting s",
            "original": "nfs"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateVolumePersistentVolumeClaimSetting",
                "name": "ReplicationControllerSpecTemplateVolumePersistentVolumeClaimSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "ClaimName is the name of a PersistentVolumeClaim in the same"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"claim_name\" <$> TF.attribute",
                    "name": "_claimName",
                    "method": "claimName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasClaimName",
                    "validate": false,
                    "optional": true,
                    "original": "claim_name"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Will force the ReadOnly setting in VolumeMounts."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.volume.persistent_volume_claim",
            "name": "ReplicationControllerSpecTemplateVolumePersistentVolumeClaimSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateVolumePersistentVolumeClaimSetting s",
            "original": "persistent_volume_claim"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateVolumePhotonPersistentDiskSetting",
                "name": "ReplicationControllerSpecTemplateVolumePhotonPersistentDiskSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type to mount. Must be a filesystem type supported by the host",
                        "operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be",
                        "\"ext4\" if unspecified."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "_pdId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "ID that identifies Photon Controller persistent disk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"pd_id\" <$> TF.attribute",
                    "name": "_pdId",
                    "method": "pdId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPdId",
                    "validate": false,
                    "optional": false,
                    "original": "pd_id"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.volume.photon_persistent_disk",
            "name": "ReplicationControllerSpecTemplateVolumePhotonPersistentDiskSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_pdId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "ID that identifies Photon Controller persistent disk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"pd_id\" <$> TF.attribute",
                    "name": "_pdId",
                    "method": "pdId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPdId",
                    "validate": false,
                    "optional": false,
                    "original": "pd_id"
                }
            ],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateVolumePhotonPersistentDiskSetting s",
            "original": "photon_persistent_disk"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateVolumeQuobyteSetting",
                "name": "ReplicationControllerSpecTemplateVolumeQuobyteSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Group to map volume access to Default is no group"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"group\" <$> TF.attribute",
                    "name": "_group",
                    "method": "group",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasGroup",
                    "validate": false,
                    "optional": true,
                    "original": "group"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the Quobyte volume to be mounted with read-only",
                        "permissions. Defaults to false."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_registry",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Registry represents a single or multiple Quobyte Registry services specified",
                        "as a string as host:port pair (multiple entries are separated with commas)",
                        "which acts as the central registry for volumes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"registry\" <$> TF.attribute",
                    "name": "_registry",
                    "method": "registry",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRegistry",
                    "validate": false,
                    "optional": false,
                    "original": "registry"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "User to map volume access to Defaults to serivceaccount user"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"user\" <$> TF.attribute",
                    "name": "_user",
                    "method": "user",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasUser",
                    "validate": false,
                    "optional": true,
                    "original": "user"
                },
                {
                    "default": "_volume",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Volume is a string that references an already created Quobyte volume by",
                        "name."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume\" <$> TF.attribute",
                    "name": "_volume",
                    "method": "volume",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolume",
                    "validate": false,
                    "optional": false,
                    "original": "volume"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.volume.quobyte",
            "name": "ReplicationControllerSpecTemplateVolumeQuobyteSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_registry",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Registry represents a single or multiple Quobyte Registry services specified",
                        "as a string as host:port pair (multiple entries are separated with commas)",
                        "which acts as the central registry for volumes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"registry\" <$> TF.attribute",
                    "name": "_registry",
                    "method": "registry",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRegistry",
                    "validate": false,
                    "optional": false,
                    "original": "registry"
                },
                {
                    "default": "_volume",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Volume is a string that references an already created Quobyte volume by",
                        "name."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume\" <$> TF.attribute",
                    "name": "_volume",
                    "method": "volume",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolume",
                    "validate": false,
                    "optional": false,
                    "original": "volume"
                }
            ],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateVolumeQuobyteSetting s",
            "original": "quobyte"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateVolumeRbdSecretRefSetting",
                "name": "ReplicationControllerSpecTemplateVolumeRbdSecretRefSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.volume.rbd.secret_ref",
            "name": "ReplicationControllerSpecTemplateVolumeRbdSecretRefSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateVolumeRbdSecretRefSetting s",
            "original": "secret_ref"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateVolumeRbdSetting",
                "name": "ReplicationControllerSpecTemplateVolumeRbdSetting'"
            },
            "arguments": [
                {
                    "default": "_cephMonitors",
                    "computed": false,
                    "required": true,
                    "help": [
                        "A collection of Ceph monitors. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ceph_monitors\" <$> TF.attribute",
                    "name": "_cephMonitors",
                    "method": "cephMonitors",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCephMonitors",
                    "validate": false,
                    "optional": false,
                    "original": "ceph_monitors"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type of the volume that you want to mount. Tip: Ensure that the",
                        "filesystem type is supported by the host operating system. Examples: \"ext4\",",
                        "\"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#rbd"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring.",
                        "More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"keyring\" <$> TF.attribute",
                    "name": "_keyring",
                    "method": "keyring",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasKeyring",
                    "validate": false,
                    "optional": true,
                    "original": "keyring"
                },
                {
                    "default": "TF.value \"admin\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The rados user name. Default is admin. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"rados_user\" <$> TF.attribute",
                    "name": "_radosUser",
                    "method": "radosUser",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRadosUser",
                    "validate": false,
                    "optional": true,
                    "original": "rados_user"
                },
                {
                    "default": "_rbdImage",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The rados image name. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"rbd_image\" <$> TF.attribute",
                    "name": "_rbdImage",
                    "method": "rbdImage",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRbdImage",
                    "validate": false,
                    "optional": false,
                    "original": "rbd_image"
                },
                {
                    "default": "TF.value \"rbd\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The rados pool name. Default is rbd. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"rbd_pool\" <$> TF.attribute",
                    "name": "_rbdPool",
                    "method": "rbdPool",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRbdPool",
                    "validate": false,
                    "optional": true,
                    "original": "rbd_pool"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to false.",
                        "More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the authentication secret for RBDUser. If provided overrides",
                        "keyring. Default is nil. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_ref\" <$> TF.attribute",
                    "name": "_secretRef",
                    "method": "secretRef",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateVolumeRbdSecretRefSetting s)",
                    "class": "HasSecretRef",
                    "validate": true,
                    "optional": true,
                    "original": "secret_ref"
                }
            ],
            "dependencies": [
                "ReplicationControllerSpecTemplateVolumeRbdSecretRefSetting"
            ],
            "key": "replication_controller.spec.template.volume.rbd",
            "name": "ReplicationControllerSpecTemplateVolumeRbdSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring.",
                        "More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"keyring\" <$> TF.attribute",
                    "name": "_computedKeyring",
                    "method": "computedKeyring",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedKeyring",
                    "validate": false,
                    "optional": false,
                    "original": "keyring"
                }
            ],
            "parameters": [
                {
                    "default": "_rbdImage",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The rados image name. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"rbd_image\" <$> TF.attribute",
                    "name": "_rbdImage",
                    "method": "rbdImage",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRbdImage",
                    "validate": false,
                    "optional": false,
                    "original": "rbd_image"
                },
                {
                    "default": "_cephMonitors",
                    "computed": false,
                    "required": true,
                    "help": [
                        "A collection of Ceph monitors. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ceph_monitors\" <$> TF.attribute",
                    "name": "_cephMonitors",
                    "method": "cephMonitors",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCephMonitors",
                    "validate": false,
                    "optional": false,
                    "original": "ceph_monitors"
                }
            ],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateVolumeRbdSetting s",
            "original": "rbd"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateVolumeSecretItemsSetting",
                "name": "ReplicationControllerSpecTemplateVolumeSecretItemsSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The key to project."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"key\" <$> TF.attribute",
                    "name": "_key",
                    "method": "key",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasKey",
                    "validate": false,
                    "optional": true,
                    "original": "key"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional: mode bits to use on this file, must be a value between 0 and 0777.",
                        "If not specified, the volume defaultMode will be used. This might be in",
                        "conflict with other options that affect the file mode, like fsGroup, and the",
                        "result can be other mode bits set."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"mode\" <$> TF.attribute",
                    "name": "_mode",
                    "method": "mode",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasMode",
                    "validate": false,
                    "optional": true,
                    "original": "mode"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The relative path of the file to map the key to. May not be an absolute",
                        "path. May not contain the path element '..'. May not start with the string",
                        "'..'."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": true,
                    "original": "path"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.volume.secret.items",
            "name": "ReplicationControllerSpecTemplateVolumeSecretItemsSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateVolumeSecretItemsSetting s",
            "original": "items"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateVolumeSecretSetting",
                "name": "ReplicationControllerSpecTemplateVolumeSecretSetting'"
            },
            "arguments": [
                {
                    "default": "TF.value 420",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional: mode bits to use on created files by default. Must be a value",
                        "between 0 and 0777. Defaults to 0644. Directories within the path are not",
                        "affected by this setting. This might be in conflict with other options that",
                        "affect the file mode, like fsGroup, and the result can be other mode bits",
                        "set."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"default_mode\" <$> TF.attribute",
                    "name": "_defaultMode",
                    "method": "defaultMode",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasDefaultMode",
                    "validate": false,
                    "optional": true,
                    "original": "default_mode"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If unspecified, each key-value pair in the Data field of the referenced",
                        "Secret will be projected into the volume as a file whose name is the key and",
                        "content is the value. If specified, the listed keys will be projected into",
                        "the specified paths, and unlisted keys will not be present. If a key is",
                        "specified which is not present in the Secret, the volume setup will error",
                        "unless it is marked optional. Paths must be relative and may not contain the",
                        "'..' path or start with '..'."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"items\" <$> TF.attribute",
                    "name": "_items",
                    "method": "items",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ReplicationControllerSpecTemplateVolumeSecretItemsSetting s)]",
                    "class": "HasItems",
                    "validate": false,
                    "optional": true,
                    "original": "items"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional: Specify whether the Secret or it's keys must be defined."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"optional\" <$> TF.attribute",
                    "name": "_optional",
                    "method": "optional",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasOptional",
                    "validate": false,
                    "optional": true,
                    "original": "optional"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the secret in the pod's namespace to use. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#secrets"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_name\" <$> TF.attribute",
                    "name": "_secretName",
                    "method": "secretName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSecretName",
                    "validate": false,
                    "optional": true,
                    "original": "secret_name"
                }
            ],
            "dependencies": [
                "ReplicationControllerSpecTemplateVolumeSecretItemsSetting"
            ],
            "key": "replication_controller.spec.template.volume.secret",
            "name": "ReplicationControllerSpecTemplateVolumeSecretSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateVolumeSecretSetting s",
            "original": "secret"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateVolumeSetting",
                "name": "ReplicationControllerSpecTemplateVolumeSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an AWS Disk resource that is attached to a kubelet's host machine",
                        "and then exposed to the pod. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"aws_elastic_block_store\" <$> TF.attribute",
                    "name": "_awsElasticBlockStore",
                    "method": "awsElasticBlockStore",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateVolumeAwsElasticBlockStoreSetting s)",
                    "class": "HasAwsElasticBlockStore",
                    "validate": true,
                    "optional": true,
                    "original": "aws_elastic_block_store"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an Azure Data Disk mount on the host and bind mount to the pod."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"azure_disk\" <$> TF.attribute",
                    "name": "_azureDisk",
                    "method": "azureDisk",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateVolumeAzureDiskSetting s)",
                    "class": "HasAzureDisk",
                    "validate": true,
                    "optional": true,
                    "original": "azure_disk"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an Azure File Service mount on the host and bind mount to the",
                        "pod."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"azure_file\" <$> TF.attribute",
                    "name": "_azureFile",
                    "method": "azureFile",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateVolumeAzureFileSetting s)",
                    "class": "HasAzureFile",
                    "validate": true,
                    "optional": true,
                    "original": "azure_file"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Ceph FS mount on the host that shares a pod's lifetime"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ceph_fs\" <$> TF.attribute",
                    "name": "_cephFs",
                    "method": "cephFs",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateVolumeCephFsSetting s)",
                    "class": "HasCephFs",
                    "validate": true,
                    "optional": true,
                    "original": "ceph_fs"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a cinder volume attached and mounted on kubelets host machine.",
                        "More info: http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cinder\" <$> TF.attribute",
                    "name": "_cinder",
                    "method": "cinder",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateVolumeCinderSetting s)",
                    "class": "HasCinder",
                    "validate": true,
                    "optional": true,
                    "original": "cinder"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "ConfigMap represents a configMap that should populate this volume"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"config_map\" <$> TF.attribute",
                    "name": "_configMap",
                    "method": "configMap",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateVolumeConfigMapSetting s)",
                    "class": "HasConfigMap",
                    "validate": true,
                    "optional": true,
                    "original": "config_map"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "DownwardAPI represents downward API about the pod that should populate this",
                        "volume"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"downward_api\" <$> TF.attribute",
                    "name": "_downwardApi",
                    "method": "downwardApi",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateVolumeDownwardApiSetting s)",
                    "class": "HasDownwardApi",
                    "validate": true,
                    "optional": true,
                    "original": "downward_api"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "EmptyDir represents a temporary directory that shares a pod's lifetime. More",
                        "info: http://kubernetes.io/docs/user-guide/volumes#emptydir"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"empty_dir\" <$> TF.attribute",
                    "name": "_emptyDir",
                    "method": "emptyDir",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateVolumeEmptyDirSetting s)",
                    "class": "HasEmptyDir",
                    "validate": true,
                    "optional": true,
                    "original": "empty_dir"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Fibre Channel resource that is attached to a kubelet's host",
                        "machine and then exposed to the pod."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fc\" <$> TF.attribute",
                    "name": "_fc",
                    "method": "fc",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateVolumeFcSetting s)",
                    "class": "HasFc",
                    "validate": true,
                    "optional": true,
                    "original": "fc"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a generic volume resource that is provisioned/attached using an",
                        "exec based plugin. This is an alpha feature and may change in future."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"flex_volume\" <$> TF.attribute",
                    "name": "_flexVolume",
                    "method": "flexVolume",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateVolumeFlexVolumeSetting s)",
                    "class": "HasFlexVolume",
                    "validate": true,
                    "optional": true,
                    "original": "flex_volume"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Flocker volume attached to a kubelet's host machine and exposed",
                        "to the pod for its usage. This depends on the Flocker control service being",
                        "running"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"flocker\" <$> TF.attribute",
                    "name": "_flocker",
                    "method": "flocker",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateVolumeFlockerSetting s)",
                    "class": "HasFlocker",
                    "validate": true,
                    "optional": true,
                    "original": "flocker"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a GCE Disk resource that is attached to a kubelet's host machine",
                        "and then exposed to the pod. Provisioned by an admin. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"gce_persistent_disk\" <$> TF.attribute",
                    "name": "_gcePersistentDisk",
                    "method": "gcePersistentDisk",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateVolumeGcePersistentDiskSetting s)",
                    "class": "HasGcePersistentDisk",
                    "validate": true,
                    "optional": true,
                    "original": "gce_persistent_disk"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "GitRepo represents a git repository at a particular revision."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"git_repo\" <$> TF.attribute",
                    "name": "_gitRepo",
                    "method": "gitRepo",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateVolumeGitRepoSetting s)",
                    "class": "HasGitRepo",
                    "validate": true,
                    "optional": true,
                    "original": "git_repo"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Glusterfs volume that is attached to a host and exposed to the",
                        "pod. Provisioned by an admin. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"glusterfs\" <$> TF.attribute",
                    "name": "_glusterfs",
                    "method": "glusterfs",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateVolumeGlusterfsSetting s)",
                    "class": "HasGlusterfs",
                    "validate": true,
                    "optional": true,
                    "original": "glusterfs"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a directory on the host. Provisioned by a developer or tester.",
                        "This is useful for single-node development and testing only! On-host storage",
                        "is not supported in any way and WILL NOT WORK in a multi-node cluster. More",
                        "info: http://kubernetes.io/docs/user-guide/volumes#hostpath"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_path\" <$> TF.attribute",
                    "name": "_hostPath",
                    "method": "hostPath",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateVolumeHostPathSetting s)",
                    "class": "HasHostPath",
                    "validate": true,
                    "optional": true,
                    "original": "host_path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an ISCSI Disk resource that is attached to a kubelet's host",
                        "machine and then exposed to the pod. Provisioned by an admin."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"iscsi\" <$> TF.attribute",
                    "name": "_iscsi",
                    "method": "iscsi",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateVolumeIscsiSetting s)",
                    "class": "HasIscsi",
                    "validate": true,
                    "optional": true,
                    "original": "iscsi"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Volume's name. Must be a DNS_LABEL and unique within the pod. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an NFS mount on the host. Provisioned by an admin. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"nfs\" <$> TF.attribute",
                    "name": "_nfs",
                    "method": "nfs",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateVolumeNfsSetting s)",
                    "class": "HasNfs",
                    "validate": true,
                    "optional": true,
                    "original": "nfs"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The specification of a persistent volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"persistent_volume_claim\" <$> TF.attribute",
                    "name": "_persistentVolumeClaim",
                    "method": "persistentVolumeClaim",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateVolumePersistentVolumeClaimSetting s)",
                    "class": "HasPersistentVolumeClaim",
                    "validate": true,
                    "optional": true,
                    "original": "persistent_volume_claim"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a PhotonController persistent disk attached and mounted on",
                        "kubelets host machine"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"photon_persistent_disk\" <$> TF.attribute",
                    "name": "_photonPersistentDisk",
                    "method": "photonPersistentDisk",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateVolumePhotonPersistentDiskSetting s)",
                    "class": "HasPhotonPersistentDisk",
                    "validate": true,
                    "optional": true,
                    "original": "photon_persistent_disk"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Quobyte represents a Quobyte mount on the host that shares a pod's lifetime"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"quobyte\" <$> TF.attribute",
                    "name": "_quobyte",
                    "method": "quobyte",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateVolumeQuobyteSetting s)",
                    "class": "HasQuobyte",
                    "validate": true,
                    "optional": true,
                    "original": "quobyte"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Rados Block Device mount on the host that shares a pod's",
                        "lifetime. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"rbd\" <$> TF.attribute",
                    "name": "_rbd",
                    "method": "rbd",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateVolumeRbdSetting s)",
                    "class": "HasRbd",
                    "validate": true,
                    "optional": true,
                    "original": "rbd"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Secret represents a secret that should populate this volume. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#secrets"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret\" <$> TF.attribute",
                    "name": "_secret",
                    "method": "secret",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateVolumeSecretSetting s)",
                    "class": "HasSecret",
                    "validate": true,
                    "optional": true,
                    "original": "secret"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a vSphere volume attached and mounted on kubelets host machine"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vsphere_volume\" <$> TF.attribute",
                    "name": "_vsphereVolume",
                    "method": "vsphereVolume",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecTemplateVolumeVsphereVolumeSetting s)",
                    "class": "HasVsphereVolume",
                    "validate": true,
                    "optional": true,
                    "original": "vsphere_volume"
                }
            ],
            "dependencies": [
                "ReplicationControllerSpecTemplateVolumeAwsElasticBlockStoreSetting",
                "ReplicationControllerSpecTemplateVolumeAzureDiskSetting",
                "ReplicationControllerSpecTemplateVolumeAzureFileSetting",
                "ReplicationControllerSpecTemplateVolumeCephFsSetting",
                "ReplicationControllerSpecTemplateVolumeCinderSetting",
                "ReplicationControllerSpecTemplateVolumeConfigMapSetting",
                "ReplicationControllerSpecTemplateVolumeDownwardApiSetting",
                "ReplicationControllerSpecTemplateVolumeEmptyDirSetting",
                "ReplicationControllerSpecTemplateVolumeFcSetting",
                "ReplicationControllerSpecTemplateVolumeFlexVolumeSetting",
                "ReplicationControllerSpecTemplateVolumeFlockerSetting",
                "ReplicationControllerSpecTemplateVolumeGcePersistentDiskSetting",
                "ReplicationControllerSpecTemplateVolumeGitRepoSetting",
                "ReplicationControllerSpecTemplateVolumeGlusterfsSetting",
                "ReplicationControllerSpecTemplateVolumeHostPathSetting",
                "ReplicationControllerSpecTemplateVolumeIscsiSetting",
                "ReplicationControllerSpecTemplateVolumeNfsSetting",
                "ReplicationControllerSpecTemplateVolumePersistentVolumeClaimSetting",
                "ReplicationControllerSpecTemplateVolumePhotonPersistentDiskSetting",
                "ReplicationControllerSpecTemplateVolumeQuobyteSetting",
                "ReplicationControllerSpecTemplateVolumeRbdSetting",
                "ReplicationControllerSpecTemplateVolumeSecretSetting",
                "ReplicationControllerSpecTemplateVolumeVsphereVolumeSetting"
            ],
            "key": "replication_controller.spec.template.volume",
            "name": "ReplicationControllerSpecTemplateVolumeSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateVolumeSetting s",
            "original": "volume"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpecTemplateVolumeVsphereVolumeSetting",
                "name": "ReplicationControllerSpecTemplateVolumeVsphereVolumeSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type to mount. Must be a filesystem type supported by the host",
                        "operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be",
                        "\"ext4\" if unspecified."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "_volumePath",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path that identifies vSphere volume vmdk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_path\" <$> TF.attribute",
                    "name": "_volumePath",
                    "method": "volumePath",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumePath",
                    "validate": false,
                    "optional": false,
                    "original": "volume_path"
                }
            ],
            "dependencies": [],
            "key": "replication_controller.spec.template.volume.vsphere_volume",
            "name": "ReplicationControllerSpecTemplateVolumeVsphereVolumeSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_volumePath",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path that identifies vSphere volume vmdk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_path\" <$> TF.attribute",
                    "name": "_volumePath",
                    "method": "volumePath",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumePath",
                    "validate": false,
                    "optional": false,
                    "original": "volume_path"
                }
            ],
            "conflicts": [],
            "type": "ReplicationControllerSpecTemplateVolumeVsphereVolumeSetting s",
            "original": "vsphere_volume"
        },
        {
            "con": {
                "smart": "newResourceQuotaMetadataSetting",
                "name": "ResourceQuotaMetadataSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "An unstructured key value map stored with the resource quota that may be",
                        "used to store arbitrary metadata. More info:",
                        "http://kubernetes.io/docs/user-guide/annotations"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"annotations\" <$> TF.attribute",
                    "name": "_annotations",
                    "method": "annotations",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasAnnotations",
                    "validate": false,
                    "optional": true,
                    "original": "annotations"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Prefix, used by the server, to generate a unique name ONLY IF the `name`",
                        "field has not been provided. This value will also be combined with a unique",
                        "suffix. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#idempotency"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"generate_name\" <$> TF.attribute",
                    "name": "_generateName",
                    "method": "generateName",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_name",
                            "method": "name"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasGenerateName",
                    "validate": false,
                    "optional": true,
                    "original": "generate_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Map of string keys and values that can be used to organize and categorize",
                        "(scope and select) the resource quota. May match selectors of replication",
                        "controllers and services. More info:",
                        "http://kubernetes.io/docs/user-guide/labels"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"labels\" <$> TF.attribute",
                    "name": "_labels",
                    "method": "labels",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasLabels",
                    "validate": false,
                    "optional": true,
                    "original": "labels"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the resource quota, must be unique. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_generateName",
                            "method": "generateName"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.value \"default\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Namespace defines the space within which name of the resource quota must be",
                        "unique."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"namespace\" <$> TF.attribute",
                    "name": "_namespace",
                    "method": "namespace",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasNamespace",
                    "validate": false,
                    "optional": true,
                    "original": "namespace"
                }
            ],
            "dependencies": [],
            "key": "resource_quota.metadata",
            "name": "ResourceQuotaMetadataSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A sequence number representing a specific generation of the desired state."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"generation\" <$> TF.attribute",
                    "name": "_computedGeneration",
                    "method": "computedGeneration",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedGeneration",
                    "validate": false,
                    "optional": false,
                    "original": "generation"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Name of the resource quota, must be unique. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_computedName",
                    "method": "computedName",
                    "threaded": true,
                    "conflicts": [
                        "_generateName"
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "An opaque value that represents the internal version of this resource quota",
                        "that can be used by clients to determine when resource quota has changed.",
                        "Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#concurrency-control-and-consistency"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_version\" <$> TF.attribute",
                    "name": "_computedResourceVersion",
                    "method": "computedResourceVersion",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedResourceVersion",
                    "validate": false,
                    "optional": false,
                    "original": "resource_version"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A URL representing this resource quota."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"self_link\" <$> TF.attribute",
                    "name": "_computedSelfLink",
                    "method": "computedSelfLink",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedSelfLink",
                    "validate": false,
                    "optional": false,
                    "original": "self_link"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The unique in time and space value for this resource quota. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#uids"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"uid\" <$> TF.attribute",
                    "name": "_computedUid",
                    "method": "computedUid",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedUid",
                    "validate": false,
                    "optional": false,
                    "original": "uid"
                }
            ],
            "parameters": [],
            "conflicts": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Prefix, used by the server, to generate a unique name ONLY IF the `name`",
                        "field has not been provided. This value will also be combined with a unique",
                        "suffix. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#idempotency"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"generate_name\" <$> TF.attribute",
                    "name": "_generateName",
                    "method": "generateName",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_name",
                            "method": "name"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasGenerateName",
                    "validate": false,
                    "optional": true,
                    "original": "generate_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the resource quota, must be unique. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_generateName",
                            "method": "generateName"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "type": "ResourceQuotaMetadataSetting s",
            "original": "metadata"
        },
        {
            "con": {
                "smart": "newResourceQuotaSpecSetting",
                "name": "ResourceQuotaSpecSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The set of desired hard limits for each named resource. More info:",
                        "http://releases.k8s.io/HEAD/docs/design/admission_control_resource_quota.md#admissioncontrol-plugin-resourcequota"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"hard\" <$> TF.attribute",
                    "name": "_hard",
                    "method": "hard",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasHard",
                    "validate": false,
                    "optional": true,
                    "original": "hard"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A collection of filters that must match each object tracked by a quota. If",
                        "not specified, the quota matches all objects."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"scopes\" <$> TF.attribute",
                    "name": "_scopes",
                    "method": "scopes",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasScopes",
                    "validate": false,
                    "optional": true,
                    "original": "scopes"
                }
            ],
            "dependencies": [],
            "key": "resource_quota.spec",
            "name": "ResourceQuotaSpecSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ResourceQuotaSpecSetting s",
            "original": "spec"
        },
        {
            "con": {
                "smart": "newSecretMetadataSetting",
                "name": "SecretMetadataSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "An unstructured key value map stored with the secret that may be used to",
                        "store arbitrary metadata. More info:",
                        "http://kubernetes.io/docs/user-guide/annotations"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"annotations\" <$> TF.attribute",
                    "name": "_annotations",
                    "method": "annotations",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasAnnotations",
                    "validate": false,
                    "optional": true,
                    "original": "annotations"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Prefix, used by the server, to generate a unique name ONLY IF the `name`",
                        "field has not been provided. This value will also be combined with a unique",
                        "suffix. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#idempotency"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"generate_name\" <$> TF.attribute",
                    "name": "_generateName",
                    "method": "generateName",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_name",
                            "method": "name"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasGenerateName",
                    "validate": false,
                    "optional": true,
                    "original": "generate_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Map of string keys and values that can be used to organize and categorize",
                        "(scope and select) the secret. May match selectors of replication",
                        "controllers and services. More info:",
                        "http://kubernetes.io/docs/user-guide/labels"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"labels\" <$> TF.attribute",
                    "name": "_labels",
                    "method": "labels",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasLabels",
                    "validate": false,
                    "optional": true,
                    "original": "labels"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the secret, must be unique. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_generateName",
                            "method": "generateName"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.value \"default\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Namespace defines the space within which name of the secret must be unique."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"namespace\" <$> TF.attribute",
                    "name": "_namespace",
                    "method": "namespace",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasNamespace",
                    "validate": false,
                    "optional": true,
                    "original": "namespace"
                }
            ],
            "dependencies": [],
            "key": "secret.metadata",
            "name": "SecretMetadataSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A sequence number representing a specific generation of the desired state."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"generation\" <$> TF.attribute",
                    "name": "_computedGeneration",
                    "method": "computedGeneration",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedGeneration",
                    "validate": false,
                    "optional": false,
                    "original": "generation"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Name of the secret, must be unique. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_computedName",
                    "method": "computedName",
                    "threaded": true,
                    "conflicts": [
                        "_generateName"
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "An opaque value that represents the internal version of this secret that can",
                        "be used by clients to determine when secret has changed. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#concurrency-control-and-consistency"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_version\" <$> TF.attribute",
                    "name": "_computedResourceVersion",
                    "method": "computedResourceVersion",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedResourceVersion",
                    "validate": false,
                    "optional": false,
                    "original": "resource_version"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A URL representing this secret."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"self_link\" <$> TF.attribute",
                    "name": "_computedSelfLink",
                    "method": "computedSelfLink",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedSelfLink",
                    "validate": false,
                    "optional": false,
                    "original": "self_link"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The unique in time and space value for this secret. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#uids"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"uid\" <$> TF.attribute",
                    "name": "_computedUid",
                    "method": "computedUid",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedUid",
                    "validate": false,
                    "optional": false,
                    "original": "uid"
                }
            ],
            "parameters": [],
            "conflicts": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Prefix, used by the server, to generate a unique name ONLY IF the `name`",
                        "field has not been provided. This value will also be combined with a unique",
                        "suffix. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#idempotency"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"generate_name\" <$> TF.attribute",
                    "name": "_generateName",
                    "method": "generateName",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_name",
                            "method": "name"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasGenerateName",
                    "validate": false,
                    "optional": true,
                    "original": "generate_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the secret, must be unique. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_generateName",
                            "method": "generateName"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "type": "SecretMetadataSetting s",
            "original": "metadata"
        },
        {
            "con": {
                "smart": "newServiceAccountImagePullSecretSetting",
                "name": "ServiceAccountImagePullSecretSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "dependencies": [],
            "key": "service_account.image_pull_secret",
            "name": "ServiceAccountImagePullSecretSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ServiceAccountImagePullSecretSetting s",
            "original": "image_pull_secret"
        },
        {
            "con": {
                "smart": "newServiceAccountMetadataSetting",
                "name": "ServiceAccountMetadataSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "An unstructured key value map stored with the service account that may be",
                        "used to store arbitrary metadata. More info:",
                        "http://kubernetes.io/docs/user-guide/annotations"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"annotations\" <$> TF.attribute",
                    "name": "_annotations",
                    "method": "annotations",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasAnnotations",
                    "validate": false,
                    "optional": true,
                    "original": "annotations"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Prefix, used by the server, to generate a unique name ONLY IF the `name`",
                        "field has not been provided. This value will also be combined with a unique",
                        "suffix. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#idempotency"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"generate_name\" <$> TF.attribute",
                    "name": "_generateName",
                    "method": "generateName",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_name",
                            "method": "name"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasGenerateName",
                    "validate": false,
                    "optional": true,
                    "original": "generate_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Map of string keys and values that can be used to organize and categorize",
                        "(scope and select) the service account. May match selectors of replication",
                        "controllers and services. More info:",
                        "http://kubernetes.io/docs/user-guide/labels"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"labels\" <$> TF.attribute",
                    "name": "_labels",
                    "method": "labels",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasLabels",
                    "validate": false,
                    "optional": true,
                    "original": "labels"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the service account, must be unique. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_generateName",
                            "method": "generateName"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.value \"default\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Namespace defines the space within which name of the service account must be",
                        "unique."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"namespace\" <$> TF.attribute",
                    "name": "_namespace",
                    "method": "namespace",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasNamespace",
                    "validate": false,
                    "optional": true,
                    "original": "namespace"
                }
            ],
            "dependencies": [],
            "key": "service_account.metadata",
            "name": "ServiceAccountMetadataSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A sequence number representing a specific generation of the desired state."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"generation\" <$> TF.attribute",
                    "name": "_computedGeneration",
                    "method": "computedGeneration",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedGeneration",
                    "validate": false,
                    "optional": false,
                    "original": "generation"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Name of the service account, must be unique. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_computedName",
                    "method": "computedName",
                    "threaded": true,
                    "conflicts": [
                        "_generateName"
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "An opaque value that represents the internal version of this service account",
                        "that can be used by clients to determine when service account has changed.",
                        "Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#concurrency-control-and-consistency"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_version\" <$> TF.attribute",
                    "name": "_computedResourceVersion",
                    "method": "computedResourceVersion",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedResourceVersion",
                    "validate": false,
                    "optional": false,
                    "original": "resource_version"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A URL representing this service account."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"self_link\" <$> TF.attribute",
                    "name": "_computedSelfLink",
                    "method": "computedSelfLink",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedSelfLink",
                    "validate": false,
                    "optional": false,
                    "original": "self_link"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The unique in time and space value for this service account. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#uids"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"uid\" <$> TF.attribute",
                    "name": "_computedUid",
                    "method": "computedUid",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedUid",
                    "validate": false,
                    "optional": false,
                    "original": "uid"
                }
            ],
            "parameters": [],
            "conflicts": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Prefix, used by the server, to generate a unique name ONLY IF the `name`",
                        "field has not been provided. This value will also be combined with a unique",
                        "suffix. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#idempotency"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"generate_name\" <$> TF.attribute",
                    "name": "_generateName",
                    "method": "generateName",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_name",
                            "method": "name"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasGenerateName",
                    "validate": false,
                    "optional": true,
                    "original": "generate_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the service account, must be unique. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_generateName",
                            "method": "generateName"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "type": "ServiceAccountMetadataSetting s",
            "original": "metadata"
        },
        {
            "con": {
                "smart": "newServiceAccountSecretSetting",
                "name": "ServiceAccountSecretSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "dependencies": [],
            "key": "service_account.secret",
            "name": "ServiceAccountSecretSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ServiceAccountSecretSetting s",
            "original": "secret"
        },
        {
            "con": {
                "smart": "newServiceLoadBalancerIngressSetting",
                "name": "ServiceLoadBalancerIngressSetting'"
            },
            "arguments": [],
            "dependencies": [],
            "key": "service.load_balancer_ingress",
            "name": "ServiceLoadBalancerIngressSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"hostname\" <$> TF.attribute",
                    "name": "_computedHostname",
                    "method": "computedHostname",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedHostname",
                    "validate": false,
                    "optional": false,
                    "original": "hostname"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"ip\" <$> TF.attribute",
                    "name": "_computedIp",
                    "method": "computedIp",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedIp",
                    "validate": false,
                    "optional": false,
                    "original": "ip"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "ServiceLoadBalancerIngressSetting s",
            "original": "load_balancer_ingress"
        },
        {
            "con": {
                "smart": "newServiceMetadataSetting",
                "name": "ServiceMetadataSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "An unstructured key value map stored with the service that may be used to",
                        "store arbitrary metadata. More info:",
                        "http://kubernetes.io/docs/user-guide/annotations"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"annotations\" <$> TF.attribute",
                    "name": "_annotations",
                    "method": "annotations",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasAnnotations",
                    "validate": false,
                    "optional": true,
                    "original": "annotations"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Map of string keys and values that can be used to organize and categorize",
                        "(scope and select) the service. May match selectors of replication",
                        "controllers and services. More info:",
                        "http://kubernetes.io/docs/user-guide/labels"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"labels\" <$> TF.attribute",
                    "name": "_labels",
                    "method": "labels",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasLabels",
                    "validate": false,
                    "optional": true,
                    "original": "labels"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the service, must be unique. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.value \"default\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Namespace defines the space within which name of the service must be unique."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"namespace\" <$> TF.attribute",
                    "name": "_namespace",
                    "method": "namespace",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasNamespace",
                    "validate": false,
                    "optional": true,
                    "original": "namespace"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Prefix, used by the server, to generate a unique name ONLY IF the `name`",
                        "field has not been provided. This value will also be combined with a unique",
                        "suffix. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#idempotency"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"generate_name\" <$> TF.attribute",
                    "name": "_generateName",
                    "method": "generateName",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_name",
                            "method": "name"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasGenerateName",
                    "validate": false,
                    "optional": true,
                    "original": "generate_name"
                }
            ],
            "dependencies": [],
            "key": "service.metadata",
            "name": "ServiceMetadataSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A sequence number representing a specific generation of the desired state."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"generation\" <$> TF.attribute",
                    "name": "_computedGeneration",
                    "method": "computedGeneration",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedGeneration",
                    "validate": false,
                    "optional": false,
                    "original": "generation"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Name of the service, must be unique. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_computedName",
                    "method": "computedName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "An opaque value that represents the internal version of this service that",
                        "can be used by clients to determine when service has changed. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#concurrency-control-and-consistency"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_version\" <$> TF.attribute",
                    "name": "_computedResourceVersion",
                    "method": "computedResourceVersion",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedResourceVersion",
                    "validate": false,
                    "optional": false,
                    "original": "resource_version"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A URL representing this service."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"self_link\" <$> TF.attribute",
                    "name": "_computedSelfLink",
                    "method": "computedSelfLink",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedSelfLink",
                    "validate": false,
                    "optional": false,
                    "original": "self_link"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The unique in time and space value for this service. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#uids"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"uid\" <$> TF.attribute",
                    "name": "_computedUid",
                    "method": "computedUid",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedUid",
                    "validate": false,
                    "optional": false,
                    "original": "uid"
                }
            ],
            "parameters": [],
            "conflicts": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Prefix, used by the server, to generate a unique name ONLY IF the `name`",
                        "field has not been provided. This value will also be combined with a unique",
                        "suffix. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#idempotency"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"generate_name\" <$> TF.attribute",
                    "name": "_generateName",
                    "method": "generateName",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_name",
                            "method": "name"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasGenerateName",
                    "validate": false,
                    "optional": true,
                    "original": "generate_name"
                }
            ],
            "type": "ServiceMetadataSetting s",
            "original": "metadata"
        },
        {
            "con": {
                "smart": "newServiceSpecPortSetting",
                "name": "ServiceSpecPortSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The name of this port within the service. All ports within the service must",
                        "have unique names. Optional if only one ServicePort is defined on this",
                        "service."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The port on each node on which this service is exposed when `type` is",
                        "`NodePort` or `LoadBalancer`. Usually assigned by the system. If specified,",
                        "it will be allocated to the service if unused or else creation of the",
                        "service will fail. Default is to auto-allocate a port if the `type` of this",
                        "service requires one. More info:",
                        "http://kubernetes.io/docs/user-guide/services#type--nodeport"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"node_port\" <$> TF.attribute",
                    "name": "_nodePort",
                    "method": "nodePort",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasNodePort",
                    "validate": false,
                    "optional": true,
                    "original": "node_port"
                },
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The port that will be exposed by this service."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                },
                {
                    "default": "TF.value \"TCP\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The IP protocol for this port. Supports `TCP` and `UDP`. Default is `TCP`."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"protocol\" <$> TF.attribute",
                    "name": "_protocol",
                    "method": "protocol",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasProtocol",
                    "validate": false,
                    "optional": true,
                    "original": "protocol"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Number or name of the port to access on the pods targeted by the service.",
                        "Number must be in the range 1 to 65535. This field is ignored for services",
                        "with `cluster_ip = \"None\"`. More info:",
                        "http://kubernetes.io/docs/user-guide/services#defining-a-service"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"target_port\" <$> TF.attribute",
                    "name": "_targetPort",
                    "method": "targetPort",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasTargetPort",
                    "validate": false,
                    "optional": true,
                    "original": "target_port"
                }
            ],
            "dependencies": [],
            "key": "service.spec.port",
            "name": "ServiceSpecPortSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The name of this port within the service. All ports within the service must",
                        "have unique names. Optional if only one ServicePort is defined on this",
                        "service."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_computedName",
                    "method": "computedName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The port on each node on which this service is exposed when `type` is",
                        "`NodePort` or `LoadBalancer`. Usually assigned by the system. If specified,",
                        "it will be allocated to the service if unused or else creation of the",
                        "service will fail. Default is to auto-allocate a port if the `type` of this",
                        "service requires one. More info:",
                        "http://kubernetes.io/docs/user-guide/services#type--nodeport"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"node_port\" <$> TF.attribute",
                    "name": "_computedNodePort",
                    "method": "computedNodePort",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedNodePort",
                    "validate": false,
                    "optional": false,
                    "original": "node_port"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The port that will be exposed by this service."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_computedPort",
                    "method": "computedPort",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The IP protocol for this port. Supports `TCP` and `UDP`. Default is `TCP`."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"protocol\" <$> TF.attribute",
                    "name": "_computedProtocol",
                    "method": "computedProtocol",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedProtocol",
                    "validate": false,
                    "optional": false,
                    "original": "protocol"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Number or name of the port to access on the pods targeted by the service.",
                        "Number must be in the range 1 to 65535. This field is ignored for services",
                        "with `cluster_ip = \"None\"`. More info:",
                        "http://kubernetes.io/docs/user-guide/services#defining-a-service"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"target_port\" <$> TF.attribute",
                    "name": "_computedTargetPort",
                    "method": "computedTargetPort",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedTargetPort",
                    "validate": false,
                    "optional": false,
                    "original": "target_port"
                }
            ],
            "parameters": [
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The port that will be exposed by this service."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                }
            ],
            "conflicts": [],
            "type": "ServiceSpecPortSetting s",
            "original": "port"
        },
        {
            "con": {
                "smart": "newServiceSpecSetting",
                "name": "ServiceSpecSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The IP address of the service. It is usually assigned randomly by the",
                        "master. If an address is specified manually and is not in use by others, it",
                        "will be allocated to the service; otherwise, creation of the service will",
                        "fail. `None` can be specified for headless services when proxying is not",
                        "required. Ignored if type is `ExternalName`. More info:",
                        "http://kubernetes.io/docs/user-guide/services#virtual-ips-and-service-proxies"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"cluster_ip\" <$> TF.attribute",
                    "name": "_clusterIp",
                    "method": "clusterIp",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasClusterIp",
                    "validate": false,
                    "optional": true,
                    "original": "cluster_ip"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of IP addresses for which nodes in the cluster will also accept",
                        "traffic for this service. These IPs are not managed by Kubernetes. The user",
                        "is responsible for ensuring that traffic arrives at a node with this IP.  A",
                        "common example is external load-balancers that are not part of the",
                        "Kubernetes system."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"external_ips\" <$> TF.attribute",
                    "name": "_externalIps",
                    "method": "externalIps",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasExternalIps",
                    "validate": false,
                    "optional": true,
                    "original": "external_ips"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The external reference that kubedns or equivalent will return as a CNAME",
                        "record for this service. No proxying will be involved. Must be a valid DNS",
                        "name and requires `type` to be `ExternalName`."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"external_name\" <$> TF.attribute",
                    "name": "_externalName",
                    "method": "externalName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasExternalName",
                    "validate": false,
                    "optional": true,
                    "original": "external_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Only applies to `type = LoadBalancer`. LoadBalancer will get created with",
                        "the IP specified in this field. This feature depends on whether the",
                        "underlying cloud-provider supports specifying this field when a load",
                        "balancer is created. This field will be ignored if the cloud-provider does",
                        "not support the feature."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"load_balancer_ip\" <$> TF.attribute",
                    "name": "_loadBalancerIp",
                    "method": "loadBalancerIp",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasLoadBalancerIp",
                    "validate": false,
                    "optional": true,
                    "original": "load_balancer_ip"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If specified and supported by the platform, this will restrict traffic",
                        "through the cloud-provider load-balancer will be restricted to the specified",
                        "client IPs. This field will be ignored if the cloud-provider does not",
                        "support the feature. More info:",
                        "http://kubernetes.io/docs/user-guide/services-firewalls"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"load_balancer_source_ranges\" <$> TF.attribute",
                    "name": "_loadBalancerSourceRanges",
                    "method": "loadBalancerSourceRanges",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasLoadBalancerSourceRanges",
                    "validate": false,
                    "optional": true,
                    "original": "load_balancer_source_ranges"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The list of ports that are exposed by this service. More info:",
                        "http://kubernetes.io/docs/user-guide/services#virtual-ips-and-service-proxies"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.NonEmpty (TF.Attr s (ServiceSpecPortSetting s)))",
                    "class": "HasPort",
                    "validate": false,
                    "optional": true,
                    "original": "port"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Route service traffic to pods with label keys and values matching this",
                        "selector. Only applies to types `ClusterIP`, `NodePort`, and `LoadBalancer`.",
                        "More info: http://kubernetes.io/docs/user-guide/services#overview"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"selector\" <$> TF.attribute",
                    "name": "_selector",
                    "method": "selector",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasSelector",
                    "validate": false,
                    "optional": true,
                    "original": "selector"
                },
                {
                    "default": "TF.value \"None\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Used to maintain session affinity. Supports `ClientIP` and `None`. Defaults",
                        "to `None`. More info:",
                        "http://kubernetes.io/docs/user-guide/services#virtual-ips-and-service-proxies"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"session_affinity\" <$> TF.attribute",
                    "name": "_sessionAffinity",
                    "method": "sessionAffinity",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSessionAffinity",
                    "validate": false,
                    "optional": true,
                    "original": "session_affinity"
                },
                {
                    "default": "TF.value \"ClusterIP\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Determines how the service is exposed. Defaults to `ClusterIP`. Valid",
                        "options are `ExternalName`, `ClusterIP`, `NodePort`, and `LoadBalancer`.",
                        "`ExternalName` maps to the specified `external_name`. More info:",
                        "http://kubernetes.io/docs/user-guide/services#overview"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"type\" <$> TF.attribute",
                    "name": "_type'",
                    "method": "type'",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasType'",
                    "validate": false,
                    "optional": true,
                    "original": "type"
                }
            ],
            "dependencies": [
                "ServiceSpecPortSetting",
                "ServiceSpecPortSetting"
            ],
            "key": "service.spec",
            "name": "ServiceSpecSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The IP address of the service. It is usually assigned randomly by the",
                        "master. If an address is specified manually and is not in use by others, it",
                        "will be allocated to the service; otherwise, creation of the service will",
                        "fail. `None` can be specified for headless services when proxying is not",
                        "required. Ignored if type is `ExternalName`. More info:",
                        "http://kubernetes.io/docs/user-guide/services#virtual-ips-and-service-proxies"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cluster_ip\" <$> TF.attribute",
                    "name": "_computedClusterIp",
                    "method": "computedClusterIp",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedClusterIp",
                    "validate": false,
                    "optional": false,
                    "original": "cluster_ip"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A list of IP addresses for which nodes in the cluster will also accept",
                        "traffic for this service. These IPs are not managed by Kubernetes. The user",
                        "is responsible for ensuring that traffic arrives at a node with this IP.  A",
                        "common example is external load-balancers that are not part of the",
                        "Kubernetes system."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"external_ips\" <$> TF.attribute",
                    "name": "_computedExternalIps",
                    "method": "computedExternalIps",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasComputedExternalIps",
                    "validate": false,
                    "optional": false,
                    "original": "external_ips"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The external reference that kubedns or equivalent will return as a CNAME",
                        "record for this service. No proxying will be involved. Must be a valid DNS",
                        "name and requires `type` to be `ExternalName`."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"external_name\" <$> TF.attribute",
                    "name": "_computedExternalName",
                    "method": "computedExternalName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedExternalName",
                    "validate": false,
                    "optional": false,
                    "original": "external_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Only applies to `type = LoadBalancer`. LoadBalancer will get created with",
                        "the IP specified in this field. This feature depends on whether the",
                        "underlying cloud-provider supports specifying this field when a load",
                        "balancer is created. This field will be ignored if the cloud-provider does",
                        "not support the feature."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"load_balancer_ip\" <$> TF.attribute",
                    "name": "_computedLoadBalancerIp",
                    "method": "computedLoadBalancerIp",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedLoadBalancerIp",
                    "validate": false,
                    "optional": false,
                    "original": "load_balancer_ip"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "If specified and supported by the platform, this will restrict traffic",
                        "through the cloud-provider load-balancer will be restricted to the specified",
                        "client IPs. This field will be ignored if the cloud-provider does not",
                        "support the feature. More info:",
                        "http://kubernetes.io/docs/user-guide/services-firewalls"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"load_balancer_source_ranges\" <$> TF.attribute",
                    "name": "_computedLoadBalancerSourceRanges",
                    "method": "computedLoadBalancerSourceRanges",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasComputedLoadBalancerSourceRanges",
                    "validate": false,
                    "optional": false,
                    "original": "load_balancer_source_ranges"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The list of ports that are exposed by this service. More info:",
                        "http://kubernetes.io/docs/user-guide/services#virtual-ips-and-service-proxies"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_computedPort",
                    "method": "computedPort",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.NonEmpty (TF.Attr s (ServiceSpecPortSetting s)))",
                    "class": "HasComputedPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Route service traffic to pods with label keys and values matching this",
                        "selector. Only applies to types `ClusterIP`, `NodePort`, and `LoadBalancer`.",
                        "More info: http://kubernetes.io/docs/user-guide/services#overview"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"selector\" <$> TF.attribute",
                    "name": "_computedSelector",
                    "method": "computedSelector",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasComputedSelector",
                    "validate": false,
                    "optional": false,
                    "original": "selector"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Used to maintain session affinity. Supports `ClientIP` and `None`. Defaults",
                        "to `None`. More info:",
                        "http://kubernetes.io/docs/user-guide/services#virtual-ips-and-service-proxies"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"session_affinity\" <$> TF.attribute",
                    "name": "_computedSessionAffinity",
                    "method": "computedSessionAffinity",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedSessionAffinity",
                    "validate": false,
                    "optional": false,
                    "original": "session_affinity"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Determines how the service is exposed. Defaults to `ClusterIP`. Valid",
                        "options are `ExternalName`, `ClusterIP`, `NodePort`, and `LoadBalancer`.",
                        "`ExternalName` maps to the specified `external_name`. More info:",
                        "http://kubernetes.io/docs/user-guide/services#overview"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"type\" <$> TF.attribute",
                    "name": "_computedType",
                    "method": "computedType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedType",
                    "validate": false,
                    "optional": false,
                    "original": "type"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "ServiceSpecSetting s",
            "original": "spec"
        },
        {
            "con": {
                "smart": "newStorageClassMetadataSetting",
                "name": "StorageClassMetadataSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "An unstructured key value map stored with the storage class that may be used",
                        "to store arbitrary metadata. More info:",
                        "http://kubernetes.io/docs/user-guide/annotations"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"annotations\" <$> TF.attribute",
                    "name": "_annotations",
                    "method": "annotations",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasAnnotations",
                    "validate": false,
                    "optional": true,
                    "original": "annotations"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Map of string keys and values that can be used to organize and categorize",
                        "(scope and select) the storage class. May match selectors of replication",
                        "controllers and services. More info:",
                        "http://kubernetes.io/docs/user-guide/labels"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"labels\" <$> TF.attribute",
                    "name": "_labels",
                    "method": "labels",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasLabels",
                    "validate": false,
                    "optional": true,
                    "original": "labels"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the storage class, must be unique. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Prefix, used by the server, to generate a unique name ONLY IF the `name`",
                        "field has not been provided. This value will also be combined with a unique",
                        "suffix. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#idempotency"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"generate_name\" <$> TF.attribute",
                    "name": "_generateName",
                    "method": "generateName",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_name",
                            "method": "name"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasGenerateName",
                    "validate": false,
                    "optional": true,
                    "original": "generate_name"
                }
            ],
            "dependencies": [],
            "key": "storage_class.metadata",
            "name": "StorageClassMetadataSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A sequence number representing a specific generation of the desired state."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"generation\" <$> TF.attribute",
                    "name": "_computedGeneration",
                    "method": "computedGeneration",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedGeneration",
                    "validate": false,
                    "optional": false,
                    "original": "generation"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Name of the storage class, must be unique. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_computedName",
                    "method": "computedName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "An opaque value that represents the internal version of this storage class",
                        "that can be used by clients to determine when storage class has changed.",
                        "Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#concurrency-control-and-consistency"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_version\" <$> TF.attribute",
                    "name": "_computedResourceVersion",
                    "method": "computedResourceVersion",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedResourceVersion",
                    "validate": false,
                    "optional": false,
                    "original": "resource_version"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A URL representing this storage class."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"self_link\" <$> TF.attribute",
                    "name": "_computedSelfLink",
                    "method": "computedSelfLink",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedSelfLink",
                    "validate": false,
                    "optional": false,
                    "original": "self_link"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The unique in time and space value for this storage class. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#uids"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"uid\" <$> TF.attribute",
                    "name": "_computedUid",
                    "method": "computedUid",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedUid",
                    "validate": false,
                    "optional": false,
                    "original": "uid"
                }
            ],
            "parameters": [],
            "conflicts": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Prefix, used by the server, to generate a unique name ONLY IF the `name`",
                        "field has not been provided. This value will also be combined with a unique",
                        "suffix. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#idempotency"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"generate_name\" <$> TF.attribute",
                    "name": "_generateName",
                    "method": "generateName",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_name",
                            "method": "name"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasGenerateName",
                    "validate": false,
                    "optional": true,
                    "original": "generate_name"
                }
            ],
            "type": "StorageClassMetadataSetting s",
            "original": "metadata"
        }
    ],
    "url": "https://www.terraform.io/docs/providers/kubernetes/index.html",
    "dataSources": [
        {
            "con": {
                "smart": "serviceData",
                "name": "ServiceData'"
            },
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard service's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ServiceMetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/kubernetes/d/service.html",
            "dependencies": [
                "ServiceMetadataSetting",
                "ServiceLoadBalancerIngressSetting",
                "ServiceSpecSetting"
            ],
            "key": "service",
            "name": "ServiceData",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"id\" <$> TF.attribute",
                    "name": "_computedId",
                    "method": "computedId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedId",
                    "validate": false,
                    "optional": false,
                    "original": "id"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"load_balancer_ingress\" <$> TF.attribute",
                    "name": "_computedLoadBalancerIngress",
                    "method": "computedLoadBalancerIngress",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ServiceLoadBalancerIngressSetting s)]",
                    "class": "HasComputedLoadBalancerIngress",
                    "validate": false,
                    "optional": false,
                    "original": "load_balancer_ingress"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Spec defines the behavior of a service.",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_computedSpec",
                    "method": "computedSpec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ServiceSpecSetting s)",
                    "class": "HasComputedSpec",
                    "validate": true,
                    "optional": false,
                    "original": "spec"
                }
            ],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard service's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ServiceMetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                }
            ],
            "conflicts": [],
            "type": "ServiceData s",
            "original": "kubernetes_service"
        },
        {
            "con": {
                "smart": "storageClassData",
                "name": "StorageClassData'"
            },
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard storage class's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (StorageClassMetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/kubernetes/d/storage_class.html",
            "dependencies": [
                "StorageClassMetadataSetting"
            ],
            "key": "storage_class",
            "name": "StorageClassData",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"id\" <$> TF.attribute",
                    "name": "_computedId",
                    "method": "computedId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedId",
                    "validate": false,
                    "optional": false,
                    "original": "id"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The parameters for the provisioner that should create volumes of this",
                        "storage class"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"parameters\" <$> TF.attribute",
                    "name": "_computedParameters",
                    "method": "computedParameters",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasComputedParameters",
                    "validate": false,
                    "optional": false,
                    "original": "parameters"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Indicates the type of the provisioner"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"storage_provisioner\" <$> TF.attribute",
                    "name": "_computedStorageProvisioner",
                    "method": "computedStorageProvisioner",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedStorageProvisioner",
                    "validate": false,
                    "optional": false,
                    "original": "storage_provisioner"
                }
            ],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard storage class's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (StorageClassMetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                }
            ],
            "conflicts": [],
            "type": "StorageClassData s",
            "original": "kubernetes_storage_class"
        }
    ],
    "resources": [
        {
            "con": {
                "smart": "configMapResource",
                "name": "ConfigMapResource'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A map of the configuration data."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"data\" <$> TF.attribute",
                    "name": "_data'",
                    "method": "data'",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasData'",
                    "validate": false,
                    "optional": true,
                    "original": "data"
                },
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard config map's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ConfigMapMetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/kubernetes/r/config_map.html",
            "dependencies": [
                "ConfigMapMetadataSetting"
            ],
            "key": "config_map",
            "name": "ConfigMapResource",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"id\" <$> TF.attribute",
                    "name": "_computedId",
                    "method": "computedId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedId",
                    "validate": false,
                    "optional": false,
                    "original": "id"
                }
            ],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard config map's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ConfigMapMetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                }
            ],
            "conflicts": [],
            "type": "ConfigMapResource s",
            "original": "kubernetes_config_map"
        },
        {
            "con": {
                "smart": "horizontalPodAutoscalerResource",
                "name": "HorizontalPodAutoscalerResource'"
            },
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard horizontal pod autoscaler's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (HorizontalPodAutoscalerMetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Behaviour of the autoscaler. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (HorizontalPodAutoscalerSpecSetting s)",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": false,
                    "original": "spec"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/kubernetes/r/horizontal_pod_autoscaler.html",
            "dependencies": [
                "HorizontalPodAutoscalerMetadataSetting",
                "HorizontalPodAutoscalerSpecSetting"
            ],
            "key": "horizontal_pod_autoscaler",
            "name": "HorizontalPodAutoscalerResource",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"id\" <$> TF.attribute",
                    "name": "_computedId",
                    "method": "computedId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedId",
                    "validate": false,
                    "optional": false,
                    "original": "id"
                }
            ],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard horizontal pod autoscaler's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (HorizontalPodAutoscalerMetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Behaviour of the autoscaler. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (HorizontalPodAutoscalerSpecSetting s)",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": false,
                    "original": "spec"
                }
            ],
            "conflicts": [],
            "type": "HorizontalPodAutoscalerResource s",
            "original": "kubernetes_horizontal_pod_autoscaler"
        },
        {
            "con": {
                "smart": "limitRangeResource",
                "name": "LimitRangeResource'"
            },
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard limit range's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (LimitRangeMetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Spec defines the limits enforced. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (LimitRangeSpecSetting s)",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": true,
                    "original": "spec"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/kubernetes/r/limit_range.html",
            "dependencies": [
                "LimitRangeMetadataSetting",
                "LimitRangeSpecSetting"
            ],
            "key": "limit_range",
            "name": "LimitRangeResource",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"id\" <$> TF.attribute",
                    "name": "_computedId",
                    "method": "computedId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedId",
                    "validate": false,
                    "optional": false,
                    "original": "id"
                }
            ],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard limit range's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (LimitRangeMetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                }
            ],
            "conflicts": [],
            "type": "LimitRangeResource s",
            "original": "kubernetes_limit_range"
        },
        {
            "con": {
                "smart": "namespaceResource",
                "name": "NamespaceResource'"
            },
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard namespace's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (NamespaceMetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/kubernetes/r/namespace.html",
            "dependencies": [
                "NamespaceMetadataSetting"
            ],
            "key": "namespace",
            "name": "NamespaceResource",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"id\" <$> TF.attribute",
                    "name": "_computedId",
                    "method": "computedId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedId",
                    "validate": false,
                    "optional": false,
                    "original": "id"
                }
            ],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard namespace's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (NamespaceMetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                }
            ],
            "conflicts": [],
            "type": "NamespaceResource s",
            "original": "kubernetes_namespace"
        },
        {
            "con": {
                "smart": "persistentVolumeResource",
                "name": "PersistentVolumeResource'"
            },
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard persistent volume's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeMetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec of the persistent volume owned by the cluster"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (PersistentVolumeSpecSetting s)]",
                    "class": "HasSpec",
                    "validate": false,
                    "optional": false,
                    "original": "spec"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/kubernetes/r/persistent_volume.html",
            "dependencies": [
                "PersistentVolumeMetadataSetting",
                "PersistentVolumeSpecSetting"
            ],
            "key": "persistent_volume",
            "name": "PersistentVolumeResource",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"id\" <$> TF.attribute",
                    "name": "_computedId",
                    "method": "computedId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedId",
                    "validate": false,
                    "optional": false,
                    "original": "id"
                }
            ],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard persistent volume's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeMetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec of the persistent volume owned by the cluster"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (PersistentVolumeSpecSetting s)]",
                    "class": "HasSpec",
                    "validate": false,
                    "optional": false,
                    "original": "spec"
                }
            ],
            "conflicts": [],
            "type": "PersistentVolumeResource s",
            "original": "kubernetes_persistent_volume"
        },
        {
            "con": {
                "smart": "persistentVolumeClaimResource",
                "name": "PersistentVolumeClaimResource'"
            },
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard persistent volume claim's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeClaimMetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec defines the desired characteristics of a volume requested by a pod",
                        "author. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#persistentvolumeclaims"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeClaimSpecSetting s)",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": false,
                    "original": "spec"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to wait for the claim to reach `Bound` state (to find volume in",
                        "which to claim the space)"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"wait_until_bound\" <$> TF.attribute",
                    "name": "_waitUntilBound",
                    "method": "waitUntilBound",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasWaitUntilBound",
                    "validate": false,
                    "optional": true,
                    "original": "wait_until_bound"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/kubernetes/r/persistent_volume_claim.html",
            "dependencies": [
                "PersistentVolumeClaimMetadataSetting",
                "PersistentVolumeClaimSpecSetting"
            ],
            "key": "persistent_volume_claim",
            "name": "PersistentVolumeClaimResource",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"id\" <$> TF.attribute",
                    "name": "_computedId",
                    "method": "computedId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedId",
                    "validate": false,
                    "optional": false,
                    "original": "id"
                }
            ],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard persistent volume claim's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeClaimMetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec defines the desired characteristics of a volume requested by a pod",
                        "author. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#persistentvolumeclaims"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeClaimSpecSetting s)",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": false,
                    "original": "spec"
                }
            ],
            "conflicts": [],
            "type": "PersistentVolumeClaimResource s",
            "original": "kubernetes_persistent_volume_claim"
        },
        {
            "con": {
                "smart": "podResource",
                "name": "PodResource'"
            },
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard pod's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodMetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec of the pod owned by the cluster"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecSetting s)",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": false,
                    "original": "spec"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/kubernetes/r/pod.html",
            "dependencies": [
                "PodMetadataSetting",
                "PodSpecSetting"
            ],
            "key": "pod",
            "name": "PodResource",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"id\" <$> TF.attribute",
                    "name": "_computedId",
                    "method": "computedId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedId",
                    "validate": false,
                    "optional": false,
                    "original": "id"
                }
            ],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard pod's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodMetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec of the pod owned by the cluster"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpecSetting s)",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": false,
                    "original": "spec"
                }
            ],
            "conflicts": [],
            "type": "PodResource s",
            "original": "kubernetes_pod"
        },
        {
            "con": {
                "smart": "replicationControllerResource",
                "name": "ReplicationControllerResource'"
            },
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard replication controller's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerMetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec defines the specification of the desired behavior of the replication",
                        "controller. More info:",
                        "http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#spec-and-status"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecSetting s)",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": false,
                    "original": "spec"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/kubernetes/r/replication_controller.html",
            "dependencies": [
                "ReplicationControllerMetadataSetting",
                "ReplicationControllerSpecSetting"
            ],
            "key": "replication_controller",
            "name": "ReplicationControllerResource",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"id\" <$> TF.attribute",
                    "name": "_computedId",
                    "method": "computedId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedId",
                    "validate": false,
                    "optional": false,
                    "original": "id"
                }
            ],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard replication controller's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerMetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec defines the specification of the desired behavior of the replication",
                        "controller. More info:",
                        "http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#spec-and-status"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpecSetting s)",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": false,
                    "original": "spec"
                }
            ],
            "conflicts": [],
            "type": "ReplicationControllerResource s",
            "original": "kubernetes_replication_controller"
        },
        {
            "con": {
                "smart": "resourceQuotaResource",
                "name": "ResourceQuotaResource'"
            },
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard resource quota's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ResourceQuotaMetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Spec defines the desired quota.",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ResourceQuotaSpecSetting s)",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": true,
                    "original": "spec"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/kubernetes/r/resource_quota.html",
            "dependencies": [
                "ResourceQuotaMetadataSetting",
                "ResourceQuotaSpecSetting"
            ],
            "key": "resource_quota",
            "name": "ResourceQuotaResource",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"id\" <$> TF.attribute",
                    "name": "_computedId",
                    "method": "computedId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedId",
                    "validate": false,
                    "optional": false,
                    "original": "id"
                }
            ],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard resource quota's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ResourceQuotaMetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                }
            ],
            "conflicts": [],
            "type": "ResourceQuotaResource s",
            "original": "kubernetes_resource_quota"
        },
        {
            "con": {
                "smart": "secretResource",
                "name": "SecretResource'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A map of the secret data."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"data\" <$> TF.attribute",
                    "name": "_data'",
                    "method": "data'",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasData'",
                    "validate": false,
                    "optional": true,
                    "original": "data"
                },
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard secret's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (SecretMetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "TF.value \"Opaque\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Type of secret"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"type\" <$> TF.attribute",
                    "name": "_type'",
                    "method": "type'",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasType'",
                    "validate": false,
                    "optional": true,
                    "original": "type"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/kubernetes/r/secret.html",
            "dependencies": [
                "SecretMetadataSetting"
            ],
            "key": "secret",
            "name": "SecretResource",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"id\" <$> TF.attribute",
                    "name": "_computedId",
                    "method": "computedId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedId",
                    "validate": false,
                    "optional": false,
                    "original": "id"
                }
            ],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard secret's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (SecretMetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                }
            ],
            "conflicts": [],
            "type": "SecretResource s",
            "original": "kubernetes_secret"
        },
        {
            "con": {
                "smart": "serviceResource",
                "name": "ServiceResource'"
            },
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard service's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ServiceMetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec defines the behavior of a service.",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ServiceSpecSetting s)",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": false,
                    "original": "spec"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/kubernetes/r/service.html",
            "dependencies": [
                "ServiceMetadataSetting",
                "ServiceSpecSetting",
                "ServiceLoadBalancerIngressSetting"
            ],
            "key": "service",
            "name": "ServiceResource",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"id\" <$> TF.attribute",
                    "name": "_computedId",
                    "method": "computedId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedId",
                    "validate": false,
                    "optional": false,
                    "original": "id"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"load_balancer_ingress\" <$> TF.attribute",
                    "name": "_computedLoadBalancerIngress",
                    "method": "computedLoadBalancerIngress",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ServiceLoadBalancerIngressSetting s)]",
                    "class": "HasComputedLoadBalancerIngress",
                    "validate": false,
                    "optional": false,
                    "original": "load_balancer_ingress"
                }
            ],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard service's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ServiceMetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec defines the behavior of a service.",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ServiceSpecSetting s)",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": false,
                    "original": "spec"
                }
            ],
            "conflicts": [],
            "type": "ServiceResource s",
            "original": "kubernetes_service"
        },
        {
            "con": {
                "smart": "serviceAccountResource",
                "name": "ServiceAccountResource'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of references to secrets in the same namespace to use for pulling any",
                        "images in pods that reference this Service Account. More info:",
                        "http://kubernetes.io/docs/user-guide/secrets#manually-specifying-an-imagepullsecret"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"image_pull_secret\" <$> TF.attribute",
                    "name": "_imagePullSecret",
                    "method": "imagePullSecret",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ServiceAccountImagePullSecretSetting s)]",
                    "class": "HasImagePullSecret",
                    "validate": false,
                    "optional": true,
                    "original": "image_pull_secret"
                },
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard service account's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ServiceAccountMetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of secrets allowed to be used by pods running using this Service",
                        "Account. More info: http://kubernetes.io/docs/user-guide/secrets"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret\" <$> TF.attribute",
                    "name": "_secret",
                    "method": "secret",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ServiceAccountSecretSetting s)]",
                    "class": "HasSecret",
                    "validate": false,
                    "optional": true,
                    "original": "secret"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/kubernetes/r/service_account.html",
            "dependencies": [
                "ServiceAccountImagePullSecretSetting",
                "ServiceAccountMetadataSetting",
                "ServiceAccountSecretSetting"
            ],
            "key": "service_account",
            "name": "ServiceAccountResource",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"id\" <$> TF.attribute",
                    "name": "_computedId",
                    "method": "computedId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedId",
                    "validate": false,
                    "optional": false,
                    "original": "id"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"default_secret_name\" <$> TF.attribute",
                    "name": "_computedDefaultSecretName",
                    "method": "computedDefaultSecretName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedDefaultSecretName",
                    "validate": false,
                    "optional": false,
                    "original": "default_secret_name"
                }
            ],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard service account's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ServiceAccountMetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                }
            ],
            "conflicts": [],
            "type": "ServiceAccountResource s",
            "original": "kubernetes_service_account"
        },
        {
            "con": {
                "smart": "storageClassResource",
                "name": "StorageClassResource'"
            },
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard storage class's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (StorageClassMetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The parameters for the provisioner that should create volumes of this",
                        "storage class"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"parameters\" <$> TF.attribute",
                    "name": "_parameters",
                    "method": "parameters",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasParameters",
                    "validate": false,
                    "optional": true,
                    "original": "parameters"
                },
                {
                    "default": "_storageProvisioner",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Indicates the type of the provisioner"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"storage_provisioner\" <$> TF.attribute",
                    "name": "_storageProvisioner",
                    "method": "storageProvisioner",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasStorageProvisioner",
                    "validate": false,
                    "optional": false,
                    "original": "storage_provisioner"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/kubernetes/r/storage_class.html",
            "dependencies": [
                "StorageClassMetadataSetting"
            ],
            "key": "storage_class",
            "name": "StorageClassResource",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"id\" <$> TF.attribute",
                    "name": "_computedId",
                    "method": "computedId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedId",
                    "validate": false,
                    "optional": false,
                    "original": "id"
                }
            ],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard storage class's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (StorageClassMetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_storageProvisioner",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Indicates the type of the provisioner"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"storage_provisioner\" <$> TF.attribute",
                    "name": "_storageProvisioner",
                    "method": "storageProvisioner",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasStorageProvisioner",
                    "validate": false,
                    "optional": false,
                    "original": "storage_provisioner"
                }
            ],
            "conflicts": [],
            "type": "StorageClassResource s",
            "original": "kubernetes_storage_class"
        }
    ],
    "schema": {
        "con": {
            "smart": "newProvider",
            "name": "Provider'"
        },
        "arguments": [
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [
                    "PEM-encoded client certificate for TLS authentication."
                ],
                "forceNew": false,
                "encoder": "TF.assign \"client_certificate\" <$>",
                "name": "_clientCertificate",
                "method": "clientCertificate",
                "threaded": false,
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasClientCertificate",
                "validate": false,
                "optional": true,
                "original": "client_certificate"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [
                    "PEM-encoded client certificate key for TLS authentication."
                ],
                "forceNew": false,
                "encoder": "TF.assign \"client_key\" <$>",
                "name": "_clientKey",
                "method": "clientKey",
                "threaded": false,
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasClientKey",
                "validate": false,
                "optional": true,
                "original": "client_key"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [
                    "PEM-encoded root certificates bundle for TLS authentication."
                ],
                "forceNew": false,
                "encoder": "TF.assign \"cluster_ca_certificate\" <$>",
                "name": "_clusterCaCertificate",
                "method": "clusterCaCertificate",
                "threaded": false,
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasClusterCaCertificate",
                "validate": false,
                "optional": true,
                "original": "cluster_ca_certificate"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [],
                "forceNew": false,
                "encoder": "TF.assign \"config_context\" <$>",
                "name": "_configContext",
                "method": "configContext",
                "threaded": false,
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasConfigContext",
                "validate": false,
                "optional": true,
                "original": "config_context"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [],
                "forceNew": false,
                "encoder": "TF.assign \"config_context_auth_info\" <$>",
                "name": "_configContextAuthInfo",
                "method": "configContextAuthInfo",
                "threaded": false,
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasConfigContextAuthInfo",
                "validate": false,
                "optional": true,
                "original": "config_context_auth_info"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [],
                "forceNew": false,
                "encoder": "TF.assign \"config_context_cluster\" <$>",
                "name": "_configContextCluster",
                "method": "configContextCluster",
                "threaded": false,
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasConfigContextCluster",
                "validate": false,
                "optional": true,
                "original": "config_context_cluster"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [
                    "Path to the kube config file, defaults to ~/.kube/config"
                ],
                "forceNew": false,
                "encoder": "TF.assign \"config_path\" <$>",
                "name": "_configPath",
                "method": "configPath",
                "threaded": false,
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasConfigPath",
                "validate": false,
                "optional": true,
                "original": "config_path"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [
                    "The hostname (in form of URI) of Kubernetes master."
                ],
                "forceNew": false,
                "encoder": "TF.assign \"host\" <$>",
                "name": "_host",
                "method": "host",
                "threaded": false,
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasHost",
                "validate": false,
                "optional": true,
                "original": "host"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [
                    "Whether server should be accessed without verifying the TLS certificate."
                ],
                "forceNew": false,
                "encoder": "TF.assign \"insecure\" <$>",
                "name": "_insecure",
                "method": "insecure",
                "threaded": false,
                "conflicts": [],
                "type": "P.Maybe P.Bool",
                "class": "HasInsecure",
                "validate": false,
                "optional": true,
                "original": "insecure"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [
                    "Load local kubeconfig."
                ],
                "forceNew": false,
                "encoder": "TF.assign \"load_config_file\" <$>",
                "name": "_loadConfigFile",
                "method": "loadConfigFile",
                "threaded": false,
                "conflicts": [],
                "type": "P.Maybe P.Bool",
                "class": "HasLoadConfigFile",
                "validate": false,
                "optional": true,
                "original": "load_config_file"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [
                    "The password to use for HTTP basic authentication when accessing the",
                    "Kubernetes master endpoint."
                ],
                "forceNew": false,
                "encoder": "TF.assign \"password\" <$>",
                "name": "_password",
                "method": "password",
                "threaded": false,
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasPassword",
                "validate": false,
                "optional": true,
                "original": "password"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [
                    "Token to authentifcate an service account"
                ],
                "forceNew": false,
                "encoder": "TF.assign \"token\" <$>",
                "name": "_token",
                "method": "token",
                "threaded": false,
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasToken",
                "validate": false,
                "optional": true,
                "original": "token"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [
                    "The username to use for HTTP basic authentication when accessing the",
                    "Kubernetes master endpoint."
                ],
                "forceNew": false,
                "encoder": "TF.assign \"username\" <$>",
                "name": "_username",
                "method": "username",
                "threaded": false,
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasUsername",
                "validate": false,
                "optional": true,
                "original": "username"
            }
        ],
        "dependencies": [],
        "key": "",
        "name": "Provider",
        "threaded": false,
        "attributes": [],
        "parameters": [],
        "conflicts": [],
        "type": "Provider",
        "original": "provider"
    },
    "dependencies": [
        "aeson",
        "base",
        "containers",
        "microlens",
        "terrafomo",
        "text"
    ],
    "name": "Kubernetes",
    "package": "terrafomo-kubernetes",
    "primitives": [],
    "original": "kubernetes"
}